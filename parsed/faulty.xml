<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="0.9.5" language="Java" filename="D:\GPgit\CS454-Automated_patching_using_GP\resources\NumberUtils.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>math</name><operator>.</operator><name>BigDecimal</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>math</name><operator>.</operator><name>BigInteger</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>text</name><operator>.</operator><name>Normalizer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>Array</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>


<comment type="line">//import org.apache.commons.lang3.StringUtils;</comment>

<comment type="block" format="javadoc">/**
 * &lt;p&gt;Provides extra functionality for Java Number classes.&lt;/p&gt;
 *
 * @since 2.0
 * @version $Id$
 */</comment>
<class><specifier>public</specifier> class <name>NumberUtils</name> <block>{

    <comment type="block" format="javadoc">/** Reusable Long constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Long</name></type> <name>LONG_ZERO</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Long constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Long</name></type> <name>LONG_ONE</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Long constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Long</name></type> <name>LONG_MINUS_ONE</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Integer constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Integer</name></type> <name>INTEGER_ZERO</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Integer constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Integer</name></type> <name>INTEGER_ONE</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Integer constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Integer</name></type> <name>INTEGER_MINUS_ONE</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Short constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Short</name></type> <name>SHORT_ZERO</name> <init>= <expr><call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>short</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Short constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Short</name></type> <name>SHORT_ONE</name> <init>= <expr><call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>short</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Short constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Short</name></type> <name>SHORT_MINUS_ONE</name> <init>= <expr><call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>short</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Byte constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Byte</name></type> <name>BYTE_ZERO</name> <init>= <expr><call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Byte constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Byte</name></type> <name>BYTE_ONE</name> <init>= <expr><call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Byte constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Byte</name></type> <name>BYTE_MINUS_ONE</name> <init>= <expr><call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Double constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Double</name></type> <name>DOUBLE_ZERO</name> <init>= <expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">0.0d</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Double constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Double</name></type> <name>DOUBLE_ONE</name> <init>= <expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1.0d</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Double constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Double</name></type> <name>DOUBLE_MINUS_ONE</name> <init>= <expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1.0d</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Float constant for zero. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Float</name></type> <name>FLOAT_ZERO</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Float constant for one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Float</name></type> <name>FLOAT_ONE</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1.0f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Reusable Float constant for minus one. */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Float</name></type> <name>FLOAT_MINUS_ONE</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1.0f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;&lt;code&gt;NumberUtils&lt;/code&gt; instances should NOT be constructed in standard programming.
     * Instead, the class should be used as &lt;code&gt;NumberUtils.toInt("6");&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance
     * to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>NumberUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;, returning
     * &lt;code&gt;zero&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toInt(null) = 0
     *   NumberUtils.toInt("")   = 0
     *   NumberUtils.toInt("1")  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @return the int represented by the string, or &lt;code&gt;zero&lt;/code&gt; if
     *  conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toInt</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toInt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, the default value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toInt(null, 1) = 1
     *   NumberUtils.toInt("", 1)   = 1
     *   NumberUtils.toInt("1", 0)  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @param defaultValue  the default value
     * @return the int represented by the string, or the default if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toInt</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if<condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;, returning
     * &lt;code&gt;zero&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toLong(null) = 0L
     *   NumberUtils.toLong("")   = 0L
     *   NumberUtils.toLong("1")  = 1L
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @return the long represented by the string, or &lt;code&gt;0&lt;/code&gt; if
     *  conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>toLong</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toLong</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, the default value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toLong(null, 1L) = 1L
     *   NumberUtils.toLong("", 1L)   = 1L
     *   NumberUtils.toLong("1", 0L)  = 1L
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @param defaultValue  the default value
     * @return the long represented by the string, or the default if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>toLong</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Long</name><operator>.</operator><name>parseLong</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;, returning
     * &lt;code&gt;0.0f&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;0.0f&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toFloat(null)   = 0.0f
     *   NumberUtils.toFloat("")     = 0.0f
     *   NumberUtils.toFloat("1.5")  = 1.5f
     * &lt;/pre&gt;
     *
     * @param str the string to convert, may be &lt;code&gt;null&lt;/code&gt;
     * @return the float represented by the string, or &lt;code&gt;0.0f&lt;/code&gt;
     *  if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>toFloat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toFloat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the default
     * value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toFloat(null, 1.1f)   = 1.0f
     *   NumberUtils.toFloat("", 1.1f)     = 1.1f
     *   NumberUtils.toFloat("1.5", 0.0f)  = 1.5f
     * &lt;/pre&gt;
     *
     * @param str the string to convert, may be &lt;code&gt;null&lt;/code&gt;
     * @param defaultValue the default value
     * @return the float represented by the string, or defaultValue
     *  if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>toFloat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Float</name><operator>.</operator><name>parseFloat</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;, returning
     * &lt;code&gt;0.0d&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;0.0d&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toDouble(null)   = 0.0d
     *   NumberUtils.toDouble("")     = 0.0d
     *   NumberUtils.toDouble("1.5")  = 1.5d
     * &lt;/pre&gt;
     *
     * @param str the string to convert, may be &lt;code&gt;null&lt;/code&gt;
     * @return the double represented by the string, or &lt;code&gt;0.0d&lt;/code&gt;
     *  if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>toDouble</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toDouble</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0.0d</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the default
     * value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d
     *   NumberUtils.toDouble("", 1.1d)     = 1.1d
     *   NumberUtils.toDouble("1.5", 0.0d)  = 1.5d
     * &lt;/pre&gt;
     *
     * @param str the string to convert, may be &lt;code&gt;null&lt;/code&gt;
     * @param defaultValue the default value
     * @return the double represented by the string, or defaultValue
     *  if conversion fails
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>toDouble</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Double</name><operator>.</operator><name>parseDouble</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt;, returning
     * &lt;code&gt;zero&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toByte(null) = 0
     *   NumberUtils.toByte("")   = 0
     *   NumberUtils.toByte("1")  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @return the byte represented by the string, or &lt;code&gt;zero&lt;/code&gt; if
     *  conversion fails
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>toByte</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toByte</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, the default value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toByte(null, 1) = 1
     *   NumberUtils.toByte("", 1)   = 1
     *   NumberUtils.toByte("1", 0)  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @param defaultValue  the default value
     * @return the byte represented by the string, or the default if conversion fails
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>toByte</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if<condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Byte</name><operator>.</operator><name>parseByte</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;short&lt;/code&gt;, returning
     * &lt;code&gt;zero&lt;/code&gt; if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt; is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toShort(null) = 0
     *   NumberUtils.toShort("")   = 0
     *   NumberUtils.toShort("1")  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @return the short represented by the string, or &lt;code&gt;zero&lt;/code&gt; if
     *  conversion fails
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>toShort</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toShort</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>short</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;short&lt;/code&gt;, returning a
     * default value if the conversion fails.&lt;/p&gt;
     *
     * &lt;p&gt;If the string is &lt;code&gt;null&lt;/code&gt;, the default value is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   NumberUtils.toShort(null, 1) = 1
     *   NumberUtils.toShort("", 1)   = 1
     *   NumberUtils.toShort("1", 0)  = 1
     * &lt;/pre&gt;
     *
     * @param str  the string to convert, may be null
     * @param defaultValue  the default value
     * @return the short represented by the string, or the default if conversion fails
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>toShort</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if<condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <try>try <block>{
            <return>return <expr><call><name><name>Short</name><operator>.</operator><name>parseShort</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="line">// must handle Long, Float, Integer, Float, Short,</comment>
    <comment type="line">//                  BigDecimal, BigInteger and Byte</comment>
    <comment type="line">// useful methods:</comment>
    <comment type="line">// Byte.decode(String)</comment>
    <comment type="line">// Byte.valueOf(String,int radix)</comment>
    <comment type="line">// Byte.valueOf(String)</comment>
    <comment type="line">// Double.valueOf(String)</comment>
    <comment type="line">// Float.valueOf(String)</comment>
    <comment type="line">// Float.valueOf(String)</comment>
    <comment type="line">// Integer.valueOf(String,int radix)</comment>
    <comment type="line">// Integer.valueOf(String)</comment>
    <comment type="line">// Integer.decode(String)</comment>
    <comment type="line">// Integer.getInteger(String)</comment>
    <comment type="line">// Integer.getInteger(String,int val)</comment>
    <comment type="line">// Integer.getInteger(String,Integer val)</comment>
    <comment type="line">// Integer.valueOf(String)</comment>
    <comment type="line">// Double.valueOf(String)</comment>
    <comment type="line">// new Byte(String)</comment>
    <comment type="line">// Long.valueOf(String)</comment>
    <comment type="line">// Long.getLong(String)</comment>
    <comment type="line">// Long.getLong(String,int)</comment>
    <comment type="line">// Long.getLong(String,Integer)</comment>
    <comment type="line">// Long.valueOf(String,int)</comment>
    <comment type="line">// Long.valueOf(String)</comment>
    <comment type="line">// Short.valueOf(String)</comment>
    <comment type="line">// Short.decode(String)</comment>
    <comment type="line">// Short.valueOf(String,int)</comment>
    <comment type="line">// Short.valueOf(String)</comment>
    <comment type="line">// new BigDecimal(String)</comment>
    <comment type="line">// new BigInteger(String)</comment>
    <comment type="line">// new BigInteger(String,int radix)</comment>
    <comment type="line">// Possible inputs:</comment>
    <comment type="line">// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd</comment>
    <comment type="line">// plus minus everything. Prolly more. A lot are not separable.</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Turns a string value into a java.lang.Number.&lt;/p&gt;
     *
     * &lt;p&gt;If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
     * prefix is more than 8 - or BigInteger if there are more than 16 digits.
     * &lt;/p&gt;
     * &lt;p&gt;Then, the value is examined for a type qualifier on the end, i.e. one of
     * &lt;code&gt;'f','F','d','D','l','L'&lt;/code&gt;.  If it is found, it starts 
     * trying to create successively larger types from the type specified
     * until one is found that can represent the value.&lt;/p&gt;
     *
     * &lt;p&gt;If a type specifier is not found, it will check for a decimal point
     * and then try successively larger types from &lt;code&gt;Integer&lt;/code&gt; to
     * &lt;code&gt;BigInteger&lt;/code&gt; and from &lt;code&gt;Float&lt;/code&gt; to
     * &lt;code&gt;BigDecimal&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;
     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
     * be Integer, Long or BigDecimal as appropriate.
     * &lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This method does not trim the input string, i.e., strings with leading
     * or trailing spaces will generate NumberFormatExceptions.&lt;/p&gt;
     *
     * @param str  String containing a number, may be null
     * @return Number created from the string (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Number</name></type> <name>createNumber</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>NumberFormatException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// Current tests fail because StringUtils() cant be resolved</comment>
<comment type="line">//        if (StringUtils.isBlank(str)) {</comment>
<comment type="line">//            throw new NumberFormatException("A blank string is not a valid number");</comment>
<comment type="line">//        }</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strLen</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><literal type="string">"A blank string is not a valid number"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// Need to deal with all possible hex prefixes here</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>hex_prefixes</name> <init>= <expr><block>{<expr><literal type="string">"0x"</literal></expr>, <expr><literal type="string">"0X"</literal></expr>, <expr><literal type="string">"-0x"</literal></expr>, <expr><literal type="string">"-0X"</literal></expr>, <expr><literal type="string">"#"</literal></expr>, <expr><literal type="string">"-#"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pfxLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>pfx</name> <range>: <expr><name>hex_prefixes</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pfxLen</name> <operator>+=</operator> <call><name><name>pfx</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <comment type="block">/* bug fix
        if (pfxLen &gt; 0) { // we have a hex number
            char firstSigDigit = 0; // strip leading zeroes
            for(int i = pfxLen; i &lt; str.length(); i++) {
                firstSigDigit = str.charAt(i);
                if (firstSigDigit == '0') { // count leading zeroes
                    pfxLen++;
                } else {
                    break;
                }
            }
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits &gt; 16 || (hexDigits == 16 &amp;&amp; firstSigDigit &gt; '7')) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits &gt; 8 || (hexDigits == 8 &amp;&amp; firstSigDigit &gt; '7')) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
         */</comment>
        <comment type="line">//bug, gzoltar likelihood faulty</comment>
        <if>if <condition>(<expr><name>pfxLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{ <comment type="line">// we have a hex number</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>hexDigits</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>pfxLen</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>hexDigits</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition><then> <block>{ <comment type="line">// too many for Long</comment>
                <return>return <expr><call><name>createBigInteger</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>hexDigits</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><then> <block>{ <comment type="line">// too many for an int</comment>
                <return>return <expr><call><name>createLong</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            }</block></then></if>
            <comment type="line">// decode() handles 0xAABD and 0777 (hex and octal) as well.</comment>
            <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>


<comment type="line">//            return createInteger(str);</comment>
        }</block></then></if>
        <comment type="line">//bug</comment>


        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>lastChar</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>mant</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>dec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>exp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>decPos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>expPos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'e'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// assumes both not present</comment>
        <comment type="line">// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)</comment>
        <comment type="line">// and the parsing which will detect if e or E appear in a number due to using the wrong offset</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>numDecimals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Check required precision (LANG-693)</comment>
        <if>if <condition>(<expr><name>decPos</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{ <comment type="line">// there is a decimal point</comment>

            <if>if <condition>(<expr><name>expPos</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{ <comment type="line">// there is an exponent</comment>
                <if>if <condition>(<expr><name><name>expPos</name> <argument_list type="generic">&lt; <argument><name>decPos</name> <operator>||</operator> <name>expPos</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// prevents double exponent causing IOOBE</comment>
                    <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="string">" is not a valid number."</literal></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><name>dec</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>decPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>expPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>dec</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>decPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>mant</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>decPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>numDecimals</name> <operator>=</operator> <call><name><name>dec</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// gets number of digits past the decimal to ensure no loss of precision for floating point numbers.</comment>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>expPos</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>expPos</name> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// prevents double exponent causing IOOBE</comment>
                    <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="string">" is not a valid number."</literal></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><name>mant</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>expPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>mant</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>dec</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isDigit</name></name><argument_list>(<argument><expr><name>lastChar</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lastChar</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>expPos</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>expPos</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>exp</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>expPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            }</block></else></if>
            <comment type="line">//Requesting a specific type..</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>numeric</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>allZeros</name> <init>= <expr><call><name>isAllZeros</name><argument_list>(<argument><expr><name>mant</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isAllZeros</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>lastChar</name></expr>)</condition> <block>{
                <case>case <expr><literal type="char">'l'</literal></expr> :</case>
                <case>case <expr><literal type="char">'L'</literal></expr> :</case>
                    <if>if <condition>(<expr><name>dec</name> <operator>==</operator> <literal type="null">null</literal>
                            <operator>&amp;&amp;</operator> <name>exp</name> <operator>==</operator> <literal type="null">null</literal>
                            <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>numeric</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <call><name>isDigits</name><argument_list>(<argument><expr><call><name><name>numeric</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isDigits</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                        <try>try <block>{
                            <return>return <expr><call><name>createLong</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr>;</return>
                        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                            <comment type="line">// Too big for a long</comment>
                        }</block></catch></try>
                        <return>return <expr><call><name>createBigInteger</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr>;</return>

                    }</block></then></if>
                    <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="string">" is not a valid number."</literal></expr></argument>)</argument_list></call></expr>;</throw>
                <case>case <expr><literal type="char">'f'</literal></expr> :</case>
                <case>case <expr><literal type="char">'F'</literal></expr> :</case>
                    <try>try <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>Float</name></type> <name>f</name> <init>= <expr><call><name><name>NumberUtils</name><operator>.</operator><name>createFloat</name></name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>f</name><operator>.</operator><name>isInfinite</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>f</name><operator>.</operator><name>floatValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0.0F</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>allZeros</name><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
                            <comment type="line">//If it's too big for a float or the float value = 0 and the string</comment>
                            <comment type="line">//has non-zeros in it, then float does not have the precision we want</comment>
                            <return>return <expr><name>f</name></expr>;</return>
                        }</block></then></if>

                    }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                        <comment type="line">// ignore the bad number</comment>
                    }</block></catch></try>
                    <comment type="line">//$FALL-THROUGH$</comment>
                <case>case <expr><literal type="char">'d'</literal></expr> :</case>
                <case>case <expr><literal type="char">'D'</literal></expr> :</case>
                    <try>try <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>Double</name></type> <name>d</name> <init>= <expr><call><name><name>NumberUtils</name><operator>.</operator><name>createDouble</name></name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>d</name><operator>.</operator><name>isInfinite</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>d</name><operator>.</operator><name>floatValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0.0D</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>allZeros</name><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
                            <return>return <expr><name>d</name></expr>;</return>
                        }</block></then></if>
                    }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                        <comment type="line">// ignore the bad number</comment>
                    }</block></catch></try>
                    <try>try <block>{
                        <return>return <expr><call><name>createBigDecimal</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                        <comment type="line">// ignore the bad number</comment>
                    }</block></catch></try>
                    <comment type="line">//$FALL-THROUGH$</comment>
                <default>default :</default>
                    <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="string">" is not a valid number."</literal></expr></argument>)</argument_list></call></expr>;</throw>

            }</block></switch>
        }</block></then></if>
        <comment type="line">//User doesn't have a preference on the return type, so let's start</comment>
        <comment type="line">//small and go from there...</comment>
        <if>if <condition>(<expr><name>expPos</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>expPos</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>exp</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>expPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>dec</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>exp</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{ <comment type="line">// no decimal point and no exponent</comment>
            <comment type="line">//Must be an Integer, Long, Biginteger</comment>
            <try>try <block>{
                <return>return <expr><call><name>createInteger</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                <comment type="line">// ignore the bad number</comment>
            }</block></catch></try>
            <try>try <block>{
                <return>return <expr><call><name>createLong</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                <comment type="line">// ignore the bad number</comment>
            }</block></catch></try>
            <return>return <expr><call><name>createBigInteger</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">//Must be a Float, Double, BigDecimal</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>allZeros</name> <init>= <expr><call><name>isAllZeros</name><argument_list>(<argument><expr><name>mant</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isAllZeros</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <if>if<condition>(<expr><name>numDecimals</name> <operator>&lt;=</operator> <literal type="number">7</literal></expr>)</condition><then><block>{<comment type="line">// If number has 7 or fewer digits past the decimal point then make it a float</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>Float</name></type> <name>f</name> <init>= <expr><call><name>createFloat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>f</name><operator>.</operator><name>isInfinite</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>f</name><operator>.</operator><name>floatValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0.0F</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>allZeros</name><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
                    <return>return <expr><name>f</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
            <comment type="line">// ignore the bad number</comment>
        }</block></catch></try>
        <try>try <block>{
            <if>if<condition>(<expr><name>numDecimals</name> <operator>&lt;=</operator> <literal type="number">16</literal></expr>)</condition><then><block>{<comment type="line">// If number has between 8 and 16 digits past the decimal point then make it a double</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>Double</name></type> <name>d</name> <init>= <expr><call><name>createDouble</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>d</name><operator>.</operator><name>isInfinite</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>d</name><operator>.</operator><name>doubleValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0.0D</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>allZeros</name><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
                    <return>return <expr><name>d</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NumberFormatException</name></type> <name>nfe</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
            <comment type="line">// ignore the bad number</comment>
        }</block></catch></try>

        <return>return <expr><call><name>createBigDecimal</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Utility method for {@link #createNumber(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if s is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  the String to check
     * @return if it is all zeros or &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAllZeros</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Float&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;Float&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Float</name></type> <name>createFloat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Double&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;Double&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Double</name></type> <name>createDouble</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Integer&lt;/code&gt;, handling
     * hex and octal notations.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;Integer&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Integer</name></type> <name>createInteger</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// decode() handles 0xAABD and 0777 (hex and octal) as well.</comment>
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Long&lt;/code&gt;;
     * since 3.1 it handles hex and octal notations.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;Long&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Long</name></type> <name>createLong</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Long</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;BigInteger&lt;/code&gt;;
     * since 3.2 it handles hex (0x or #) and octal (0) notations.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;BigInteger&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>BigInteger</name></type> <name>createBigInteger</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// offset within string</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>radix</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>negate</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt> <comment type="line">// need to negate later?</comment>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>negate</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// hex</comment>
            <expr_stmt><expr><name>radix</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"#"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// alternative hex (allowed by Long/Integer)</comment>
            <expr_stmt><expr><name>radix</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>++</operator></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{ <comment type="line">// octal; so long as there are additional digits</comment>
            <expr_stmt><expr><name>radix</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>++</operator></expr>;</expr_stmt>
        }</block></then></if></elseif></if> <comment type="line">// default is to treat as decimal</comment>

        <decl_stmt><decl><type><specifier>final</specifier> <name>BigInteger</name></type> <name>value</name> <init>= <expr><operator>new</operator> <call><name>BigInteger</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>negate</name></expr> ?</condition><then> <expr><call><name><name>value</name><operator>.</operator><name>negate</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>value</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Convert a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;BigDecimal&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  a &lt;code&gt;String&lt;/code&gt; to convert, may be null
     * @return converted &lt;code&gt;BigDecimal&lt;/code&gt; (or null if the input is null)
     * @throws NumberFormatException if the value cannot be converted
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>BigDecimal</name></type> <name>createBigDecimal</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// handle JDK1.3.1 bug where "" throws IndexOutOfBoundsException</comment>
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isBlank</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><literal type="string">"A blank string is not a valid number"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>startsWith</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// this is protection for poorness in java.lang.BigDecimal.</comment>
            <comment type="line">// it accepts this as a legal value, but it does not appear</comment>
            <comment type="line">// to be in specification of class. OS X Java parses it to</comment>
            <comment type="line">// a wrong value.</comment>
            <throw>throw <expr><operator>new</operator> <call><name>NumberFormatException</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="string">" is not a valid number."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>BigDecimal</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Min in array</comment>
    <comment type="line">//--------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>short</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>byte</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Double</name><operator>.</operator><name>isNaN</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name><name>Double</name><operator>.</operator><name>NaN</name></name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the minimum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns min</comment>
        <decl_stmt><decl><type><name>float</name></type> <name>min</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Float</name><operator>.</operator><name>isNaN</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name><name>Float</name><operator>.</operator><name>NaN</name></name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>min</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <comment type="line">// Max in array</comment>
    <comment type="line">//--------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>short</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>byte</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Double</name><operator>.</operator><name>isNaN</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name><name>Double</name><operator>.</operator><name>NaN</name></name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the maximum value in an array.&lt;/p&gt;
     *
     * @param array  an array, must not be null or empty
     * @return the minimum value in the array
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;array&lt;/code&gt; is empty
     * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Validates input</comment>
        <expr_stmt><expr><call><name>validateArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Finds and returns max</comment>
        <decl_stmt><decl><type><name>float</name></type> <name>max</name> <init>= <expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Float</name><operator>.</operator><name>isNaN</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name><name>Float</name><operator>.</operator><name>NaN</name></name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified array is neither null nor empty.
     *
     * @param array  the array to check
     * @throws IllegalArgumentException if {@code array} is either {@code null} or empty
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>validateArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The Array must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Array cannot be empty."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if></elseif></if>
    }</block></function>

    <comment type="line">// 3 param min</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;long&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;int&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;short&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>short</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;byte&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>byte</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;double&lt;/code&gt; values.&lt;/p&gt;
     *
     * &lt;p&gt;If any value is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is
     * returned. Infinity is handled.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     * @see IEEE754rUtils#min(double, double, double) for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;float&lt;/code&gt; values.&lt;/p&gt;
     *
     * &lt;p&gt;If any value is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is
     * returned. Infinity is handled.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     * @see IEEE754rUtils#min(float, float, float) for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// 3 param max</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;long&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;int&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;short&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>short</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;byte&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>byte</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>a</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>a</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;double&lt;/code&gt; values.&lt;/p&gt;
     *
     * &lt;p&gt;If any value is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is
     * returned. Infinity is handled.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     * @see IEEE754rUtils#max(double, double, double) for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the maximum of three &lt;code&gt;float&lt;/code&gt; values.&lt;/p&gt;
     *
     * &lt;p&gt;If any value is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is
     * returned. Infinity is handled.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the largest of the values
     * @see IEEE754rUtils#max(float, float, float) for a version of this method that handles NaN differently
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the &lt;code&gt;String&lt;/code&gt; contains only
     * digit characters.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;Null&lt;/code&gt; and empty String will return
     * &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  the &lt;code&gt;String&lt;/code&gt; to check
     * @return &lt;code&gt;true&lt;/code&gt; if str contains only Unicode numeric
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isDigits</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isDigit</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the String a valid Java number.&lt;/p&gt;
     *
     * &lt;p&gt;Valid numbers include hexadecimal marked with the &lt;code&gt;0x&lt;/code&gt;
     * qualifier, scientific notation and numbers marked with a type
     * qualifier (e.g. 123L).&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;Null&lt;/code&gt; and empty String will return
     * &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * @param str  the &lt;code&gt;String&lt;/code&gt; to check
     * @return &lt;code&gt;true&lt;/code&gt; if the string is a correctly formatted number
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNumber</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>chars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>hasExp</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>hasDecPoint</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>allowSigns</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>foundDigit</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// deal with any possible sign up front</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>start</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>sz</name></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return> <comment type="line">// str == "0x"</comment>
            }</block></then></if>
            <comment type="line">// checking hex (it can't be anything else)</comment>
            <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'a'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'f'</literal><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'A'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'F'</literal><operator>)</operator></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>sz</name><operator>--</operator></expr>;</expr_stmt> <comment type="line">// don't want to loop to the last char, check it afterwords</comment>
        <comment type="line">// for type qualifiers</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// loop to the next to last char or to the last char if we need another digit to</comment>
        <comment type="line">// make a valid number (e.g. chars[0..5] = "1234E")</comment>
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>sz</name> <operator>||</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name>sz</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>allowSigns</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>foundDigit</name><operator>)</operator></expr>)</condition> <block>{
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>foundDigit</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>allowSigns</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            }</block></then> <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>hasDecPoint</name> <operator>||</operator> <name>hasExp</name></expr>)</condition><then> <block>{
                    <comment type="line">// two decimal points or dec in exponent</comment>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>hasDecPoint</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition><then> <block>{
                <comment type="line">// we've already taken care of hex.</comment>
                <if>if <condition>(<expr><name>hasExp</name></expr>)</condition><then> <block>{
                    <comment type="line">// two E's</comment>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><operator>!</operator><name>foundDigit</name></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>hasExp</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>allowSigns</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><operator>!</operator><name>allowSigns</name></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>allowSigns</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>foundDigit</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt> <comment type="line">// we need a digit after the E</comment>
            }</block></then></if></elseif> <else>else <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></else></if>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><then> <block>{
                <comment type="line">// no type qualifier, OK</comment>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition><then> <block>{
                <comment type="line">// can't have an E at the last byte</comment>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>hasDecPoint</name> <operator>||</operator> <name>hasExp</name></expr>)</condition><then> <block>{
                    <comment type="line">// two decimal points or dec in exponent</comment>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
                <comment type="line">// single trailing decimal point after non-exponent is ok</comment>
                <return>return <expr><name>foundDigit</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><operator>!</operator><name>allowSigns</name>
                    <operator>&amp;&amp;</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal>
                    <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal>
                    <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal>
                    <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'F'</literal><operator>)</operator></expr>)</condition><then> <block>{
                <return>return <expr><name>foundDigit</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal>
                    <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'L'</literal></expr>)</condition><then> <block>{
                <comment type="line">// not allowing L with an exponent or decimal point</comment>
                <return>return <expr><name>foundDigit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasExp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasDecPoint</name></expr>;</return>
            }</block></then></if>
            <comment type="line">// last character is illegal</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// allowSigns is true iff the val ends in 'E'</comment>
        <comment type="line">// found digit it to make sure weird stuff like '.' and '1E-' doesn't pass</comment>
        <return>return <expr><operator>!</operator><name>allowSigns</name> <operator>&amp;&amp;</operator> <name>foundDigit</name></expr>;</return>
    }</block></function>

}</block></class>

<comment type="line">//@Immutablestatic</comment>
<class>class <name>StringUtils</name> <block>{
    <comment type="line">// Performance testing notes (JDK 1.4, Jul03, scolebourne)</comment>
    <comment type="line">// Whitespace:</comment>
    <comment type="line">// Character.isWhitespace() is faster than WHITESPACE.indexOf()</comment>
    <comment type="line">// where WHITESPACE is a string of all whitespace characters</comment>
    <comment type="line">//</comment>
    <comment type="line">// Character access:</comment>
    <comment type="line">// String.charAt(n) versus toCharArray(), then array[n]</comment>
    <comment type="line">// String.charAt(n) is about 15% worse for a 10K string</comment>
    <comment type="line">// They are about equal for a length 50 string</comment>
    <comment type="line">// String.charAt(n) is about 4 times better for a length 3 string</comment>
    <comment type="line">// String.charAt(n) is best bet overall</comment>
    <comment type="line">//</comment>
    <comment type="line">// Append:</comment>
    <comment type="line">// String.concat about twice as fast as StringBuffer.append</comment>
    <comment type="line">// (not sure who tested this)</comment>

    <comment type="block" format="javadoc">/**
     * A String for a space character.
     *
     * @since 3.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>SPACE</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The empty String {@code ""}.
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>EMPTY</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A String for linefeed LF ("\n").
     *
     * @see &lt;a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"&gt;JLF: Escape Sequences
     *      for Character and String Literals&lt;/a&gt;
     * @since 3.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>LF</name> <init>= <expr><literal type="string">"\n"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A String for carriage return CR ("\r").
     *
     * @see &lt;a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"&gt;JLF: Escape Sequences
     *      for Character and String Literals&lt;/a&gt;
     * @since 3.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>CR</name> <init>= <expr><literal type="string">"\r"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Represents a failed index search.
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>INDEX_NOT_FOUND</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;The maximum size to which the padding constant(s) can expand.&lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>PAD_LIMIT</name> <init>= <expr><literal type="number">8192</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A regex pattern for recognizing blocks of whitespace characters.
     * The apparent convolutedness of the pattern serves the purpose of
     * ignoring "blocks" consisting of only a single space:  the pattern
     * is used only to normalize whitespace, condensing "blocks" down to a
     * single space, thus matching the same would likely cause a great
     * many noop replacements.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Pattern</name></type> <name>WHITESPACE_PATTERN</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">"(?: \\s|[\\s&amp;&amp;[^ ]])\\s*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;{@code StringUtils} instances should NOT be constructed in
     * standard programming. Instead, the class should be used as
     * {@code StringUtils.trim(" foo ");}.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
     * instance to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>StringUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">// Empty checks</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if a CharSequence is empty ("") or null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isEmpty(null)      = true
     * StringUtils.isEmpty("")        = true
     * StringUtils.isEmpty(" ")       = false
     * StringUtils.isEmpty("bob")     = false
     * StringUtils.isEmpty("  bob  ") = false
     * &lt;/pre&gt;
     *
     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
     * It no longer trims the CharSequence.
     * That functionality is available in isBlank().&lt;/p&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if the CharSequence is empty or null
     * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if a CharSequence is not empty ("") and not null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotEmpty(null)      = false
     * StringUtils.isNotEmpty("")        = false
     * StringUtils.isNotEmpty(" ")       = true
     * StringUtils.isNotEmpty("bob")     = true
     * StringUtils.isNotEmpty("  bob  ") = true
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if the CharSequence is not empty and not null
     * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>!</operator><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if a CharSequence is whitespace, empty ("") or null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isBlank(null)      = true
     * StringUtils.isBlank("")        = true
     * StringUtils.isBlank(" ")       = true
     * StringUtils.isBlank("bob")     = false
     * StringUtils.isBlank("  bob  ") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if the CharSequence is null, empty or whitespace
     * @since 2.0
     * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isBlank</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strLen</name> <operator>=</operator> <call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if a CharSequence is not empty (""), not null and not whitespace only.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotBlank(null)      = false
     * StringUtils.isNotBlank("")        = false
     * StringUtils.isNotBlank(" ")       = false
     * StringUtils.isNotBlank("bob")     = true
     * StringUtils.isNotBlank("  bob  ") = true
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if the CharSequence is
     *  not empty and not null and not whitespace
     * @since 2.0
     * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotBlank</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>!</operator><call><name><name>StringUtils</name><operator>.</operator><name>isBlank</name></name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Trim</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String, handling {@code null} by returning
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #strip(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;To trim your choice of characters, use the
     * {@link #strip(String, String)} methods.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trim(null)          = null
     * StringUtils.trim("")            = ""
     * StringUtils.trim("     ")       = ""
     * StringUtils.trim("abc")         = "abc"
     * StringUtils.trim("    abc    ") = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed string, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>trim</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name><name>str</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String returning {@code null} if the String is
     * empty ("") after the trim or if it is {@code null}.
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #stripToNull(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToNull(null)          = null
     * StringUtils.trimToNull("")            = null
     * StringUtils.trimToNull("     ")       = null
     * StringUtils.trimToNull("abc")         = "abc"
     * StringUtils.trimToNull("    abc    ") = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed String,
     *  {@code null} if only chars &amp;lt;= 32, empty or null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>trimToNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>ts</name> <init>= <expr><call><name>trim</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>ts</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String returning an empty String ("") if the String
     * is empty ("") after the trim or if it is {@code null}.
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #stripToEmpty(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToEmpty(null)          = ""
     * StringUtils.trimToEmpty("")            = ""
     * StringUtils.trimToEmpty("     ")       = ""
     * StringUtils.trimToEmpty("abc")         = "abc"
     * StringUtils.trimToEmpty("    abc    ") = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed String, or an empty String if {@code null} input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>trimToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>EMPTY</name></expr> </then><else>: <expr><call><name><name>str</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">// Stripping</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips whitespace from the start and end of a String.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trim(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.strip(null)     = null
     * StringUtils.strip("")       = ""
     * StringUtils.strip("   ")    = ""
     * StringUtils.strip("abc")    = "abc"
     * StringUtils.strip("  abc")  = "abc"
     * StringUtils.strip("abc  ")  = "abc"
     * StringUtils.strip(" abc ")  = "abc"
     * StringUtils.strip(" ab c ") = "ab c"
     * &lt;/pre&gt;
     *
     * @param str  the String to remove whitespace from, may be null
     * @return the stripped String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>strip</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>strip</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
     * {@code null} if the String is empty ("") after the strip.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trimToNull(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripToNull(null)     = null
     * StringUtils.stripToNull("")       = null
     * StringUtils.stripToNull("   ")    = null
     * StringUtils.stripToNull("abc")    = "abc"
     * StringUtils.stripToNull("  abc")  = "abc"
     * StringUtils.stripToNull("abc  ")  = "abc"
     * StringUtils.stripToNull(" abc ")  = "abc"
     * StringUtils.stripToNull(" ab c ") = "ab c"
     * &lt;/pre&gt;
     *
     * @param str  the String to be stripped, may be null
     * @return the stripped String,
     *  {@code null} if whitespace, empty or null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>stripToNull</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strip</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><call><name><name>str</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
     * an empty String if {@code null} input.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trimToEmpty(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripToEmpty(null)     = ""
     * StringUtils.stripToEmpty("")       = ""
     * StringUtils.stripToEmpty("   ")    = ""
     * StringUtils.stripToEmpty("abc")    = "abc"
     * StringUtils.stripToEmpty("  abc")  = "abc"
     * StringUtils.stripToEmpty("abc  ")  = "abc"
     * StringUtils.stripToEmpty(" abc ")  = "abc"
     * StringUtils.stripToEmpty(" ab c ") = "ab c"
     * &lt;/pre&gt;
     *
     * @param str  the String to be stripped, may be null
     * @return the trimmed String, or an empty String if {@code null} input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>stripToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>EMPTY</name></expr> </then><else>: <expr><call><name>strip</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips any of a set of characters from the start and end of a String.
     * This is similar to {@link String#trim()} but allows the characters
     * to be stripped to be controlled.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * An empty string ("") input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is {@code null}, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.
     * Alternatively use {@link #strip(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.strip(null, *)          = null
     * StringUtils.strip("", *)            = ""
     * StringUtils.strip("abc", null)      = "abc"
     * StringUtils.strip("  abc", null)    = "abc"
     * StringUtils.strip("abc  ", null)    = "abc"
     * StringUtils.strip(" abc ", null)    = "abc"
     * StringUtils.strip("  abcyx", "xyz") = "  abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>strip</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>stripChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>stripStart</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>stripChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>stripEnd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>stripChars</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips any of a set of characters from the start of a String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * An empty string ("") input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is {@code null}, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripStart(null, *)          = null
     * StringUtils.stripStart("", *)            = ""
     * StringUtils.stripStart("abc", "")        = "abc"
     * StringUtils.stripStart("abc", null)      = "abc"
     * StringUtils.stripStart("  abc", null)    = "abc"
     * StringUtils.stripStart("abc  ", null)    = "abc  "
     * StringUtils.stripStart(" abc ", null)    = "abc "
     * StringUtils.stripStart("yxabc  ", "xyz") = "abc  "
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>stripStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>stripChars</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strLen</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>stripChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>start</name> <operator>!=</operator> <name>strLen</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>stripChars</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <while>while <condition>(<expr><name>start</name> <operator>!=</operator> <name>strLen</name> <operator>&amp;&amp;</operator> <call><name><name>stripChars</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></else></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * An empty string ("") input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is {@code null}, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripEnd(null, *)          = null
     * StringUtils.stripEnd("", *)            = ""
     * StringUtils.stripEnd("abc", "")        = "abc"
     * StringUtils.stripEnd("abc", null)      = "abc"
     * StringUtils.stripEnd("  abc", null)    = "  abc"
     * StringUtils.stripEnd("abc  ", null)    = "abc"
     * StringUtils.stripEnd(" abc ", null)    = " abc"
     * StringUtils.stripEnd("  abcyx", "xyz") = "  abc"
     * StringUtils.stripEnd("120.00", ".0")   = "12"
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the set of characters to remove, null treated as whitespace
     * @return the stripped String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>stripEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>stripChars</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>end</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>stripChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>end</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>end</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>stripChars</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <while>while <condition>(<expr><name>end</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>stripChars</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>end</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></else></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// StripAll</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips whitespace from the start and end of every String in an array.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A new array is returned each time, except for length zero.
     * A {@code null} array will return {@code null}.
     * An empty array will return itself.
     * A {@code null} array entry will be ignored.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripAll(null)             = null
     * StringUtils.stripAll([])               = []
     * StringUtils.stripAll(["abc", "  abc"]) = ["abc", "abc"]
     * StringUtils.stripAll(["abc  ", null])  = ["abc", null]
     * &lt;/pre&gt;
     *
     * @param strs  the array to remove whitespace from, may be null
     * @return the stripped Strings, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>stripAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>strs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>stripAll</name><argument_list>(<argument><expr><name>strs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Strips any of a set of characters from the start and end of every
     * String in an array.&lt;/p&gt;
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A new array is returned each time, except for length zero.
     * A {@code null} array will return {@code null}.
     * An empty array will return itself.
     * A {@code null} array entry will be ignored.
     * A {@code null} stripChars will strip whitespace as defined by
     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripAll(null, *)                = null
     * StringUtils.stripAll([], *)                  = []
     * StringUtils.stripAll(["abc", "  abc"], null) = ["abc", "abc"]
     * StringUtils.stripAll(["abc  ", null], null)  = ["abc", null]
     * StringUtils.stripAll(["abc  ", null], "yz")  = ["abc  ", null]
     * StringUtils.stripAll(["yabcz", null], "yz")  = ["abc", null]
     * &lt;/pre&gt;
     *
     * @param strs  the array to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped Strings, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>stripAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>strs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>stripChars</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>strsLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strsLen</name> <operator>=</operator> <name><name>strs</name><operator>.</operator><name>length</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>strs</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>newArr</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>strsLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strsLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>newArr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strip</name><argument_list>(<argument><expr><name><name>strs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>stripChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>newArr</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes diacritics (~= accents) from a string. The case will not be altered.&lt;/p&gt;
     * &lt;p&gt;For instance, '&amp;agrave;' will be replaced by 'a'.&lt;/p&gt;
     * &lt;p&gt;Note that ligatures will be left as is.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripAccents(null)                = null
     * StringUtils.stripAccents("")                  = ""
     * StringUtils.stripAccents("control")           = "control"
     * StringUtils.stripAccents("&amp;eacute;clair")     = "eclair"
     * &lt;/pre&gt;
     *
     * @param input String to be stripped
     * @return input text with diacritics removed
     *
     * @since 3.0
     */</comment>
    <comment type="line">// See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommitted bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>stripAccents</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <if>if<condition>(<expr><name>input</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Pattern</name></type> <name>pattern</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">"\\p{InCombiningDiacriticalMarks}+"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><comment type="line">//$NON-NLS-1$</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>decomposed</name> <init>= <expr><call><name><name>Normalizer</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>Normalizer</name><operator>.</operator><name>Form</name><operator>.</operator><name>NFD</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Note that this doesn't correctly remove ligatures...</comment>
        <return>return <expr><call><name><name>pattern</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><name>decomposed</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return><comment type="line">//$NON-NLS-1$</comment>
    }</block></function>

    <comment type="line">// Equals</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two CharSequences, returning {@code true} if they represent
     * equal sequences of characters.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equals(null, null)   = true
     * StringUtils.equals(null, "abc")  = false
     * StringUtils.equals("abc", null)  = false
     * StringUtils.equals("abc", "abc") = true
     * StringUtils.equals("abc", "ABC") = false
     * &lt;/pre&gt;
     *
     * @see Object#equals(Object)
     * @param cs1  the first CharSequence, may be {@code null}
     * @param cs2  the second CharSequence, may be {@code null}
     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
     * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs1</name> <operator>==</operator> <name>cs2</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>cs1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cs2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>cs1</name> <operator>instanceof</operator> <name>String</name> <operator>&amp;&amp;</operator> <name>cs2</name> <operator>instanceof</operator> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>cs1</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cs2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>cs1</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cs2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><call><name><name>cs1</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cs2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two CharSequences, returning {@code true} if they represent
     * equal sequences of characters, ignoring case.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered equal. Comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equalsIgnoreCase(null, null)   = true
     * StringUtils.equalsIgnoreCase(null, "abc")  = false
     * StringUtils.equalsIgnoreCase("abc", null)  = false
     * StringUtils.equalsIgnoreCase("abc", "abc") = true
     * StringUtils.equalsIgnoreCase("abc", "ABC") = true
     * &lt;/pre&gt;
     *
     * @param str1  the first CharSequence, may be null
     * @param str2  the second CharSequence, may be null
     * @return {@code true} if the CharSequence are equal, case insensitive, or
     *  both {@code null}
     * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>equalsIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>str2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str1</name> <operator>==</operator> <name>str2</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>str1</name> <operator>==</operator> <name>str2</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><call><name><name>str1</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>str2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>str1</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="line">// IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the first index within a CharSequence, handling {@code null}.
     * This method uses {@link String#indexOf(int, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *)         = -1
     * StringUtils.indexOf("", *)           = -1
     * StringUtils.indexOf("aabaabaa", 'a') = 0
     * StringUtils.indexOf("aabaabaa", 'b') = 2
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChar  the character to find
     * @return the first index of the search character,
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchChar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the first index within a CharSequence from a start position,
     * handling {@code null}.
     * This method uses {@link String#indexOf(int, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.
     * A negative start position is treated as zero.
     * A start position greater than the string length returns {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *, *)          = -1
     * StringUtils.indexOf("", *, *)            = -1
     * StringUtils.indexOf("aabaabaa", 'b', 0)  = 2
     * StringUtils.indexOf("aabaabaa", 'b', 3)  = 5
     * StringUtils.indexOf("aabaabaa", 'b', 9)  = -1
     * StringUtils.indexOf("aabaabaa", 'b', -1) = 2
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChar  the character to find
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search character (always &amp;ge; startPos),
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchChar</name></expr></argument>, <argument><expr><name>startPos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the first index within a CharSequence, handling {@code null}.
     * This method uses {@link String#indexOf(String, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *)          = -1
     * StringUtils.indexOf(*, null)          = -1
     * StringUtils.indexOf("", "")           = 0
     * StringUtils.indexOf("", *)            = -1 (except when * = "")
     * StringUtils.indexOf("aabaabaa", "a")  = 0
     * StringUtils.indexOf("aabaabaa", "b")  = 2
     * StringUtils.indexOf("aabaabaa", "ab") = 1
     * StringUtils.indexOf("aabaabaa", "")   = 0
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchSeq  the CharSequence to find, may be null
     * @return the first index of the search CharSequence,
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchSeq</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchSeq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the first index within a CharSequence, handling {@code null}.
     * This method uses {@link String#indexOf(String, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position is treated as zero.
     * An empty ("") search CharSequence always matches.
     * A start position greater than the string length only matches
     * an empty search CharSequence.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *, *)          = -1
     * StringUtils.indexOf(*, null, *)          = -1
     * StringUtils.indexOf("", "", 0)           = 0
     * StringUtils.indexOf("", *, 0)            = -1 (except when * = "")
     * StringUtils.indexOf("aabaabaa", "a", 0)  = 0
     * StringUtils.indexOf("aabaabaa", "b", 0)  = 2
     * StringUtils.indexOf("aabaabaa", "ab", 0) = 1
     * StringUtils.indexOf("aabaabaa", "b", 3)  = 5
     * StringUtils.indexOf("aabaabaa", "b", 9)  = -1
     * StringUtils.indexOf("aabaabaa", "b", -1) = 2
     * StringUtils.indexOf("aabaabaa", "", 2)   = 2
     * StringUtils.indexOf("abc", "", 9)        = 3
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchSeq  the CharSequence to find, may be null
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search CharSequence (always &amp;ge; startPos),
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from indexOf(String, String, int) to indexOf(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchSeq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchSeq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchSeq</name></expr></argument>, <argument><expr><name>startPos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the n-th index within a CharSequence, handling {@code null}.
     * This method uses {@link String#indexOf(String)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.ordinalIndexOf(null, *, *)          = -1
     * StringUtils.ordinalIndexOf(*, null, *)          = -1
     * StringUtils.ordinalIndexOf("", "", *)           = 0
     * StringUtils.ordinalIndexOf("aabaabaa", "a", 1)  = 0
     * StringUtils.ordinalIndexOf("aabaabaa", "a", 2)  = 1
     * StringUtils.ordinalIndexOf("aabaabaa", "b", 1)  = 2
     * StringUtils.ordinalIndexOf("aabaabaa", "b", 2)  = 5
     * StringUtils.ordinalIndexOf("aabaabaa", "ab", 1) = 1
     * StringUtils.ordinalIndexOf("aabaabaa", "ab", 2) = 4
     * StringUtils.ordinalIndexOf("aabaabaa", "", 1)   = 0
     * StringUtils.ordinalIndexOf("aabaabaa", "", 2)   = 0
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note that 'head(CharSequence str, int n)' may be implemented as: &lt;/p&gt;
     *
     * &lt;pre&gt;
     *   str.substring(0, lastOrdinalIndexOf(str, "\n", n))
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @param ordinal  the n-th {@code searchStr} to find
     * @return the n-th index of the search CharSequence,
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
     * @since 2.1
     * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>ordinalIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>ordinal</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>ordinalIndexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><name>ordinal</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the n-th index within a String, handling {@code null}.
     * This method uses {@link String#indexOf(String)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.&lt;/p&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @param ordinal  the n-th {@code searchStr} to find
     * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()
     * @return the n-th index of the search CharSequence,
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
     */</comment>
    <comment type="line">// Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>ordinalIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>ordinal</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>lastIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStr</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>ordinal</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><ternary><condition><expr><name>lastIndex</name></expr> ?</condition><then> <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><ternary><condition><expr><name>lastIndex</name></expr> ?</condition><then> <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>INDEX_NOT_FOUND</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <do>do <block>{
            <if>if <condition>(<expr><name>lastIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>index</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
        }</block> while <condition>(<expr><name>found</name> <operator>&lt;</operator> <name>ordinal</name></expr>)</condition>;</do>
        <return>return <expr><name>index</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case in-sensitive find of the first index within a CharSequence.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position is treated as zero.
     * An empty ("") search CharSequence always matches.
     * A start position greater than the string length only matches
     * an empty search CharSequence.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfIgnoreCase(null, *)          = -1
     * StringUtils.indexOfIgnoreCase(*, null)          = -1
     * StringUtils.indexOfIgnoreCase("", "")           = 0
     * StringUtils.indexOfIgnoreCase("aabaabaa", "a")  = 0
     * StringUtils.indexOfIgnoreCase("aabaabaa", "b")  = 2
     * StringUtils.indexOfIgnoreCase("aabaabaa", "ab") = 1
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @return the first index of the search CharSequence,
     *  -1 if no match or {@code null} string input
     * @since 2.5
     * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOfIgnoreCase</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case in-sensitive find of the first index within a CharSequence
     * from the specified position.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position is treated as zero.
     * An empty ("") search CharSequence always matches.
     * A start position greater than the string length only matches
     * an empty search CharSequence.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
     * StringUtils.indexOfIgnoreCase("", "", 0)           = 0
     * StringUtils.indexOfIgnoreCase("aabaabaa", "A", 0)  = 0
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 0)  = 2
     * StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0) = 1
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 3)  = 5
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 9)  = -1
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", -1) = 2
     * StringUtils.indexOfIgnoreCase("aabaabaa", "", 2)   = 2
     * StringUtils.indexOfIgnoreCase("abc", "", 9)        = 3
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search CharSequence (always &amp;ge; startPos),
     *  -1 if no match or {@code null} string input
     * @since 2.5
     * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startPos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>endLimit</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>startPos</name> <operator>&gt;</operator> <name>endLimit</name></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>startPos</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startPos</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endLimit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// LastIndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index within a CharSequence, handling {@code null}.
     * This method uses {@link String#lastIndexOf(int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") CharSequence will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *)         = -1
     * StringUtils.lastIndexOf("", *)           = -1
     * StringUtils.lastIndexOf("aabaabaa", 'a') = 7
     * StringUtils.lastIndexOf("aabaabaa", 'b') = 5
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChar  the character to find
     * @return the last index of the search character,
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchChar</name></expr></argument>, <argument><expr><call><name><name>seq</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index within a CharSequence from a start position,
     * handling {@code null}.
     * This method uses {@link String#lastIndexOf(int, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") CharSequence will return {@code -1}.
     * A negative start position returns {@code -1}.
     * A start position greater than the string length searches the whole string.
     * The search starts at the startPos and works backwards; matches starting after the start
     * position are ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *, *)          = -1
     * StringUtils.lastIndexOf("", *,  *)           = -1
     * StringUtils.lastIndexOf("aabaabaa", 'b', 8)  = 5
     * StringUtils.lastIndexOf("aabaabaa", 'b', 4)  = 2
     * StringUtils.lastIndexOf("aabaabaa", 'b', 0)  = -1
     * StringUtils.lastIndexOf("aabaabaa", 'b', 9)  = 5
     * StringUtils.lastIndexOf("aabaabaa", 'b', -1) = -1
     * StringUtils.lastIndexOf("aabaabaa", 'a', 0)  = 0
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChar  the character to find
     * @param startPos  the start position
     * @return the last index of the search character (always &amp;le; startPos),
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchChar</name></expr></argument>, <argument><expr><name>startPos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index within a CharSequence, handling {@code null}.
     * This method uses {@link String#lastIndexOf(String)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *)          = -1
     * StringUtils.lastIndexOf(*, null)          = -1
     * StringUtils.lastIndexOf("", "")           = 0
     * StringUtils.lastIndexOf("aabaabaa", "a")  = 7
     * StringUtils.lastIndexOf("aabaabaa", "b")  = 5
     * StringUtils.lastIndexOf("aabaabaa", "ab") = 4
     * StringUtils.lastIndexOf("aabaabaa", "")   = 8
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchSeq  the CharSequence to find, may be null
     * @return the last index of the search String,
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from lastIndexOf(String, String) to lastIndexOf(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchSeq</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchSeq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchSeq</name></expr></argument>, <argument><expr><call><name><name>seq</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the n-th last index within a String, handling {@code null}.
     * This method uses {@link String#lastIndexOf(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} String will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
     * StringUtils.lastOrdinalIndexOf("", "", *)           = 0
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 1)  = 7
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 2)  = 6
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 1)  = 5
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 2)  = 2
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 1) = 4
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 2) = 1
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "", 1)   = 8
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "", 2)   = 8
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note that 'tail(CharSequence str, int n)' may be implemented as: &lt;/p&gt;
     *
     * &lt;pre&gt;
     *   str.substring(lastOrdinalIndexOf(str, "\n", n) + 1)
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @param ordinal  the n-th last {@code searchStr} to find
     * @return the n-th last index of the search CharSequence,
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
     * @since 2.5
     * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastOrdinalIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>ordinal</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>ordinalIndexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><name>ordinal</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index within a CharSequence, handling {@code null}.
     * This method uses {@link String#lastIndexOf(String, int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position returns {@code -1}.
     * An empty ("") search CharSequence always matches unless the start position is negative.
     * A start position greater than the string length searches the whole string.
     * The search starts at the startPos and works backwards; matches starting after the start
     * position are ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *, *)          = -1
     * StringUtils.lastIndexOf(*, null, *)          = -1
     * StringUtils.lastIndexOf("aabaabaa", "a", 8)  = 7
     * StringUtils.lastIndexOf("aabaabaa", "b", 8)  = 5
     * StringUtils.lastIndexOf("aabaabaa", "ab", 8) = 4
     * StringUtils.lastIndexOf("aabaabaa", "b", 9)  = 5
     * StringUtils.lastIndexOf("aabaabaa", "b", -1) = -1
     * StringUtils.lastIndexOf("aabaabaa", "a", 0)  = 0
     * StringUtils.lastIndexOf("aabaabaa", "b", 0)  = -1
     * StringUtils.lastIndexOf("aabaabaa", "b", 1)  = -1
     * StringUtils.lastIndexOf("aabaabaa", "b", 2)  = 2
     * StringUtils.lastIndexOf("aabaabaa", "ba", 2)  = -1
     * StringUtils.lastIndexOf("aabaabaa", "ba", 2)  = 2
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchSeq  the CharSequence to find, may be null
     * @param startPos  the start position, negative treated as zero
     * @return the last index of the search CharSequence (always &amp;le; startPos),
     *  -1 if no match or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from lastIndexOf(String, String, int) to lastIndexOf(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchSeq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchSeq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchSeq</name></expr></argument>, <argument><expr><name>startPos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case in-sensitive find of the last index within a CharSequence.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position returns {@code -1}.
     * An empty ("") search CharSequence always matches unless the start position is negative.
     * A start position greater than the string length searches the whole string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A")  = 7
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B")  = 5
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB") = 4
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @return the first index of the search CharSequence,
     *  -1 if no match or {@code null} string input
     * @since 2.5
     * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOfIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>lastIndexOfIgnoreCase</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case in-sensitive find of the last index within a CharSequence
     * from the specified position.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A negative start position returns {@code -1}.
     * An empty ("") search CharSequence always matches unless the start position is negative.
     * A start position greater than the string length searches the whole string.
     * The search starts at the startPos and works backwards; matches starting after the start
     * position are ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8)  = 7
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 8)  = 5
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB", 8) = 4
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 9)  = 5
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", -1) = -1
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 0)  = 0
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 0)  = -1
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @param startPos  the start position
     * @return the last index of the search CharSequence (always &amp;le; startPos),
     *  -1 if no match or {@code null} input
     * @since 2.5
     * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOfIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startPos</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startPos</name> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startPos</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>startPos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>startPos</name></expr>;</return>
        }</block></then></if>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startPos</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// Contains</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if CharSequence contains a search character, handling {@code null}.
     * This method uses {@link String#indexOf(int)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") CharSequence will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *)    = false
     * StringUtils.contains("", *)      = false
     * StringUtils.contains("abc", 'a') = true
     * StringUtils.contains("abc", 'z') = false
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChar  the character to find
     * @return true if the CharSequence contains the search character,
     *  false if not or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchChar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if CharSequence contains a search CharSequence, handling {@code null}.
     * This method uses {@link String#indexOf(String)} if possible.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *)     = false
     * StringUtils.contains(*, null)     = false
     * StringUtils.contains("", "")      = true
     * StringUtils.contains("abc", "")   = true
     * StringUtils.contains("abc", "a")  = true
     * StringUtils.contains("abc", "z")  = false
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchSeq  the CharSequence to find, may be null
     * @return true if the CharSequence contains the search CharSequence,
     *  false if not or {@code null} string input
     * @since 2.0
     * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchSeq</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchSeq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>searchSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if CharSequence contains a search CharSequence irrespective of case,
     * handling {@code null}. Case-insensitivity is defined as by
     * {@link String#equalsIgnoreCase(String)}.
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *) = false
     * StringUtils.contains(*, null) = false
     * StringUtils.contains("", "") = true
     * StringUtils.contains("abc", "") = true
     * StringUtils.contains("abc", "a") = true
     * StringUtils.contains("abc", "z") = false
     * StringUtils.contains("abc", "A") = true
     * StringUtils.contains("abc", "Z") = false
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStr  the CharSequence to find, may be null
     * @return true if the CharSequence contains the search CharSequence irrespective of
     * case or false if not or {@code null} string input
     * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchStr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>len</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check whether the given CharSequence contains any whitespace characters.
     * @param seq the CharSequence to check (may be {@code null})
     * @return {@code true} if the CharSequence is not empty and
     * contains at least 1 whitespace character
     * @see Character#isWhitespace
     * @since 3.0
     */</comment>
    <comment type="line">// From org.springframework.util.StringUtils, under Apache License 2.0</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsWhitespace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>seq</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>seq</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="line">// IndexOfAny chars</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Search a CharSequence to find the first index of any
     * character in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} String will return {@code -1}.
     * A {@code null} or zero length search array will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)                = -1
     * StringUtils.indexOfAny("", *)                  = -1
     * StringUtils.indexOfAny(*, null)                = -1
     * StringUtils.indexOfAny(*, [])                  = -1
     * StringUtils.indexOfAny("zzabyycdxx",['z','a']) = 0
     * StringUtils.indexOfAny("zzabyycdxx",['b','y']) = 3
     * StringUtils.indexOfAny("aba", ['z'])           = -1
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLen</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLast</name> <init>= <expr><name>csLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLen</name> <init>= <expr><name><name>searchChars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLast</name> <init>= <expr><name>searchLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>searchLen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>csLast</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>searchLast</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isHighSurrogate</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// ch is a supplementary character</comment>
                        <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <return>return <expr><name>i</name></expr>;</return>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <return>return <expr><name>i</name></expr>;</return>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Search a CharSequence to find the first index of any
     * character in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} String will return {@code -1}.
     * A {@code null} search string will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)            = -1
     * StringUtils.indexOfAny("", *)              = -1
     * StringUtils.indexOfAny(*, null)            = -1
     * StringUtils.indexOfAny(*, "")              = -1
     * StringUtils.indexOfAny("zzabyycdxx", "za") = 0
     * StringUtils.indexOfAny("zzabyycdxx", "by") = 3
     * StringUtils.indexOfAny("aba","z")          = -1
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>indexOfAny</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><call><name><name>searchChars</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// ContainsAny</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains any character in the given
     * set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code false}.
     * A {@code null} or zero length search array will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsAny(null, *)                = false
     * StringUtils.containsAny("", *)                  = false
     * StringUtils.containsAny(*, null)                = false
     * StringUtils.containsAny(*, [])                  = false
     * StringUtils.containsAny("zzabyycdxx",['z','a']) = true
     * StringUtils.containsAny("zzabyycdxx",['b','y']) = true
     * StringUtils.containsAny("aba", ['z'])           = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the {@code true} if any of the chars are found,
     * {@code false} if no match or null input
     * @since 2.4
     * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLength</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLength</name> <init>= <expr><name><name>searchChars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLast</name> <init>= <expr><name>csLength</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLast</name> <init>= <expr><name>searchLength</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>searchLength</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isHighSurrogate</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>searchLast</name></expr>)</condition><then> <block>{
                            <comment type="line">// missing low surrogate, fine, like String.indexOf(String)</comment>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>csLast</name> <operator>&amp;&amp;</operator> <name><name>searchChars</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <comment type="line">// ch is in the Basic Multilingual Plane</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Checks if the CharSequence contains any character in the given set of characters.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return
     * {@code false}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsAny(null, *)            = false
     * StringUtils.containsAny("", *)              = false
     * StringUtils.containsAny(*, null)            = false
     * StringUtils.containsAny(*, "")              = false
     * StringUtils.containsAny("zzabyycdxx", "za") = true
     * StringUtils.containsAny("zzabyycdxx", "by") = true
     * StringUtils.containsAny("aba","z")          = false
     * &lt;/pre&gt;
     *
     * @param cs
     *            the CharSequence to check, may be null
     * @param searchChars
     *            the chars to search for, may be null
     * @return the {@code true} if any of the chars are found, {@code false} if no match or null input
     * @since 2.4
     * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>searchChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>containsAny</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>toCharArray</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// IndexOfAnyBut chars</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Searches a CharSequence to find the first index of any
     * character not in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A {@code null} or zero length search array will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAnyBut(null, *)                              = -1
     * StringUtils.indexOfAnyBut("", *)                                = -1
     * StringUtils.indexOfAnyBut(*, null)                              = -1
     * StringUtils.indexOfAnyBut(*, [])                                = -1
     * StringUtils.indexOfAnyBut("zzabyycdxx", new char[] {'z', 'a'} ) = 3
     * StringUtils.indexOfAnyBut("aba", new char[] {'z'} )             = 0
     * StringUtils.indexOfAnyBut("aba", new char[] {'a', 'b'} )        = -1

     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfAnyBut</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLen</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLast</name> <init>= <expr><name>csLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLen</name> <init>= <expr><name><name>searchChars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLast</name> <init>= <expr><name>searchLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <label><name>outer</name>:</label>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>searchLen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>csLast</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>searchLast</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isHighSurrogate</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <continue>continue <name>outer</name>;</continue>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <continue>continue <name>outer</name>;</continue>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
            <return>return <expr><name>i</name></expr>;</return>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Search a CharSequence to find the first index of any
     * character not in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A {@code null} or empty search string will return {@code -1}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAnyBut(null, *)            = -1
     * StringUtils.indexOfAnyBut("", *)              = -1
     * StringUtils.indexOfAnyBut(*, null)            = -1
     * StringUtils.indexOfAnyBut(*, "")              = -1
     * StringUtils.indexOfAnyBut("zzabyycdxx", "za") = 3
     * StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1
     * StringUtils.indexOfAnyBut("aba","ab")         = -1
     * &lt;/pre&gt;
     *
     * @param seq  the CharSequence to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfAnyBut</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>seq</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>seq</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>chFound</name> <init>= <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>strLen</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isHighSurrogate</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch2</name> <init>= <expr><call><name><name>seq</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>chFound</name> <operator>&amp;&amp;</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>, <argument><expr><name>ch2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><operator>!</operator><name>chFound</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// ContainsOnly</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code false}.
     * A {@code null} valid character array will return {@code false}.
     * An empty CharSequence (length()=0) always returns {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsOnly(null, *)       = false
     * StringUtils.containsOnly(*, null)       = false
     * StringUtils.containsOnly("", *)         = true
     * StringUtils.containsOnly("ab", '')      = false
     * StringUtils.containsOnly("abab", 'abc') = true
     * StringUtils.containsOnly("ab1", 'abc')  = false
     * StringUtils.containsOnly("abz", 'abc')  = false
     * &lt;/pre&gt;
     *
     * @param cs  the String to check, may be null
     * @param valid  an array of valid chars, may be null
     * @return true if it only contains valid chars and is non-null
     * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsOnly</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>valid</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// All these pre-checks are to maintain API with an older version</comment>
        <if>if <condition>(<expr><name>valid</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>valid</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>indexOfAnyBut</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>valid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code false}.
     * A {@code null} valid character String will return {@code false}.
     * An empty String (length()=0) always returns {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsOnly(null, *)       = false
     * StringUtils.containsOnly(*, null)       = false
     * StringUtils.containsOnly("", *)         = true
     * StringUtils.containsOnly("ab", "")      = false
     * StringUtils.containsOnly("abab", "abc") = true
     * StringUtils.containsOnly("ab1", "abc")  = false
     * StringUtils.containsOnly("abz", "abc")  = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param validChars  a String of valid chars, may be null
     * @return true if it only contains valid chars and is non-null
     * @since 2.0
     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsOnly</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>validChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>validChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>containsOnly</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><call><name><name>validChars</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// ContainsNone</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks that the CharSequence does not contain certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code true}.
     * A {@code null} invalid character array will return {@code true}.
     * An empty CharSequence (length()=0) always returns true.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsNone(null, *)       = true
     * StringUtils.containsNone(*, null)       = true
     * StringUtils.containsNone("", *)         = true
     * StringUtils.containsNone("ab", '')      = true
     * StringUtils.containsNone("abab", 'xyz') = true
     * StringUtils.containsNone("ab1", 'xyz')  = true
     * StringUtils.containsNone("abz", 'xyz')  = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param searchChars  an array of invalid chars, may be null
     * @return true if it contains none of the invalid chars, or is null
     * @since 2.0
     * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsNone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>searchChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLen</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>csLast</name> <init>= <expr><name>csLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLen</name> <init>= <expr><name><name>searchChars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLast</name> <init>= <expr><name>searchLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>searchLen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>searchChars</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isHighSurrogate</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>searchLast</name></expr>)</condition><then> <block>{
                            <comment type="line">// missing low surrogate, fine, like String.indexOf(String)</comment>
                            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>csLast</name> <operator>&amp;&amp;</operator> <name><name>searchChars</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <comment type="line">// ch is in the Basic Multilingual Plane</comment>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks that the CharSequence does not contain certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code true}.
     * A {@code null} invalid character array will return {@code true}.
     * An empty String ("") always returns true.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsNone(null, *)       = true
     * StringUtils.containsNone(*, null)       = true
     * StringUtils.containsNone("", *)         = true
     * StringUtils.containsNone("ab", "")      = true
     * StringUtils.containsNone("abab", "xyz") = true
     * StringUtils.containsNone("ab1", "xyz")  = true
     * StringUtils.containsNone("abz", "xyz")  = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @param invalidChars  a String of invalid chars, may be null
     * @return true if it contains none of the invalid chars, or is null
     * @since 2.0
     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>containsNone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>invalidChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>invalidChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>containsNone</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><call><name><name>invalidChars</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// IndexOfAny strings</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Find the first index of any of a set of potential substrings.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A {@code null} or zero length search array will return {@code -1}.
     * A {@code null} search array entry will be ignored, but a search
     * array containing "" will return {@code 0} if {@code str} is not
     * null. This method uses {@link String#indexOf(String)} if possible.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)                     = -1
     * StringUtils.indexOfAny(*, null)                     = -1
     * StringUtils.indexOfAny(*, [])                       = -1
     * StringUtils.indexOfAny("zzabyycdxx", ["ab","cd"])   = 2
     * StringUtils.indexOfAny("zzabyycdxx", ["cd","ab"])   = 2
     * StringUtils.indexOfAny("zzabyycdxx", ["mn","op"])   = -1
     * StringUtils.indexOfAny("zzabyycdxx", ["zab","aby"]) = 1
     * StringUtils.indexOfAny("zzabyycdxx", [""])          = 0
     * StringUtils.indexOfAny("", [""])                    = 0
     * StringUtils.indexOfAny("", ["a"])                   = -1
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStrs  the CharSequences to search for, may be null
     * @return the first index of any of the searchStrs in str, -1 if no match
     * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>searchStrs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStrs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><name><name>searchStrs</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// String's can't have a MAX_VALUEth index.</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>search</name> <init>= <expr><name><name>searchStrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>search</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>search</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <if>if <condition>(<expr><name>tmp</name> <operator>&lt;</operator> <name>ret</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr> ?</condition><then> <expr><name>INDEX_NOT_FOUND</name></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Find the latest index of any of a set of potential substrings.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} CharSequence will return {@code -1}.
     * A {@code null} search array will return {@code -1}.
     * A {@code null} or zero length search array entry will be ignored,
     * but a search array containing "" will return the length of {@code str}
     * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOfAny(null, *)                   = -1
     * StringUtils.lastIndexOfAny(*, null)                   = -1
     * StringUtils.lastIndexOfAny(*, [])                     = -1
     * StringUtils.lastIndexOfAny(*, [null])                 = -1
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["ab","cd"]) = 6
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["cd","ab"]) = 6
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn","op"]) = -1
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn","op"]) = -1
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn",""])   = 10
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param searchStrs  the CharSequences to search for, may be null
     * @return the last index of any of the CharSequences, -1 if no match
     * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOfAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>searchStrs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>searchStrs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><name><name>searchStrs</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>INDEX_NOT_FOUND</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>search</name> <init>= <expr><name><name>searchStrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>search</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>search</name></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tmp</name> <operator>&gt;</operator> <name>ret</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>ret</name></expr>;</return>
    }</block></function>

    <comment type="line">// Substring</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
     *
     * &lt;p&gt;A negative start position can be used to start {@code n}
     * characters from the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} String will return {@code null}.
     * An empty ("") String will return "".&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *)   = null
     * StringUtils.substring("", *)     = ""
     * StringUtils.substring("abc", 0)  = "abc"
     * StringUtils.substring("abc", 2)  = "c"
     * StringUtils.substring("abc", 4)  = ""
     * StringUtils.substring("abc", -2) = "bc"
     * StringUtils.substring("abc", -4) = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to get the substring from, may be null
     * @param start  the position to start from, negative means
     *  count back from the end of the String by this many characters
     * @return substring from start position, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substring</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <comment type="line">// handle negatives, which means last n characters</comment>
        <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>start</name></expr>;</expr_stmt> <comment type="line">// remember start is negative</comment>
        }</block></then></if>

        <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
     *
     * &lt;p&gt;A negative start position can be used to start/end {@code n}
     * characters from the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;The returned substring starts with the character in the {@code start}
     * position and ends before the {@code end} position. All position counting is
     * zero-based -- i.e., to start at the beginning of the string use
     * {@code start = 0}. Negative start and end positions can be used to
     * specify offsets relative to the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code start} is not strictly to the left of {@code end}, ""
     * is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *, *)    = null
     * StringUtils.substring("", * ,  *)    = "";
     * StringUtils.substring("abc", 0, 2)   = "ab"
     * StringUtils.substring("abc", 2, 0)   = ""
     * StringUtils.substring("abc", 2, 4)   = "c"
     * StringUtils.substring("abc", 4, 6)   = ""
     * StringUtils.substring("abc", 2, 2)   = ""
     * StringUtils.substring("abc", -2, -1) = "b"
     * StringUtils.substring("abc", -4, 2)  = "ab"
     * &lt;/pre&gt;
     *
     * @param str  the String to get the substring from, may be null
     * @param start  the position to start from, negative means
     *  count back from the end of the String by this many characters
     * @param end  the position to end at (exclusive), negative means
     *  count back from the end of the String by this many characters
     * @return substring from start position to end position,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substring</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <comment type="line">// handle negatives</comment>
        <if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>end</name></expr>;</expr_stmt> <comment type="line">// remember end is negative</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>start</name></expr>;</expr_stmt> <comment type="line">// remember start is negative</comment>
        }</block></then></if>

        <comment type="line">// check length next</comment>
        <if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// if start is greater than end, return ""</comment>
        <if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Left/Right/Mid</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the leftmost {@code len} characters of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code len} characters are not available, or the
     * String is {@code null}, the String will be returned without
     * an exception. An empty String is returned if len is negative.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.left(null, *)    = null
     * StringUtils.left(*, -ve)     = ""
     * StringUtils.left("", *)      = ""
     * StringUtils.left("abc", 0)   = ""
     * StringUtils.left("abc", 2)   = "ab"
     * StringUtils.left("abc", 4)   = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to get the leftmost characters from, may be null
     * @param len  the length of the required String
     * @return the leftmost characters, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>left</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>len</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the rightmost {@code len} characters of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code len} characters are not available, or the String
     * is {@code null}, the String will be returned without an
     * an exception. An empty String is returned if len is negative.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.right(null, *)    = null
     * StringUtils.right(*, -ve)     = ""
     * StringUtils.right("", *)      = ""
     * StringUtils.right("abc", 0)   = ""
     * StringUtils.right("abc", 2)   = "bc"
     * StringUtils.right("abc", 4)   = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to get the rightmost characters from, may be null
     * @param len  the length of the required String
     * @return the rightmost characters, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>right</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>len</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets {@code len} characters from the middle of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code len} characters are not available, the remainder
     * of the String will be returned without an exception. If the
     * String is {@code null}, {@code null} will be returned.
     * An empty String is returned if len is negative or exceeds the
     * length of {@code str}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.mid(null, *, *)    = null
     * StringUtils.mid(*, *, -ve)     = ""
     * StringUtils.mid("", 0, *)      = ""
     * StringUtils.mid("abc", 0, 2)   = "ab"
     * StringUtils.mid("abc", 0, 4)   = "abc"
     * StringUtils.mid("abc", 2, 4)   = "c"
     * StringUtils.mid("abc", 4, 2)   = ""
     * StringUtils.mid("abc", -2, 2)  = "ab"
     * &lt;/pre&gt;
     *
     * @param str  the String to get the characters from, may be null
     * @param pos  the position to start from, negative treated as zero
     * @param len  the length of the required String
     * @return the middle characters, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>mid</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>len</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>pos</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// SubStringAfter/SubStringBefore</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the substring before the first occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input will return {@code null}.
     * An empty ("") string input will return the empty string.
     * A {@code null} separator will return the input string.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBefore(null, *)      = null
     * StringUtils.substringBefore("", *)        = ""
     * StringUtils.substringBefore("abc", "a")   = ""
     * StringUtils.substringBefore("abcba", "b") = "a"
     * StringUtils.substringBefore("abc", "c")   = "ab"
     * StringUtils.substringBefore("abc", "d")   = "abc"
     * StringUtils.substringBefore("abc", "")    = ""
     * StringUtils.substringBefore("abc", null)  = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring before the first occurrence of the separator,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringBefore</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>separator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>separator</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the substring after the first occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input will return {@code null}.
     * An empty ("") string input will return the empty string.
     * A {@code null} separator will return the empty string if the
     * input string is not {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfter(null, *)      = null
     * StringUtils.substringAfter("", *)        = ""
     * StringUtils.substringAfter(*, null)      = ""
     * StringUtils.substringAfter("abc", "a")   = "bc"
     * StringUtils.substringAfter("abcba", "b") = "cba"
     * StringUtils.substringAfter("abc", "c")   = ""
     * StringUtils.substringAfter("abc", "d")   = ""
     * StringUtils.substringAfter("abc", "")    = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring after the first occurrence of the separator,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringAfter</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>separator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <call><name><name>separator</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the substring before the last occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input will return {@code null}.
     * An empty ("") string input will return the empty string.
     * An empty or {@code null} separator will return the input string.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBeforeLast(null, *)      = null
     * StringUtils.substringBeforeLast("", *)        = ""
     * StringUtils.substringBeforeLast("abcba", "b") = "abc"
     * StringUtils.substringBeforeLast("abc", "c")   = "ab"
     * StringUtils.substringBeforeLast("a", "a")     = ""
     * StringUtils.substringBeforeLast("a", "z")     = "a"
     * StringUtils.substringBeforeLast("a", null)    = "a"
     * StringUtils.substringBeforeLast("a", "")      = "a"
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring before the last occurrence of the separator,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringBeforeLast</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the substring after the last occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input will return {@code null}.
     * An empty ("") string input will return the empty string.
     * An empty or {@code null} separator will return the empty string if
     * the input string is not {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfterLast(null, *)      = null
     * StringUtils.substringAfterLast("", *)        = ""
     * StringUtils.substringAfterLast(*, "")        = ""
     * StringUtils.substringAfterLast(*, null)      = ""
     * StringUtils.substringAfterLast("abc", "a")   = "bc"
     * StringUtils.substringAfterLast("abcba", "b") = "a"
     * StringUtils.substringAfterLast("abc", "c")   = ""
     * StringUtils.substringAfterLast("a", "a")     = ""
     * StringUtils.substringAfterLast("a", "z")     = ""
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring after the last occurrence of the separator,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringAfterLast</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name> <operator>||</operator> <name>pos</name> <operator>==</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>separator</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <call><name><name>separator</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Substring between</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the String that is nested in between two instances of the
     * same String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} tag returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween(null, *)            = null
     * StringUtils.substringBetween("", "")             = ""
     * StringUtils.substringBetween("", "tag")          = null
     * StringUtils.substringBetween("tagabctag", null)  = null
     * StringUtils.substringBetween("tagabctag", "")    = ""
     * StringUtils.substringBetween("tagabctag", "tag") = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substring, may be null
     * @param tag  the String before and after the substring, may be null
     * @return the substring, {@code null} if no match
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>tag</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>substringBetween</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the String that is nested in between two Strings.
     * Only the first match is returned.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} open/close returns {@code null} (no match).
     * An empty ("") open and close returns an empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween("wx[b]yz", "[", "]") = "b"
     * StringUtils.substringBetween(null, *, *)          = null
     * StringUtils.substringBetween(*, null, *)          = null
     * StringUtils.substringBetween(*, *, null)          = null
     * StringUtils.substringBetween("", "", "")          = ""
     * StringUtils.substringBetween("", "", "]")         = null
     * StringUtils.substringBetween("", "[", "]")        = null
     * StringUtils.substringBetween("yabcz", "", "")     = ""
     * StringUtils.substringBetween("yabcz", "y", "z")   = "abc"
     * StringUtils.substringBetween("yabczyabcz", "y", "z")   = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substring, may be null
     * @param open  the String before the substring, may be null
     * @param close  the String after the substring, may be null
     * @return the substring, {@code null} if no match
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>substringBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>open</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>close</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>open</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>close</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>open</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>start</name> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>end</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>close</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <call><name><name>open</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name> <operator>+</operator> <call><name><name>open</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Searches a String for substrings delimited by a start and end tag,
     * returning all matching substrings in an array.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} open/close returns {@code null} (no match).
     * An empty ("") open/close returns {@code null} (no match).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringsBetween("[a][b][c]", "[", "]") = ["a","b","c"]
     * StringUtils.substringsBetween(null, *, *)            = null
     * StringUtils.substringsBetween(*, null, *)            = null
     * StringUtils.substringsBetween(*, *, null)            = null
     * StringUtils.substringsBetween("", "[", "]")          = []
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substrings, null returns null, empty returns empty
     * @param open  the String identifying the start of the substring, empty returns null
     * @param close  the String identifying the end of the substring, empty returns null
     * @return a String Array of substrings, or {@code null} if no match
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>substringsBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>open</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>close</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>open</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>close</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>closeLen</name> <init>= <expr><call><name><name>close</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>openLen</name> <init>= <expr><call><name><name>open</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>strLen</name> <operator>-</operator> <name>closeLen</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>open</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>openLen</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>end</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>close</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>end</name> <operator>+</operator> <name>closeLen</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><call><name><name>list</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name> <index>[<expr><call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Nested extraction</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>

    <comment type="line">// Splitting</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
     * separator.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null)       = null
     * StringUtils.split("")         = []
     * StringUtils.split("abc def")  = ["abc", "def"]
     * StringUtils.split("abc  def") = ["abc", "def"]
     * StringUtils.split(" abc ")    = ["abc"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @return an array of parsed Strings, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>split</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>split</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator specified.
     * This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *)         = null
     * StringUtils.split("", *)           = []
     * StringUtils.split("a.b.c", '.')    = ["a", "b", "c"]
     * StringUtils.split("a..b.c", '.')   = ["a", "b", "c"]
     * StringUtils.split("a:b:c", '.')    = ["a:b:c"]
     * StringUtils.split("a b c", ' ')    = ["a", "b", "c"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChar  the character used as the delimiter
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>split</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separatorChar</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChar</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separators specified.
     * This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *)         = null
     * StringUtils.split("", *)           = []
     * StringUtils.split("abc def", null) = ["abc", "def"]
     * StringUtils.split("abc def", " ")  = ["abc", "def"]
     * StringUtils.split("abc  def", " ") = ["abc", "def"]
     * StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  {@code null} splits on whitespace
     * @return an array of parsed Strings, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>split</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separatorChars</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChars</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array with a maximum length,
     * separators specified.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;If more than {@code max} delimited substrings are found, the last
     * returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *, *)            = null
     * StringUtils.split("", *, *)              = []
     * StringUtils.split("ab cd ef", null, 0)   = ["ab", "cd", "ef"]
     * StringUtils.split("ab   cd ef", null, 0) = ["ab", "cd", "ef"]
     * StringUtils.split("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]
     * StringUtils.split("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  {@code null} splits on whitespace
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>split</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separatorChars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChars</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.&lt;/p&gt;
     *
     * &lt;p&gt;The separator(s) will not be included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparator(null, *)               = null
     * StringUtils.splitByWholeSeparator("", *)                 = []
     * StringUtils.splitByWholeSeparator("ab de fg", null)      = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparator("ab   de fg", null)    = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparator("ab:cd:ef", ":")       = ["ab", "cd", "ef"]
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-") = ["ab", "cd", "ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  {@code null} splits on whitespace
     * @return an array of parsed Strings, {@code null} if null String was input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByWholeSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitByWholeSeparatorWorker</name><argument_list>( <argument><expr><name>str</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument> )</argument_list></call></expr> ;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.
     * Returns a maximum of {@code max} substrings.&lt;/p&gt;
     *
     * &lt;p&gt;The separator(s) will not be included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparator(null, *, *)               = null
     * StringUtils.splitByWholeSeparator("", *, *)                 = []
     * StringUtils.splitByWholeSeparator("ab de fg", null, 0)      = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparator("ab   de fg", null, 0)    = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparator("ab:cd:ef", ":", 2)       = ["ab", "cd:ef"]
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-", 5) = ["ab", "cd", "ef"]
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-", 2) = ["ab", "cd-!-ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  {@code null} splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @return an array of parsed Strings, {@code null} if null String was input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByWholeSeparator</name><parameter_list>( <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter> )</parameter_list> <block>{
        <return>return <expr><call><name>splitByWholeSeparatorWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator string specified. &lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("", *)                 = []
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null)      = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab   de fg", null)    = ["ab", "", "", "de", "fg"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab:cd:ef", ":")       = ["ab", "cd", "ef"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-") = ["ab", "cd", "ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  {@code null} splits on whitespace
     * @return an array of parsed Strings, {@code null} if null String was input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByWholeSeparatorPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitByWholeSeparatorWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.
     * Returns a maximum of {@code max} substrings.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("", *, *)                 = []
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null, 0)      = ["ab", "de", "fg"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab   de fg", null, 0)    = ["ab", "", "", "de", "fg"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab:cd:ef", ":", 2)       = ["ab", "cd:ef"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-", 5) = ["ab", "cd", "ef"]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-", 2) = ["ab", "cd-!-ef"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  {@code null} splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @return an array of parsed Strings, {@code null} if null String was input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByWholeSeparatorPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitByWholeSeparatorWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Performs the logic for the {@code splitByWholeSeparatorPreserveAllTokens} methods.
     *
     * @param str  the String to parse, may be {@code null}
     * @param separator  String containing the String to be used as a delimiter,
     *  {@code null} splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @param preserveAllTokens if {@code true}, adjacent separators are
     * treated as empty token separators; if {@code false}, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByWholeSeparatorWorker</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>preserveAllTokens</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>separator</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>EMPTY</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Split on whitespace.</comment>
            <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>preserveAllTokens</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>separatorLength</name> <init>= <expr><call><name><name>separator</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>substrings</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>numberOfSubstrings</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>beg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>end</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>beg</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>numberOfSubstrings</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>numberOfSubstrings</name> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>end</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>substrings</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <comment type="line">// The following is OK, because String.substring( beg, end ) excludes</comment>
                        <comment type="line">// the character at the position 'end'.</comment>
                        <expr_stmt><expr><call><name><name>substrings</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Set the starting point for the next search.</comment>
                        <comment type="line">// The following is equivalent to beg = end + (separatorLength - 1) + 1,</comment>
                        <comment type="line">// which is the right calculation:</comment>
                        <expr_stmt><expr><name>beg</name> <operator>=</operator> <name>end</name> <operator>+</operator> <name>separatorLength</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then> <else>else <block>{
                    <comment type="line">// We found a consecutive occurrence of the separator, so skip it.</comment>
                    <if>if <condition>(<expr><name>preserveAllTokens</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>numberOfSubstrings</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>numberOfSubstrings</name> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>end</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>substrings</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name><name>substrings</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then></if>
                    <expr_stmt><expr><name>beg</name> <operator>=</operator> <name>end</name> <operator>+</operator> <name>separatorLength</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <comment type="line">// String.substring( beg ) goes from 'beg' to the end of the String.</comment>
                <expr_stmt><expr><call><name><name>substrings</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>end</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>

        <return>return <expr><call><name><name>substrings</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>substrings</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
     * separator, preserving all tokens, including empty tokens created by
     * adjacent separators. This is an alternative to using StringTokenizer.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null)       = null
     * StringUtils.splitPreserveAllTokens("")         = []
     * StringUtils.splitPreserveAllTokens("abc def")  = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc  def") = ["abc", "", "def"]
     * StringUtils.splitPreserveAllTokens(" abc ")    = ["", "abc", ""]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be {@code null}
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separator specified,
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *)         = null
     * StringUtils.splitPreserveAllTokens("", *)           = []
     * StringUtils.splitPreserveAllTokens("a.b.c", '.')    = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a..b.c", '.')   = ["a", "", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a:b:c", '.')    = ["a:b:c"]
     * StringUtils.splitPreserveAllTokens("a\tb\nc", null) = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a b c", ' ')    = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a b c ", ' ')   = ["a", "b", "c", ""]
     * StringUtils.splitPreserveAllTokens("a b c  ", ' ')   = ["a", "b", "c", "", ""]
     * StringUtils.splitPreserveAllTokens(" a b c", ' ')   = ["", a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("  a b c", ' ')  = ["", "", a", "b", "c"]
     * StringUtils.splitPreserveAllTokens(" a b c ", ' ')  = ["", a", "b", "c", ""]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be {@code null}
     * @param separatorChar  the character used as the delimiter,
     *  {@code null} splits on whitespace
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separatorChar</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChar</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Performs the logic for the {@code split} and
     * {@code splitPreserveAllTokens} methods that do not return a
     * maximum array length.
     *
     * @param str  the String to parse, may be {@code null}
     * @param separatorChar the separate character
     * @param preserveAllTokens if {@code true}, adjacent separators are
     * treated as empty token separators; if {@code false}, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, {@code null} if null String input
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitWorker</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separatorChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>preserveAllTokens</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Performance tuned for 2.0 (JDK1.4)</comment>

        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>match</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>lastMatch</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
            <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>separatorChar</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>i</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name> <operator>&amp;&amp;</operator> <name>lastMatch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array, separators specified,
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *)           = null
     * StringUtils.splitPreserveAllTokens("", *)             = []
     * StringUtils.splitPreserveAllTokens("abc def", null)   = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc def", " ")    = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc  def", " ")   = ["abc", "", def"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":")   = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef:", ":")  = ["ab", "cd", "ef", ""]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef::", ":") = ["ab", "cd", "ef", "", ""]
     * StringUtils.splitPreserveAllTokens("ab::cd:ef", ":")  = ["ab", "", cd", "ef"]
     * StringUtils.splitPreserveAllTokens(":cd:ef", ":")     = ["", cd", "ef"]
     * StringUtils.splitPreserveAllTokens("::cd:ef", ":")    = ["", "", cd", "ef"]
     * StringUtils.splitPreserveAllTokens(":cd:ef:", ":")    = ["", cd", "ef", ""]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be {@code null}
     * @param separatorChars  the characters used as the delimiters,
     *  {@code null} splits on whitespace
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separatorChars</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChars</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits the provided text into an array with a maximum length,
     * separators specified, preserving all tokens, including empty tokens
     * created by adjacent separators.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * A {@code null} separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;If more than {@code max} delimited substrings are found, the last
     * returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *, *)            = null
     * StringUtils.splitPreserveAllTokens("", *, *)              = []
     * StringUtils.splitPreserveAllTokens("ab de fg", null, 0)   = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 0) = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 2) = ["ab", "  de fg"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 3) = ["ab", "", " de fg"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 4) = ["ab", "", "", "de fg"]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be {@code null}
     * @param separatorChars  the characters used as the delimiters,
     *  {@code null} splits on whitespace
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitPreserveAllTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separatorChars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitWorker</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChars</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Performs the logic for the {@code split} and
     * {@code splitPreserveAllTokens} methods that return a maximum array
     * length.
     *
     * @param str  the String to parse, may be {@code null}
     * @param separatorChars the separate character
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit.
     * @param preserveAllTokens if {@code true}, adjacent separators are
     * treated as empty token separators; if {@code false}, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, {@code null} if null String input
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitWorker</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separatorChars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>preserveAllTokens</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Performance tuned for 2.0 (JDK1.4)</comment>
        <comment type="line">// Direct code is quicker than StringTokenizer.</comment>
        <comment type="line">// Also, StringTokenizer uses isSpace() not isWhitespace()</comment>

        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sizePlus1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>match</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>lastMatch</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>separatorChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <comment type="line">// Null separator means use whitespace</comment>
            <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>sizePlus1</name><operator>++</operator> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>i</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>separatorChars</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <comment type="line">// Optimise 1 character case</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>sep</name> <init>= <expr><call><name><name>separatorChars</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sep</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>sizePlus1</name><operator>++</operator> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>i</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="line">// standard case</comment>
            <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name><name>separatorChars</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>sizePlus1</name><operator>++</operator> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>i</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name>lastMatch</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
        }</block></else></if>
        <if>if <condition>(<expr><name>match</name> <operator>||</operator> <name>preserveAllTokens</name> <operator>&amp;&amp;</operator> <name>lastMatch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits a String by Character type as returned by
     * {@code java.lang.Character.getType(char)}. Groups of contiguous
     * characters of the same type are returned as complete tokens.
     * &lt;pre&gt;
     * StringUtils.splitByCharacterType(null)         = null
     * StringUtils.splitByCharacterType("")           = []
     * StringUtils.splitByCharacterType("ab de fg")   = ["ab", " ", "de", " ", "fg"]
     * StringUtils.splitByCharacterType("ab   de fg") = ["ab", "   ", "de", " ", "fg"]
     * StringUtils.splitByCharacterType("ab:cd:ef")   = ["ab", ":", "cd", ":", "ef"]
     * StringUtils.splitByCharacterType("number5")    = ["number", "5"]
     * StringUtils.splitByCharacterType("fooBar")     = ["foo", "B", "ar"]
     * StringUtils.splitByCharacterType("foo200Bar")  = ["foo", "200", "B", "ar"]
     * StringUtils.splitByCharacterType("ASFRules")   = ["ASFR", "ules"]
     * &lt;/pre&gt;
     * @param str the String to split, may be {@code null}
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByCharacterType</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitByCharacterType</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits a String by Character type as returned by
     * {@code java.lang.Character.getType(char)}. Groups of contiguous
     * characters of the same type are returned as complete tokens, with the
     * following exception: the character of type
     * {@code Character.UPPERCASE_LETTER}, if any, immediately
     * preceding a token of type {@code Character.LOWERCASE_LETTER}
     * will belong to the following token rather than to the preceding, if any,
     * {@code Character.UPPERCASE_LETTER} token.
     * &lt;pre&gt;
     * StringUtils.splitByCharacterTypeCamelCase(null)         = null
     * StringUtils.splitByCharacterTypeCamelCase("")           = []
     * StringUtils.splitByCharacterTypeCamelCase("ab de fg")   = ["ab", " ", "de", " ", "fg"]
     * StringUtils.splitByCharacterTypeCamelCase("ab   de fg") = ["ab", "   ", "de", " ", "fg"]
     * StringUtils.splitByCharacterTypeCamelCase("ab:cd:ef")   = ["ab", ":", "cd", ":", "ef"]
     * StringUtils.splitByCharacterTypeCamelCase("number5")    = ["number", "5"]
     * StringUtils.splitByCharacterTypeCamelCase("fooBar")     = ["foo", "Bar"]
     * StringUtils.splitByCharacterTypeCamelCase("foo200Bar")  = ["foo", "200", "Bar"]
     * StringUtils.splitByCharacterTypeCamelCase("ASFRules")   = ["ASF", "Rules"]
     * &lt;/pre&gt;
     * @param str the String to split, may be {@code null}
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByCharacterTypeCamelCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>splitByCharacterType</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Splits a String by Character type as returned by
     * {@code java.lang.Character.getType(char)}. Groups of contiguous
     * characters of the same type are returned as complete tokens, with the
     * following exception: if {@code camelCase} is {@code true},
     * the character of type {@code Character.UPPERCASE_LETTER}, if any,
     * immediately preceding a token of type {@code Character.LOWERCASE_LETTER}
     * will belong to the following token rather than to the preceding, if any,
     * {@code Character.UPPERCASE_LETTER} token.
     * @param str the String to split, may be {@code null}
     * @param camelCase whether to use so-called "camel-case" for letter types
     * @return an array of parsed Strings, {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>splitByCharacterType</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>camelCase</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>c</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tokenStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>currentType</name> <init>= <expr><call><name><name>Character</name><operator>.</operator><name>getType</name></name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>tokenStart</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>tokenStart</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>c</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>type</name> <init>= <expr><call><name><name>Character</name><operator>.</operator><name>getType</name></name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>currentType</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr><name>camelCase</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name><name>Character</name><operator>.</operator><name>LOWERCASE_LETTER</name></name> <operator>&amp;&amp;</operator> <name>currentType</name> <operator>==</operator> <name><name>Character</name><operator>.</operator><name>UPPERCASE_LETTER</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newTokenStart</name> <init>= <expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>newTokenStart</name> <operator>!=</operator> <name>tokenStart</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tokenStart</name></expr></argument>, <argument><expr><name>newTokenStart</name> <operator>-</operator> <name>tokenStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tokenStart</name> <operator>=</operator> <name>newTokenStart</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tokenStart</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name>tokenStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tokenStart</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>currentType</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tokenStart</name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>tokenStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Joining</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No separator is added to the joined String.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null)            = null
     * StringUtils.join([])              = ""
     * StringUtils.join([null])          = ""
     * StringUtils.join(["a", "b", "c"]) = "abc"
     * StringUtils.join([null, "", "a"]) = "a"
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the specific type of values to join together
     * @param elements  the values to join together, may be null
     * @return the joined String, {@code null} if null array input
     * @since 2.0
     * @since 3.0 Changed signature to use varargs
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>elements</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>elements</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join(["a", "b", "c"], ';')  = "a;b;c"
     * StringUtils.join(["a", "b", "c"], null) = "abc"
     * StringUtils.join([null, "", "a"], ';')  = ";;a"
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join(["a", "b", "c"], ';')  = "a;b;c"
     * StringUtils.join(["a", "b", "c"], null) = "abc"
     * StringUtils.join([null, "", "a"], ';')  = ";;a"
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use
     * @param startIndex the first index to start joining from.  It is
     * an error to pass in an end index past the end of the array
     * @param endIndex the index to stop joining from (exclusive). It is
     * an error to pass in an end index past the end of the array
     * @return the joined String, {@code null} if null array input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Joins the elements of the provided array into a single String containing the provided list of elements.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented
     * by empty strings.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = ""
     * StringUtils.join([null], *)             = ""
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"
     * StringUtils.join([1, 2, 3], null) = "123"
     * &lt;/pre&gt;
     *
     * @param array
     *            the array of values to join together, may be null
     * @param separator
     *            the separator character to use
     * @param startIndex
     *            the first index to start joining from. It is an error to pass in an end index past the end of the
     *            array
     * @param endIndex
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of
     *            the array
     * @return the joined String, {@code null} if null array input
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A {@code null} separator is the same as an empty String ("").
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)                = null
     * StringUtils.join([], *)                  = ""
     * StringUtils.join([null], *)              = ""
     * StringUtils.join(["a", "b", "c"], "--")  = "a--b--c"
     * StringUtils.join(["a", "b", "c"], null)  = "abc"
     * StringUtils.join(["a", "b", "c"], "")    = "abc"
     * StringUtils.join([null, "", "a"], ',')   = ",,a"
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use, null treated as ""
     * @return the joined String, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A {@code null} separator is the same as an empty String ("").
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *, *, *)                = null
     * StringUtils.join([], *, *, *)                  = ""
     * StringUtils.join([null], *, *, *)              = ""
     * StringUtils.join(["a", "b", "c"], "--", 0, 3)  = "a--b--c"
     * StringUtils.join(["a", "b", "c"], "--", 1, 3)  = "b--c"
     * StringUtils.join(["a", "b", "c"], "--", 2, 3)  = "c"
     * StringUtils.join(["a", "b", "c"], "--", 2, 2)  = ""
     * StringUtils.join(["a", "b", "c"], null, 0, 3)  = "abc"
     * StringUtils.join(["a", "b", "c"], "", 0, 3)    = "abc"
     * StringUtils.join([null, "", "a"], ',', 0, 3)   = ",,a"
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use, null treated as ""
     * @param startIndex the first index to start joining from.
     * @param endIndex the index to stop joining from (exclusive).
     * @return the joined String, {@code null} if null array input; or the empty string
     * if {@code endIndex - startIndex &lt;= 0}. The number of joined entries is given by
     * {@code endIndex - startIndex}
     * @throws ArrayIndexOutOfBoundsException ife&lt;br/&gt;
     * {@code startIndex &lt; 0} or &lt;br/&gt;
     * {@code startIndex &gt;= array.length()} or &lt;br/&gt;
     * {@code endIndex &lt; 0} or &lt;br/&gt;
     * {@code endIndex &gt; array.length()}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>separator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>separator</name> <operator>=</operator> <name>EMPTY</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// endIndex - startIndex &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))</comment>
        <comment type="line">//           (Assuming that all Strings are roughly equally long)</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>noOfItems</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>noOfItems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>noOfItems</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>startIndex</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided {@code Iterator} into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
     * strings within the iteration are represented by empty strings.&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
     *
     * @param iterator  the {@code Iterator} of values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, {@code null} if null iterator input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{

        <comment type="line">// handle null, zero and one elements before building a buffer</comment>
        <if>if <condition>(<expr><name>iterator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>first</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>ObjectUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// two or more elements</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Java default is 16, probably too small</comment>
        <if>if <condition>(<expr><name>first</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <while>while <condition>(<expr><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>

        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided {@code Iterator} into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A {@code null} separator is the same as an empty String ("").&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
     *
     * @param iterator  the {@code Iterator} of values to join together, may be null
     * @param separator  the separator character to use, null treated as ""
     * @return the joined String, {@code null} if null iterator input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{

        <comment type="line">// handle null, zero and one elements before building a buffer</comment>
        <if>if <condition>(<expr><name>iterator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>first</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>ObjectUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// two or more elements</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Java default is 16, probably too small</comment>
        <if>if <condition>(<expr><name>first</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <while>while <condition>(<expr><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <if>if <condition>(<expr><name>separator</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided {@code Iterable} into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
     * strings within the iteration are represented by empty strings.&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
     *
     * @param iterable  the {@code Iterable} providing the values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, {@code null} if null iterator input
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterable</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>iterable</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><call><name><name>iterable</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Joins the elements of the provided {@code Iterable} into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A {@code null} separator is the same as an empty String ("").&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
     *
     * @param iterable  the {@code Iterable} providing the values to join together, may be null
     * @param separator  the separator character to use, null treated as ""
     * @return the joined String, {@code null} if null iterator input
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterable</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>iterable</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><call><name><name>iterable</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Delete</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deletes all whitespaces from a String as defined by
     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.deleteWhitespace(null)         = null
     * StringUtils.deleteWhitespace("")           = ""
     * StringUtils.deleteWhitespace("abc")        = "abc"
     * StringUtils.deleteWhitespace("   ab  c  ") = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to delete whitespace from, may be null
     * @return the String without whitespaces, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>deleteWhitespace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chs</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>sz</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>chs</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>sz</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>chs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Remove</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes a substring only if it is at the beginning of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStart(null, *)      = null
     * StringUtils.removeStart("", *)        = ""
     * StringUtils.removeStart(*, null)      = *
     * StringUtils.removeStart("www.domain.com", "www.")   = "domain.com"
     * StringUtils.removeStart("domain.com", "www.")       = "domain.com"
     * StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com"
     * StringUtils.removeStart("abc", "")    = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>removeStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>remove</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case insensitive removal of a substring if it is at the beginning of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStartIgnoreCase(null, *)      = null
     * StringUtils.removeStartIgnoreCase("", *)        = ""
     * StringUtils.removeStartIgnoreCase(*, null)      = *
     * StringUtils.removeStartIgnoreCase("www.domain.com", "www.")   = "domain.com"
     * StringUtils.removeStartIgnoreCase("www.domain.com", "WWW.")   = "domain.com"
     * StringUtils.removeStartIgnoreCase("domain.com", "www.")       = "domain.com"
     * StringUtils.removeStartIgnoreCase("www.domain.com", "domain") = "www.domain.com"
     * StringUtils.removeStartIgnoreCase("abc", "")    = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for (case insensitive) and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>removeStartIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>startsWithIgnoreCase</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>remove</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes a substring only if it is at the end of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEnd(null, *)      = null
     * StringUtils.removeEnd("", *)        = ""
     * StringUtils.removeEnd(*, null)      = *
     * StringUtils.removeEnd("www.domain.com", ".com.")  = "www.domain.com"
     * StringUtils.removeEnd("www.domain.com", ".com")   = "www.domain"
     * StringUtils.removeEnd("www.domain.com", "domain") = "www.domain.com"
     * StringUtils.removeEnd("abc", "")    = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>removeEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>remove</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case insensitive removal of a substring if it is at the end of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEndIgnoreCase(null, *)      = null
     * StringUtils.removeEndIgnoreCase("", *)        = ""
     * StringUtils.removeEndIgnoreCase(*, null)      = *
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".com.")  = "www.domain.com"
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".com")   = "www.domain"
     * StringUtils.removeEndIgnoreCase("www.domain.com", "domain") = "www.domain.com"
     * StringUtils.removeEndIgnoreCase("abc", "")    = "abc"
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".COM") = "www.domain")
     * StringUtils.removeEndIgnoreCase("www.domain.COM", ".com") = "www.domain")
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for (case insensitive) and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>removeEndIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>endsWithIgnoreCase</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>remove</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes all occurrences of a substring from within the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.
     * A {@code null} remove string will return the source string.
     * An empty ("") remove string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)        = null
     * StringUtils.remove("", *)          = ""
     * StringUtils.remove(*, null)        = *
     * StringUtils.remove(*, "")          = *
     * StringUtils.remove("queued", "ue") = "qd"
     * StringUtils.remove("queued", "zz") = "queued"
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>remove</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes all occurrences of a character from within the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty ("") source string will return the empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)       = null
     * StringUtils.remove("", *)         = ""
     * StringUtils.remove("queued", 'u') = "qeed"
     * StringUtils.remove("queued", 'z') = "queued"
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the char to search for and remove, may be null
     * @return the substring with the char removed if found,
     *  {@code null} if null String input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>remove</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>str</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>remove</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>remove</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>chars</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Replacing</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Replaces a String with another String inside a larger String, once.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceOnce(null, *, *)        = null
     * StringUtils.replaceOnce("", *, *)          = ""
     * StringUtils.replaceOnce("any", null, *)    = "any"
     * StringUtils.replaceOnce("any", *, null)    = "any"
     * StringUtils.replaceOnce("any", "", *)      = "any"
     * StringUtils.replaceOnce("aba", "a", null)  = "aba"
     * StringUtils.replaceOnce("aba", "a", "")    = "ba"
     * StringUtils.replaceOnce("aba", "a", "z")   = "zba"
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int max)
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace with, may be null
     * @return the text with any replacements processed,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceOnce</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchString</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replacement</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>searchString</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces each substring of the source String that matches the given regular expression with the given
     * replacement using the {@link Pattern#DOTALL} option. DOTALL is also know as single-line mode in Perl. This call
     * is also equivalent to:
     * &lt;ul&gt;
     * &lt;li&gt;{@code source.replaceAll(&amp;quot;(?s)&amp;quot; + regex, replacement)}&lt;/li&gt;
     * &lt;li&gt;{@code Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param source
     *            the source string
     * @param regex
     *            the regular expression to which this string is to be matched
     * @param replacement
     *            the string to be substituted for each match
     * @return The resulting {@code String}
     * @see String#replaceAll(String, String)
     * @see Pattern#DOTALL
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replacePattern</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replacement</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name><name>Pattern</name><operator>.</operator><name>DOTALL</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matcher</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Removes each substring of the source String that matches the given regular expression using the DOTALL option.
     *
     * @param source
     *            the source string
     * @param regex
     *            the regular expression to which this string is to be matched
     * @return The resulting {@code String}
     * @see String#replaceAll(String, String)
     * @see Pattern#DOTALL
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>removePattern</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>regex</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replacePattern</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>regex</name></expr></argument>, <argument><expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Replaces all occurrences of a String within another String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *)        = null
     * StringUtils.replace("", *, *)          = ""
     * StringUtils.replace("any", null, *)    = "any"
     * StringUtils.replace("any", *, null)    = "any"
     * StringUtils.replace("any", "", *)      = "any"
     * StringUtils.replace("aba", "a", null)  = "aba"
     * StringUtils.replace("aba", "a", "")    = "b"
     * StringUtils.replace("aba", "a", "z")   = "zbz"
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int max)
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @return the text with any replacements processed,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchString</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replacement</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>searchString</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Replaces a String with another String inside a larger String,
     * for the first {@code max} values of the search String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *, *)         = null
     * StringUtils.replace("", *, *, *)           = ""
     * StringUtils.replace("any", null, *, *)     = "any"
     * StringUtils.replace("any", *, null, *)     = "any"
     * StringUtils.replace("any", "", *, *)       = "any"
     * StringUtils.replace("any", *, *, 0)        = "any"
     * StringUtils.replace("abaa", "a", null, -1) = "abaa"
     * StringUtils.replace("abaa", "a", "", -1)   = "b"
     * StringUtils.replace("abaa", "a", "z", 0)   = "abaa"
     * StringUtils.replace("abaa", "a", "z", 1)   = "zbaa"
     * StringUtils.replace("abaa", "a", "z", 2)   = "zbza"
     * StringUtils.replace("abaa", "a", "z", -1)  = "zbzz"
     * &lt;/pre&gt;
     *
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @param max  maximum number of values to replace, or {@code -1} if no maximum
     * @return the text with any replacements processed,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchString</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replacement</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>searchString</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>replacement</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>text</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><call><name><name>text</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>searchString</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>text</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replLength</name> <init>= <expr><call><name><name>searchString</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>increase</name> <init>= <expr><call><name><name>replacement</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>replLength</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>increase</name> <operator>=</operator> <ternary><condition><expr><name>increase</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>increase</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>increase</name> <operator>*=</operator> <ternary><condition><expr><name>max</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><ternary><condition><expr><name>max</name> <operator>&gt;</operator> <literal type="number">64</literal></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><name>max</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>increase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>end</name> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <name>replLength</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>--</operator><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name><name>text</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>searchString</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if
     * any "search string" or "string to replace" is null, that replace will be
     * ignored. This will not repeat. For repeating replaces, call the
     * overloaded method.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *)        = null
     *  StringUtils.replaceEach("", *, *)          = ""
     *  StringUtils.replaceEach("aba", null, null) = "aba"
     *  StringUtils.replaceEach("aba", new String[0], null) = "aba"
     *  StringUtils.replaceEach("aba", null, new String[0]) = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null)  = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""})  = "b"
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"})  = "aba"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"})  = "wcte"
     *  (example of how it does not repeat)
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"})  = "dcte"
     * &lt;/pre&gt;
     *
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @return the text with any replacements processed, {@code null} if
     *         null String input
     * @throws IllegalArgumentException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceEach</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>searchList</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>replacementList</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replaceEach</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>searchList</name></expr></argument>, <argument><expr><name>replacementList</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if
     * any "search string" or "string to replace" is null, that replace will be
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach("", *, *, *) = ""
     *  StringUtils.replaceEach("aba", null, null, *) = "aba"
     *  StringUtils.replaceEach("aba", new String[0], null, *) = "aba"
     *  StringUtils.replaceEach("aba", null, new String[0], *) = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *) = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *) = "b"
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *) = "aba"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *) = "wcte"
     *  (example of how it repeats)
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false) = "dcte"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true) = "tcte"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, true) = IllegalStateException
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, false) = "dcabe"
     * &lt;/pre&gt;
     *
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @return the text with any replacements processed, {@code null} if
     *         null String input
     * @throws IllegalStateException
     *             if the search is repeating and there is an endless loop due
     *             to outputs of one being inputs to another
     * @throws IllegalArgumentException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceEachRepeatedly</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>searchList</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>replacementList</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// timeToLive should be 0 if not used or nothing to replace, else it's</comment>
        <comment type="line">// the length of the replace array</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>timeToLive</name> <init>= <expr><ternary><condition><expr><name>searchList</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>searchList</name><operator>.</operator><name>length</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>replaceEach</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>searchList</name></expr></argument>, <argument><expr><name>replacementList</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>timeToLive</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if
     * any "search string" or "string to replace" is null, that replace will be
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach("", *, *, *) = ""
     *  StringUtils.replaceEach("aba", null, null, *) = "aba"
     *  StringUtils.replaceEach("aba", new String[0], null, *) = "aba"
     *  StringUtils.replaceEach("aba", null, new String[0], *) = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *) = "aba"
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *) = "b"
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *) = "aba"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *) = "wcte"
     *  (example of how it repeats)
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false) = "dcte"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true) = "tcte"
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *) = IllegalStateException
     * &lt;/pre&gt;
     *
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @param repeat if true, then replace repeatedly
     *       until there are no more possible replacements or timeToLive &lt; 0
     * @param timeToLive
     *            if less than 0 then there is a circular reference and endless
     *            loop
     * @return the text with any replacements processed, {@code null} if
     *         null String input
     * @throws IllegalStateException
     *             if the search is repeating and there is an endless loop due
     *             to outputs of one being inputs to another
     * @throws IllegalArgumentException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceEach</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>searchList</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>replacementList</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>timeToLive</name></decl></parameter>)</parameter_list> <block>{

        <comment type="line">// mchyzer Performance note: This creates very few new objects (one major goal)</comment>
        <comment type="line">// let me know if there are performance requests, we can create a harness to measure</comment>

        <if>if <condition>(<expr><name>text</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>text</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>searchList</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator>
                <name><name>searchList</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>replacementList</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>replacementList</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>text</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// if recursing, this shouldn't be less than 0</comment>
        <if>if <condition>(<expr><name>timeToLive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Aborting to protect against StackOverflowError - "</literal> <operator>+</operator>
                    <literal type="string">"output of one loop is the input of another"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLength</name> <init>= <expr><name><name>searchList</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replacementLength</name> <init>= <expr><name><name>replacementList</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// make sure lengths are ok, these need to be equal</comment>
        <if>if <condition>(<expr><name>searchLength</name> <operator>!=</operator> <name>replacementLength</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Search and Replace array lengths don't match: "</literal>
                    <operator>+</operator> <name>searchLength</name>
                    <operator>+</operator> <literal type="string">" vs "</literal>
                    <operator>+</operator> <name>replacementLength</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// keep track of which still have matches</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>noMoreMatchesForReplIndex</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name>searchLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// index on index that the match was found</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>textIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>replaceIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tempIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// index of replace array that will replace the search string found</comment>
        <comment type="line">// NOTE: logic duplicated below START</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>searchLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>noMoreMatchesForReplIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator>
                    <name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>replacementList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>tempIndex</name> <operator>=</operator> <call><name><name>text</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// see if we need to keep searching for this</comment>
            <if>if <condition>(<expr><name>tempIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>noMoreMatchesForReplIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>textIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>tempIndex</name> <operator>&lt;</operator> <name>textIndex</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>textIndex</name> <operator>=</operator> <name>tempIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>replaceIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></for>
        <comment type="line">// NOTE: logic mostly below END</comment>

        <comment type="line">// no search strings found, we are done</comment>
        <if>if <condition>(<expr><name>textIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>text</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>increase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// count the replacement text elements that are larger than their corresponding text being replaced</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>searchList</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>replacementList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>greater</name> <init>= <expr><name><name>replacementList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>greater</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>increase</name> <operator>+=</operator> <literal type="number">3</literal> <operator>*</operator> <name>greater</name></expr>;</expr_stmt> <comment type="line">// assume 3 matches</comment>
            }</block></then></if>
        }</block></for>
        <comment type="line">// have upper-bound at 20% increase, then let Java take over</comment>
        <expr_stmt><expr><name>increase</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>increase</name></expr></argument>, <argument><expr><call><name><name>text</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>increase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>textIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>textIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>replacementList</name><index>[<expr><name>replaceIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>textIndex</name> <operator>+</operator> <name><name>searchList</name><index>[<expr><name>replaceIndex</name></expr>]</index></name><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>textIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>replaceIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>tempIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <comment type="line">// find the next earliest match</comment>
            <comment type="line">// NOTE: logic mostly duplicated above START</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>searchLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>noMoreMatchesForReplIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator>
                        <name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>replacementList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name>tempIndex</name> <operator>=</operator> <call><name><name>text</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name><name>searchList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// see if we need to keep searching for this</comment>
                <if>if <condition>(<expr><name>tempIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>noMoreMatchesForReplIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><name>textIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>tempIndex</name> <operator>&lt;</operator> <name>textIndex</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>textIndex</name> <operator>=</operator> <name>tempIndex</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>replaceIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></for>
            <comment type="line">// NOTE: logic duplicated above END</comment>

        }</block></while>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>textLength</name> <init>= <expr><call><name><name>text</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>textLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>text</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>result</name> <init>= <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><operator>!</operator><name>repeat</name></expr>)</condition><then> <block>{
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name>replaceEach</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>searchList</name></expr></argument>, <argument><expr><name>replacementList</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>, <argument><expr><name>timeToLive</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Replace, character based</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Replaces all occurrences of a character in a String with another.
     * This is a null-safe version of {@link String#replace(char, char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input returns {@code null}.
     * An empty ("") string input returns an empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)        = null
     * StringUtils.replaceChars("", *, *)          = ""
     * StringUtils.replaceChars("abcba", 'b', 'y') = "aycya"
     * StringUtils.replaceChars("abcba", 'z', 'y') = "abcba"
     * &lt;/pre&gt;
     *
     * @param str  String to replace characters in, may be null
     * @param searchChar  the character to search for, may be null
     * @param replaceChar  the character to replace, may be null
     * @return modified String, {@code null} if null string input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceChars</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>replaceChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>replace</name></name><argument_list>(<argument><expr><name>searchChar</name></expr></argument>, <argument><expr><name>replaceChar</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Replaces multiple characters in a String in one go.
     * This method can also be used to delete characters.&lt;/p&gt;
     *
     * &lt;p&gt;For example:&lt;br /&gt;
     * &lt;code&gt;replaceChars(&amp;quot;hello&amp;quot;, &amp;quot;ho&amp;quot;, &amp;quot;jy&amp;quot;) = jelly&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input returns {@code null}.
     * An empty ("") string input returns an empty string.
     * A null or empty set of search characters returns the input string.&lt;/p&gt;
     *
     * &lt;p&gt;The length of the search characters should normally equal the length
     * of the replace characters.
     * If the search characters is longer, then the extra search characters
     * are deleted.
     * If the search characters is shorter, then the extra replace characters
     * are ignored.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)           = null
     * StringUtils.replaceChars("", *, *)             = ""
     * StringUtils.replaceChars("abc", null, *)       = "abc"
     * StringUtils.replaceChars("abc", "", *)         = "abc"
     * StringUtils.replaceChars("abc", "b", null)     = "ac"
     * StringUtils.replaceChars("abc", "b", "")       = "ac"
     * StringUtils.replaceChars("abcba", "bc", "yz")  = "ayzya"
     * StringUtils.replaceChars("abcba", "bc", "y")   = "ayya"
     * StringUtils.replaceChars("abcba", "bc", "yzx") = "ayzya"
     * &lt;/pre&gt;
     *
     * @param str  String to replace characters in, may be null
     * @param searchChars  a set of characters to search for, may be null
     * @param replaceChars  a set of characters to replace, may be null
     * @return modified String, {@code null} if null string input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>replaceChars</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchChars</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>replaceChars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>searchChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>replaceChars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>replaceChars</name> <operator>=</operator> <name>EMPTY</name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>boolean</name></type> <name>modified</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replaceCharsLength</name> <init>= <expr><call><name><name>replaceChars</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLength</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>strLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name><name>searchChars</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>modified</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>replaceCharsLength</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>replaceChars</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <if>if <condition>(<expr><name>modified</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="line">// Overlay</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Overlays part of a String with another String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} string input returns {@code null}.
     * A negative index is treated as zero.
     * An index greater than the string length is treated as the string length.
     * The start index is always the smaller of the two indices.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.overlay(null, *, *, *)            = null
     * StringUtils.overlay("", "abc", 0, 0)          = "abc"
     * StringUtils.overlay("abcdef", null, 2, 4)     = "abef"
     * StringUtils.overlay("abcdef", "", 2, 4)       = "abef"
     * StringUtils.overlay("abcdef", "", 4, 2)       = "abef"
     * StringUtils.overlay("abcdef", "zzzz", 2, 4)   = "abzzzzef"
     * StringUtils.overlay("abcdef", "zzzz", 4, 2)   = "abzzzzef"
     * StringUtils.overlay("abcdef", "zzzz", -1, 4)  = "zzzzef"
     * StringUtils.overlay("abcdef", "zzzz", 2, 8)   = "abzzzz"
     * StringUtils.overlay("abcdef", "zzzz", -2, -3) = "zzzzabcdef"
     * StringUtils.overlay("abcdef", "zzzz", 8, 10)  = "abcdefzzzz"
     * &lt;/pre&gt;
     *
     * @param str  the String to do overlaying in, may be null
     * @param overlay  the String to overlay, may be null
     * @param start  the position to start overlaying at
     * @param end  the position to stop overlaying before
     * @return overlayed String, {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>overlay</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>overlay</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>overlay</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>overlay</name> <operator>=</operator> <name>EMPTY</name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>temp</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>start</name> <operator>-</operator> <name>end</name> <operator>+</operator> <call><name><name>overlay</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>overlay</name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Chomping</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes one newline from end of a String if it's there,
     * otherwise leave it alone.  A newline is &amp;quot;{@code \n}&amp;quot;,
     * &amp;quot;{@code \r}&amp;quot;, or &amp;quot;{@code \r\n}&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: This method changed in 2.0.
     * It now more closely matches Perl chomp.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chomp(null)          = null
     * StringUtils.chomp("")            = ""
     * StringUtils.chomp("abc \r")      = "abc "
     * StringUtils.chomp("abc\n")       = "abc"
     * StringUtils.chomp("abc\r\n")     = "abc"
     * StringUtils.chomp("abc\r\n\r\n") = "abc\r\n"
     * StringUtils.chomp("abc\n\r")     = "abc\n"
     * StringUtils.chomp("abc\n\rabc")  = "abc\n\rabc"
     * StringUtils.chomp("\r")          = ""
     * StringUtils.chomp("\n")          = ""
     * StringUtils.chomp("\r\n")        = ""
     * &lt;/pre&gt;
     *
     * @param str  the String to chomp a newline from, may be null
     * @return String without newline, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>chomp</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>CR</name></name> <operator>||</operator> <name>ch</name> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>LF</name></name></expr>)</condition><then> <block>{
                <return>return <expr><name>EMPTY</name></expr>;</return>
            }</block></then></if>
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>lastIdx</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>last</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>lastIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>last</name> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>LF</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>lastIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>CR</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>lastIdx</name><operator>--</operator></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>last</name> <operator>!=</operator> <name><name>CharUtils</name><operator>.</operator><name>CR</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lastIdx</name><operator>++</operator></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lastIdx</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes {@code separator} from the end of
     * {@code str} if it's there, otherwise leave it alone.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: This method changed in version 2.0.
     * It now more closely matches Perl chomp.
     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
     * This method uses {@link String#endsWith(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chomp(null, *)         = null
     * StringUtils.chomp("", *)           = ""
     * StringUtils.chomp("foobar", "bar") = "foo"
     * StringUtils.chomp("foobar", "baz") = "foobar"
     * StringUtils.chomp("foo", "foo")    = ""
     * StringUtils.chomp("foo ", "foo")   = "foo "
     * StringUtils.chomp(" foo", "foo")   = " "
     * StringUtils.chomp("foo", "foooo")  = "foo"
     * StringUtils.chomp("foo", "")       = "foo"
     * StringUtils.chomp("foo", null)     = "foo"
     * &lt;/pre&gt;
     *
     * @param str  the String to chomp from, may be null
     * @param separator  separator String, may be null
     * @return String without trailing separator, {@code null} if null String input
     * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String, String)} instead
     */</comment>
    <function><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>chomp</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>removeEnd</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Chopping</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Remove the last character from a String.&lt;/p&gt;
     *
     * &lt;p&gt;If the String ends in {@code \r\n}, then remove both
     * of them.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chop(null)          = null
     * StringUtils.chop("")            = ""
     * StringUtils.chop("abc \r")      = "abc "
     * StringUtils.chop("abc\n")       = "abc"
     * StringUtils.chop("abc\r\n")     = "abc"
     * StringUtils.chop("abc")         = "ab"
     * StringUtils.chop("abc\nabc")    = "abc\nab"
     * StringUtils.chop("a")           = ""
     * StringUtils.chop("\r")          = ""
     * StringUtils.chop("\n")          = ""
     * StringUtils.chop("\r\n")        = ""
     * &lt;/pre&gt;
     *
     * @param str  the String to chop last character from, may be null
     * @return String without last character, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>chop</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastIdx</name> <init>= <expr><name>strLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>ret</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lastIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>last</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>lastIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>last</name> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>LF</name></name> <operator>&amp;&amp;</operator> <call><name><name>ret</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>lastIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>CharUtils</name><operator>.</operator><name>CR</name></name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>ret</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lastIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>ret</name></expr>;</return>
    }</block></function>

    <comment type="line">// Conversion</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>

    <comment type="line">// Padding</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Repeat a String {@code repeat} times to form a
     * new String.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, 2) = null
     * StringUtils.repeat("", 0)   = ""
     * StringUtils.repeat("", 2)   = ""
     * StringUtils.repeat("a", 3)  = "aaa"
     * StringUtils.repeat("ab", 2) = "abab"
     * StringUtils.repeat("a", -2) = ""
     * &lt;/pre&gt;
     *
     * @param str  the String to repeat, may be null
     * @param repeat  number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>repeat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>repeat</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Performance tuned for 2.0 (JDK1.4)</comment>

        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>repeat</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>inputLength</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>repeat</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>inputLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>inputLength</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat</name> <operator>&lt;=</operator> <name>PAD_LIMIT</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>repeat</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>outputLength</name> <init>= <expr><name>inputLength</name> <operator>*</operator> <name>repeat</name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>inputLength</name></expr>)</condition> <block>{
            <case>case <expr><literal type="number">1</literal></expr> :</case>
                <return>return <expr><call><name>repeat</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</return>
            <case>case <expr><literal type="number">2</literal></expr> :</case>
                <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch0</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch1</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>output2</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>outputLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>repeat</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><name><name>output2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ch0</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>output2</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ch1</name></expr>;</expr_stmt>
                }</block></for>
                <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>output2</name></expr></argument>)</argument_list></call></expr>;</return>
            <default>default :</default>
                <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>outputLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>repeat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></switch>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Repeat a String {@code repeat} times to form a
     * new String, with a String separator injected each time. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, null, 2) = null
     * StringUtils.repeat(null, "x", 2)  = null
     * StringUtils.repeat("", null, 0)   = ""
     * StringUtils.repeat("", "", 2)     = ""
     * StringUtils.repeat("", "x", 3)    = "xxx"
     * StringUtils.repeat("?", ", ", 3)  = "?, ?, ?"
     * &lt;/pre&gt;
     *
     * @param str        the String to repeat, may be null
     * @param separator  the String to inject, may be null
     * @param repeat     number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  {@code null} if null String input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>repeat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>repeat</name></decl></parameter>)</parameter_list> <block>{
        <if>if<condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>separator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>repeat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="line">// given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>result</name> <init>= <expr><call><name>repeat</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>separator</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>removeEnd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns padding using the specified delimiter repeated
     * to a given length.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat('e', 0)  = ""
     * StringUtils.repeat('e', 3)  = "eee"
     * StringUtils.repeat('e', -2) = ""
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: this method doesn't not support padding with
     * &lt;a href="http://www.unicode.org/glossary/#supplementary_character"&gt;Unicode Supplementary Characters&lt;/a&gt;
     * as they require a pair of {@code char}s to be represented.
     * If you are needing to support full I18N of your applications
     * consider using {@link #repeat(String, int)} instead.
     * &lt;/p&gt;
     *
     * @param ch  character to repeat
     * @param repeat  number of times to repeat char, negative treated as zero
     * @return String with repeated character
     * @see #repeat(String, int)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>repeat</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>repeat</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>repeat</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>repeat</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Right pad a String with spaces (' ').&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *)   = null
     * StringUtils.rightPad("", 3)     = "   "
     * StringUtils.rightPad("bat", 3)  = "bat"
     * StringUtils.rightPad("bat", 5)  = "bat  "
     * StringUtils.rightPad("bat", 1)  = "bat"
     * StringUtils.rightPad("bat", -1) = "bat"
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @return right padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>rightPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>rightPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Right pad a String with a specified character.&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *, *)     = null
     * StringUtils.rightPad("", 3, 'z')     = "zzz"
     * StringUtils.rightPad("bat", 3, 'z')  = "bat"
     * StringUtils.rightPad("bat", 5, 'z')  = "batzz"
     * StringUtils.rightPad("bat", 1, 'z')  = "bat"
     * StringUtils.rightPad("bat", -1, 'z') = "bat"
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padChar  the character to pad with
     * @return right padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>rightPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return> <comment type="line">// returns original String when possible</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>pads</name> <operator>&gt;</operator> <name>PAD_LIMIT</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>rightPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><call><name>repeat</name><argument_list>(<argument><expr><name>padChar</name></expr></argument>, <argument><expr><name>pads</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Right pad a String with a specified String.&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *, *)      = null
     * StringUtils.rightPad("", 3, "z")      = "zzz"
     * StringUtils.rightPad("bat", 3, "yz")  = "bat"
     * StringUtils.rightPad("bat", 5, "yz")  = "batyz"
     * StringUtils.rightPad("bat", 8, "yz")  = "batyzyzy"
     * StringUtils.rightPad("bat", 1, "yz")  = "bat"
     * StringUtils.rightPad("bat", -1, "yz") = "bat"
     * StringUtils.rightPad("bat", 5, null)  = "bat  "
     * StringUtils.rightPad("bat", 5, "")    = "bat  "
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padStr  the String to pad with, null or empty treated as single space
     * @return right padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>rightPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>padStr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>padStr</name> <operator>=</operator> <name>SPACE</name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>padLen</name> <init>= <expr><call><name><name>padStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return> <comment type="line">// returns original String when possible</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>padLen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pads</name> <operator>&lt;=</operator> <name>PAD_LIMIT</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>rightPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name><name>padStr</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>pads</name> <operator>==</operator> <name>padLen</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>pads</name> <operator>&lt;</operator> <name>padLen</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><call><name><name>padStr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pads</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>padding</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>pads</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>padChars</name> <init>= <expr><call><name><name>padStr</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name><name>padding</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>padChars</name><index>[<expr><name>i</name> <operator>%</operator> <name>padLen</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Left pad a String with spaces (' ').&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *)   = null
     * StringUtils.leftPad("", 3)     = "   "
     * StringUtils.leftPad("bat", 3)  = "bat"
     * StringUtils.leftPad("bat", 5)  = "  bat"
     * StringUtils.leftPad("bat", 1)  = "bat"
     * StringUtils.leftPad("bat", -1) = "bat"
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @return left padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>leftPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>leftPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Left pad a String with a specified character.&lt;/p&gt;
     *
     * &lt;p&gt;Pad to a size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *, *)     = null
     * StringUtils.leftPad("", 3, 'z')     = "zzz"
     * StringUtils.leftPad("bat", 3, 'z')  = "bat"
     * StringUtils.leftPad("bat", 5, 'z')  = "zzbat"
     * StringUtils.leftPad("bat", 1, 'z')  = "bat"
     * StringUtils.leftPad("bat", -1, 'z') = "bat"
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padChar  the character to pad with
     * @return left padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>leftPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return> <comment type="line">// returns original String when possible</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>pads</name> <operator>&gt;</operator> <name>PAD_LIMIT</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>leftPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>repeat</name><argument_list>(<argument><expr><name>padChar</name></expr></argument>, <argument><expr><name>pads</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Left pad a String with a specified String.&lt;/p&gt;
     *
     * &lt;p&gt;Pad to a size of {@code size}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *, *)      = null
     * StringUtils.leftPad("", 3, "z")      = "zzz"
     * StringUtils.leftPad("bat", 3, "yz")  = "bat"
     * StringUtils.leftPad("bat", 5, "yz")  = "yzbat"
     * StringUtils.leftPad("bat", 8, "yz")  = "yzyzybat"
     * StringUtils.leftPad("bat", 1, "yz")  = "bat"
     * StringUtils.leftPad("bat", -1, "yz") = "bat"
     * StringUtils.leftPad("bat", 5, null)  = "  bat"
     * StringUtils.leftPad("bat", 5, "")    = "  bat"
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padStr  the String to pad with, null or empty treated as single space
     * @return left padded String or original String if no padding is necessary,
     *  {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>leftPad</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>padStr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>padStr</name> <operator>=</operator> <name>SPACE</name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>padLen</name> <init>= <expr><call><name><name>padStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return> <comment type="line">// returns original String when possible</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>padLen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pads</name> <operator>&lt;=</operator> <name>PAD_LIMIT</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>leftPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name><name>padStr</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>pads</name> <operator>==</operator> <name>padLen</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>padStr</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>pads</name> <operator>&lt;</operator> <name>padLen</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>padStr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pads</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>padding</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>pads</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>padChars</name> <init>= <expr><call><name><name>padStr</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name><name>padding</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>padChars</name><index>[<expr><name>i</name> <operator>%</operator> <name>padLen</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a CharSequence length or {@code 0} if the CharSequence is
     * {@code null}.
     *
     * @param cs
     *            a CharSequence or {@code null}
     * @return CharSequence length or {@code 0} if the CharSequence is
     *         {@code null}.
     * @since 2.4
     * @since 3.0 Changed signature from length(String) to length(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>length</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">// Centering</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Centers a String in a larger String of size {@code size}
     * using the space character (' ').&lt;p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A {@code null} String returns {@code null}.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;p&gt;Equivalent to {@code center(str, size, " ")}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *)   = null
     * StringUtils.center("", 4)     = "    "
     * StringUtils.center("ab", -1)  = "ab"
     * StringUtils.center("ab", 4)   = " ab "
     * StringUtils.center("abcd", 2) = "abcd"
     * StringUtils.center("a", 4)    = " a  "
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @return centered String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>center</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>center</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Centers a String in a larger String of size {@code size}.
     * Uses a supplied character as the value to pad the String with.&lt;/p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A {@code null} String returns {@code null}.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *, *)     = null
     * StringUtils.center("", 4, ' ')     = "    "
     * StringUtils.center("ab", -1, ' ')  = "ab"
     * StringUtils.center("ab", 4, ' ')   = " ab "
     * StringUtils.center("abcd", 2, ' ') = "abcd"
     * StringUtils.center("a", 4, ' ')    = " a  "
     * StringUtils.center("a", 4, 'y')    = "yayy"
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @param padChar  the character to pad the new String with
     * @return centered String, {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>center</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>leftPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strLen</name> <operator>+</operator> <name>pads</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rightPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Centers a String in a larger String of size {@code size}.
     * Uses a supplied String as the value to pad the String with.&lt;/p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A {@code null} String returns {@code null}.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *, *)     = null
     * StringUtils.center("", 4, " ")     = "    "
     * StringUtils.center("ab", -1, " ")  = "ab"
     * StringUtils.center("ab", 4, " ")   = " ab "
     * StringUtils.center("abcd", 2, " ") = "abcd"
     * StringUtils.center("a", 4, " ")    = " a  "
     * StringUtils.center("a", 4, "yz")   = "yayz"
     * StringUtils.center("abc", 7, null) = "  abc  "
     * StringUtils.center("abc", 7, "")   = "  abc  "
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @param padStr  the String to pad the new String with, must not be null or empty
     * @return centered String, {@code null} if null String input
     * @throws IllegalArgumentException if padStr is {@code null} or empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>center</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>padStr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>padStr</name> <operator>=</operator> <name>SPACE</name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pads</name> <init>= <expr><name>size</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>leftPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>strLen</name> <operator>+</operator> <name>pads</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rightPad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>padStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <comment type="line">// Case conversion</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase()}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.upperCase(null)  = null
     * StringUtils.upperCase("")    = ""
     * StringUtils.upperCase("aBc") = "ABC"
     * &lt;/pre&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toUpperCase()},
     * the result of this method is affected by the current locale.
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
     *
     * @param str  the String to upper case, may be null
     * @return the upper cased String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>upperCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>toUpperCase</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase(Locale)}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.upperCase(null, Locale.ENGLISH)  = null
     * StringUtils.upperCase("", Locale.ENGLISH)    = ""
     * StringUtils.upperCase("aBc", Locale.ENGLISH) = "ABC"
     * &lt;/pre&gt;
     *
     * @param str  the String to upper case, may be null
     * @param locale  the locale that defines the case transformation rules, must not be null
     * @return the upper cased String, {@code null} if null String input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>upperCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Locale</name></type> <name>locale</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase()}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lowerCase(null)  = null
     * StringUtils.lowerCase("")    = ""
     * StringUtils.lowerCase("aBc") = "abc"
     * &lt;/pre&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toLowerCase()},
     * the result of this method is affected by the current locale.
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
     *
     * @param str  the String to lower case, may be null
     * @return the lower cased String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>lowerCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>toLowerCase</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase(Locale)}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
     * StringUtils.lowerCase("", Locale.ENGLISH)    = ""
     * StringUtils.lowerCase("aBc", Locale.ENGLISH) = "abc"
     * &lt;/pre&gt;
     *
     * @param str  the String to lower case, may be null
     * @param locale  the locale that defines the case transformation rules, must not be null
     * @return the lower cased String, {@code null} if null String input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>lowerCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Locale</name></type> <name>locale</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Capitalizes a String changing the first letter to title case as
     * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#capitalize(String)}.
     * A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.capitalize(null)  = null
     * StringUtils.capitalize("")    = ""
     * StringUtils.capitalize("cat") = "Cat"
     * StringUtils.capitalize("cAt") = "CAt"
     * &lt;/pre&gt;
     *
     * @param str the String to capitalize, may be null
     * @return the capitalized String, {@code null} if null String input
     * @see org.apache.commons.lang3.text.WordUtils#capitalize(String)
     * @see #uncapitalize(String)
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>capitalize</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strLen</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>char</name></type> <name>firstChar</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isTitleCase</name></name><argument_list>(<argument><expr><name>firstChar</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// already capitalized</comment>
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>strLen</name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Character</name><operator>.</operator><name>toTitleCase</name></name><argument_list>(<argument><expr><name>firstChar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Uncapitalizes a String changing the first letter to title case as
     * per {@link Character#toLowerCase(char)}. No other letters are changed.&lt;/p&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
     * A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.uncapitalize(null)  = null
     * StringUtils.uncapitalize("")    = ""
     * StringUtils.uncapitalize("Cat") = "cat"
     * StringUtils.uncapitalize("CAT") = "cAT"
     * &lt;/pre&gt;
     *
     * @param str the String to uncapitalize, may be null
     * @return the uncapitalized String, {@code null} if null String input
     * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
     * @see #capitalize(String)
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>uncapitalize</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>strLen</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>char</name></type> <name>firstChar</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLowerCase</name></name><argument_list>(<argument><expr><name>firstChar</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// already uncapitalized</comment>
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>strLen</name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Character</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>firstChar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Swaps the case of a String changing upper and title case to
     * lower case, and lower case to upper case.&lt;/p&gt;
     *
     * &lt;ul&gt;
     *  &lt;li&gt;Upper case character converts to Lower case&lt;/li&gt;
     *  &lt;li&gt;Title case character converts to Lower case&lt;/li&gt;
     *  &lt;li&gt;Lower case character converts to Upper case&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
     * A {@code null} input String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.swapCase(null)                 = null
     * StringUtils.swapCase("")                   = ""
     * StringUtils.swapCase("The dog has a BONE") = "tHE DOG HAS A bone"
     * &lt;/pre&gt;
     *
     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
     * It no longer performs a word based algorithm.
     * If you only use ASCII, you will notice no change.
     * That functionality is available in org.apache.commons.lang3.text.WordUtils.&lt;/p&gt;
     *
     * @param str  the String to swap case, may be null
     * @return the changed String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>swapCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>buffer</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isUpperCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Character</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isTitleCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Character</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLowerCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Character</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif></if>
        }</block></for>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Count matches</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Counts how many times the substring appears in the larger string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} or empty ("") String input returns {@code 0}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.countMatches(null, *)       = 0
     * StringUtils.countMatches("", *)         = 0
     * StringUtils.countMatches("abba", null)  = 0
     * StringUtils.countMatches("abba", "")    = 0
     * StringUtils.countMatches("abba", "a")   = 2
     * StringUtils.countMatches("abba", "ab")  = 1
     * StringUtils.countMatches("abba", "xxx") = 0
     * &lt;/pre&gt;
     *
     * @param str  the CharSequence to check, may be null
     * @param sub  the substring to count, may be null
     * @return the number of occurrences, 0 if either CharSequence is {@code null}
     * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>countMatches</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>sub</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>idx</name> <operator>=</operator> <call><name><name>CharSequenceUtils</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name><name>sub</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>count</name></expr>;</return>
    }</block></function>

    <comment type="line">// Character Tests</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode letters.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlpha(null)   = false
     * StringUtils.isAlpha("")     = false
     * StringUtils.isAlpha("  ")   = false
     * StringUtils.isAlpha("abc")  = true
     * StringUtils.isAlpha("ab2c") = false
     * StringUtils.isAlpha("ab-c") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains letters, and is non-null
     * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)
     * @since 3.0 Changed "" to return false and not true
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAlpha</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLetter</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode letters and
     * space (' ').&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}
     * An empty CharSequence (length()=0) will return {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphaSpace(null)   = false
     * StringUtils.isAlphaSpace("")     = true
     * StringUtils.isAlphaSpace("  ")   = true
     * StringUtils.isAlphaSpace("abc")  = true
     * StringUtils.isAlphaSpace("ab c") = true
     * StringUtils.isAlphaSpace("ab2c") = false
     * StringUtils.isAlphaSpace("ab-c") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains letters and space,
     *  and is non-null
     * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAlphaSpace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLetter</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode letters or digits.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphanumeric(null)   = false
     * StringUtils.isAlphanumeric("")     = false
     * StringUtils.isAlphanumeric("  ")   = false
     * StringUtils.isAlphanumeric("abc")  = true
     * StringUtils.isAlphanumeric("ab c") = false
     * StringUtils.isAlphanumeric("ab2c") = true
     * StringUtils.isAlphanumeric("ab-c") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains letters or digits,
     *  and is non-null
     * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
     * @since 3.0 Changed "" to return false and not true
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAlphanumeric</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLetterOrDigit</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode letters, digits
     * or space ({@code ' '}).&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphanumericSpace(null)   = false
     * StringUtils.isAlphanumericSpace("")     = true
     * StringUtils.isAlphanumericSpace("  ")   = true
     * StringUtils.isAlphanumericSpace("abc")  = true
     * StringUtils.isAlphanumericSpace("ab c") = true
     * StringUtils.isAlphanumericSpace("ab2c") = true
     * StringUtils.isAlphanumericSpace("ab-c") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains letters, digits or space,
     *  and is non-null
     * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAlphanumericSpace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLetterOrDigit</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only ASCII printable characters.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAsciiPrintable(null)     = false
     * StringUtils.isAsciiPrintable("")       = true
     * StringUtils.isAsciiPrintable(" ")      = true
     * StringUtils.isAsciiPrintable("Ceki")   = true
     * StringUtils.isAsciiPrintable("ab2c")   = true
     * StringUtils.isAsciiPrintable("!ab-c~") = true
     * StringUtils.isAsciiPrintable("\u0020") = true
     * StringUtils.isAsciiPrintable("\u0021") = true
     * StringUtils.isAsciiPrintable("\u007e") = true
     * StringUtils.isAsciiPrintable("\u007f") = false
     * StringUtils.isAsciiPrintable("Ceki G\u00fclc\u00fc") = false
     * &lt;/pre&gt;
     *
     * @param cs the CharSequence to check, may be null
     * @return {@code true} if every character is in the range
     *  32 thru 126
     * @since 2.1
     * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiPrintable</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>CharUtils</name><operator>.</operator><name>isAsciiPrintable</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode digits.
     * A decimal point is not a Unicode digit and returns false.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code false}.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the method does not allow for a leading sign, either positive or negative.
     * Also, if a String passes the numeric test, it may still generate a NumberFormatException
     * when parsed by Integer.parseInt or Long.parseLong, e.g. if the value is outside the range
     * for int or long respectively.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNumeric(null)   = false
     * StringUtils.isNumeric("")     = false
     * StringUtils.isNumeric("  ")   = false
     * StringUtils.isNumeric("123")  = true
     * StringUtils.isNumeric("12 3") = false
     * StringUtils.isNumeric("ab2c") = false
     * StringUtils.isNumeric("12-3") = false
     * StringUtils.isNumeric("12.3") = false
     * StringUtils.isNumeric("-123") = false
     * StringUtils.isNumeric("+123") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains digits, and is non-null
     * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)
     * @since 3.0 Changed "" to return false and not true
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNumeric</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isDigit</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only Unicode digits or space
     * ({@code ' '}).
     * A decimal point is not a Unicode digit and returns false.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNumericSpace(null)   = false
     * StringUtils.isNumericSpace("")     = true
     * StringUtils.isNumericSpace("  ")   = true
     * StringUtils.isNumericSpace("123")  = true
     * StringUtils.isNumericSpace("12 3") = true
     * StringUtils.isNumericSpace("ab2c") = false
     * StringUtils.isNumericSpace("12-3") = false
     * StringUtils.isNumericSpace("12.3") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains digits or space,
     *  and is non-null
     * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNumericSpace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isDigit</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code true}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isWhitespace(null)   = false
     * StringUtils.isWhitespace("")     = true
     * StringUtils.isWhitespace("  ")   = true
     * StringUtils.isWhitespace("abc")  = false
     * StringUtils.isWhitespace("ab2c") = false
     * StringUtils.isWhitespace("ab-c") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains whitespace, and is non-null
     * @since 2.0
     * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isWhitespace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only lowercase characters.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty CharSequence (length()=0) will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAllLowerCase(null)   = false
     * StringUtils.isAllLowerCase("")     = false
     * StringUtils.isAllLowerCase("  ")   = false
     * StringUtils.isAllLowerCase("abc")  = true
     * StringUtils.isAllLowerCase("abC") = false
     * &lt;/pre&gt;
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if only contains lowercase characters, and is non-null
     * @since 2.5
     * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAllLowerCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isLowerCase</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the CharSequence contains only uppercase characters.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null} will return {@code false}.
     * An empty String (length()=0) will return {@code false}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAllUpperCase(null)   = false
     * StringUtils.isAllUpperCase("")     = false
     * StringUtils.isAllUpperCase("  ")   = false
     * StringUtils.isAllUpperCase("ABC")  = true
     * StringUtils.isAllUpperCase("aBC") = false
     * &lt;/pre&gt;
     *
     * @param cs the CharSequence to check, may be null
     * @return {@code true} if only contains uppercase characters, and is non-null
     * @since 2.5
     * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAllUpperCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isUpperCase</name></name><argument_list>(<argument><expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">// Defaults</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns either the passed in String,
     * or if the String is {@code null}, an empty String ("").&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultString(null)  = ""
     * StringUtils.defaultString("")    = ""
     * StringUtils.defaultString("bat") = "bat"
     * &lt;/pre&gt;
     *
     * @see ObjectUtils#toString(Object)
     * @see String#valueOf(Object)
     * @param str  the String to check, may be null
     * @return the passed in String, or the empty String if it
     *  was {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>defaultString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>EMPTY</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns either the passed in String, or if the String is
     * {@code null}, the value of {@code defaultStr}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultString(null, "NULL")  = "NULL"
     * StringUtils.defaultString("", "NULL")    = ""
     * StringUtils.defaultString("bat", "NULL") = "bat"
     * &lt;/pre&gt;
     *
     * @see ObjectUtils#toString(Object,String)
     * @see String#valueOf(Object)
     * @param str  the String to check, may be null
     * @param defaultStr  the default String to return
     *  if the input is {@code null}, may be null
     * @return the passed in String, or the default if it was {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>defaultString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>defaultStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>defaultStr</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns either the passed in CharSequence, or if the CharSequence is
     * whitespace, empty ("") or {@code null}, the value of {@code defaultStr}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfBlank(null, "NULL")  = "NULL"
     * StringUtils.defaultIfBlank("", "NULL")    = "NULL"
     * StringUtils.defaultIfBlank(" ", "NULL")   = "NULL"
     * StringUtils.defaultIfBlank("bat", "NULL") = "bat"
     * StringUtils.defaultIfBlank("", null)      = null
     * &lt;/pre&gt;
     * @param &lt;T&gt; the specific kind of CharSequence
     * @param str the CharSequence to check, may be null
     * @param defaultStr  the default CharSequence to return
     *  if the input is whitespace, empty ("") or {@code null}, may be null
     * @return the passed in CharSequence, or the default
     * @see StringUtils#defaultString(String, String)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>defaultIfBlank</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>defaultStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><call><name><name>StringUtils</name><operator>.</operator><name>isBlank</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>defaultStr</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns either the passed in CharSequence, or if the CharSequence is
     * empty or {@code null}, the value of {@code defaultStr}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfEmpty(null, "NULL")  = "NULL"
     * StringUtils.defaultIfEmpty("", "NULL")    = "NULL"
     * StringUtils.defaultIfEmpty(" ", "NULL")   = " "
     * StringUtils.defaultIfEmpty("bat", "NULL") = "bat"
     * StringUtils.defaultIfEmpty("", null)      = null
     * &lt;/pre&gt;
     * @param &lt;T&gt; the specific kind of CharSequence
     * @param str  the CharSequence to check, may be null
     * @param defaultStr  the default CharSequence to return
     *  if the input is empty ("") or {@code null}, may be null
     * @return the passed in CharSequence, or the default
     * @see StringUtils#defaultString(String, String)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>defaultIfEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>defaultStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>defaultStr</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">// Reversing</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses a String as per {@link StringBuilder#reverse()}.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} String returns {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.reverse(null)  = null
     * StringUtils.reverse("")    = ""
     * StringUtils.reverse("bat") = "tab"
     * &lt;/pre&gt;
     *
     * @param str  the String to reverse, may be null
     * @return the reversed String, {@code null} if null String input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reverse</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses a String that is delimited by a specific character.&lt;/p&gt;
     *
     * &lt;p&gt;The Strings between the delimiters are not reversed.
     * Thus java.lang.String becomes String.lang.java (if the delimiter
     * is {@code '.'}).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.reverseDelimited(null, *)      = null
     * StringUtils.reverseDelimited("", *)        = ""
     * StringUtils.reverseDelimited("a.b.c", 'x') = "a.b.c"
     * StringUtils.reverseDelimited("a.b.c", ".") = "c.b.a"
     * &lt;/pre&gt;
     *
     * @param str  the String to reverse, may be null
     * @param separatorChar  the separator character to use
     * @return the reversed String, {@code null} if null String input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>reverseDelimited</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separatorChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// could implement manually, but simple way is to reuse other,</comment>
        <comment type="line">// probably slower, methods.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>strs</name> <init>= <expr><call><name>split</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>separatorChar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ArrayUtils</name><operator>.</operator><name>reverse</name></name><argument_list>(<argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>strs</name></expr></argument>, <argument><expr><name>separatorChar</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Abbreviating</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "Now is the time for..."&lt;/p&gt;
     *
     * &lt;p&gt;Specifically:
     * &lt;ul&gt;
     *   &lt;li&gt;If {@code str} is less than {@code maxWidth} characters
     *       long, return it.&lt;/li&gt;
     *   &lt;li&gt;Else abbreviate it to {@code (substring(str, 0, max-3) + "...")}.&lt;/li&gt;
     *   &lt;li&gt;If {@code maxWidth} is less than {@code 4}, throw an
     *       {@code IllegalArgumentException}.&lt;/li&gt;
     *   &lt;li&gt;In no case will it return a String of length greater than
     *       {@code maxWidth}.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.abbreviate(null, *)      = null
     * StringUtils.abbreviate("", 4)        = ""
     * StringUtils.abbreviate("abcdefg", 6) = "abc..."
     * StringUtils.abbreviate("abcdefg", 7) = "abcdefg"
     * StringUtils.abbreviate("abcdefg", 8) = "abcdefg"
     * StringUtils.abbreviate("abcdefg", 4) = "a..."
     * StringUtils.abbreviate("abcdefg", 3) = IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param maxWidth  maximum length of result String, must be at least 4
     * @return abbreviated String, {@code null} if null String input
     * @throws IllegalArgumentException if the width is too small
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>abbreviate</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxWidth</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>abbreviate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxWidth</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "...is the time for..."&lt;/p&gt;
     *
     * &lt;p&gt;Works like {@code abbreviate(String, int)}, but allows you to specify
     * a "left edge" offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * ellipses, but it will appear somewhere in the result.
     *
     * &lt;p&gt;In no case will it return a String of length greater than
     * {@code maxWidth}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.abbreviate(null, *, *)                = null
     * StringUtils.abbreviate("", 0, 4)                  = ""
     * StringUtils.abbreviate("abcdefghijklmno", -1, 10) = "abcdefg..."
     * StringUtils.abbreviate("abcdefghijklmno", 0, 10)  = "abcdefg..."
     * StringUtils.abbreviate("abcdefghijklmno", 1, 10)  = "abcdefg..."
     * StringUtils.abbreviate("abcdefghijklmno", 4, 10)  = "abcdefg..."
     * StringUtils.abbreviate("abcdefghijklmno", 5, 10)  = "...fghi..."
     * StringUtils.abbreviate("abcdefghijklmno", 6, 10)  = "...ghij..."
     * StringUtils.abbreviate("abcdefghijklmno", 8, 10)  = "...ijklmno"
     * StringUtils.abbreviate("abcdefghijklmno", 10, 10) = "...ijklmno"
     * StringUtils.abbreviate("abcdefghijklmno", 12, 10) = "...ijklmno"
     * StringUtils.abbreviate("abcdefghij", 0, 3)        = IllegalArgumentException
     * StringUtils.abbreviate("abcdefghij", 5, 6)        = IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param offset  left edge of source String
     * @param maxWidth  maximum length of result String, must be at least 4
     * @return abbreviated String, {@code null} if null String input
     * @throws IllegalArgumentException if the width is too small
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>abbreviate</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxWidth</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>maxWidth</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Minimum abbreviation width is 4"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>maxWidth</name></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>offset</name> <operator>&lt;</operator> <name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <operator>(</operator><name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>abrevMarker</name> <init>= <expr><literal type="string">"..."</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>abrevMarker</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>maxWidth</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Minimum abbreviation width with offset is 7"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>abrevMarker</name> <operator>+</operator> <call><name>abbreviate</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>abrevMarker</name> <operator>+</operator> <call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <operator>(</operator><name>maxWidth</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Abbreviates a String to the length passed, replacing the middle characters with the supplied
     * replacement String.&lt;/p&gt;
     *
     * &lt;p&gt;This abbreviation only occurs if the following criteria is met:
     * &lt;ul&gt;
     * &lt;li&gt;Neither the String for abbreviation nor the replacement String are null or empty &lt;/li&gt;
     * &lt;li&gt;The length to truncate to is less than the length of the supplied String&lt;/li&gt;
     * &lt;li&gt;The length to truncate to is greater than 0&lt;/li&gt;
     * &lt;li&gt;The abbreviated String will have enough room for the length supplied replacement String
     * and the first and last characters of the supplied String for abbreviation&lt;/li&gt;
     * &lt;/ul&gt;
     * Otherwise, the returned String will be the same as the supplied String for abbreviation.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.abbreviateMiddle(null, null, 0)      = null
     * StringUtils.abbreviateMiddle("abc", null, 0)      = "abc"
     * StringUtils.abbreviateMiddle("abc", ".", 0)      = "abc"
     * StringUtils.abbreviateMiddle("abc", ".", 3)      = "abc"
     * StringUtils.abbreviateMiddle("abcdef", ".", 4)     = "ab.f"
     * &lt;/pre&gt;
     *
     * @param str  the String to abbreviate, may be null
     * @param middle the String to replace the middle characters with, may be null
     * @param length the length to abbreviate {@code str} to.
     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>abbreviateMiddle</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>middle</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>middle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>length</name> <operator>&lt;</operator> <call><name><name>middle</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>+</operator><literal type="number">2</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>targetSting</name> <init>= <expr><name>length</name><operator>-</operator><call><name><name>middle</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>startOffset</name> <init>= <expr><name>targetSting</name><operator>/</operator><literal type="number">2</literal><operator>+</operator><name>targetSting</name><operator>%</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>endOffset</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><name>targetSting</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>middle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Difference</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two Strings, and returns the portion where they differ.
     * More precisely, return the remainder of the second String,
     * starting from where it's different from the first. This means that
     * the difference between "abc" and "ab" is the empty String and not "c". &lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * {@code difference("i am a machine", "i am a robot") -&gt; "robot"}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.difference(null, null) = null
     * StringUtils.difference("", "") = ""
     * StringUtils.difference("", "abc") = "abc"
     * StringUtils.difference("abc", "") = ""
     * StringUtils.difference("abc", "abc") = ""
     * StringUtils.difference("abc", "ab") = ""
     * StringUtils.difference("ab", "abxyz") = "xyz"
     * StringUtils.difference("abcde", "abxyz") = "xyz"
     * StringUtils.difference("abcde", "xyz") = "xyz"
     * &lt;/pre&gt;
     *
     * @param str1  the first String, may be null
     * @param str2  the second String, may be null
     * @return the portion of str2 where it differs from str1; returns the
     * empty String if they are equal
     * @see #indexOfDifference(CharSequence,CharSequence)
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>difference</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str2</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>str2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str1</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>at</name> <init>= <expr><call><name>indexOfDifference</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>at</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str2</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two CharSequences, and returns the index at which the
     * CharSequences begin to differ.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * {@code indexOfDifference("i am a machine", "i am a robot") -&gt; 7}&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfDifference(null, null) = -1
     * StringUtils.indexOfDifference("", "") = -1
     * StringUtils.indexOfDifference("", "abc") = 0
     * StringUtils.indexOfDifference("abc", "") = 0
     * StringUtils.indexOfDifference("abc", "abc") = -1
     * StringUtils.indexOfDifference("ab", "abxyz") = 2
     * StringUtils.indexOfDifference("abcde", "abxyz") = 2
     * StringUtils.indexOfDifference("abcde", "xyz") = 0
     * &lt;/pre&gt;
     *
     * @param cs1  the first CharSequence, may be null
     * @param cs2  the second CharSequence, may be null
     * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
     * @since 2.0
     * @since 3.0 Changed signature from indexOfDifference(String, String) to
     * indexOfDifference(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfDifference</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs1</name> <operator>==</operator> <name>cs2</name></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>cs1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cs2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>cs1</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name><name>cs2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>cs1</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>cs2</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name><name>cs2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <call><name><name>cs1</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>i</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares all CharSequences in an array and returns the index at which the
     * CharSequences begin to differ.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;indexOfDifference(new String[] {"i am a machine", "i am a robot"}) -&gt; 7&lt;/code&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfDifference(null) = -1
     * StringUtils.indexOfDifference(new String[] {}) = -1
     * StringUtils.indexOfDifference(new String[] {"abc"}) = -1
     * StringUtils.indexOfDifference(new String[] {null, null}) = -1
     * StringUtils.indexOfDifference(new String[] {"", ""}) = -1
     * StringUtils.indexOfDifference(new String[] {"", null}) = 0
     * StringUtils.indexOfDifference(new String[] {"abc", null, null}) = 0
     * StringUtils.indexOfDifference(new String[] {null, null, "abc"}) = 0
     * StringUtils.indexOfDifference(new String[] {"", "abc"}) = 0
     * StringUtils.indexOfDifference(new String[] {"abc", ""}) = 0
     * StringUtils.indexOfDifference(new String[] {"abc", "abc"}) = -1
     * StringUtils.indexOfDifference(new String[] {"abc", "a"}) = 1
     * StringUtils.indexOfDifference(new String[] {"ab", "abxyz"}) = 2
     * StringUtils.indexOfDifference(new String[] {"abcde", "abxyz"}) = 2
     * StringUtils.indexOfDifference(new String[] {"abcde", "xyz"}) = 0
     * StringUtils.indexOfDifference(new String[] {"xyz", "abcde"}) = 0
     * StringUtils.indexOfDifference(new String[] {"i am a machine", "i am a robot"}) = 7
     * &lt;/pre&gt;
     *
     * @param css  array of CharSequences, entries may be null
     * @return the index where the strings begin to differ; -1 if they are all equal
     * @since 2.4
     * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOfDifference</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>css</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>css</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>css</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>boolean</name></type> <name>anyStringNull</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>allStringsNull</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>arrayLen</name> <init>= <expr><name><name>css</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>shortestStrLen</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>longestStrLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// find the min and max string lengths; this avoids checking to make</comment>
        <comment type="line">// sure we are not exceeding the length of the string each time through</comment>
        <comment type="line">// the bottom loop.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>css</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>anyStringNull</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>shortestStrLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>allStringsNull</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>shortestStrLen</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name><name>css</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>shortestStrLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>longestStrLen</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name><name>css</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>longestStrLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <comment type="line">// handle lists containing all nulls or all empty strings</comment>
        <if>if <condition>(<expr><name>allStringsNull</name> <operator>||</operator> <name>longestStrLen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>anyStringNull</name></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// handle lists containing some nulls or some empty strings</comment>
        <if>if <condition>(<expr><name>shortestStrLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>

        <comment type="line">// find the position with the first difference across all strings</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>firstDiff</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>stringPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stringPos</name> <operator>&lt;</operator> <name>shortestStrLen</name></expr>;</condition> <incr><expr><name>stringPos</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>comparisonChar</name> <init>= <expr><name><name>css</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>charAt</name><argument_list>(<argument><expr><name>stringPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>arrayPos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>arrayPos</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>arrayPos</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>css</name><index>[<expr><name>arrayPos</name></expr>]</index></name><operator>.</operator><call><name>charAt</name><argument_list>(<argument><expr><name>stringPos</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>comparisonChar</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>firstDiff</name> <operator>=</operator> <name>stringPos</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>firstDiff</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>firstDiff</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>shortestStrLen</name> <operator>!=</operator> <name>longestStrLen</name></expr>)</condition><then> <block>{
            <comment type="line">// we compared all of the characters up to the length of the</comment>
            <comment type="line">// shortest string and didn't find a match, but the string lengths</comment>
            <comment type="line">// vary, so return the length of the shortest string.</comment>
            <return>return <expr><name>shortestStrLen</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>firstDiff</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares all Strings in an array and returns the initial sequence of
     * characters that is common to all of them.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -&gt; "i am a "&lt;/code&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.getCommonPrefix(null) = ""
     * StringUtils.getCommonPrefix(new String[] {}) = ""
     * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"
     * StringUtils.getCommonPrefix(new String[] {null, null}) = ""
     * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""
     * StringUtils.getCommonPrefix(new String[] {"", null}) = ""
     * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""
     * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""
     * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""
     * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""
     * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"
     * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"
     * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"
     * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"
     * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""
     * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""
     * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "
     * &lt;/pre&gt;
     *
     * @param strs  array of String objects, entries may be null
     * @return the initial sequence of characters that are common to all Strings
     * in the array; empty String if the array is null, the elements are all null
     * or if there is no common prefix.
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getCommonPrefix</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>strs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>strs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>strs</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>smallestIndexOfDiff</name> <init>= <expr><call><name>indexOfDifference</name><argument_list>(<argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>smallestIndexOfDiff</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <comment type="line">// all strings were identical</comment>
            <if>if <condition>(<expr><name><name>strs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>EMPTY</name></expr>;</return>
            }</block></then></if>
            <return>return <expr><name><name>strs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>smallestIndexOfDiff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <comment type="line">// there were no common initial characters</comment>
            <return>return <expr><name>EMPTY</name></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="line">// we found a common initial character sequence</comment>
            <return>return <expr><name><name>strs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>substring</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>smallestIndexOfDiff</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="line">// Misc</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Find the Levenshtein distance between two Strings.&lt;/p&gt;
     *
     * &lt;p&gt;This is the number of changes needed to change one String into
     * another, where each change is a single character modification (deletion,
     * insertion or substitution).&lt;/p&gt;
     *
     * &lt;p&gt;The previous implementation of the Levenshtein distance algorithm
     * was from &lt;a href="http://www.merriampark.com/ld.htm"&gt;http://www.merriampark.com/ld.htm&lt;/a&gt;&lt;/p&gt;
     *
     * &lt;p&gt;Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
     * which can occur when my Java implementation is used with very large strings.&lt;br&gt;
     * This implementation of the Levenshtein distance algorithm
     * is from &lt;a href="http://www.merriampark.com/ldjava.htm"&gt;http://www.merriampark.com/ldjava.htm&lt;/a&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance("","")               = 0
     * StringUtils.getLevenshteinDistance("","a")              = 1
     * StringUtils.getLevenshteinDistance("aaapppp", "")       = 7
     * StringUtils.getLevenshteinDistance("frog", "fog")       = 1
     * StringUtils.getLevenshteinDistance("fly", "ant")        = 3
     * StringUtils.getLevenshteinDistance("elephant", "hippo") = 7
     * StringUtils.getLevenshteinDistance("hippo", "elephant") = 7
     * StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") = 8
     * StringUtils.getLevenshteinDistance("hello", "hallo")    = 1
     * &lt;/pre&gt;
     *
     * @param s  the first String, must not be null
     * @param t  the second String, must not be null
     * @return result distance
     * @throws IllegalArgumentException if either String input {@code null}
     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
     * getLevenshteinDistance(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>getLevenshteinDistance</name><parameter_list>(<parameter><decl><type><name>CharSequence</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>CharSequence</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>t</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Strings must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="block">/*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// length of s</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name><name>t</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// length of t</comment>

        <if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>m</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>n</name></expr>;</return>
        }</block></then></if></elseif></if>

        <if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>m</name></expr>)</condition><then> <block>{
            <comment type="line">// swap the input strings to consume less memory</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>tmp</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name><name>p</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">//'previous' cost array, horizontally</comment>
        <decl_stmt><decl><type><name>int</name></type> <name><name>d</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// cost array, horizontally</comment>
        <decl_stmt><decl><type><name>int</name></type> <name><name>_d</name><index>[]</index></name></decl>;</decl_stmt> <comment type="line">//placeholder to assist in swapping p and d</comment>

        <comment type="line">// indexes into strings s and t</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> <comment type="line">// iterates through s</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt> <comment type="line">// iterates through t</comment>

        <decl_stmt><decl><type><name>char</name></type> <name>t_j</name></decl>;</decl_stmt> <comment type="line">// jth character of t</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>cost</name></decl>;</decl_stmt> <comment type="line">// cost</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        }</block></for>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>t_j</name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>cost</name> <operator>=</operator> <ternary><condition><expr><call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>t_j</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                <comment type="line">// minimum of cell to the left+1, to the top+1, diagonally left and up +cost</comment>
                <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// copy current distance counts to 'previous row' distance counts</comment>
            <expr_stmt><expr><name>_d</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name>_d</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// our last action in the above loop was to switch d and p, so p now</comment>
        <comment type="line">// actually has the most recent cost counts</comment>
        <return>return <expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Find the Levenshtein distance between two Strings if it's less than or equal to a given
     * threshold.&lt;/p&gt;
     *
     * &lt;p&gt;This is the number of changes needed to change one String into
     * another, where each change is a single character modification (deletion,
     * insertion or substitution).&lt;/p&gt;
     *
     * &lt;p&gt;This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
     * and Chas Emerick's implementation of the Levenshtein distance algorithm from
     * &lt;a href="http://www.merriampark.com/ld.htm"&gt;http://www.merriampark.com/ld.htm&lt;/a&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
     * StringUtils.getLevenshteinDistance("","", 0)               = 0
     * StringUtils.getLevenshteinDistance("aaapppp", "", 8)       = 7
     * StringUtils.getLevenshteinDistance("aaapppp", "", 7)       = 7
     * StringUtils.getLevenshteinDistance("aaapppp", "", 6))      = -1
     * StringUtils.getLevenshteinDistance("elephant", "hippo", 7) = 7
     * StringUtils.getLevenshteinDistance("elephant", "hippo", 6) = -1
     * StringUtils.getLevenshteinDistance("hippo", "elephant", 7) = 7
     * StringUtils.getLevenshteinDistance("hippo", "elephant", 6) = -1
     * &lt;/pre&gt;
     *
     * @param s  the first String, must not be null
     * @param t  the second String, must not be null
     * @param threshold the target threshold, must not be negative
     * @return result distance, or {@code -1} if the distance would be greater than the threshold
     * @throws IllegalArgumentException if either String input {@code null} or negative threshold
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>getLevenshteinDistance</name><parameter_list>(<parameter><decl><type><name>CharSequence</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>CharSequence</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>threshold</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>t</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Strings must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>threshold</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Threshold must not be negative"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="block">/*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.

        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member

        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two,
        the stripe will always run off to the upper right instead of the lower left of the matrix.

        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:

           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.

        Additionally, this implementation decreases memory usage by using two
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// length of s</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name><name>t</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// length of t</comment>

        <comment type="line">// if one string is empty, the edit distance is necessarily the length of the other</comment>
        <if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><ternary><condition><expr><name>m</name> <operator>&lt;=</operator> <name>threshold</name></expr> ?</condition><then> <expr><name>m</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><ternary><condition><expr><name>n</name> <operator>&lt;=</operator> <name>threshold</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        }</block></then></if></elseif></if>

        <if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>m</name></expr>)</condition><then> <block>{
            <comment type="line">// swap the two strings to consume less memory</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>tmp</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name><name>p</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 'previous' cost array, horizontally</comment>
        <decl_stmt><decl><type><name>int</name></type> <name><name>d</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// cost array, horizontally</comment>
        <decl_stmt><decl><type><name>int</name></type> <name><name>_d</name><index>[]</index></name></decl>;</decl_stmt> <comment type="line">// placeholder to assist in swapping p and d</comment>

        <comment type="line">// fill in starting table values</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>boundary</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>threshold</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>boundary</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// these fills ensure that the value above the rightmost entry of our</comment>
        <comment type="line">// stripe will be ignored in following loop iterations</comment>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// iterates through t</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>t_j</name> <init>= <expr><call><name><name>t</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// jth character of t</comment>
            <expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

            <comment type="line">// compute stripe indices, constrain to array size</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>min</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <name>threshold</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>max</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <name>threshold</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// the stripe may lead off of the table if s and t are of different sizes</comment>
            <if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            }</block></then></if>

            <comment type="line">// ignore entry left of leftmost</comment>
            <if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>d</name><index>[<expr><name>min</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// iterates through [min, max] in s</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>min</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>t_j</name></expr>)</condition><then> <block>{
                    <comment type="line">// diagonally left and up</comment>
                    <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// 1 + minimum of cell to the left, to the top, diagonally left and up</comment>
                    <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>

            <comment type="line">// copy current distance counts to 'previous row' distance counts</comment>
            <expr_stmt><expr><name>_d</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name>_d</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// if p[n] is greater than the threshold, there's no guarantee on it being the correct</comment>
        <comment type="line">// distance</comment>
        <if>if <condition>(<expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&lt;=</operator> <name>threshold</name></expr>)</condition><then> <block>{
            <return>return <expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="line">// startsWith</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence starts with a specified prefix.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWith(null, null)      = true
     * StringUtils.startsWith(null, "abc")     = false
     * StringUtils.startsWith("abcdef", null)  = false
     * StringUtils.startsWith("abcdef", "abc") = true
     * StringUtils.startsWith("ABCDEF", "abc") = false
     * &lt;/pre&gt;
     *
     * @see String#startsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param prefix the prefix to find, may be null
     * @return {@code true} if the CharSequence starts with the prefix, case sensitive, or
     *  both {@code null}
     * @since 2.4
     * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>startsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>startsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case insensitive check if a CharSequence starts with a specified prefix.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWithIgnoreCase(null, null)      = true
     * StringUtils.startsWithIgnoreCase(null, "abc")     = false
     * StringUtils.startsWithIgnoreCase("abcdef", null)  = false
     * StringUtils.startsWithIgnoreCase("abcdef", "abc") = true
     * StringUtils.startsWithIgnoreCase("ABCDEF", "abc") = true
     * &lt;/pre&gt;
     *
     * @see String#startsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param prefix the prefix to find, may be null
     * @return {@code true} if the CharSequence starts with the prefix, case insensitive, or
     *  both {@code null}
     * @since 2.4
     * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>startsWithIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>startsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence starts with a specified prefix (optionally case insensitive).&lt;/p&gt;
     *
     * @see String#startsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param prefix the prefix to find, may be null
     * @param ignoreCase indicates whether the compare should ignore case
     *  (case insensitive) or not.
     * @return {@code true} if the CharSequence starts with the prefix or
     *  both {@code null}
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>startsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreCase</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>prefix</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>prefix</name> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>prefix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>prefix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence starts with any of an array of specified strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWithAny(null, null)      = false
     * StringUtils.startsWithAny(null, new String[] {"abc"})  = false
     * StringUtils.startsWithAny("abcxyz", null)     = false
     * StringUtils.startsWithAny("abcxyz", new String[] {""}) = false
     * StringUtils.startsWithAny("abcxyz", new String[] {"abc"}) = true
     * StringUtils.startsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true
     * &lt;/pre&gt;
     *
     * @param string  the CharSequence to check, may be null
     * @param searchStrings the CharSequences to find, may be null or empty
     * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or
     *  both {@code null}
     * @since 2.5
     * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>startsWithAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>searchStrings</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>searchStrings</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchString</name> <range>: <expr><name>searchStrings</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>searchString</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="line">// endsWith</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence ends with a specified suffix.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWith(null, null)      = true
     * StringUtils.endsWith(null, "def")     = false
     * StringUtils.endsWith("abcdef", null)  = false
     * StringUtils.endsWith("abcdef", "def") = true
     * StringUtils.endsWith("ABCDEF", "def") = false
     * StringUtils.endsWith("ABCDEF", "cde") = false
     * &lt;/pre&gt;
     *
     * @see String#endsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param suffix the suffix to find, may be null
     * @return {@code true} if the CharSequence ends with the suffix, case sensitive, or
     *  both {@code null}
     * @since 2.4
     * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>endsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>endsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Case insensitive check if a CharSequence ends with a specified suffix.&lt;/p&gt;
     *
     * &lt;p&gt;{@code null}s are handled without exceptions. Two {@code null}
     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWithIgnoreCase(null, null)      = true
     * StringUtils.endsWithIgnoreCase(null, "def")     = false
     * StringUtils.endsWithIgnoreCase("abcdef", null)  = false
     * StringUtils.endsWithIgnoreCase("abcdef", "def") = true
     * StringUtils.endsWithIgnoreCase("ABCDEF", "def") = true
     * StringUtils.endsWithIgnoreCase("ABCDEF", "cde") = false
     * &lt;/pre&gt;
     *
     * @see String#endsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param suffix the suffix to find, may be null
     * @return {@code true} if the CharSequence ends with the suffix, case insensitive, or
     *  both {@code null}
     * @since 2.4
     * @since 3.0 Changed signature from endsWithIgnoreCase(String, String) to endsWithIgnoreCase(CharSequence, CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>endsWithIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>endsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence ends with a specified suffix (optionally case insensitive).&lt;/p&gt;
     *
     * @see String#endsWith(String)
     * @param str  the CharSequence to check, may be null
     * @param suffix the suffix to find, may be null
     * @param ignoreCase indicates whether the compare should ignore case
     *  (case insensitive) or not.
     * @return {@code true} if the CharSequence starts with the prefix or
     *  both {@code null}
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>endsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreCase</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>suffix</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>suffix</name> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>suffix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strOffset</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>suffix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>CharSequenceUtils</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>, <argument><expr><name>strOffset</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>suffix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Similar to &lt;a
     * href="http://www.w3.org/TR/xpath/#function-normalize-space"&gt;http://www.w3.org/TR/xpath/#function-normalize
     * -space&lt;/a&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * The function returns the argument string with whitespace normalized by using
     * &lt;code&gt;{@link #trim(String)}&lt;/code&gt; to remove leading and trailing whitespace
     * and then replacing sequences of whitespace characters by a single space.
     * &lt;/p&gt;
     * In XML Whitespace characters are the same as those allowed by the &lt;a
     * href="http://www.w3.org/TR/REC-xml/#NT-S"&gt;S&lt;/a&gt; production, which is S ::= (#x20 | #x9 | #xD | #xA)+
     * &lt;p&gt;
     * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
     * &lt;p&gt;
     * For reference:
     * &lt;ul&gt;
     * &lt;li&gt;\x0B = vertical tab&lt;/li&gt;
     * &lt;li&gt;\f = #xC = form feed&lt;/li&gt;
     * &lt;li&gt;#x20 = space&lt;/li&gt;
     * &lt;li&gt;#x9 = \t&lt;/li&gt;
     * &lt;li&gt;#xA = \n&lt;/li&gt;
     * &lt;li&gt;#xD = \r&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
     * normalize. Additionally &lt;code&gt;{@link #trim(String)}&lt;/code&gt; removes control characters (char &amp;lt;= 32) from both
     * ends of this String.
     * &lt;/p&gt;
     *
     * @see Pattern
     * @see #trim(String)
     * @see &lt;a
     *      href="http://www.w3.org/TR/xpath/#function-normalize-space"&gt;http://www.w3.org/TR/xpath/#function-normalize-space&lt;/a&gt;
     * @param str the source String to normalize whitespaces from, may be null
     * @return the modified string with whitespace normalized, {@code null} if null String input
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>normalizeSpace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>WHITESPACE_PATTERN</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><call><name>trim</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><name>SPACE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Check if a CharSequence ends with any of an array of specified strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWithAny(null, null)      = false
     * StringUtils.endsWithAny(null, new String[] {"abc"})  = false
     * StringUtils.endsWithAny("abcxyz", null)     = false
     * StringUtils.endsWithAny("abcxyz", new String[] {""}) = true
     * StringUtils.endsWithAny("abcxyz", new String[] {"xyz"}) = true
     * StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true
     * &lt;/pre&gt;
     *
     * @param string  the CharSequence to check, may be null
     * @param searchStrings the CharSequences to find, may be null or empty
     * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
     *  both {@code null}
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>endsWithAny</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>searchStrings</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>searchStrings</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchString</name> <range>: <expr><name>searchStrings</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>searchString</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends the suffix to the end of the string if the string does not
     * already end in the suffix.
     *
     * @param str The string.
     * @param suffix The suffix to append to the end of the string.
     * @param ignoreCase Indicates whether the compare should ignore case.
     * @param suffixes Additional suffixes that are valid terminators (optional).
     *
     * @return A new String if suffix was appened, the same string otherwise.
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>appendIfMissing</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreCase</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>suffixes</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>endsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>suffixes</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>suffixes</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>s</name> <range>: <expr><name>suffixes</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><call><name>endsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>str</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>str</name> <operator>+</operator> <call><name><name>suffix</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends the suffix to the end of the string if the string does not
     * already end with any the suffixes.
     *
     * &lt;pre&gt;
     * StringUtils.appendIfMissing(null, null) = null
     * StringUtils.appendIfMissing("abc", null) = "abc"
     * StringUtils.appendIfMissing("", "xyz") = "xyz"
     * StringUtils.appendIfMissing("abc", "xyz") = "abcxyz"
     * StringUtils.appendIfMissing("abcxyz", "xyz") = "abcxyz"
     * StringUtils.appendIfMissing("abcXYZ", "xyz") = "abcXYZxyz"
     * &lt;/pre&gt;
     * &lt;p&gt;With additional suffixes,&lt;/p&gt;
     * &lt;pre&gt;
     * StringUtils.appendIfMissing(null, null, null) = null
     * StringUtils.appendIfMissing("abc", null, null) = "abc"
     * StringUtils.appendIfMissing("", "xyz", null) = "xyz"
     * StringUtils.appendIfMissing("abc", "xyz", new CharSequence[]{null}) = "abcxyz"
     * StringUtils.appendIfMissing("abc", "xyz", "") = "abc"
     * StringUtils.appendIfMissing("abc", "xyz", "mno") = "abcxyz"
     * StringUtils.appendIfMissing("abcxyz", "xyz", "mno") = "abcxyz"
     * StringUtils.appendIfMissing("abcmno", "xyz", "mno") = "abcmno"
     * StringUtils.appendIfMissing("abcXYZ", "xyz", "mno") = "abcXYZxyz"
     * StringUtils.appendIfMissing("abcMNO", "xyz", "mno") = "abcMNOxyz"
     * &lt;/pre&gt;
     *
     * @param str The string.
     * @param suffix The suffix to append to the end of the string.
     * @param suffixes Additional suffixes that are valid terminators.
     *
     * @return A new String if suffix was appened, the same string otherwise.
     *
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>appendIfMissing</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>suffixes</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>appendIfMissing</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>suffixes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends the suffix to the end of the string if the string does not
     * already end, case insensitive, with any of the suffixes.
     *
     * &lt;pre&gt;
     * StringUtils.appendIfMissingIgnoreCase(null, null) = null
     * StringUtils.appendIfMissingIgnoreCase("abc", null) = "abc"
     * StringUtils.appendIfMissingIgnoreCase("", "xyz") = "xyz"
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz") = "abcxyz"
     * StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz") = "abcxyz"
     * StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz") = "abcXYZ"
     * &lt;/pre&gt;
     * &lt;p&gt;With additional suffixes,&lt;/p&gt;
     * &lt;pre&gt;
     * StringUtils.appendIfMissingIgnoreCase(null, null, null) = null
     * StringUtils.appendIfMissingIgnoreCase("abc", null, null) = "abc"
     * StringUtils.appendIfMissingIgnoreCase("", "xyz", null) = "xyz"
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", new CharSequence[]{null}) = "abcxyz"
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", "") = "abc"
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", "mno") = "axyz"
     * StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz", "mno") = "abcxyz"
     * StringUtils.appendIfMissingIgnoreCase("abcmno", "xyz", "mno") = "abcmno"
     * StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz", "mno") = "abcXYZ"
     * StringUtils.appendIfMissingIgnoreCase("abcMNO", "xyz", "mno") = "abcMNO"
     * &lt;/pre&gt;
     *
     * @param str The string.
     * @param suffix The suffix to append to the end of the string.
     * @param suffixes Additional suffixes that are valid terminators.
     *
     * @return A new String if suffix was appened, the same string otherwise.
     *
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>appendIfMissingIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>suffixes</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>appendIfMissing</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>suffixes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Prepends the prefix to the start of the string if the string does not
     * already start with any of the prefixes.
     *
     * @param str The string.
     * @param prefix The prefix to prepend to the start of the string.
     * @param ignoreCase Indicates whether the compare should ignore case.
     * @param prefixes Additional prefixes that are valid (optional).
     *
     * @return A new String if prefix was prepended, the same string otherwise.
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>prependIfMissing</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreCase</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>prefixes</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>startsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>str</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>prefixes</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>prefixes</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>p</name> <range>: <expr><name>prefixes</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><call><name>startsWith</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ignoreCase</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>str</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><call><name><name>prefix</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>str</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Prepends the prefix to the start of the string if the string does not
     * already start with any of the prefixes.
     *
     * &lt;pre&gt;
     * StringUtils.prependIfMissing(null, null) = null
     * StringUtils.prependIfMissing("abc", null) = "abc"
     * StringUtils.prependIfMissing("", "xyz") = "xyz"
     * StringUtils.prependIfMissing("abc", "xyz") = "xyzabc"
     * StringUtils.prependIfMissing("xyzabc", "xyz") = "xyzabc"
     * StringUtils.prependIfMissing("XYZabc", "xyz") = "xyzXYZabc"
     * &lt;/pre&gt;
     * &lt;p&gt;With additional prefixes,&lt;/p&gt;
     * &lt;pre&gt;
     * StringUtils.prependIfMissing(null, null, null) = null
     * StringUtils.prependIfMissing("abc", null, null) = "abc"
     * StringUtils.prependIfMissing("", "xyz", null) = "xyz"
     * StringUtils.prependIfMissing("abc", "xyz", new CharSequence[]{null}) = "xyzabc"
     * StringUtils.prependIfMissing("abc", "xyz", "") = "abc"
     * StringUtils.prependIfMissing("abc", "xyz", "mno") = "xyzabc"
     * StringUtils.prependIfMissing("xyzabc", "xyz", "mno") = "xyzabc"
     * StringUtils.prependIfMissing("mnoabc", "xyz", "mno") = "mnoabc"
     * StringUtils.prependIfMissing("XYZabc", "xyz", "mno") = "xyzXYZabc"
     * StringUtils.prependIfMissing("MNOabc", "xyz", "mno") = "xyzMNOabc"
     * &lt;/pre&gt;
     *
     * @param str The string.
     * @param prefix The prefix to prepend to the start of the string.
     * @param prefixes Additional prefixes that are valid.
     *
     * @return A new String if prefix was prepended, the same string otherwise.
     *
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>prependIfMissing</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>prefixes</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>prependIfMissing</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>prefixes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Prepends the prefix to the start of the string if the string does not
     * already start, case insensitive, with any of the prefixes.
     *
     * &lt;pre&gt;
     * StringUtils.prependIfMissingIgnoreCase(null, null) = null
     * StringUtils.prependIfMissingIgnoreCase("abc", null) = "abc"
     * StringUtils.prependIfMissingIgnoreCase("", "xyz") = "xyz"
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz") = "xyzabc"
     * StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz") = "xyzabc"
     * StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz") = "XYZabc"
     * &lt;/pre&gt;
     * &lt;p&gt;With additional prefixes,&lt;/p&gt;
     * &lt;pre&gt;
     * StringUtils.prependIfMissingIgnoreCase(null, null, null) = null
     * StringUtils.prependIfMissingIgnoreCase("abc", null, null) = "abc"
     * StringUtils.prependIfMissingIgnoreCase("", "xyz", null) = "xyz"
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", new CharSequence[]{null}) = "xyzabc"
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", "") = "abc"
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", "mno") = "xyzabc"
     * StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz", "mno") = "xyzabc"
     * StringUtils.prependIfMissingIgnoreCase("mnoabc", "xyz", "mno") = "mnoabc"
     * StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz", "mno") = "XYZabc"
     * StringUtils.prependIfMissingIgnoreCase("MNOabc", "xyz", "mno") = "MNOabc"
     * &lt;/pre&gt;
     *
     * @param str The string.
     * @param prefix The prefix to prepend to the start of the string.
     * @param prefixes Additional prefixes that are valid (optional).
     *
     * @return A new String if prefix was prepended, the same string otherwise.
     *
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>prependIfMissingIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name><modifier>...</modifier></type> <name>prefixes</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>prependIfMissing</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>prefixes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Converts a &lt;code&gt;byte[]&lt;/code&gt; to a String using the specified character encoding.
     *
     * @param bytes
     *            the byte array to read from
     * @param charsetName
     *            the encoding to use, if null then use the platform default
     * @return a new String
     * @throws UnsupportedEncodingException
     *             If the named charset is not supported
     * @throws NullPointerException
     *             if the input is null
     * @since 3.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>charsetName</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnsupportedEncodingException</name></expr></argument></throws> <block>{
        <return>return <expr><ternary><condition><expr><name>charsetName</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>charsetName</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

}</block></class>



<comment type="block" format="javadoc">/**
 * &lt;p&gt;Operations on {@link java.lang.CharSequence} that are
 * {@code null} safe.&lt;/p&gt;
 *
 * @see java.lang.CharSequence
 * @since 3.0
 * @version $Id$
 */</comment>
<class>class <name>CharSequenceUtils</name> <block>{

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;{@code CharSequenceUtils} instances should NOT be constructed in
     * standard programming. &lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
     * instance to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>CharSequenceUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns a new {@code CharSequence} that is a subsequence of this
     * sequence starting with the {@code char} value at the specified index.&lt;/p&gt;
     *
     * &lt;p&gt;This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.
     * The length (in {@code char}) of the returned sequence is {@code length() - start},
     * so if {@code start == end} then an empty sequence is returned.&lt;/p&gt;
     *
     * @param cs  the specified subsequence, null returns null
     * @param start  the start index, inclusive, valid
     * @return a new subsequence, may be null
     * @throws IndexOutOfBoundsException if {@code start} is negative or if
     *  {@code start} is greater than {@code length()}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>CharSequence</name></type> <name>subSequence</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>cs</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name><name>cs</name><operator>.</operator><name>subSequence</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the first index in the {@code CharSequence} that matches the
     * specified character.&lt;/p&gt;
     *
     * @param cs  the {@code CharSequence} to be processed, not null
     * @param searchChar  the char to be searched for
     * @param start  the start index, negative starts at the string start
     * @return the index where the search char was found, -1 if not found
     */</comment>
    <function><specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>instanceof</operator> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>(</operator><operator>(</operator><name>String</name><operator>)</operator> <name>cs</name><operator>)</operator><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><name>searchChar</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            }</block></then></if>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>searchChar</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.
     *
     * @param cs the {@code CharSequence} to be processed
     * @param searchChar the {@code CharSequence} to be searched for
     * @param start the start index
     * @return the index where the search sequence was found
     */</comment>
    <function><specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>cs</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><call><name><name>searchChar</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
<comment type="line">//        if (cs instanceof String &amp;&amp; searchChar instanceof String) {</comment>
<comment type="line">//            // TODO: Do we assume searchChar is usually relatively small;</comment>
<comment type="line">//            //       If so then calling toString() on it is better than reverting to</comment>
<comment type="line">//            //       the green implementation in the else block</comment>
<comment type="line">//            return ((String) cs).indexOf((String) searchChar, start);</comment>
<comment type="line">//        } else {</comment>
<comment type="line">//            // TODO: Implement rather than convert to String</comment>
<comment type="line">//            return cs.toString().indexOf(searchChar.toString(), start);</comment>
<comment type="line">//        }</comment>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index in the {@code CharSequence} that matches the
     * specified character.&lt;/p&gt;
     *
     * @param cs  the {@code CharSequence} to be processed
     * @param searchChar  the char to be searched for
     * @param start  the start index, negative returns -1, beyond length starts at end
     * @return the index where the search char was found, -1 if not found
     */</comment>
    <function><specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>instanceof</operator> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>(</operator><operator>(</operator><name>String</name><operator>)</operator> <name>cs</name><operator>)</operator><operator>.</operator><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>searchChar</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>sz</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>sz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>searchChar</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf
     *
     * @param cs the {@code CharSequence} to be processed
     * @param searchChar the {@code CharSequence} to be searched for
     * @param start the start index
     * @return the index where the search sequence was found
     */</comment>
    <function><specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>searchChar</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>cs</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lastIndexOf</name><argument_list>(<argument><expr><call><name><name>searchChar</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
<comment type="line">//        if (cs instanceof String &amp;&amp; searchChar instanceof String) {</comment>
<comment type="line">//            // TODO: Do we assume searchChar is usually relatively small;</comment>
<comment type="line">//            //       If so then calling toString() on it is better than reverting to</comment>
<comment type="line">//            //       the green implementation in the else block</comment>
<comment type="line">//            return ((String) cs).lastIndexOf((String) searchChar, start);</comment>
<comment type="line">//        } else {</comment>
<comment type="line">//            // TODO: Implement rather than convert to String</comment>
<comment type="line">//            return cs.toString().lastIndexOf(searchChar.toString(), start);</comment>
<comment type="line">//        }</comment>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Green implementation of toCharArray.
     *
     * @param cs the {@code CharSequence} to be processed
     * @return the resulting char array
     */</comment>
    <function><specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>toCharArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>instanceof</operator> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>(</operator><operator>(</operator><name>String</name><operator>)</operator> <name>cs</name><operator>)</operator><operator>.</operator><call><name>toCharArray</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><call><name><name>cs</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <return>return <expr><name>array</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Green implementation of regionMatches.
     *
     * @param cs the {@code CharSequence} to be processed
     * @param ignoreCase whether or not to be case insensitive
     * @param thisStart the index to start on the {@code cs} CharSequence
     * @param substring the {@code CharSequence} to be looked for
     * @param start the index to start on the {@code substring} CharSequence
     * @param length character length of the region
     * @return whether the region matched
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>regionMatches</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>cs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreCase</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>thisStart</name></decl></parameter>,
                                 <parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>substring</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>    <block>{
        <if>if <condition>(<expr><name>cs</name> <operator>instanceof</operator> <name>String</name> <operator>&amp;&amp;</operator> <name>substring</name> <operator>instanceof</operator> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>(</operator><operator>(</operator><name>String</name><operator>)</operator> <name>cs</name><operator>)</operator><operator>.</operator><call><name>regionMatches</name><argument_list>(<argument><expr><name>ignoreCase</name></expr></argument>, <argument><expr><name>thisStart</name></expr></argument>, <argument><expr><operator>(</operator><name>String</name><operator>)</operator> <name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>index1</name> <init>= <expr><name>thisStart</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>index2</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>tmpLen</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>tmpLen</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>char</name></type> <name>c1</name> <init>= <expr><call><name><name>cs</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>index1</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name>c2</name> <init>= <expr><call><name><name>substring</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>index2</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c1</name> <operator>==</operator> <name>c2</name></expr>)</condition><then> <block>{
                    <continue>continue;</continue>
                }</block></then></if>

                <if>if <condition>(<expr><operator>!</operator><name>ignoreCase</name></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>

                <comment type="line">// The same check as in String.regionMatches():</comment>
                <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Character</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call>
                        <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Character</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
            }</block></while>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></else></if>
    }</block></function>
}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Operations on arrays, primitive arrays (like {@code int[]}) and
 * primitive wrapper arrays (like {@code Integer[]}).&lt;/p&gt;
 *
 * &lt;p&gt;This class tries to handle {@code null} input gracefully.
 * An exception will not be thrown for a {@code null}
 * array input. However, an Object array that contains a {@code null}
 * element may throw an exception. Each method documents its behaviour.&lt;/p&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @since 2.0
 * @version $Id$
 */</comment>
<class>class <name>ArrayUtils</name> <block>{

    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Object} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>EMPTY_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Object</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Class} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>EMPTY_CLASS_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Class</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code String} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>EMPTY_STRING_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code long} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>EMPTY_LONG_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Long} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Long</name><index>[]</index></name></type> <name>EMPTY_LONG_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Long</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code int} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>EMPTY_INT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Integer} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Integer</name><index>[]</index></name></type> <name>EMPTY_INTEGER_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Integer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code short} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>EMPTY_SHORT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>short</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Short} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Short</name><index>[]</index></name></type> <name>EMPTY_SHORT_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Short</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code byte} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>EMPTY_BYTE_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Byte} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Byte</name><index>[]</index></name></type> <name>EMPTY_BYTE_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Byte</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code double} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>EMPTY_DOUBLE_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Double} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Double</name><index>[]</index></name></type> <name>EMPTY_DOUBLE_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Double</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code float} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>EMPTY_FLOAT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Float} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Float</name><index>[]</index></name></type> <name>EMPTY_FLOAT_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Float</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code boolean} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>EMPTY_BOOLEAN_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Boolean} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Boolean</name><index>[]</index></name></type> <name>EMPTY_BOOLEAN_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Boolean</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code char} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>EMPTY_CHAR_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * An empty immutable {@code Character} array.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Character</name><index>[]</index></name></type> <name>EMPTY_CHARACTER_OBJECT_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>Character</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The index value when an element is not found in a list or array: {@code -1}.
     * This value is returned by methods in this class and can also be used in comparisons with values returned by
     * various method from {@link java.util.List}.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>INDEX_NOT_FOUND</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;ArrayUtils instances should NOT be constructed in standard programming.
     * Instead, the class should be used as &lt;code&gt;ArrayUtils.clone(new int[] {2})&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance
     * to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ArrayUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>


    <comment type="line">// NOTE: Cannot use {@code} to enclose text which includes {}, but &lt;code&gt;&lt;/code&gt; is OK</comment>


    <comment type="line">// Basic methods handling multi-dimensional arrays</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Outputs an array as a String, treating {@code null} as an empty array.&lt;/p&gt;
     *
     * &lt;p&gt;Multi-dimensional arrays are handled correctly, including
     * multi-dimensional primitive arrays.&lt;/p&gt;
     *
     * &lt;p&gt;The format is that of Java source code, for example &lt;code&gt;{a,b}&lt;/code&gt;.&lt;/p&gt;
     *
     * @param array  the array to get a toString for, may be {@code null}
     * @return a String representation of the array, '{}' if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Outputs an array as a String handling {@code null}s.&lt;/p&gt;
     *
     * &lt;p&gt;Multi-dimensional arrays are handled correctly, including
     * multi-dimensional primitive arrays.&lt;/p&gt;
     *
     * &lt;p&gt;The format is that of Java source code, for example &lt;code&gt;{a,b}&lt;/code&gt;.&lt;/p&gt;
     *
     * @param array  the array to get a toString for, may be {@code null}
     * @param stringIfNull  the String to return if the array is {@code null}
     * @return a String representation of the array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>stringIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>stringIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>ToStringBuilder</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>ToStringStyle</name><operator>.</operator><name>SIMPLE_STYLE</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Get a hash code for an array handling multi-dimensional arrays correctly.&lt;/p&gt;
     *
     * &lt;p&gt;Multi-dimensional primitive arrays are also handled correctly by this method.&lt;/p&gt;
     *
     * @param array  the array to get a hash code for, {@code null} returns zero
     * @return a hash code for the array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>HashCodeBuilder</name><argument_list>()</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toHashCode</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two arrays, using equals(), handling multi-dimensional arrays
     * correctly.&lt;/p&gt;
     *
     * &lt;p&gt;Multi-dimensional primitive arrays are also handled correctly by this method.&lt;/p&gt;
     *
     * @param array1  the left hand array to compare, may be {@code null}
     * @param array2  the right hand array to compare, may be {@code null}
     * @return {@code true} if the arrays are equal
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>EqualsBuilder</name><argument_list>()</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><name>array2</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isEquals</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// To map</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the given array into a {@link java.util.Map}. Each element of the array
     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two
     * elements, where the first element is used as key and the second as
     * value.&lt;/p&gt;
     *
     * &lt;p&gt;This method can be used to initialize:&lt;/p&gt;
     * &lt;pre&gt;
     * // Create a Map mapping colors.
     * Map colorMap = MapUtils.toMap(new String[][] {{
     *     {"RED", "#FF0000"},
     *     {"GREEN", "#00FF00"},
     *     {"BLUE", "#0000FF"}});
     * &lt;/pre&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or
     *  an Array containing at least two elements, may be {@code null}
     * @return a {@code Map} that was created from the array
     * @throws IllegalArgumentException  if one element of this Array is
     *  itself an Array containing less then two elements
     * @throws IllegalArgumentException  if the array contains elements other
     *  than {@link java.util.Map.Entry} and an Array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>toMap</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">1.5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><ternary><condition><expr><name>object</name> <operator>instanceof</operator> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></name></expr>)</condition> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></name></expr></condition></ternary><operator>)</operator> <name>object</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></ternary></expr></condition> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>Object</name><index>[]</index></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>entry</name> <init>= <expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><then> <block>{
                    <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Array element "</literal> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="string">", '"</literal>
                            <operator>+</operator> <name>object</name>
                            <operator>+</operator> <literal type="string">"', has a length less than 2"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <else>else <block>{
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Array element "</literal> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="string">", '"</literal>
                        <operator>+</operator> <name>object</name>
                        <operator>+</operator> <literal type="string">"', is neither of type Map.Entry nor an Array"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <comment type="line">// Generic array</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Create a type-safe generic array.&lt;/p&gt;
     *
     * &lt;p&gt;The Java language does not allow an array to be created from a generic type:&lt;/p&gt;
     *
     * &lt;pre&gt;
     public static &amp;lt;T&amp;gt; T[] createAnArray(int size) {
     return new T[size]; // compiler error here
     }
     public static &amp;lt;T&amp;gt; T[] createAnArray(int size) {
     return (T[])new Object[size]; // ClassCastException at runtime
     }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Therefore new arrays of generic types can be created with this method.
     * For example, an array of Strings can be created:&lt;/p&gt;
     *
     * &lt;pre&gt;
     String[] array = ArrayUtils.toArray("1", "2");
     String[] emptyArray = ArrayUtils.&amp;lt;String&amp;gt;toArray();
     * &lt;/pre&gt;
     *
     * &lt;p&gt;The method is typically used in scenarios, where the caller itself uses generic types
     * that have to be combined into an array.&lt;/p&gt;
     *
     * &lt;p&gt;Note, this method makes only sense to provide arguments of the same type so that the
     * compiler can deduce the type of the array itself. While it is possible to select the
     * type explicitly like in
     * &lt;code&gt;Number[] array = ArrayUtils.&amp;lt;Number&amp;gt;toArray(Integer.valueOf(42), Double.valueOf(Math.PI))&lt;/code&gt;,
     * there is no real advantage when compared to
     * &lt;code&gt;new Number[] {Integer.valueOf(42), Double.valueOf(Math.PI)}&lt;/code&gt;.&lt;/p&gt;
     *
     * @param  &lt;T&gt;   the array's element type
     * @param  items  the varargs array items, null allowed
     * @return the array, not null unless a null array is passed in
     * @since  3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>toArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>items</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>items</name></expr>;</return>
    }</block></function>

    <comment type="line">// Clone</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Shallow clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;The objects in the array are not cloned, thus there is no special
     * handling for multi-dimensional arrays.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to shallow clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clones an array returning a typecast result and handling
     * {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to clone, may be {@code null}
     * @return the cloned array, {@code null} if {@code null} input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>array</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// nullToEmpty</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Object</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_STRING_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHAR_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Long</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Integer</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Integer</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INTEGER_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Short</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Character</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Character</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHARACTER_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Byte</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Double</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Float</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Defensive programming technique to change a {@code null}
     * reference to an empty one.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns an empty array for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;As a memory optimizing technique an empty array passed in will be overridden with
     * the empty {@code public static} references in this class.&lt;/p&gt;
     *
     * @param array  the array to check for {@code null} or empty
     * @return the same array, {@code public static} empty array if {@code null} or empty input
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Boolean</name><index>[]</index></name></type> <name>nullToEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="line">// Subarrays</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new array containing the elements between
     * the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * &lt;p&gt;The component type of the subarray is always the same as
     * that of the input array. Thus, if the input is an array of type
     * {@code Date}, the following usage is envisaged:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name> <init>= <expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// OK, because array is of type T</comment>
            <type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>emptyArray</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>emptyArray</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// OK, because array is of type T</comment>
        <type><specifier>final</specifier>
        <name><name>T</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code long} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code int} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INT_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code short} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>short</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code char} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHAR_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code byte} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code double} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code float} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Produces a new {@code boolean} array containing the elements
     * between the start and end indices.&lt;/p&gt;
     *
     * &lt;p&gt;The start index is inclusive, the end index exclusive.
     * Null array input produces null output.&lt;/p&gt;
     *
     * @param array  the array
     * @param startIndexInclusive  the starting index. Undervalue (&amp;lt;0)
     *      is promoted to 0, overvalue (&amp;gt;array.length) results
     *      in an empty array.
     * @param endIndexExclusive  elements up to endIndex-1 are present in the
     *      returned subarray. Undervalue (&amp;lt; startIndex) produces
     *      empty array, overvalue (&amp;gt;array.length) is demoted to
     *      array length.
     * @return a new array containing the elements between
     *      the start and end indices.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>subarray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndexInclusive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndexExclusive</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndexInclusive</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndexInclusive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndexExclusive</name> <operator>&gt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndexExclusive</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>endIndexExclusive</name> <operator>-</operator> <name>startIndexInclusive</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_ARRAY</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>subarray</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>startIndexInclusive</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subarray</name></expr>;</return>
    }</block></function>

    <comment type="line">// Is same length</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.
     *
     * &lt;p&gt;Any multi-dimensional aspects of the arrays are ignored.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same length, treating
     * {@code null} arrays as length {@code 0}.&lt;/p&gt;
     *
     * @param array1 the first array, may be {@code null}
     * @param array2 the second array, may be {@code null}
     * @return {@code true} if length of arrays matches, treating
     *  {@code null} as an empty array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>(</operator><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array2</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array2</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>array1</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>array2</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array1</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>array2</name><operator>.</operator><name>length</name></name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the length of the specified array.
     * This method can deal with {@code Object} arrays and with primitive arrays.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, {@code 0} is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.getLength(null)            = 0
     * ArrayUtils.getLength([])              = 0
     * ArrayUtils.getLength([null])          = 1
     * ArrayUtils.getLength([true, false])   = 2
     * ArrayUtils.getLength([1, 2, 3])       = 3
     * ArrayUtils.getLength(["a", "b", "c"]) = 3
     * &lt;/pre&gt;
     *
     * @param array  the array to retrieve the length from, may be null
     * @return The length of the array, or {@code 0} if the array is {@code null}
     * @throws IllegalArgumentException if the object argument is not an array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>getLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether two arrays are the same type taking into account
     * multi-dimensional arrays.&lt;/p&gt;
     *
     * @param array1 the first array, must not be {@code null}
     * @param array2 the second array, must not be {@code null}
     * @return {@code true} if type of arrays matches
     * @throws IllegalArgumentException if either array is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isSameType</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The Array must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name><name>array1</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>array2</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Reverse</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;There is no special handling for multi-dimensional arrays.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Object</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>short</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Reverses the order of the given array.&lt;/p&gt;
     *
     * &lt;p&gt;This method does nothing for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to reverse, may be {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reverse</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>tmp</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="line">// IndexOf search</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>

    <comment type="line">// Object IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given object in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param objectToFind  the object to find, may be {@code null}
     * @return the index of the object within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>objectToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>objectToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given object in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param objectToFind  the object to find, may be {@code null}
     * @param startIndex  the index to start searching at
     * @return the index of the object within the array starting at the index,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>objectToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>objectToFind</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInstance</name><argument_list>(<argument><expr><name>objectToFind</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>objectToFind</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if></elseif></if>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given object within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param objectToFind  the object to find, may be {@code null}
     * @return the last index of the object within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>objectToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>objectToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given object in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than
     * the array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param objectToFind  the object to find, may be {@code null}
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the object within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>objectToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <if>if <condition>(<expr><name>objectToFind</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInstance</name><argument_list>(<argument><expr><name>objectToFind</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>objectToFind</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>i</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if></elseif></if>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the object is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param objectToFind  the object to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>objectToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>objectToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// long IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// int IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// short IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// char IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// byte IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// double IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value within a given tolerance in the array.
     * This method will return the index of the first value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param tolerance tolerance of the search
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>tolerance</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tolerance</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.
     * This method will return the index of the first value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @param tolerance tolerance of the search
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>tolerance</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>min</name> <init>= <expr><name>valueToFind</name> <operator>-</operator> <name>tolerance</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>max</name> <init>= <expr><name>valueToFind</name> <operator>+</operator> <name>tolerance</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>min</name> <operator>&amp;&amp;</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>max</name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within a given tolerance in the array.
     * This method will return the index of the last value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param tolerance tolerance of the search
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>tolerance</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>, <argument><expr><name>tolerance</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.
     * This method will return the index of the last value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @param tolerance  search for value within plus/minus this amount
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>tolerance</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>min</name> <init>= <expr><name>valueToFind</name> <operator>-</operator> <name>tolerance</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>max</name> <init>= <expr><name>valueToFind</name> <operator>+</operator> <name>tolerance</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>min</name> <operator>&amp;&amp;</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>max</name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if a value falling within the given tolerance is in the
     * given array.  If the array contains a value within the inclusive range
     * defined by (value - tolerance) to (value + tolerance).&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array
     * is passed in.&lt;/p&gt;
     *
     * @param array  the array to search
     * @param valueToFind  the value to find
     * @param tolerance  the array contains the tolerance of the search
     * @return true if value falling within tolerance is in array
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>tolerance</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tolerance</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// float IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// boolean IndexOf</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).&lt;/p&gt;
     *
     * @param array  the array to search through for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null}
     *  array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value within the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) if
     * {@code null} array input.&lt;/p&gt;
     *
     * @param array  the array to travers backwords looking for the object, may be {@code null}
     * @param valueToFind  the object to find
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Finds the last index of the given value in the array starting at the given index.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.&lt;/p&gt;
     *
     * &lt;p&gt;A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than
     * the array length will search from the end of the array.&lt;/p&gt;
     *
     * @param array  the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind  the value to find
     * @param startIndex  the start index to travers backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueToFind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>valueToFind</name> <operator>==</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if the value is in the given array.&lt;/p&gt;
     *
     * &lt;p&gt;The method returns {@code false} if a {@code null} array is passed in.&lt;/p&gt;
     *
     * @param array  the array to search through
     * @param valueToFind  the value to find
     * @return {@code true} if the array contains the object
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueToFind</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>valueToFind</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INDEX_NOT_FOUND</name></expr>;</return>
    }</block></function>

    <comment type="line">// Primitive/Object array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>

    <comment type="line">// Character array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Characters to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Character} array, may be {@code null}
     * @return a {@code char} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Character</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHAR_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>charValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Character to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Character} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code char} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Character</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHAR_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Character</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive chars to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array a {@code char} array
     * @return a {@code Character} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Character</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_CHARACTER_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Character</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Character</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Character</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Long array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Longs to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Long} array, may be {@code null}
     * @return a {@code long} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>longValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Long to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Long} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code long} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Long</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>longValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive longs to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code long} array
     * @return a {@code Long} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Long</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_LONG_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Long</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Long</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Int array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Integers to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Integer} array, may be {@code null}
     * @return an {@code int} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Integer</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Integer to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Integer} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return an {@code int} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Integer</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Integer</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive ints to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  an {@code int} array
     * @return an {@code Integer} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Integer</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_INTEGER_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Integer</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Integer</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Short array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Shorts to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Short} array, may be {@code null}
     * @return a {@code byte} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>short</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>shortValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Short to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Short} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code byte} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>short</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Short</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>shortValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive shorts to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code short} array
     * @return a {@code Short} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Short</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_SHORT_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Short</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Short</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Byte array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Bytes to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Byte} array, may be {@code null}
     * @return a {@code byte} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>byteValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Bytes to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Byte} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code byte} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Byte</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>byteValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive bytes to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code byte} array
     * @return a {@code Byte} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Byte</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BYTE_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Byte</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Byte</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Double array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Doubles to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Double} array, may be {@code null}
     * @return a {@code double} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>doubleValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Doubles to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Double} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code double} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Double</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>doubleValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive doubles to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code double} array
     * @return a {@code Double} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Double</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_DOUBLE_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Double</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Double</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">//   Float array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Floats to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Float} array, may be {@code null}
     * @return a {@code float} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>floatValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Floats to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Float} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code float} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Float</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>floatValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive floats to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code float} array
     * @return a {@code Float} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Float</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_FLOAT_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Float</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Float</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Boolean array converters</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Booleans to primitives.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Boolean} array, may be {@code null}
     * @return a {@code boolean} array, {@code null} if null array input
     * @throws NullPointerException if array content is {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>booleanValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of object Booleans to primitives handling {@code null}.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code Boolean} array, may be {@code null}
     * @param valueForNull  the value to insert if {@code null} found
     * @return a {@code boolean} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>toPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>valueForNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>b</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>b</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>valueForNull</name></expr> </then><else>: <expr><call><name><name>b</name><operator>.</operator><name>booleanValue</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of primitive booleans to objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array  a {@code boolean} array
     * @return a {@code Boolean} array, {@code null} if null array input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Boolean</name><index>[]</index></name></type> <name>toObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EMPTY_BOOLEAN_OBJECT_ARRAY</name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Boolean</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>Boolean</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>Boolean</name><operator>.</operator><name>TRUE</name></name></expr> </then><else>: <expr><name><name>Boolean</name><operator>.</operator><name>FALSE</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of Objects is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive longs is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive ints is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive shorts is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive chars is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive bytes is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive doubles is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive floats is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive booleans is empty or {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is empty or {@code null}
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>array</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of Objects is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive longs is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive ints is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive shorts is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive chars is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive bytes is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive doubles is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive floats is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of primitive booleans is not empty or not {@code null}.&lt;/p&gt;
     *
     * @param array  the array to test
     * @return {@code true} if the array is not empty or not {@code null}
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isNotEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(null, null)     = null
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * ArrayUtils.addAll([null], [null]) = [null, null]
     * ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array1  the first array whose elements are added to the new array, may be {@code null}
     * @param array2  the second array whose elements are added to the new array, may be {@code null}
     * @return The new array, {@code null} if both arrays are {@code null}.
     *      The type of the new array is the type of the first array,
     *      unless the first array is null, in which case the type is the same as the second array.
     * @since 2.1
     * @throws IllegalArgumentException if the array types are incompatible
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type1</name> <init>= <expr><call><name><name>array1</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// OK, because array is of type T</comment>
        <type><specifier>final</specifier>
        <name><name>T</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>type1</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ArrayStoreException</name></type> <name>ase</name></decl></parameter>)</parameter_list> <block>{
            <comment type="line">// Check if problem was due to incompatible types</comment>
            <comment type="block">/*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type2</name> <init>= <expr><call><name><name>array2</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>type1</name><operator>.</operator><name>isAssignableFrom</name></name><argument_list>(<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Cannot store "</literal><operator>+</operator><call><name><name>type2</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>+</operator><literal type="string">" in an array of "</literal>
                        <operator>+</operator><call><name><name>type1</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ase</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr><name>ase</name></expr>;</throw> <comment type="line">// No, so rethrow original</comment>
        }</block></catch></try>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new boolean[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new char[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new byte[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new short[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>short</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new int[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new long[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new float[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds all the elements of the given arrays into a new array.&lt;/p&gt;
     * &lt;p&gt;The new array contains all of the element of {@code array1} followed
     * by all of the elements {@code array2}. When an array is returned, it is always
     * a new array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2
     * ArrayUtils.addAll([], [])         = []
     * &lt;/pre&gt;
     *
     * @param array1  the first array whose elements are added to the new array.
     * @param array2  the second array whose elements are added to the new array.
     * @return The new double[] array.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name><modifier>...</modifier></type> <name>array2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>array2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>joinedArray</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><name><name>array1</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>array2</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><name><name>array1</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>array2</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>joinedArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element, unless the element itself is null,
     *  in which case the return type is Object[]&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, null)      = [null]
     * ArrayUtils.add(null, "a")       = ["a"]
     * ArrayUtils.add(["a"], null)     = ["a", null]
     * ArrayUtils.add(["a"], "b")      = ["a", "b"]
     * ArrayUtils.add(["a", "b"], "c") = ["a", "b", "c"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to "add" the element to, may be {@code null}
     * @param element  the object to add, may be {@code null}
     * @return A new array containing the existing elements plus the new element
     * The returned array type will be that of the input array (unless null),
     * in which case it will have the same type as the element.
     * If both are null, an IllegalArgumentException is thrown
     * @since 2.1
     * @throws IllegalArgumentException if both arguments are null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>array</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then><block>{
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>element</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name><name>element</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Arguments cannot both be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// type must be T</comment>
        <type><specifier>final</specifier>
        <name><name>T</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, true)          = [true]
     * ArrayUtils.add([true], false)       = [true, false]
     * ArrayUtils.add([true, false], true) = [true, false, true]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Boolean</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Byte</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, '0')       = ['0']
     * ArrayUtils.add(['1'], '0')      = ['1', '0']
     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Character</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Double</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Float</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Copies the given array and adds the given element at the end of the new array.&lt;/p&gt;
     *
     * &lt;p&gt;The new array contains the same elements of the input
     * array plus the given element in the last position. The component type of
     * the new array is the same as that of the input array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0)   = [0]
     * ArrayUtils.add([1], 0)    = [1, 0]
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to copy and add the element to, may be {@code null}
     * @param element  the object to add at the last index of the new array
     * @return A new array containing the existing elements plus the new element
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator><call><name>copyArrayGrow1</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>Short</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newArray</name><index>[<expr><name><name>newArray</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>element</name></expr>;</expr_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a copy of the given array of size 1 greater than the argument.
     * The last value of the array is left to the default value.
     *
     * @param array The array to copy, must not be {@code null}.
     * @param newArrayComponentType If {@code array} is {@code null}, create a
     * size 1 array of this type.
     * @return A new copy of the array of size 1 greater than the input.
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>Object</name></type> <name>copyArrayGrow1</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>newArrayComponentType</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>arrayLength</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>newArray</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>arrayLength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arrayLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>newArray</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>newArrayComponentType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0, null)      = [null]
     * ArrayUtils.add(null, 0, "a")       = ["a"]
     * ArrayUtils.add(["a"], 1, null)     = ["a", null]
     * ArrayUtils.add(["a"], 1, "b")      = ["a", "b"]
     * ArrayUtils.add(["a", "b"], 3, "c") = ["a", "b", "c"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     * @throws IllegalArgumentException if both array and element are null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clss</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>array</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>clss</name> <operator>=</operator> <call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>element</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>clss</name> <operator>=</operator> <call><name><name>element</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Array and element cannot both be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// the add method creates an array of type clss, which is type T</comment>
        <type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>newArray</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>clss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>newArray</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0, true)          = [true]
     * ArrayUtils.add([true], 0, false)       = [false, true]
     * ArrayUtils.add([false], 1, true)       = [false, true]
     * ArrayUtils.add([true, false], 1, true) = [true, true, false]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Boolean</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add(null, 0, 'a')            = ['a']
     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']
     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']
     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']
     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Character</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Character</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1], 0, 2)         = [2, 1]
     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]
     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Byte</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1], 0, 2)         = [2, 1]
     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Short</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1], 0, 2)         = [2, 1]
     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]
     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]
     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]
     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]
     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]
     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]
     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Float</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Inserts the specified element at the specified position in the array.
     * Shifts the element currently at that position (if any) and any subsequent
     * elements to the right (adds one to their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array plus the given element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, a new one element array is returned
     *  whose component type is the same as the element.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]
     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]
     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]
     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]
     * &lt;/pre&gt;
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @return A new array containing the existing elements and the new element
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt; array.length).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <call><name>add</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Double</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Underlying implementation of add(array, index, element) methods.
     * The last parameter is the class, which may not equal element.getClass
     * for primitives.
     *
     * @param array  the array to add the element to, may be {@code null}
     * @param index  the position of the new object
     * @param element  the object to add
     * @param clss the type of the element being added
     * @return A new array containing the existing elements and the new element
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>Object</name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>element</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clss</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Index: "</literal> <operator>+</operator> <name>index</name> <operator>+</operator> <literal type="string">", Length: 0"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>joinedArray</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>clss</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Array</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>joinedArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>joinedArray</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name>length</name> <operator>||</operator> <name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Index: "</literal> <operator>+</operator> <name>index</name> <operator>+</operator> <literal type="string">", Length: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>result</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>clss</name></expr></argument>, <argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Array</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>length</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove(["a"], 0)           = []
     * ArrayUtils.remove(["a", "b"], 0)      = ["b"]
     * ArrayUtils.remove(["a", "b"], 1)      = ["a"]
     * ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// remove() always creates an array of the same type as its input</comment>
    <specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, "a")            = null
     * ArrayUtils.removeElement([], "a")              = []
     * ArrayUtils.removeElement(["a"], "b")           = ["a"]
     * ArrayUtils.removeElement(["a", "b"], "a")      = ["b"]
     * ArrayUtils.removeElement(["a", "b", "a"], "a") = ["b", "a"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([true], 0)              = []
     * ArrayUtils.remove([true, false], 0)       = [false]
     * ArrayUtils.remove([true, false], 1)       = [true]
     * ArrayUtils.remove([true, true, false], 1) = [true, false]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, true)                = null
     * ArrayUtils.removeElement([], true)                  = []
     * ArrayUtils.removeElement([true], false)             = [true]
     * ArrayUtils.removeElement([true, false], false)      = [true]
     * ArrayUtils.removeElement([true, false, true], true) = [false, true]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1], 0)          = []
     * ArrayUtils.remove([1, 0], 0)       = [0]
     * ArrayUtils.remove([1, 0], 1)       = [1]
     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1)        = null
     * ArrayUtils.removeElement([], 1)          = []
     * ArrayUtils.removeElement([1], 0)         = [1]
     * ArrayUtils.removeElement([1, 0], 0)      = [1]
     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove(['a'], 0)           = []
     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']
     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']
     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 'a')            = null
     * ArrayUtils.removeElement([], 'a')              = []
     * ArrayUtils.removeElement(['a'], 'b')           = ['a']
     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']
     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1.1], 0)           = []
     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1.1)            = null
     * ArrayUtils.removeElement([], 1.1)              = []
     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1.1], 0)           = []
     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1.1)            = null
     * ArrayUtils.removeElement([], 1.1)              = []
     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1], 0)         = []
     * ArrayUtils.remove([2, 6], 0)      = [6]
     * ArrayUtils.remove([2, 6], 1)      = [2]
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1)      = null
     * ArrayUtils.removeElement([], 1)        = []
     * ArrayUtils.removeElement([1], 2)       = [1]
     * ArrayUtils.removeElement([1, 3], 1)    = [3]
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1], 0)         = []
     * ArrayUtils.remove([2, 6], 0)      = [6]
     * ArrayUtils.remove([2, 6], 1)      = [2]
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1)      = null
     * ArrayUtils.removeElement([], 1)        = []
     * ArrayUtils.removeElement([1], 2)       = [1]
     * ArrayUtils.removeElement([1, 3], 1)    = [3]
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.remove([1], 0)         = []
     * ArrayUtils.remove([2, 6], 0)      = [6]
     * ArrayUtils.remove([2, 6], 1)      = [2]
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <call><name>remove</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the first occurrence of the specified element from the
     * specified array. All subsequent elements are shifted to the left
     * (subtracts one from their indices). If the array doesn't contains
     * such an element, no elements are removed from the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the first occurrence of the specified element. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElement(null, 1)      = null
     * ArrayUtils.removeElement([], 1)        = []
     * ArrayUtils.removeElement([1], 2)       = [1]
     * ArrayUtils.removeElement([1, 3], 1)    = [3]
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param element  the element to be removed
     * @return A new array containing the existing elements except the first
     *         occurrence of the specified element.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>removeElement</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>element</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>INDEX_NOT_FOUND</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the element at the specified position from the specified array.
     * All subsequent elements are shifted to the left (subtracts one from
     * their indices).&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except the element on the specified position. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * @param array  the array to remove the element from, may not be {@code null}
     * @param index  the position of the element to be removed
     * @return A new array containing the existing elements except the element
     *         at the specified position.
     * @throws IndexOutOfBoundsException if the index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 2.1
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>Object</name></type> <name>remove</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>getLength</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name>length</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Index: "</literal> <operator>+</operator> <name>index</name> <operator>+</operator> <literal type="string">", Length: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>result</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll(["a", "b", "c"], 0, 2) = ["b"]
     * ArrayUtils.removeAll(["a", "b", "c"], 1, 2) = ["a"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// removeAll() always creates an array of the same type as its input</comment>
    <specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, "a", "b")            = null
     * ArrayUtils.removeElements([], "a", "b")              = []
     * ArrayUtils.removeElements(["a"], "b", "c")           = ["a"]
     * ArrayUtils.removeElements(["a", "b"], "a", "c")      = ["b"]
     * ArrayUtils.removeElements(["a", "b", "a"], "a")      = ["b", "a"]
     * ArrayUtils.removeElements(["a", "b", "a"], "a", "a") = ["b"]
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>T</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>T</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// removeAll() always creates an array of the same type as its input</comment>
        <type><specifier>final</specifier>
        <name><name>T</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>(</operator><name><name>T</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>byte</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Byte</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Byte</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>byte</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Byte</name></type> <name>boxed</name> <init>= <expr><call><name><name>Byte</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Byte</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Byte</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>byteValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>short</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Short</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Short</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>short</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Short</name></type> <name>boxed</name> <init>= <expr><call><name><name>Short</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Short</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Short</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>shortValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Integer</name></type> <name>boxed</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Integer</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Character</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Character</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>char</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Character</name></type> <name>boxed</name> <init>= <expr><call><name><name>Character</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Character</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Character</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>long</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>long</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Long</name></type> <name>boxed</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Long</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>longValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Float</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Float</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>float</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Float</name></type> <name>boxed</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Float</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Float</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>floatValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([1], 0)             = []
     * ArrayUtils.removeAll([2, 6], 0)          = [6]
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, 1, 2)      = null
     * ArrayUtils.removeElements([], 1, 2)        = []
     * ArrayUtils.removeElements([1], 2, 3)       = [1]
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>double</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Double</name></type> <name>boxed</name> <init>= <expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Double</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>doubleValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes the elements at the specified positions from the specified array.
     * All remaining elements are shifted to the left.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except those at the specified positions. The component
     * type of the returned array is always the same as that of the input
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;If the input array is {@code null}, an IndexOutOfBoundsException
     * will be thrown, because in that case no valid index can be specified.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeAll([true, false, true], 0, 2) = [false]
     * ArrayUtils.removeAll([true, false, true], 1, 2) = [true]
     * &lt;/pre&gt;
     *
     * @param array   the array to remove the element from, may not be {@code null}
     * @param indices the positions of the elements to be removed
     * @return A new array containing the existing elements except those
     *         at the specified positions.
     * @throws IndexOutOfBoundsException if any index is out of range
     * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><operator>(</operator><name>Object</name><operator>)</operator> <name>array</name></expr></argument>, <argument><expr><call><name>clone</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Removes occurrences of specified elements, in specified quantities,
     * from the specified array. All subsequent elements are shifted left.
     * For any element-to-be-removed specified in greater quantities than
     * contained in the original array, no change occurs beyond the
     * removal of the existing matching items.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns a new array with the same elements of the input
     * array except for the earliest-encountered occurrences of the specified
     * elements. The component type of the returned array is always the same
     * as that of the input array.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ArrayUtils.removeElements(null, true, false)               = null
     * ArrayUtils.removeElements([], true, false)                 = []
     * ArrayUtils.removeElements([true], false, false)            = [true]
     * ArrayUtils.removeElements([true, false], true, true)       = [false]
     * ArrayUtils.removeElements([true, false, true], true)       = [false, true]
     * ArrayUtils.removeElements([true, false, true], true, true) = [false]
     * &lt;/pre&gt;
     *
     * @param array  the array to remove the element from, may be {@code null}
     * @param values the elements to be removed
     * @return A new array containing the existing elements except the
     *         earliest-encountered occurrences of the specified elements.
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>removeElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isEmpty</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>clone</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// only two possible values here</comment>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>boxed</name> <init>= <expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>boxed</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>toRemove</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ct</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ct</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>found</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <call><name>removeAll</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Removes multiple array elements specified by index.
     * @param array source
     * @param indices to remove, WILL BE SORTED--so only clones of user-owned arrays!
     * @return new array of same type minus elements specified by unique values of {@code indices}
     * @since 3.0.1
     */</comment>
    <comment type="line">// package protected for access by unit tests</comment>
    <function><specifier>static</specifier> <type><name>Object</name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name><modifier>...</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>getLength</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// number of distinct indexes, i.e. number of entries that will be removed</comment>

        <if>if <condition>(<expr><call><name>isNotEmpty</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>indices</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>prevIndex</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name>length</name></expr>)</condition><then> <block>{
                    <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Index: "</literal> <operator>+</operator> <name>index</name> <operator>+</operator> <literal type="string">", Length: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>prevIndex</name></expr>)</condition><then> <block>{
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name>diff</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>prevIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>result</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <name>diff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <name>length</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt> <comment type="line">// index just after last copy</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>dest</name> <init>= <expr><name>length</name> <operator>-</operator> <name>diff</name></expr></init></decl>;</decl_stmt> <comment type="line">// number of entries so far not copied</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>indices</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>index</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{ <comment type="line">// same as (cp &gt; 0)</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cp</name> <init>= <expr><name>end</name> <operator>-</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>dest</name> <operator>-=</operator> <name>cp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// Afer this copy, we still have room for dest items.</comment>
                }</block></then></if>
                <expr_stmt><expr><name>end</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Removes multiple array elements specified by indices.
     *
     * @param array source
     * @param indices to remove
     * @return new array of same type minus elements specified by the set bits in {@code indices}
     * @since 3.2
     */</comment>
    <comment type="line">// package protected for access by unit tests</comment>
    <function><specifier>static</specifier> <type><name>Object</name></type> <name>removeAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>BitSet</name></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>srcLength</name> <init>= <expr><call><name><name>ArrayUtils</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// No need to check maxIndex here, because method only currently called from removeElements()</comment>
        <comment type="line">// which guarantee to generate on;y valid bit entries.</comment>
<comment type="line">//        final int maxIndex = indices.length();</comment>
<comment type="line">//        if (maxIndex &gt; srcLength) {</comment>
<comment type="line">//            throw new IndexOutOfBoundsException("Index: " + (maxIndex-1) + ", Length: " + srcLength);</comment>
<comment type="line">//        }</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>removals</name> <init>= <expr><call><name><name>indices</name><operator>.</operator><name>cardinality</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// true bits are items to remove</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>result</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><call><name><name>array</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>srcLength</name> <operator>-</operator> <name>removals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>srcIndex</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>destIndex</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name><name>indices</name><operator>.</operator><name>nextSetBit</name></name><argument_list>(<argument><expr><name>srcIndex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block>{
            <expr_stmt><expr><name>count</name> <operator>=</operator> <name>set</name> <operator>-</operator> <name>srcIndex</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>srcIndex</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>destIndex</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>destIndex</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>srcIndex</name> <operator>=</operator> <call><name><name>indices</name><operator>.</operator><name>nextClearBit</name></name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <name>srcLength</name> <operator>-</operator> <name>srcIndex</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>srcIndex</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>destIndex</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Operations on {@code Object}.&lt;/p&gt;
 *
 * &lt;p&gt;This class tries to handle {@code null} input gracefully.
 * An exception will generally not be thrown for a {@code null} input.
 * Each method documents its behaviour in more detail.&lt;/p&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @since 1.0
 * @version $Id$
 */</comment>
<comment type="line">//@Immutable</comment>
<class>class <name>ObjectUtils</name> <block>{

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Singleton used as a {@code null} placeholder where
     * {@code null} has another meaning.&lt;/p&gt;
     *
     * &lt;p&gt;For example, in a {@code HashMap} the
     * {@link java.util.HashMap#get(java.lang.Object)} method returns
     * {@code null} if the {@code Map} contains {@code null} or if there
     * is no matching key. The {@code Null} placeholder can be used to
     * distinguish between these two cases.&lt;/p&gt;
     *
     * &lt;p&gt;Another example is {@code Hashtable}, where {@code null}
     * cannot be stored.&lt;/p&gt;
     *
     * &lt;p&gt;This instance is Serializable.&lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Null</name></type> <name>NULL</name> <init>= <expr><operator>new</operator> <call><name>Null</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;{@code ObjectUtils} instances should NOT be constructed in
     * standard programming. Instead, the static methods on the class should
     * be used, such as {@code ObjectUtils.defaultIfNull("a","b");}.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
     * instance to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ObjectUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">// Defaulting</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns a default value if the object passed is {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.defaultIfNull(null, null)      = null
     * ObjectUtils.defaultIfNull(null, "")        = ""
     * ObjectUtils.defaultIfNull(null, "zz")      = "zz"
     * ObjectUtils.defaultIfNull("abc", *)        = "abc"
     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the object
     * @param object  the {@code Object} to test, may be {@code null}
     * @param defaultValue  the default value to return, may be {@code null}
     * @return {@code object} if it is not {@code null}, defaultValue otherwise
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>defaultIfNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>object</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>object</name></expr> </then><else>: <expr><name>defaultValue</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the first value in the array which is not {@code null}.
     * If all the values are {@code null} or the array is {@code null}
     * or empty then {@code null} is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.firstNonNull(null, null)      = null
     * ObjectUtils.firstNonNull(null, "")        = ""
     * ObjectUtils.firstNonNull(null, null, "")  = ""
     * ObjectUtils.firstNonNull(null, "zz")      = "zz"
     * ObjectUtils.firstNonNull("abc", *)        = "abc"
     * ObjectUtils.firstNonNull(null, "xyz", *)  = "xyz"
     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE
     * ObjectUtils.firstNonNull()                = null
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the component type of the array
     * @param values  the values to test, may be {@code null} or empty
     * @return the first value from {@code values} which is not {@code null},
     *  or {@code null} if there are no non-null values
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>firstNonNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>values</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>T</name></type> <name>val</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><name>val</name></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="line">// Null-safe equals/hashCode</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two objects for equality, where either one or both
     * objects may be {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.equals(null, null)                  = true
     * ObjectUtils.equals(null, "")                    = false
     * ObjectUtils.equals("", null)                    = false
     * ObjectUtils.equals("", "")                      = true
     * ObjectUtils.equals(Boolean.TRUE, null)          = false
     * ObjectUtils.equals(Boolean.TRUE, "true")        = false
     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true
     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false
     * &lt;/pre&gt;
     *
     * @param object1  the first object, may be {@code null}
     * @param object2  the second object, may be {@code null}
     * @return {@code true} if the values of both objects are the same
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object2</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object1</name> <operator>==</operator> <name>object2</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>object1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>object2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>object1</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>object2</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two objects for inequality, where either one or both
     * objects may be {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.notEqual(null, null)                  = false
     * ObjectUtils.notEqual(null, "")                    = true
     * ObjectUtils.notEqual("", null)                    = true
     * ObjectUtils.notEqual("", "")                      = false
     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true
     * ObjectUtils.notEqual(Boolean.TRUE, "true")        = true
     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false
     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true
     * &lt;/pre&gt;
     *
     * @param object1  the first object, may be {@code null}
     * @param object2  the second object, may be {@code null}
     * @return {@code false} if the values of both objects are the same
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>notEqual</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object2</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ObjectUtils</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>object1</name></expr></argument>, <argument><expr><name>object2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the hash code of an object returning zero when the
     * object is {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.hashCode(null)   = 0
     * ObjectUtils.hashCode(obj)    = obj.hashCode()
     * &lt;/pre&gt;
     *
     * @param obj  the object to obtain the hash code of, may be {@code null}
     * @return the hash code of the object, or zero if null
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// hashCode(Object) retained for performance, as hash code is often critical</comment>
        <return>return <expr><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the hash code for multiple objects.&lt;/p&gt;
     *
     * &lt;p&gt;This allows a hash code to be rapidly calculated for a number of objects.
     * The hash code for a single object is the &lt;em&gt;not&lt;/em&gt; same as {@link #hashCode(Object)}.
     * The hash code for multiple objects is the same as that calculated by an
     * {@code ArrayList} containing the specified objects.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.hashCodeMulti()                 = 1
     * ObjectUtils.hashCodeMulti((Object[]) null)  = 1
     * ObjectUtils.hashCodeMulti(a)                = 31 + a.hashCode()
     * ObjectUtils.hashCodeMulti(a,b)              = (31 + a.hashCode()) * 31 + b.hashCode()
     * ObjectUtils.hashCodeMulti(a,b,c)            = ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode()
     * &lt;/pre&gt;
     *
     * @param objects  the objects to obtain the hash code of, may be {@code null}
     * @return the hash code of the objects, or zero if null
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>hashCodeMulti</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>objects</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>objects</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name> <range>: <expr><name>objects</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>*</operator> <literal type="number">31</literal> <operator>+</operator> <call><name><name>ObjectUtils</name><operator>.</operator><name>hashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>hash</name></expr>;</return>
    }</block></function>

    <comment type="line">// Identity ToString</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the toString that would be produced by {@code Object}
     * if a class did not override toString itself. {@code null}
     * will return {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.identityToString(null)         = null
     * ObjectUtils.identityToString("")           = "java.lang.String@1e23"
     * ObjectUtils.identityToString(Boolean.TRUE) = "java.lang.Boolean@7fa"
     * &lt;/pre&gt;
     *
     * @param object  the object to create a toString for, may be
     *  {@code null}
     * @return the default toString text, or {@code null} if
     *  {@code null} passed in
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>identityToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>identityToString</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends the toString that would be produced by {@code Object}
     * if a class did not override toString itself. {@code null}
     * will throw a NullPointerException for either of the two parameters. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.identityToString(appendable, "")            = appendable.append("java.lang.String@1e23"
     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append("java.lang.Boolean@7fa"
     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append("java.lang.Boolean@7fa")
     * &lt;/pre&gt;
     *
     * @param appendable  the appendable to append to
     * @param object  the object to create a toString for
     * @throws IOException
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>identityToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Appendable</name></type> <name>appendable</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><literal type="string">"Cannot get the toString of a null identity"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>appendable</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends the toString that would be produced by {@code Object}
     * if a class did not override toString itself. {@code null}
     * will throw a NullPointerException for either of the two parameters. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.identityToString(builder, "")            = builder.append("java.lang.String@1e23"
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa"
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa")
     * &lt;/pre&gt;
     *
     * @param builder  the builder to append to
     * @param object  the object to create a toString for
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>identityToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><literal type="string">"Cannot get the toString of a null identity"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends the toString that would be produced by {@code Object}
     * if a class did not override toString itself. {@code null}
     * will throw a NullPointerException for either of the two parameters. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.identityToString(buf, "")            = buf.append("java.lang.String@1e23"
     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append("java.lang.Boolean@7fa"
     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append("java.lang.Boolean@7fa")
     * &lt;/pre&gt;
     *
     * @param buffer  the buffer to append to
     * @param object  the object to create a toString for
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>identityToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><literal type="string">"Cannot get the toString of a null identity"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends the toString that would be produced by {@code Object}
     * if a class did not override toString itself. {@code null}
     * will throw a NullPointerException for either of the two parameters. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.identityToString(builder, "")            = builder.append("java.lang.String@1e23"
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa"
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa")
     * &lt;/pre&gt;
     *
     * @param builder  the builder to append to
     * @param object  the object to create a toString for
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>identityToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><literal type="string">"Cannot get the toString of a null identity"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ToString</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the {@code toString} of an {@code Object} returning
     * an empty string ("") if {@code null} input.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.toString(null)         = ""
     * ObjectUtils.toString("")           = ""
     * ObjectUtils.toString("bat")        = "bat"
     * ObjectUtils.toString(Boolean.TRUE) = "true"
     * &lt;/pre&gt;
     *
     * @see StringUtils#defaultString(String)
     * @see String#valueOf(Object)
     * @param obj  the Object to {@code toString}, may be null
     * @return the passed in Object's toString, or {@code ""} if {@code null} input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the {@code toString} of an {@code Object} returning
     * a specified text if {@code null} input.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * ObjectUtils.toString(null, null)           = null
     * ObjectUtils.toString(null, "null")         = "null"
     * ObjectUtils.toString("", "null")           = ""
     * ObjectUtils.toString("bat", "null")        = "bat"
     * ObjectUtils.toString(Boolean.TRUE, "null") = "true"
     * &lt;/pre&gt;
     *
     * @see StringUtils#defaultString(String,String)
     * @see String#valueOf(Object)
     * @param obj  the Object to {@code toString}, may be null
     * @param nullStr  the String to return if {@code null} input, may be null
     * @return the passed in Object's toString, or {@code nullStr} if {@code null} input
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>nullStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>nullStr</name></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">// Comparable</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null safe comparison of Comparables.&lt;/p&gt;
     *
     * @param &lt;T&gt; type of the values processed by this method
     * @param values the set of comparable values, may be null
     * @return
     *  &lt;ul&gt;
     *   &lt;li&gt;If any objects are non-null and unequal, the lesser object.
     *   &lt;li&gt;If all objects are non-null and equal, the first.
     *   &lt;li&gt;If any of the comparables are null, the lesser of the non-null objects.
     *   &lt;li&gt;If all the comparables are null, null is returned.
     *  &lt;/ul&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>min</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>T</name></type> <name>result</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>values</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>T</name></type> <name>value</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null safe comparison of Comparables.&lt;/p&gt;
     *
     * @param &lt;T&gt; type of the values processed by this method
     * @param values the set of comparable values, may be null
     * @return
     *  &lt;ul&gt;
     *   &lt;li&gt;If any objects are non-null and unequal, the greater object.
     *   &lt;li&gt;If all objects are non-null and equal, the first.
     *   &lt;li&gt;If any of the comparables are null, the greater of the non-null objects.
     *   &lt;li&gt;If all the comparables are null, null is returned.
     *  &lt;/ul&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>max</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>T</name></type> <name>result</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>values</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>T</name></type> <name>value</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null safe comparison of Comparables.
     * {@code null} is assumed to be less than a non-{@code null} value.&lt;/p&gt;
     *
     * @param &lt;T&gt; type of the values processed by this method
     * @param c1  the first comparable, may be null
     * @param c2  the second comparable, may be null
     * @return a negative value if c1 &lt; c2, zero if c1 = c2
     *  and a positive value if c1 &gt; c2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>c2</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>compare</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null safe comparison of Comparables.&lt;/p&gt;
     *
     * @param &lt;T&gt; type of the values processed by this method
     * @param c1  the first comparable, may be null
     * @param c2  the second comparable, may be null
     * @param nullGreater if true {@code null} is considered greater
     *  than a non-{@code null} value or if false {@code null} is
     *  considered less than a Non-{@code null} value
     * @return a negative value if c1 &lt; c2, zero if c1 = c2
     *  and a positive value if c1 &gt; c2
     * @see java.util.Comparator#compare(Object, Object)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>c2</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>nullGreater</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>c1</name> <operator>==</operator> <name>c2</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>c1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><ternary><condition><expr><name>nullGreater</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><ternary><condition><expr><name>nullGreater</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        }</block></then></if></elseif></if>
        <return>return <expr><call><name><name>c1</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Find the "best guess" middle value among comparables. If there is an even
     * number of total values, the lower of the two middle values will be returned.
     * @param &lt;T&gt; type of values processed by this method
     * @param items to compare
     * @return T at middle position
     * @throws NullPointerException if items is {@code null}
     * @throws IllegalArgumentException if items is empty or contains {@code null} values
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>median</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>items</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notEmpty</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>noNullElements</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>TreeSet</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>sort</name> <init>= <expr><operator>new</operator> <call><name><name>TreeSet</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>sort</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">//we know all items added were T instances</comment>
        <type><specifier>final</specifier>
        <name>T</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>T</name><operator>)</operator> <call><name><name>sort</name><operator>.</operator><name>toArray</name></name><argument_list>()</argument_list></call><index>[<expr><operator>(</operator><call><name><name>sort</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>]</index></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Find the "best guess" middle value among comparables. If there is an even
     * number of total values, the lower of the two middle values will be returned.
     * @param &lt;T&gt; type of values processed by this method
     * @param comparator to use for comparisons
     * @param items to compare
     * @return T at middle position
     * @throws NullPointerException if items or comparator is {@code null}
     * @throws IllegalArgumentException if items is empty or contains {@code null} values
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>median</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>items</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notEmpty</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><literal type="string">"null/empty items"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>noNullElements</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>comparator</name></expr></argument>, <argument><expr><literal type="string">"null comparator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>TreeSet</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>sort</name> <init>= <expr><operator>new</operator> <call><name><name>TreeSet</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>sort</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">//we know all items added were T instances</comment>
        <type><specifier>final</specifier>
        <name>T</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>T</name><operator>)</operator> <call><name><name>sort</name><operator>.</operator><name>toArray</name></name><argument_list>()</argument_list></call><index>[<expr><operator>(</operator><call><name><name>sort</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>]</index></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="line">// Mode</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Find the most frequently occurring item.
     *
     * @param &lt;T&gt; type of values processed by this method
     * @param items to check
     * @return most populous T, {@code null} if non-unique or no items supplied
     * @since 3.0.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>mode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>items</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isNotEmpty</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>items</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>T</name></type> <name>t</name> <range>: <expr><name>items</name></expr></range></decl></init>)</control> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>count</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>occurrences</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MutableInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>increment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
            <decl_stmt><decl><type><name>T</name></type> <name>result</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>MutableInt</name></argument>&gt;</argument_list></name></name></type> <name>e</name> <range>: <expr><call><name><name>occurrences</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cmp</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                }</block></then> <elseif>else <if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>max</name> <operator>=</operator> <name>cmp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif></if>
            }</block></for>
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="line">// cloning</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clone an object.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object
     * @param obj  the object to clone, null returns null
     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}
     * @throws CloneFailedException if the object is cloneable and the clone operation fails
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>clone</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>obj</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>instanceof</operator> <name>Cloneable</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>result</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>componentType</name> <init>= <expr><call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><call><name><name>componentType</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>obj</name><operator>)</operator><operator>.</operator><call><name>clone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>Array</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <while>while <condition>(<expr><name>length</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                        <expr_stmt><expr><call><name><name>Array</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><call><name><name>Array</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></while>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <try>try <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>Method</name></type> <name>clone</name> <init>= <expr><call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMethod</name><argument_list>(<argument><expr><literal type="string">"clone"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>clone</name><operator>.</operator><name>invoke</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NoSuchMethodException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                    <throw>throw <expr><operator>new</operator> <call><name>Exception</name><argument_list>(<argument><expr><literal type="string">"Cloneable type "</literal>
                            <operator>+</operator> <call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call>
                            <operator>+</operator> <literal type="string">" has no clone method"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalAccessException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                    <throw>throw <expr><operator>new</operator> <call><name>Exception</name><argument_list>(<argument><expr><literal type="string">"Cannot clone Cloneable type "</literal>
                            <operator>+</operator> <call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>InvocationTargetException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                    <throw>throw <expr><operator>new</operator> <call><name>Exception</name><argument_list>(<argument><expr><literal type="string">"Exception cloning Cloneable type "</literal>
                            <operator>+</operator> <call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>getCause</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></else></if>
            <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// OK because input is of type T</comment>
            <type><specifier>final</specifier> <name>T</name></type> <name>checked</name> <init>= <expr><operator>(</operator><name>T</name><operator>)</operator> <name>result</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>checked</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Clone an object if possible.&lt;/p&gt;
     *
     * &lt;p&gt;This method is similar to {@link #clone(Object)}, but will return the provided
     * instance as the return value instead of {@code null} if the instance
     * is not cloneable. This is more convenient if the caller uses different
     * implementations (e.g. of a service) and some of the implementations do not allow concurrent
     * processing or have state. In such cases the implementation can simply provide a proper
     * clone implementation and the caller's code does not have to change.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object
     * @param obj  the object to clone, null returns null
     * @return the clone if the object implements {@link Cloneable} otherwise the object itself
     * @throws CloneFailedException if the object is cloneable and the clone operation fails
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>cloneIfPossible</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>obj</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>T</name></type> <name>clone</name> <init>= <expr><call><name>clone</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>clone</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>obj</name></expr> </then><else>: <expr><name>clone</name></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">// Null</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Class used as a null placeholder where {@code null}
     * has another meaning.&lt;/p&gt;
     *
     * &lt;p&gt;For example, in a {@code HashMap} the
     * {@link java.util.HashMap#get(java.lang.Object)} method returns
     * {@code null} if the {@code Map} contains {@code null} or if there is
     * no matching key. The {@code Null} placeholder can be used to distinguish
     * between these two cases.&lt;/p&gt;
     *
     * &lt;p&gt;Another example is {@code Hashtable}, where {@code null}
     * cannot be stored.&lt;/p&gt;
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Null</name> <super><implements>implements <name>Serializable</name></implements></super> <block>{
        <comment type="block" format="javadoc">/**
         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0
         *
         * @see java.io.Serializable
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">7092611880189329093L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Restricted constructor - singleton.
         */</comment>
        <constructor><name>Null</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure singleton.&lt;/p&gt;
         *
         * @return the singleton value
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ObjectUtils</name><operator>.</operator><name>NULL</name></name></expr>;</return>
        }</block></function>
    }</block></class>


    <comment type="line">// Constants (LANG-816):</comment>
    <comment type="block">/*
        These methods ensure constants are not inlined by javac.
        For example, typically a developer might declare a constant like so:

            public final static int MAGIC_NUMBER = 5;

        Should a different jar file refer to this, and the MAGIC_NUMBER
        is changed a later date (e.g., MAGIC_NUMBER = 6), the different jar
        file will need to recompile itself.  This is because javac
        typically inlines the primitive or String constant directly into
        the bytecode, and removes the reference to the MAGIC_NUMBER field.

        To help the other jar (so that it does not need to recompile
        when constants are changed) the original developer can declare
        their constant using one of the CONST() utility methods, instead:

            public final static int MAGIC_NUMBER = CONST(5);
     */</comment>


    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static boolean MAGIC_FLAG = ObjectUtils.CONST(true);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the boolean value to return
     * @return the boolean v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST((byte) 127);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the byte value to return
     * @return the byte v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the byte literal (as an int) value to return
     * @throws IllegalArgumentException if the value passed to v
     *         is larger than a byte, that is, smaller than -128 or
     *         larger than 127.
     * @return the byte v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>byte</name></type> <name>CONST_BYTE</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IllegalArgumentException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name><name>v</name> <argument_list type="generic">&lt; <argument><name><name>Byte</name><operator>.</operator><name>MIN_VALUE</name></name> <operator>||</operator> <name>v</name></argument> &gt;</argument_list></name> <name><name>Byte</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Supplied value must be a valid byte literal between -128 and 127: ["</literal> <operator>+</operator> <name>v</name> <operator>+</operator> <literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><operator>(</operator><name>byte</name><operator>)</operator> <name>v</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static char MAGIC_CHAR = ObjectUtils.CONST('a');
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the char value to return
     * @return the char v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>char</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static short MAGIC_SHORT = ObjectUtils.CONST((short) 123);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the short value to return
     * @return the short v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the short literal (as an int) value to return
     * @throws IllegalArgumentException if the value passed to v
     *         is larger than a short, that is, smaller than -32768 or
     *         larger than 32767.
     * @return the byte v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>short</name></type> <name>CONST_SHORT</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IllegalArgumentException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name><name>v</name> <argument_list type="generic">&lt; <argument><name><name>Short</name><operator>.</operator><name>MIN_VALUE</name></name> <operator>||</operator> <name>v</name></argument> &gt;</argument_list></name> <name><name>Short</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Supplied value must be a valid byte literal between -32768 and 32767: ["</literal> <operator>+</operator> <name>v</name> <operator>+</operator> <literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><operator>(</operator><name>short</name><operator>)</operator> <name>v</name></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static int MAGIC_INT = ObjectUtils.CONST(123);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the int value to return
     * @return the int v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static long MAGIC_LONG = ObjectUtils.CONST(123L);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the long value to return
     * @return the long v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>long</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the float value to return
     * @return the float v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param v the double value to return
     * @return the double v, unchanged
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>double</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the provided value unchanged.
     * This can prevent javac from inlining a constant
     * field, e.g.,
     *
     * &lt;pre&gt;
     *     public final static String MAGIC_STRING = ObjectUtils.CONST("abc");
     * &lt;/pre&gt;
     *
     * This way any jars that refer to this field do not
     * have to recompile themselves if the field's value
     * changes at some future date.
     *
     * @param &lt;T&gt; the Object type
     * @param v the genericized Object value to return (typically a String).
     * @return the genericized Object v, unchanged (typically a String).
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>CONST</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>v</name></expr>;</return> }</block></function>

}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Operations on char primitives and Character objects.&lt;/p&gt;
 *
 * &lt;p&gt;This class tries to handle {@code null} input gracefully.
 * An exception will not be thrown for a {@code null} input.
 * Each method documents its behaviour in more detail.&lt;/p&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @since 2.1
 * @version $Id$
 */</comment>
<class>class <name>CharUtils</name> <block>{

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>CHAR_STRING_ARRAY</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * {@code \u000a} linefeed LF ('\n').
     *
     * @see &lt;a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"&gt;JLF: Escape Sequences
     *      for Character and String Literals&lt;/a&gt;
     * @since 2.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>char</name></type> <name>LF</name> <init>= <expr><literal type="char">'\n'</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * {@code \u000d} carriage return CR ('\r').
     *
     * @see &lt;a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"&gt;JLF: Escape Sequences
     *      for Character and String Literals&lt;/a&gt;
     * @since 2.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>char</name></type> <name>CR</name> <init>= <expr><literal type="char">'\r'</literal></expr></init></decl>;</decl_stmt>


    <static>static <block>{
        <for>for <control>(<init><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>CHAR_STRING_ARRAY</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>CHAR_STRING_ARRAY</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></static>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;{@code CharUtils} instances should NOT be constructed in standard programming.
     * Instead, the class should be used as {@code CharUtils.toString('c');}.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance
     * to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>CharUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to a Character.&lt;/p&gt;
     *
     * &lt;p&gt;For ASCII 7 bit characters, this uses a cache that will return the
     * same Character object each time.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toCharacterObject(' ')  = ' '
     *   CharUtils.toCharacterObject('A')  = 'A'
     * &lt;/pre&gt;
     *
     * @deprecated Java 5 introduced {@link Character#valueOf(char)} which caches chars 0 through 127.
     * @param ch  the character to convert
     * @return a Character of the specified character
     */</comment>
    <function><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> <type><name>Character</name></type> <name>toCharacterObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>Character</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the String to a Character using the first character, returning
     * null for empty Strings.&lt;/p&gt;
     *
     * &lt;p&gt;For ASCII 7 bit characters, this uses a cache that will return the
     * same Character object each time.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toCharacterObject(null) = null
     *   CharUtils.toCharacterObject("")   = null
     *   CharUtils.toCharacterObject("A")  = 'A'
     *   CharUtils.toCharacterObject("BA") = 'B'
     * &lt;/pre&gt;
     *
     * @param str  the character to convert
     * @return the Character value of the first letter of the String
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Character</name></type> <name>toCharacterObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>Character</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the Character to a char throwing an exception for {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toChar(' ')  = ' '
     *   CharUtils.toChar('A')  = 'A'
     *   CharUtils.toChar(null) throws IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @return the char value of the Character
     * @throws IllegalArgumentException if the Character is null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>char</name></type> <name>toChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The Character must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the Character to a char handling {@code null}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toChar(null, 'X') = 'X'
     *   CharUtils.toChar(' ', 'X')  = ' '
     *   CharUtils.toChar('A', 'X')  = 'A'
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @param defaultValue  the value to use if the  Character is null
     * @return the char value of the Character or the default if null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>char</name></type> <name>toChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the String to a char using the first character, throwing
     * an exception on empty Strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toChar("A")  = 'A'
     *   CharUtils.toChar("BA") = 'B'
     *   CharUtils.toChar(null) throws IllegalArgumentException
     *   CharUtils.toChar("")   throws IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param str  the character to convert
     * @return the char value of the first letter of the String
     * @throws IllegalArgumentException if the String is empty
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>char</name></type> <name>toChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The String must not be empty"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the String to a char using the first character, defaulting
     * the value on empty Strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toChar(null, 'X') = 'X'
     *   CharUtils.toChar("", 'X')   = 'X'
     *   CharUtils.toChar("A", 'X')  = 'A'
     *   CharUtils.toChar("BA", 'X') = 'B'
     * &lt;/pre&gt;
     *
     * @param str  the character to convert
     * @param defaultValue  the value to use if the  Character is null
     * @return the char value of the first letter of the String or the default if null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>char</name></type> <name>toChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to the Integer it represents, throwing an
     * exception if the character is not numeric.&lt;/p&gt;
     *
     * &lt;p&gt;This method coverts the char '1' to the int 1 and so on.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toIntValue('3')  = 3
     *   CharUtils.toIntValue('A')  throws IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @return the int value of the character
     * @throws IllegalArgumentException if the character is not ASCII numeric
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toIntValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isAsciiNumeric</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The character "</literal> <operator>+</operator> <name>ch</name> <operator>+</operator> <literal type="string">" is not in the range '0' - '9'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>ch</name> <operator>-</operator> <literal type="number">48</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to the Integer it represents, throwing an
     * exception if the character is not numeric.&lt;/p&gt;
     *
     * &lt;p&gt;This method coverts the char '1' to the int 1 and so on.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toIntValue('3', -1)  = 3
     *   CharUtils.toIntValue('A', -1)  = -1
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @param defaultValue  the default value to use if the character is not numeric
     * @return the int value of the character
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toIntValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isAsciiNumeric</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>ch</name> <operator>-</operator> <literal type="number">48</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to the Integer it represents, throwing an
     * exception if the character is not numeric.&lt;/p&gt;
     *
     * &lt;p&gt;This method coverts the char '1' to the int 1 and so on.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toIntValue('3')  = 3
     *   CharUtils.toIntValue(null) throws IllegalArgumentException
     *   CharUtils.toIntValue('A')  throws IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert, not null
     * @return the int value of the character
     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toIntValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The character must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>toIntValue</name><argument_list>(<argument><expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to the Integer it represents, throwing an
     * exception if the character is not numeric.&lt;/p&gt;
     *
     * &lt;p&gt;This method coverts the char '1' to the int 1 and so on.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toIntValue(null, -1) = -1
     *   CharUtils.toIntValue('3', -1)  = 3
     *   CharUtils.toIntValue('A', -1)  = -1
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @param defaultValue  the default value to use if the character is not numeric
     * @return the int value of the character
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>toIntValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultValue</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>toIntValue</name><argument_list>(<argument><expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>defaultValue</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to a String that contains the one character.&lt;/p&gt;
     *
     * &lt;p&gt;For ASCII 7 bit characters, this uses a cache that will return the
     * same String object each time.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toString(' ')  = " "
     *   CharUtils.toString('A')  = "A"
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @return a String containing the one specified character
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>CHAR_STRING_ARRAY</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><operator>new</operator> <name><name>char</name><index>[]</index></name> <block>{<expr><name>ch</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the character to a String that contains the one character.&lt;/p&gt;
     *
     * &lt;p&gt;For ASCII 7 bit characters, this uses a cache that will return the
     * same String object each time.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code null} is passed in, {@code null} will be returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.toString(null) = null
     *   CharUtils.toString(' ')  = " "
     *   CharUtils.toString('A')  = "A"
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @return a String containing the one specified character
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the string to the Unicode format '\u0020'.&lt;/p&gt;
     *
     * &lt;p&gt;This format is the Java source code format.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.unicodeEscaped(' ') = "\u0020"
     *   CharUtils.unicodeEscaped('A') = "\u0041"
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert
     * @return the escaped Unicode string
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>unicodeEscaped</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0x10</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">"\\u000"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0x100</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">"\\u00"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0x1000</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">"\\u0"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif></if>
        <return>return <expr><literal type="string">"\\u"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the string to the Unicode format '\u0020'.&lt;/p&gt;
     *
     * &lt;p&gt;This format is the Java source code format.&lt;/p&gt;
     *
     * &lt;p&gt;If {@code null} is passed in, {@code null} will be returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.unicodeEscaped(null) = null
     *   CharUtils.unicodeEscaped(' ')  = "\u0020"
     *   CharUtils.unicodeEscaped('A')  = "\u0041"
     * &lt;/pre&gt;
     *
     * @param ch  the character to convert, may be null
     * @return the escaped Unicode string, null if null input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>unicodeEscaped</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Character</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>unicodeEscaped</name><argument_list>(<argument><expr><call><name><name>ch</name><operator>.</operator><name>charValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAscii('a')  = true
     *   CharUtils.isAscii('A')  = true
     *   CharUtils.isAscii('3')  = true
     *   CharUtils.isAscii('-')  = true
     *   CharUtils.isAscii('\n') = true
     *   CharUtils.isAscii('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if less than 128
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAscii</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit printable.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiPrintable('a')  = true
     *   CharUtils.isAsciiPrintable('A')  = true
     *   CharUtils.isAsciiPrintable('3')  = true
     *   CharUtils.isAsciiPrintable('-')  = true
     *   CharUtils.isAsciiPrintable('\n') = false
     *   CharUtils.isAsciiPrintable('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 32 and 126 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiPrintable</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;</operator> <literal type="number">127</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit control.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiControl('a')  = false
     *   CharUtils.isAsciiControl('A')  = false
     *   CharUtils.isAsciiControl('3')  = false
     *   CharUtils.isAsciiControl('-')  = false
     *   CharUtils.isAsciiControl('\n') = true
     *   CharUtils.isAsciiControl('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if less than 32 or equals 127
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiControl</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&lt;</operator> <literal type="number">32</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="number">127</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit alphabetic.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiAlpha('a')  = true
     *   CharUtils.isAsciiAlpha('A')  = true
     *   CharUtils.isAsciiAlpha('3')  = false
     *   CharUtils.isAsciiAlpha('-')  = false
     *   CharUtils.isAsciiAlpha('\n') = false
     *   CharUtils.isAsciiAlpha('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 65 and 90 or 97 and 122 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiAlpha</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit alphabetic upper case.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiAlphaUpper('a')  = false
     *   CharUtils.isAsciiAlphaUpper('A')  = true
     *   CharUtils.isAsciiAlphaUpper('3')  = false
     *   CharUtils.isAsciiAlphaUpper('-')  = false
     *   CharUtils.isAsciiAlphaUpper('\n') = false
     *   CharUtils.isAsciiAlphaUpper('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 65 and 90 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiAlphaUpper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit alphabetic lower case.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiAlphaLower('a')  = true
     *   CharUtils.isAsciiAlphaLower('A')  = false
     *   CharUtils.isAsciiAlphaLower('3')  = false
     *   CharUtils.isAsciiAlphaLower('-')  = false
     *   CharUtils.isAsciiAlphaLower('\n') = false
     *   CharUtils.isAsciiAlphaLower('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 97 and 122 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiAlphaLower</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'z'</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit numeric.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiNumeric('a')  = false
     *   CharUtils.isAsciiNumeric('A')  = false
     *   CharUtils.isAsciiNumeric('3')  = true
     *   CharUtils.isAsciiNumeric('-')  = false
     *   CharUtils.isAsciiNumeric('\n') = false
     *   CharUtils.isAsciiNumeric('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 48 and 57 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiNumeric</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>ch</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks whether the character is ASCII 7 bit numeric.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   CharUtils.isAsciiAlphanumeric('a')  = true
     *   CharUtils.isAsciiAlphanumeric('A')  = true
     *   CharUtils.isAsciiAlphanumeric('3')  = true
     *   CharUtils.isAsciiAlphanumeric('-')  = false
     *   CharUtils.isAsciiAlphanumeric('\n') = false
     *   CharUtils.isAsciiAlphanumeric('&amp;copy;') = false
     * &lt;/pre&gt;
     *
     * @param ch  the character to check
     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAsciiAlphanumeric</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>;</return>
    }</block></function>

}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Assists in implementing {@link Object#toString()} methods.&lt;/p&gt;
 *
 * &lt;p&gt;This class enables a good and consistent &lt;code&gt;toString()&lt;/code&gt; to be built for any
 * class or object. This class aims to simplify the process by:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;allowing field names&lt;/li&gt;
 *  &lt;li&gt;handling all types consistently&lt;/li&gt;
 *  &lt;li&gt;handling nulls consistently&lt;/li&gt;
 *  &lt;li&gt;outputting arrays and multi-dimensional arrays&lt;/li&gt;
 *  &lt;li&gt;enabling the detail level to be controlled for Objects and Collections&lt;/li&gt;
 *  &lt;li&gt;handling class hierarchies&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;To use this class write code as follows:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class Person {
 *   String name;
 *   int age;
 *   boolean smoker;
 *
 *   ...
 *
 *   public String toString() {
 *     return new ToStringBuilder(this).
 *       append("name", name).
 *       append("age", age).
 *       append("smoker", smoker).
 *       toString();
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;This will produce a toString of the format:
 * &lt;code&gt;Person@7f54[name=Stephen,age=29,smoker=false]&lt;/code&gt;&lt;/p&gt;
 *
 * &lt;p&gt;To add the superclass &lt;code&gt;toString&lt;/code&gt;, use {@link #appendSuper}.
 * To append the &lt;code&gt;toString&lt;/code&gt; from an object that is delegated
 * to (or any other object), use {@link #appendToString}.&lt;/p&gt;
 *
 * &lt;p&gt;Alternatively, there is a method that uses reflection to determine
 * the fields to test. Because these fields are usually private, the method,
 * &lt;code&gt;reflectionToString&lt;/code&gt;, uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to
 * change the visibility of the fields. This will fail under a security manager,
 * unless the appropriate permissions are set up correctly. It is also
 * slower than testing explicitly.&lt;/p&gt;
 *
 * &lt;p&gt;A typical invocation for this method would look like:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * public String toString() {
 *   return ToStringBuilder.reflectionToString(this);
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;You can also use the builder to debug 3rd party objects:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * System.out.println("An object: " + ToStringBuilder.reflectionToString(anObject));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The exact format of the &lt;code&gt;toString&lt;/code&gt; is determined by
 * the {@link ToStringStyle} passed into the constructor.&lt;/p&gt;
 *
 * @since 1.0
 * @version $Id$
 */</comment>
<class>class <name>ToStringBuilder</name> <super><implements>implements <name><name>Builder</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></implements></super> <block>{

    <comment type="block" format="javadoc">/**
     * The default style of output to use, not null.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>volatile</specifier> <name>ToStringStyle</name></type> <name>defaultStyle</name> <init>= <expr><name><name>ToStringStyle</name><operator>.</operator><name>DEFAULT_STYLE</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the default &lt;code&gt;ToStringStyle&lt;/code&gt; to use.&lt;/p&gt;
     *
     * &lt;p&gt;This method gets a singleton default value, typically for the whole JVM.
     * Changing this default should generally only be done during application startup.
     * It is recommended to pass a &lt;code&gt;ToStringStyle&lt;/code&gt; to the constructor instead
     * of using this global default.&lt;/p&gt;
     *
     * &lt;p&gt;This method can be used from multiple threads.
     * Internally, a &lt;code&gt;volatile&lt;/code&gt; variable is used to provide the guarantee
     * that the latest value set using {@link #setDefaultStyle} is the value returned.
     * It is strongly recommended that the default style is only changed during application startup.&lt;/p&gt;
     *
     * &lt;p&gt;One reason for changing the default could be to have a verbose style during
     * development and a compact style in production.&lt;/p&gt;
     *
     * @return the default &lt;code&gt;ToStringStyle&lt;/code&gt;, never null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>ToStringStyle</name></type> <name>getDefaultStyle</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>defaultStyle</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the default &lt;code&gt;ToStringStyle&lt;/code&gt; to use.&lt;/p&gt;
     *
     * &lt;p&gt;This method sets a singleton default value, typically for the whole JVM.
     * Changing this default should generally only be done during application startup.
     * It is recommended to pass a &lt;code&gt;ToStringStyle&lt;/code&gt; to the constructor instead
     * of changing this global default.&lt;/p&gt;
     *
     * &lt;p&gt;This method is not intended for use from multiple threads.
     * Internally, a &lt;code&gt;volatile&lt;/code&gt; variable is used to provide the guarantee
     * that the latest value set is the value returned from {@link #getDefaultStyle}.&lt;/p&gt;
     *
     * @param style  the default &lt;code&gt;ToStringStyle&lt;/code&gt;
     * @throws IllegalArgumentException if the style is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>setDefaultStyle</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The style must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>defaultStyle</name> <operator>=</operator> <name>style</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Uses &lt;code&gt;ReflectionToStringBuilder&lt;/code&gt; to generate a
     * &lt;code&gt;toString&lt;/code&gt; for the specified object.&lt;/p&gt;
     *
     * @param object  the Object to be output
     * @return the String result
     * @see ReflectionToStringBuilder#toString(Object)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>reflectionToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Uses &lt;code&gt;ReflectionToStringBuilder&lt;/code&gt; to generate a
     * &lt;code&gt;toString&lt;/code&gt; for the specified object.&lt;/p&gt;
     *
     * @param object  the Object to be output
     * @param style  the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @return the String result
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>reflectionToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Uses &lt;code&gt;ReflectionToStringBuilder&lt;/code&gt; to generate a
     * &lt;code&gt;toString&lt;/code&gt; for the specified object.&lt;/p&gt;
     *
     * @param object  the Object to be output
     * @param style  the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients  whether to include transient fields
     * @return the String result
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>reflectionToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>outputTransients</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Uses &lt;code&gt;ReflectionToStringBuilder&lt;/code&gt; to generate a
     * &lt;code&gt;toString&lt;/code&gt; for the specified object.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of the object
     * @param object  the Object to be output
     * @param style  the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients  whether to include transient fields
     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be &lt;code&gt;null&lt;/code&gt;
     * @return the String result
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>String</name></type> <name>reflectionToString</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>outputTransients</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>reflectUpToClass</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * Current toString buffer, not null.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * The object being output, may be null.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * The style of output to use, not null.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructs a builder for the specified object using the default output style.&lt;/p&gt;
     *
     * &lt;p&gt;This default style is obtained from {@link #getDefaultStyle()}.&lt;/p&gt;
     *
     * @param object  the Object to build a &lt;code&gt;toString&lt;/code&gt; for, not recommended to be null
     */</comment>
    <constructor><specifier>public</specifier> <name>ToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructs a builder for the specified object using the a defined output style.&lt;/p&gt;
     *
     * &lt;p&gt;If the style is &lt;code&gt;null&lt;/code&gt;, the default style is used.&lt;/p&gt;
     *
     * @param object  the Object to build a &lt;code&gt;toString&lt;/code&gt; for, not recommended to be null
     * @param style  the style of the &lt;code&gt;toString&lt;/code&gt; to create, null uses the default style
     */</comment>
    <constructor><specifier>public</specifier> <name>ToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructs a builder for the specified object.&lt;/p&gt;
     *
     * &lt;p&gt;If the style is &lt;code&gt;null&lt;/code&gt;, the default style is used.&lt;/p&gt;
     *
     * &lt;p&gt;If the buffer is &lt;code&gt;null&lt;/code&gt;, a new one is created.&lt;/p&gt;
     *
     * @param object  the Object to build a &lt;code&gt;toString&lt;/code&gt; for, not recommended to be null
     * @param style  the style of the &lt;code&gt;toString&lt;/code&gt; to create, null uses the default style
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate, may be null
     */</comment>
    <constructor><specifier>public</specifier> <name>ToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>style</name> <operator>=</operator> <call><name>getDefaultStyle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <call><name>StringBuffer</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>style</name></name> <operator>=</operator> <name>style</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>object</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>appendStart</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param obj  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;byte&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;float&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param obj  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param obj  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail,
     *  &lt;code&gt;false&lt;/code&gt; for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;short&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * &lt;p&gt;A boolean parameter controls the level of detail to show.
     * Setting &lt;code&gt;true&lt;/code&gt; will output the array in full. Setting
     * &lt;code&gt;false&lt;/code&gt; will output a summary, typically the size of
     * the array.
     *
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends with the same format as the default &lt;code&gt;Object toString()
     * &lt;/code&gt; method. Appends the class name followed by
     * {@link System#identityHashCode(java.lang.Object)}.&lt;/p&gt;
     *
     * @param object  the &lt;code&gt;Object&lt;/code&gt; whose class name and id to output
     * @return this
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>appendAsObjectToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>ObjectUtils</name><operator>.</operator><name>identityToString</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getStringBuffer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append the &lt;code&gt;toString&lt;/code&gt; from the superclass.&lt;/p&gt;
     *
     * &lt;p&gt;This method assumes that the superclass uses the same &lt;code&gt;ToStringStyle&lt;/code&gt;
     * as this one.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;superToString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no change is made.&lt;/p&gt;
     *
     * @param superToString  the result of &lt;code&gt;super.toString()&lt;/code&gt;
     * @return this
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>appendSuper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>superToString</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>superToString</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>appendSuper</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>superToString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append the &lt;code&gt;toString&lt;/code&gt; from another object.&lt;/p&gt;
     *
     * &lt;p&gt;This method is useful where a class delegates most of the implementation of
     * its properties to another class. You can then call &lt;code&gt;toString()&lt;/code&gt; on
     * the other class and pass the result into this method.&lt;/p&gt;
     *
     * &lt;pre&gt;
     *   private AnotherObject delegate;
     *   private String fieldInThisClass;
     *
     *   public String toString() {
     *     return new ToStringBuilder(this).
     *       appendToString(delegate.toString()).
     *       append(fieldInThisClass).
     *       toString();
     *   }&lt;/pre&gt;
     *
     * &lt;p&gt;This method assumes that the other object uses the same &lt;code&gt;ToStringStyle&lt;/code&gt;
     * as this one.&lt;/p&gt;
     *
     * &lt;p&gt;If the &lt;code&gt;toString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no change is made.&lt;/p&gt;
     *
     * @param toString  the result of &lt;code&gt;toString()&lt;/code&gt; on another object
     * @return this
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringBuilder</name></type> <name>appendToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>toString</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>toString</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>appendToString</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>toString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the &lt;code&gt;Object&lt;/code&gt; being output.&lt;/p&gt;
     *
     * @return The object being output.
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>Object</name></type> <name>getObject</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>object</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the &lt;code&gt;StringBuffer&lt;/code&gt; being populated.&lt;/p&gt;
     *
     * @return the &lt;code&gt;StringBuffer&lt;/code&gt; being populated
     */</comment>
    <function><specifier>public</specifier> <type><name>StringBuffer</name></type> <name>getStringBuffer</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>buffer</name></expr>;</return>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the &lt;code&gt;ToStringStyle&lt;/code&gt; being used.&lt;/p&gt;
     *
     * @return the &lt;code&gt;ToStringStyle&lt;/code&gt; being used
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>ToStringStyle</name></type> <name>getStyle</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>style</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the built &lt;code&gt;toString&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This method appends the end of data indicator, and can only be called once.
     * Use {@link #getStringBuffer} to get the current string state.&lt;/p&gt;
     *
     * &lt;p&gt;If the object is &lt;code&gt;null&lt;/code&gt;, return the style's &lt;code&gt;nullText&lt;/code&gt;&lt;/p&gt;
     *
     * @return the String &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>getStringBuffer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getStyle</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNullText</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>style</name><operator>.</operator><name>appendEnd</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getStringBuffer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>getStringBuffer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the String that was build as an object representation. The
     * default implementation utilizes the {@link #toString()} implementation.
     *
     * @return the String &lt;code&gt;toString&lt;/code&gt;
     *
     * @see #toString()
     *
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>build</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>
}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Controls &lt;code&gt;String&lt;/code&gt; formatting for {@link ToStringBuilder}.
 * The main public interface is always via &lt;code&gt;ToStringBuilder&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;These classes are intended to be used as &lt;code&gt;Singletons&lt;/code&gt;.
 * There is no need to instantiate a new style each time. A program
 * will generally use one of the predefined constants on this class.
 * Alternatively, the {@link StandardToStringStyle} class can be used
 * to set the individual settings. Thus most styles can be achieved
 * without subclassing.&lt;/p&gt;
 *
 * &lt;p&gt;If required, a subclass can override as many or as few of the
 * methods as it requires. Each object type (from &lt;code&gt;boolean&lt;/code&gt;
 * to &lt;code&gt;long&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;int[]&lt;/code&gt;) has
 * its own methods to output it. Most have two versions, detail and summary.
 *
 * &lt;p&gt;For example, the detail version of the array based methods will
 * output the whole array, whereas the summary method will just output
 * the array length.&lt;/p&gt;
 *
 * &lt;p&gt;If you want to format the output of certain objects, such as dates, you
 * must create a subclass and override a method.
 * &lt;pre&gt;
 * public class MyStyle extends ToStringStyle {
 *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {
 *     if (value instanceof Date) {
 *       value = new SimpleDateFormat("yyyy-MM-dd").format(value);
 *     }
 *     buffer.append(value);
 *   }
 * }
 * &lt;/pre&gt;
 * &lt;/p&gt;
 *
 * @since 1.0
 * @version $Id$
 */</comment>
<class><specifier>abstract</specifier> class <name>ToStringStyle</name> <super><implements>implements <name>Serializable</name></implements></super> <block>{

    <comment type="block" format="javadoc">/**
     * Serialization version ID.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><operator>-</operator><literal type="number">2587890625525655916L</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The default toString style. Using the Using the &lt;code&gt;Person&lt;/code&gt;
     * example from {@link ToStringBuilder}, the output would look like this:
     *
     * &lt;pre&gt;
     * Person@182f0db[name=John Doe,age=33,smoker=false]
     * &lt;/pre&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>DEFAULT_STYLE</name> <init>= <expr><operator>new</operator> <call><name>DefaultToStringStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The multi line toString style. Using the Using the &lt;code&gt;Person&lt;/code&gt;
     * example from {@link ToStringBuilder}, the output would look like this:
     *
     * &lt;pre&gt;
     * Person@182f0db[
     *   name=John Doe
     *   age=33
     *   smoker=false
     * ]
     * &lt;/pre&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>MULTI_LINE_STYLE</name> <init>= <expr><operator>new</operator> <call><name>MultiLineToStringStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The no field names toString style. Using the Using the
     * &lt;code&gt;Person&lt;/code&gt; example from {@link ToStringBuilder}, the output
     * would look like this:
     *
     * &lt;pre&gt;
     * Person@182f0db[John Doe,33,false]
     * &lt;/pre&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>NO_FIELD_NAMES_STYLE</name> <init>= <expr><operator>new</operator> <call><name>NoFieldNameToStringStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The short prefix toString style. Using the &lt;code&gt;Person&lt;/code&gt; example
     * from {@link ToStringBuilder}, the output would look like this:
     *
     * &lt;pre&gt;
     * Person[name=John Doe,age=33,smoker=false]
     * &lt;/pre&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>SHORT_PREFIX_STYLE</name> <init>= <expr><operator>new</operator> <call><name>ShortPrefixToStringStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The simple toString style. Using the Using the &lt;code&gt;Person&lt;/code&gt;
     * example from {@link ToStringBuilder}, the output would look like this:
     *
     * &lt;pre&gt;
     * John Doe,33,false
     * &lt;/pre&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>SIMPLE_STYLE</name> <init>= <expr><operator>new</operator> <call><name>SimpleToStringStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * A registry of objects used by &lt;code&gt;reflectionToString&lt;/code&gt; methods
     * to detect cyclical object references and avoid infinite loops.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>WeakHashMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>REGISTRY</name> <init>=
            <expr><operator>new</operator> <call><name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>WeakHashMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>,<argument><name>Object</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
     * Note that objects of this class are generally shared between threads, so
     * an instance variable would not be suitable here.
     *
     * In normal use the registry should always be left empty, because the caller
     * should call toString() which will clean up.
     *
     * See LANG-792
     */</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns the registry of objects being traversed by the &lt;code&gt;reflectionToString&lt;/code&gt;
     * methods in the current thread.
     * &lt;/p&gt;
     *
     * @return Set the registry of objects being traversed
     */</comment>
    <function><specifier>static</specifier> <type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getRegistry</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>REGISTRY</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns &lt;code&gt;true&lt;/code&gt; if the registry contains the given object.
     * Used by the reflection methods to avoid infinite loops.
     * &lt;/p&gt;
     *
     * @param value
     *                  The object to lookup in the registry.
     * @return boolean &lt;code&gt;true&lt;/code&gt; if the registry contains the given
     *             object.
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>isRegistered</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>m</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>m</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Registers the given object. Used by the reflection methods to avoid
     * infinite loops.
     * &lt;/p&gt;
     *
     * @param value
     *                  The object to register.
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>register</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>WeakHashMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>getRegistry</name><argument_list>()</argument_list></call><operator>.</operator><call><name>put</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Unregisters the given object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Used by the reflection methods to avoid infinite loops.
     * &lt;/p&gt;
     *
     * @param value
     *                  The object to unregister.
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>unregister</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>m</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>m</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>m</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Whether to use the field names, the default is &lt;code&gt;true&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>useFieldNames</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether to use the class name, the default is &lt;code&gt;true&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>useClassName</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether to use short class names, the default is &lt;code&gt;false&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>useShortClassName</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether to use the identity hash code, the default is &lt;code&gt;true&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>useIdentityHashCode</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The content start &lt;code&gt;'['&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>contentStart</name> <init>= <expr><literal type="string">"["</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The content end &lt;code&gt;']'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>contentEnd</name> <init>= <expr><literal type="string">"]"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The field name value separator &lt;code&gt;'='&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>fieldNameValueSeparator</name> <init>= <expr><literal type="string">"="</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether the field separator should be added before any other fields.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>fieldSeparatorAtStart</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether the field separator should be added after any other fields.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>fieldSeparatorAtEnd</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The field separator &lt;code&gt;','&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>fieldSeparator</name> <init>= <expr><literal type="string">","</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The array start &lt;code&gt;'{'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>arrayStart</name> <init>= <expr><literal type="string">"{"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The array separator &lt;code&gt;','&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>arraySeparator</name> <init>= <expr><literal type="string">","</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The detail for array content.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>arrayContentDetail</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The array end &lt;code&gt;'}'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>arrayEnd</name> <init>= <expr><literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value to use when fullDetail is &lt;code&gt;null&lt;/code&gt;,
     * the default value is &lt;code&gt;true&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>defaultFullDetail</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The &lt;code&gt;null&lt;/code&gt; text &lt;code&gt;'&amp;lt;null&amp;gt;'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>nullText</name> <init>= <expr><literal type="string">"&lt;null&gt;"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The summary size text start &lt;code&gt;'&lt;size'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>sizeStartText</name> <init>= <expr><literal type="string">"&lt;size="</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The summary size text start &lt;code&gt;'&amp;gt;'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>sizeEndText</name> <init>= <expr><literal type="string">"&gt;"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The summary object text start &lt;code&gt;'&amp;lt;'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>summaryObjectStartText</name> <init>= <expr><literal type="string">"&lt;"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The summary object text start &lt;code&gt;'&amp;gt;'&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>summaryObjectEndText</name> <init>= <expr><literal type="string">"&gt;"</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructor.&lt;/p&gt;
     */</comment>
    <constructor><specifier>protected</specifier> <name>ToStringStyle</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the superclass toString.&lt;/p&gt;
     * &lt;p&gt;NOTE: It assumes that the toString has been created from the same ToStringStyle. &lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; &lt;code&gt;superToString&lt;/code&gt; is ignored.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param superToString  the &lt;code&gt;super.toString()&lt;/code&gt;
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>appendSuper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>superToString</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendToString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>superToString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; another toString.&lt;/p&gt;
     * &lt;p&gt;NOTE: It assumes that the toString has been created from the same ToStringStyle. &lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; &lt;code&gt;toString&lt;/code&gt; is ignored.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param toString  the additional &lt;code&gt;toString&lt;/code&gt;
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>appendToString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>toString</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>toString</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos1</name> <init>= <expr><call><name><name>toString</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>contentStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>contentStart</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos2</name> <init>= <expr><call><name><name>toString</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>contentEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>pos1</name> <operator>!=</operator> <name>pos2</name> <operator>&amp;&amp;</operator> <name>pos1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>data</name> <init>= <expr><call><name><name>toString</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos1</name></expr></argument>, <argument><expr><name>pos2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>fieldSeparatorAtStart</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>removeLastFieldSeparator</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendFieldSeparator</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the start of data indicator.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param object  the &lt;code&gt;Object&lt;/code&gt; to build a &lt;code&gt;toString&lt;/code&gt; for
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>appendStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendClassName</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendIdentityHashCode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendContentStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>fieldSeparatorAtStart</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>appendFieldSeparator</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the end of data indicator.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param object  the &lt;code&gt;Object&lt;/code&gt; to build a
     *  &lt;code&gt;toString&lt;/code&gt; for.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>appendEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>fieldSeparatorAtEnd</name></name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>removeLastFieldSeparator</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>appendContentEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unregister</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Remove the last field separator from the buffer.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>removeLastFieldSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sepLen</name> <init>= <expr><call><name><name>fieldSeparator</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sepLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <name>sepLen</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>match</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sepLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>fieldSeparator</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>sepLen</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>match</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>sepLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value, printing the full &lt;code&gt;toString&lt;/code&gt; of the
     * &lt;code&gt;Object&lt;/code&gt; passed in.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>appendInternal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;,
     * correctly interpreting its type.&lt;/p&gt;
     *
     * &lt;p&gt;This method performs the main lookup by Class type to correctly
     * route arrays, &lt;code&gt;Collections&lt;/code&gt;, &lt;code&gt;Maps&lt;/code&gt; and
     * &lt;code&gt;Objects&lt;/code&gt; to the appropriate method.&lt;/p&gt;
     *
     * &lt;p&gt;Either detail or summary views can be specified.&lt;/p&gt;
     *
     * &lt;p&gt;If a cycle is detected, an object will be appended with the
     * &lt;code&gt;Object.toString()&lt;/code&gt; format.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     * @param detail  output detail or not
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendInternal</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>detail</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isRegistered</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>value</name> <operator>instanceof</operator> <name>Number</name> <operator>||</operator> <name>value</name> <operator>instanceof</operator> <name>Boolean</name> <operator>||</operator> <name>value</name> <operator>instanceof</operator> <name>Character</name><operator>)</operator></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendCyclicObject</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>register</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <try>try <block>{
            <if>if <condition>(<expr><ternary><condition><expr><name>value</name> <operator>instanceof</operator> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then/></if></block></ternary></expr></condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></expr></condition></ternary><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><ternary><condition><expr><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></expr></condition></ternary><operator>)</operator> <name>value</name><operator>)</operator><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></try> <elseif>else <if>if <condition>(<expr><ternary><condition><expr><name>value</name> <operator>instanceof</operator> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then/></if></block></ternary></expr></condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></expr></condition></ternary><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><ternary><condition><expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></expr></condition></ternary><operator>)</operator> <name>value</name><operator>)</operator><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else>

            }</block></function> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>long</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>int</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>short</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>byte</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>char</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>double</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>float</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>value</name> <operator>instanceof</operator> <name><name>boolean</name><index>[]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><call><name><name>value</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if></elseif> <else>else <block>{
                <if>if <condition>(<expr><name>detail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else>
        }</block></class> <finally>finally <block>{
            <expr_stmt><expr><call><name>unregister</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally>
    }

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value that has been detected to participate in a cycle. This
     * implementation will print the standard string value of the value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     *
     * @since 2.2
     */</comment>
    protected <function><type><name>void</name></type> <name>appendCyclicObject</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>ObjectUtils</name><operator>.</operator><name>identityToString</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value, printing the full detail of the &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;Collection&lt;/code&gt;.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param coll  the &lt;code&gt;Collection&lt;/code&gt; to add to the
     *  &lt;code&gt;toString&lt;/code&gt;, not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>coll</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;Map&lt;code&gt;.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param map  the &lt;code&gt;Map&lt;/code&gt; to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * value, printing a summary of the &lt;code&gt;Object&lt;/code&gt;.&lt;/P&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>summaryObjectStartText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>getShortClassName</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>summaryObjectEndText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * value.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param value  the value to add to the &lt;code&gt;toString&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the toString
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of an
     * &lt;code&gt;Object&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>item</name> <init>= <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>item</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>appendInternal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>arrayContentDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of an array type.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>reflectionAppendArrayDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>getLength</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>item</name> <init>= <expr><call><name><name>Array</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>item</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>appendInternal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>arrayContentDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of an
     * &lt;code&gt;Object&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;long&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;long&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;long&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;int&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of an
     * &lt;code&gt;int&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of an
     * &lt;code&gt;int&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;short&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;short&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;short&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;byte&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;byte&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;byte&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;char&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;char&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;char&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;double&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the toString
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;double&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;double&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the toString
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;float&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;float&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a &lt;code&gt;boolean&lt;/code&gt;
     * array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     * @param array  the array to add to the toString
     * @param fullDetail  &lt;code&gt;true&lt;/code&gt; for detail, &lt;code&gt;false&lt;/code&gt;
     *  for summary info, &lt;code&gt;null&lt;/code&gt; for style decides
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldStart</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendNullText</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isFullDetail</name><argument_list>(<argument><expr><name>fullDetail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>appendSummary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>appendFieldEnd</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the detail of a
     * &lt;code&gt;boolean&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arraySeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>appendDetail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>arrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a summary of a
     * &lt;code&gt;boolean&lt;/code&gt; array.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param array  the array to add to the &lt;code&gt;toString&lt;/code&gt;,
     *  not &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummary</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendSummarySize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the class name.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param object  the &lt;code&gt;Object&lt;/code&gt; whose name to output
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>useClassName</name> <operator>&amp;&amp;</operator> <name>object</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>register</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>useShortClassName</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>getShortClassName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append the {@link System#identityHashCode(java.lang.Object)}.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param object  the &lt;code&gt;Object&lt;/code&gt; whose id to output
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendIdentityHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>isUseIdentityHashCode</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>object</name><operator>!=</operator><literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>register</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the content start.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendContentStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>contentStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the content end.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendContentEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>contentEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; an indicator for &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The default indicator is &lt;code&gt;'&amp;lt;null&amp;gt;'&lt;/code&gt;.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendNullText</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>nullText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the field separator.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendFieldSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>fieldSeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; the field start.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendFieldStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>useFieldNames</name> <operator>&amp;&amp;</operator> <name>fieldName</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>fieldNameValueSeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;code&gt; the field end.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendFieldEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>appendFieldSeparator</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Append to the &lt;code&gt;toString&lt;/code&gt; a size summary.&lt;/p&gt;
     *
     * &lt;p&gt;The size summary is used to summarize the contents of
     * &lt;code&gt;Collections&lt;/code&gt;, &lt;code&gt;Maps&lt;/code&gt; and arrays.&lt;/p&gt;
     *
     * &lt;p&gt;The output consists of a prefix, the passed in size
     * and a suffix.&lt;/p&gt;
     *
     * &lt;p&gt;The default format is &lt;code&gt;'&amp;lt;size=n&amp;gt;'&lt;code&gt;.&lt;/p&gt;
     *
     * @param buffer  the &lt;code&gt;StringBuffer&lt;/code&gt; to populate
     * @param fieldName  the field name, typically not used as already appended
     * @param size  the size to append
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendSummarySize</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>sizeStartText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>sizeEndText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Is this field to be output in full detail.&lt;/p&gt;
     *
     * &lt;p&gt;This method converts a detail request into a detail level.
     * The calling code may request full detail (&lt;code&gt;true&lt;/code&gt;),
     * but a subclass might ignore that and always return
     * &lt;code&gt;false&lt;/code&gt;. The calling code may pass in
     * &lt;code&gt;null&lt;/code&gt; indicating that it doesn't care about
     * the detail level. In this case the default detail level is
     * used.&lt;/p&gt;
     *
     * @param fullDetailRequest  the detail level requested
     * @return whether full detail is to be shown
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isFullDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Boolean</name></type> <name>fullDetailRequest</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>fullDetailRequest</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>defaultFullDetail</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>fullDetailRequest</name><operator>.</operator><name>booleanValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the short class name for a class.&lt;/p&gt;
     *
     * &lt;p&gt;The short class name is the classname excluding
     * the package name.&lt;/p&gt;
     *
     * @param cls  the &lt;code&gt;Class&lt;/code&gt; to get the short name of
     * @return the short name
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getShortClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ClassUtils</name><operator>.</operator><name>getShortClassName</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Setters and getters for the customizable parts of the style</comment>
    <comment type="line">// These methods are not expected to be overridden, except to make public</comment>
    <comment type="line">// (They are not public so that immutable subclasses can be written)</comment>
    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to use the class name.&lt;/p&gt;
     *
     * @return the current useClassName flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isUseClassName</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>useClassName</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to use the class name.&lt;/p&gt;
     *
     * @param useClassName  the new useClassName flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setUseClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useClassName</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>useClassName</name></name> <operator>=</operator> <name>useClassName</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to output short or long class names.&lt;/p&gt;
     *
     * @return the current useShortClassName flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isUseShortClassName</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>useShortClassName</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to output short or long class names.&lt;/p&gt;
     *
     * @param useShortClassName  the new useShortClassName flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setUseShortClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useShortClassName</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>useShortClassName</name></name> <operator>=</operator> <name>useShortClassName</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to use the identity hash code.&lt;/p&gt;
     *
     * @return the current useIdentityHashCode flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isUseIdentityHashCode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>useIdentityHashCode</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to use the identity hash code.&lt;/p&gt;
     *
     * @param useIdentityHashCode  the new useIdentityHashCode flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setUseIdentityHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useIdentityHashCode</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>useIdentityHashCode</name></name> <operator>=</operator> <name>useIdentityHashCode</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to use the field names passed in.&lt;/p&gt;
     *
     * @return the current useFieldNames flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isUseFieldNames</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>useFieldNames</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to use the field names passed in.&lt;/p&gt;
     *
     * @param useFieldNames  the new useFieldNames flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setUseFieldNames</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useFieldNames</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>useFieldNames</name></name> <operator>=</operator> <name>useFieldNames</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to use full detail when the caller doesn't
     * specify.&lt;/p&gt;
     *
     * @return the current defaultFullDetail flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isDefaultFullDetail</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>defaultFullDetail</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to use full detail when the caller doesn't
     * specify.&lt;/p&gt;
     *
     * @param defaultFullDetail  the new defaultFullDetail flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setDefaultFullDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>defaultFullDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>defaultFullDetail</name></name> <operator>=</operator> <name>defaultFullDetail</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether to output array content detail.&lt;/p&gt;
     *
     * @return the current array content detail setting
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isArrayContentDetail</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>arrayContentDetail</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether to output array content detail.&lt;/p&gt;
     *
     * @param arrayContentDetail  the new arrayContentDetail flag
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setArrayContentDetail</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>arrayContentDetail</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>arrayContentDetail</name></name> <operator>=</operator> <name>arrayContentDetail</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the array start text.&lt;/p&gt;
     *
     * @return the current array start text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getArrayStart</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>arrayStart</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the array start text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param arrayStart  the new array start text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setArrayStart</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>arrayStart</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>arrayStart</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>arrayStart</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>arrayStart</name></name> <operator>=</operator> <name>arrayStart</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the array end text.&lt;/p&gt;
     *
     * @return the current array end text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getArrayEnd</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>arrayEnd</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the array end text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param arrayEnd  the new array end text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setArrayEnd</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>arrayEnd</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>arrayEnd</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>arrayEnd</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>arrayEnd</name></name> <operator>=</operator> <name>arrayEnd</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the array separator text.&lt;/p&gt;
     *
     * @return the current array separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getArraySeparator</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>arraySeparator</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the array separator text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param arraySeparator  the new array separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setArraySeparator</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>arraySeparator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>arraySeparator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>arraySeparator</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>arraySeparator</name></name> <operator>=</operator> <name>arraySeparator</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the content start text.&lt;/p&gt;
     *
     * @return the current content start text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getContentStart</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>contentStart</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the content start text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param contentStart  the new content start text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setContentStart</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>contentStart</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>contentStart</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>contentStart</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>contentStart</name></name> <operator>=</operator> <name>contentStart</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the content end text.&lt;/p&gt;
     *
     * @return the current content end text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getContentEnd</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>contentEnd</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the content end text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param contentEnd  the new content end text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setContentEnd</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>contentEnd</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>contentEnd</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>contentEnd</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>contentEnd</name></name> <operator>=</operator> <name>contentEnd</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the field name value separator text.&lt;/p&gt;
     *
     * @return the current field name value separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getFieldNameValueSeparator</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fieldNameValueSeparator</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the field name value separator text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param fieldNameValueSeparator  the new field name value separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setFieldNameValueSeparator</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldNameValueSeparator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>fieldNameValueSeparator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>fieldNameValueSeparator</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldNameValueSeparator</name></name> <operator>=</operator> <name>fieldNameValueSeparator</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the field separator text.&lt;/p&gt;
     *
     * @return the current field separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getFieldSeparator</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fieldSeparator</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the field separator text.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param fieldSeparator  the new field separator text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setFieldSeparator</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldSeparator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>fieldSeparator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>fieldSeparator</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldSeparator</name></name> <operator>=</operator> <name>fieldSeparator</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether the field separator should be added at the start
     * of each buffer.&lt;/p&gt;
     *
     * @return the fieldSeparatorAtStart flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isFieldSeparatorAtStart</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fieldSeparatorAtStart</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether the field separator should be added at the start
     * of each buffer.&lt;/p&gt;
     *
     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setFieldSeparatorAtStart</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fieldSeparatorAtStart</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldSeparatorAtStart</name></name> <operator>=</operator> <name>fieldSeparatorAtStart</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets whether the field separator should be added at the end
     * of each buffer.&lt;/p&gt;
     *
     * @return fieldSeparatorAtEnd flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isFieldSeparatorAtEnd</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fieldSeparatorAtEnd</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets whether the field separator should be added at the end
     * of each buffer.&lt;/p&gt;
     *
     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag
     * @since 2.0
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setFieldSeparatorAtEnd</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>fieldSeparatorAtEnd</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldSeparatorAtEnd</name></name> <operator>=</operator> <name>fieldSeparatorAtEnd</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the text to output when &lt;code&gt;null&lt;/code&gt; found.&lt;/p&gt;
     *
     * @return the current text to output when null found
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getNullText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>nullText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the text to output when &lt;code&gt;null&lt;/code&gt; found.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param nullText  the new text to output when null found
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setNullText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>nullText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>nullText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>nullText</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nullText</name></name> <operator>=</operator> <name>nullText</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the start text to output when a &lt;code&gt;Collection&lt;/code&gt;,
     * &lt;code&gt;Map&lt;/code&gt; or array size is output.&lt;/p&gt;
     *
     * &lt;p&gt;This is output before the size value.&lt;/p&gt;
     *
     * @return the current start of size text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getSizeStartText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>sizeStartText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the start text to output when a &lt;code&gt;Collection&lt;/code&gt;,
     * &lt;code&gt;Map&lt;/code&gt; or array size is output.&lt;/p&gt;
     *
     * &lt;p&gt;This is output before the size value.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param sizeStartText  the new start of size text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setSizeStartText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>sizeStartText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>sizeStartText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>sizeStartText</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sizeStartText</name></name> <operator>=</operator> <name>sizeStartText</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the end text to output when a &lt;code&gt;Collection&lt;/code&gt;,
     * &lt;code&gt;Map&lt;/code&gt; or array size is output.&lt;/p&gt;
     *
     * &lt;p&gt;This is output after the size value.&lt;/p&gt;
     *
     * @return the current end of size text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getSizeEndText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>sizeEndText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the end text to output when a &lt;code&gt;Collection&lt;/code&gt;,
     * &lt;code&gt;Map&lt;/code&gt; or array size is output.&lt;/p&gt;
     *
     * &lt;p&gt;This is output after the size value.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param sizeEndText  the new end of size text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setSizeEndText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>sizeEndText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>sizeEndText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>sizeEndText</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sizeEndText</name></name> <operator>=</operator> <name>sizeEndText</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the start text to output when an &lt;code&gt;Object&lt;/code&gt; is
     * output in summary mode.&lt;/p&gt;
     *
     * &lt;p&gt;This is output before the size value.&lt;/p&gt;
     *
     * @return the current start of summary text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getSummaryObjectStartText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>summaryObjectStartText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the start text to output when an &lt;code&gt;Object&lt;/code&gt; is
     * output in summary mode.&lt;/p&gt;
     *
     * &lt;p&gt;This is output before the size value.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param summaryObjectStartText  the new start of summary text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setSummaryObjectStartText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>summaryObjectStartText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>summaryObjectStartText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>summaryObjectStartText</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>summaryObjectStartText</name></name> <operator>=</operator> <name>summaryObjectStartText</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//---------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the end text to output when an &lt;code&gt;Object&lt;/code&gt; is
     * output in summary mode.&lt;/p&gt;
     *
     * &lt;p&gt;This is output after the size value.&lt;/p&gt;
     *
     * @return the current end of summary text
     */</comment>
    <function><specifier>protected</specifier> <type><name>String</name></type> <name>getSummaryObjectEndText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>summaryObjectEndText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Sets the end text to output when an &lt;code&gt;Object&lt;/code&gt; is
     * output in summary mode.&lt;/p&gt;
     *
     * &lt;p&gt;This is output after the size value.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; is accepted, but will be converted to
     * an empty String.&lt;/p&gt;
     *
     * @param summaryObjectEndText  the new end of summary text
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setSummaryObjectEndText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>summaryObjectEndText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>summaryObjectEndText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>summaryObjectEndText</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>summaryObjectEndText</name></name> <operator>=</operator> <name>summaryObjectEndText</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Default &lt;code&gt;ToStringStyle&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This is an inner class rather than using
     * &lt;code&gt;StandardToStringStyle&lt;/code&gt; to ensure its immutability.&lt;/p&gt;
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>DefaultToStringStyle</name> <super><extends>extends <name>ToStringStyle</name></extends></super> <block>{

        <comment type="block" format="javadoc">/**
         * Required for serialization support.
         *
         * @see java.io.Serializable
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Constructor.&lt;/p&gt;
         *
         * &lt;p&gt;Use the static constant rather than instantiating.&lt;/p&gt;
         */</comment>
        <constructor><name>DefaultToStringStyle</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure &lt;code&gt;Singleton&lt;/code&gt; after serialization.&lt;/p&gt;
         *
         * @return the singleton
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ToStringStyle</name><operator>.</operator><name>DEFAULT_STYLE</name></name></expr>;</return>
        }</block></function>

    }</block></class>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;&lt;code&gt;ToStringStyle&lt;/code&gt; that does not print out
     * the field names.&lt;/p&gt;
     *
     * &lt;p&gt;This is an inner class rather than using
     * &lt;code&gt;StandardToStringStyle&lt;/code&gt; to ensure its immutability.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>NoFieldNameToStringStyle</name> <super><extends>extends <name>ToStringStyle</name></extends></super> <block>{

        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Constructor.&lt;/p&gt;
         *
         * &lt;p&gt;Use the static constant rather than instantiating.&lt;/p&gt;
         */</comment>
        <constructor><name>NoFieldNameToStringStyle</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseFieldNames</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure &lt;code&gt;Singleton&lt;/code&gt; after serialization.&lt;/p&gt;
         *
         * @return the singleton
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ToStringStyle</name><operator>.</operator><name>NO_FIELD_NAMES_STYLE</name></name></expr>;</return>
        }</block></function>

    }</block></class>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;&lt;code&gt;ToStringStyle&lt;/code&gt; that prints out the short
     * class name and no identity hashcode.&lt;/p&gt;
     *
     * &lt;p&gt;This is an inner class rather than using
     * &lt;code&gt;StandardToStringStyle&lt;/code&gt; to ensure its immutability.&lt;/p&gt;
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>ShortPrefixToStringStyle</name> <super><extends>extends <name>ToStringStyle</name></extends></super> <block>{

        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Constructor.&lt;/p&gt;
         *
         * &lt;p&gt;Use the static constant rather than instantiating.&lt;/p&gt;
         */</comment>
        <constructor><name>ShortPrefixToStringStyle</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseShortClassName</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseIdentityHashCode</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure &lt;code&gt;Singleton&lt;/ode&gt; after serialization.&lt;/p&gt;
         * @return the singleton
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ToStringStyle</name><operator>.</operator><name>SHORT_PREFIX_STYLE</name></name></expr>;</return>
        }</block></function>

    }</block></class>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;&lt;code&gt;ToStringStyle&lt;/code&gt; that does not print out the
     * classname, identity hashcode, content start or field name.&lt;/p&gt;
     *
     * &lt;p&gt;This is an inner class rather than using
     * &lt;code&gt;StandardToStringStyle&lt;/code&gt; to ensure its immutability.&lt;/p&gt;
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>SimpleToStringStyle</name> <super><extends>extends <name>ToStringStyle</name></extends></super> <block>{

        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Constructor.&lt;/p&gt;
         *
         * &lt;p&gt;Use the static constant rather than instantiating.&lt;/p&gt;
         */</comment>
        <constructor><name>SimpleToStringStyle</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseClassName</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseIdentityHashCode</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUseFieldNames</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setContentStart</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setContentEnd</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure &lt;code&gt;Singleton&lt;/ode&gt; after serialization.&lt;/p&gt;
         * @return the singleton
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ToStringStyle</name><operator>.</operator><name>SIMPLE_STYLE</name></name></expr>;</return>
        }</block></function>

    }</block></class>

    <comment type="line">//----------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;&lt;code&gt;ToStringStyle&lt;/code&gt; that outputs on multiple lines.&lt;/p&gt;
     *
     * &lt;p&gt;This is an inner class rather than using
     * &lt;code&gt;StandardToStringStyle&lt;/code&gt; to ensure its immutability.&lt;/p&gt;
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>MultiLineToStringStyle</name> <super><extends>extends <name>ToStringStyle</name></extends></super> <block>{

        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Constructor.&lt;/p&gt;
         *
         * &lt;p&gt;Use the static constant rather than instantiating.&lt;/p&gt;
         */</comment>
        <constructor><name>MultiLineToStringStyle</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setContentStart</name></name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setFieldSeparator</name></name><argument_list>(<argument><expr><name><name>SystemUtils</name><operator>.</operator><name>LINE_SEPARATOR</name></name> <operator>+</operator> <literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setFieldSeparatorAtStart</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setContentEnd</name></name><argument_list>(<argument><expr><name><name>SystemUtils</name><operator>.</operator><name>LINE_SEPARATOR</name></name> <operator>+</operator> <literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * &lt;p&gt;Ensure &lt;code&gt;Singleton&lt;/code&gt; after serialization.&lt;/p&gt;
         *
         * @return the singleton
         */</comment>
        <function><specifier>private</specifier> <type><name>Object</name></type> <name>readResolve</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>ToStringStyle</name><operator>.</operator><name>MULTI_LINE_STYLE</name></name></expr>;</return>
        }</block></function>

    }</block></class>

}


<comment type="block" format="javadoc">/**
 * &lt;p&gt;
 * Assists in implementing {@link Object#hashCode()} methods.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This class enables a good &lt;code&gt;hashCode&lt;/code&gt; method to be built for any class. It follows the rules laid out in
 * the book &lt;a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html"&gt;Effective Java&lt;/a&gt; by Joshua Bloch. Writing a
 * good &lt;code&gt;hashCode&lt;/code&gt; method is actually quite difficult. This class aims to simplify the process.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The following is the approach taken. When appending a data field, the current total is multiplied by the
 * multiplier then a relevant value
 * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then
 * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * All relevant fields from the object should be included in the &lt;code&gt;hashCode&lt;/code&gt; method. Derived fields may be
 * excluded. In general, any field used in the &lt;code&gt;equals&lt;/code&gt; method must be used in the &lt;code&gt;hashCode&lt;/code&gt;
 * method.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * To use this class write code as follows:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class Person {
 *   String name;
 *   int age;
 *   boolean smoker;
 *   ...
 *
 *   public int hashCode() {
 *     // you pick a hard-coded, randomly chosen, non-zero, odd number
 *     // ideally different for each class
 *     return new HashCodeBuilder(17, 37).
 *       append(name).
 *       append(age).
 *       append(smoker).
 *       toHashCode();
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If required, the superclass &lt;code&gt;hashCode()&lt;/code&gt; can be added using {@link #appendSuper}.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are
 * usually private, the method, &lt;code&gt;reflectionHashCode&lt;/code&gt;, uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
 * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions
 * are set up correctly. It is also slower than testing explicitly.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * A typical invocation for this method would look like:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public int hashCode() {
 *   return HashCodeBuilder.reflectionHashCode(this);
 * }
 * &lt;/pre&gt;
 *
 * @since 1.0
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>HashCodeBuilder</name> implements <name><name>Builder</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name> <block>{
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.
     * &lt;/p&gt;
     *
     * @since 2.3
     */</comment>
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name> <name>REGISTRY</name> <operator>=</operator> <operator>new</operator> <call><name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;

    <comment type="block">/*
     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()
     * we are in the process of calculating.
     *
     * So we generate a one-to-one mapping from the original object to a new object.
     *
     * Now HashSet uses equals() to determine if two elements with the same hashcode really
     * are equal, so we also need to ensure that the replacement objects are only equal
     * if the original objects are identical.
     *
     * The original implementation (2.4 and before) used the System.indentityHashCode()
     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)
     *
     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)
     * to disambiguate the duplicate ids.
     */</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns the registry of objects being traversed by the reflection methods in the current thread.
     * &lt;/p&gt;
     *
     * @return Set the registry of objects being traversed
     * @since 2.3
     */</comment>
    <expr><specifier>static</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name> <call><name>getRegistry</name><argument_list>()</argument_list></call> <block>{
        <return>return <expr><call><name><name>REGISTRY</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
    }</block>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns &lt;code&gt;true&lt;/code&gt; if the registry contains the given object. Used by the reflection methods to avoid
     * infinite loops.
     * &lt;/p&gt;
     *
     * @param value
     *            The object to lookup in the registry.
     * @return boolean &lt;code&gt;true&lt;/code&gt; if the registry contains the given object.
     * @since 2.3
     */</comment>
    <specifier>static</specifier> <name>boolean</name> <call><name>isRegistered</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
        <expr><name>final</name> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name> <name>registry</name> <operator>=</operator> <call><name>getRegistry</name><argument_list>()</argument_list></call></expr>;
        <return>return <expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>registry</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>IDKey</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Appends the fields and values defined by the given object of the given &lt;code&gt;Class&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param object
     *            the object to append details of
     * @param clazz
     *            the class to append details of
     * @param builder
     *            the builder to append to
     * @param useTransients
     *            whether to use transient fields
     * @param excludeFields
     *            Collection of String field names to exclude from use in calculation of hash code
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reflectionAppend</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>HashCodeBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useTransients</name></decl></parameter>,
                                         <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isRegistered</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <try>try <block>{
            <expr_stmt><expr><call><name>register</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Field</name><index>[]</index></name></type> <name>fields</name> <init>= <expr><call><name><name>clazz</name><operator>.</operator><name>getDeclaredFields</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>AccessibleObject</name><operator>.</operator><name>setAccessible</name></name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Field</name></type> <name>field</name> <range>: <expr><name>fields</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><operator>!</operator><call><name><name>ArrayUtils</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>, <argument><expr><call><name><name>field</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                        <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>field</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><name>useTransients</name> <operator>||</operator> <operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isTransient</name></name><argument_list>(<argument><expr><call><name><name>field</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isStatic</name></name><argument_list>(<argument><expr><call><name><name>field</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                    <try>try <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>fieldValue</name> <init>= <expr><call><name><name>field</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>fieldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalAccessException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                        <comment type="line">// this can't happen. Would get a Security exception instead</comment>
                        <comment type="line">// throw a runtime exception in case the impossible happens.</comment>
                        <throw>throw <expr><operator>new</operator> <call><name>InternalError</name><argument_list>(<argument><expr><literal type="string">"Unexpected IllegalAccessException"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                }</block></then></if>
            }</block></for>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name>unregister</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the
     * &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be tested. Superclass fields will be included.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.
     * &lt;/p&gt;
     *
     * @param initialNonZeroOddNumber
     *            a non-zero, odd number used as the initial value
     * @param multiplierNonZeroOddNumber
     *            a non-zero, odd number used as the multiplier
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the number is zero or even
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>initialNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>multiplierNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionHashCode</name><argument_list>(<argument><expr><name>initialNonZeroOddNumber</name></expr></argument>, <argument><expr><name>multiplierNonZeroOddNumber</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the TestTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient members will be tested, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be tested. Superclass fields will be included.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.
     * &lt;/p&gt;
     *
     * @param initialNonZeroOddNumber
     *            a non-zero, odd number used as the initial value
     * @param multiplierNonZeroOddNumber
     *            a non-zero, odd number used as the multiplier
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @param testTransients
     *            whether to include transient fields
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the number is zero or even
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>initialNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>multiplierNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>,
                                         <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>testTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionHashCode</name><argument_list>(<argument><expr><name>initialNonZeroOddNumber</name></expr></argument>, <argument><expr><name>multiplierNonZeroOddNumber</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the TestTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient members will be tested, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be included. Superclass fields will be included up to and including the specified
     * superclass. A null superclass is treated as java.lang.Object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt;
     *            the type of the object involved
     * @param initialNonZeroOddNumber
     *            a non-zero, odd number used as the initial value
     * @param multiplierNonZeroOddNumber
     *            a non-zero, odd number used as the multiplier
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @param testTransients
     *            whether to include transient fields
     * @param reflectUpToClass
     *            the superclass to reflect up to (inclusive), may be &lt;code&gt;null&lt;/code&gt;
     * @param excludeFields
     *            array of field names to exclude from use in calculation of hash code
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the number is zero or even
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>initialNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>multiplierNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>,
                                             <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>testTransients</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"The object to build a hash code for must not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>HashCodeBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>HashCodeBuilder</name><argument_list>(<argument><expr><name>initialNonZeroOddNumber</name></expr></argument>, <argument><expr><name>multiplierNonZeroOddNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name> <init>= <expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>builder</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>clazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>clazz</name> <operator>!=</operator> <name>reflectUpToClass</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>clazz</name> <operator>=</operator> <call><name><name>clazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>builder</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toHashCode</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This constructor uses two hard coded choices for the constants needed to build a hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;P&gt;
     * If the TestTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient members will be tested, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be tested. Superclass fields will be included.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @param testTransients
     *            whether to include transient fields
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the object is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>testTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionHashCode</name><argument_list>(<argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><literal type="number">37</literal></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This constructor uses two hard coded choices for the constants needed to build a hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the
     * &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be tested. Superclass fields will be included.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @param excludeFields
     *            Collection of String field names to exclude from use in calculation of hash code
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the object is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionHashCode</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toNoNullStringArray</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// -------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * This method uses reflection to build a valid hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This constructor uses two hard coded choices for the constants needed to build a hash code.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the
     * &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be tested. Superclass fields will be included.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to create a &lt;code&gt;hashCode&lt;/code&gt; for
     * @param excludeFields
     *            array of field names to exclude from use in calculation of hash code
     * @return int hash code
     * @throws IllegalArgumentException
     *             if the object is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionHashCode</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionHashCode</name><argument_list>(<argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><literal type="number">37</literal></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Registers the given object. Used by the reflection methods to avoid infinite loops.
     * &lt;/p&gt;
     *
     * @param value
     *            The object to register.
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>register</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <synchronized>synchronized <init>(<expr><name><name>HashCodeBuilder</name><operator>.</operator><name>class</name></name></expr>)</init> <block>{
            <if>if <condition>(<expr><call><name>getRegistry</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></synchronized>
        <expr_stmt><expr><call><name>getRegistry</name><argument_list>()</argument_list></call><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>IDKey</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Unregisters the given object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Used by the reflection methods to avoid infinite loops.
     *
     * @param value
     *            The object to unregister.
     * @since 2.3
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>unregister</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>&gt;</argument_list></name></type> <name>registry</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>registry</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>IDKey</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <synchronized>synchronized <init>(<expr><name><name>HashCodeBuilder</name><operator>.</operator><name>class</name></name></expr>)</init> <block>{
                <comment type="line">//read again</comment>
                <expr_stmt><expr><name>registry</name> <operator>=</operator> <call><name>getRegistry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>registry</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></synchronized>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Constant to use in building the hashCode.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>iConstant</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Running total of the hashCode.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>iTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Uses two hard coded choices for the constants needed to build a &lt;code&gt;hashCode&lt;/code&gt;.
     * &lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>HashCodeBuilder</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>iConstant</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <literal type="number">17</literal></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,
     * however this is not vital.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Prime numbers are preferred, especially for the multiplier.
     * &lt;/p&gt;
     *
     * @param initialNonZeroOddNumber
     *            a non-zero, odd number used as the initial value
     * @param multiplierNonZeroOddNumber
     *            a non-zero, odd number used as the multiplier
     * @throws IllegalArgumentException
     *             if the number is zero or even
     */</comment>
    <constructor><specifier>public</specifier> <name>HashCodeBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>initialNonZeroOddNumber</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>multiplierNonZeroOddNumber</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>initialNonZeroOddNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"HashCodeBuilder requires a non zero initial value"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>initialNonZeroOddNumber</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"HashCodeBuilder requires an odd initial value"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>multiplierNonZeroOddNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"HashCodeBuilder requires a non zero multiplier"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>multiplierNonZeroOddNumber</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"HashCodeBuilder requires an odd multiplier"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>iConstant</name> <operator>=</operator> <name>multiplierNonZeroOddNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>initialNonZeroOddNumber</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;boolean&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This adds &lt;code&gt;1&lt;/code&gt; when true, and &lt;code&gt;0&lt;/code&gt; when false to the &lt;code&gt;hashCode&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This is in contrast to the standard &lt;code&gt;java.lang.Boolean.hashCode&lt;/code&gt; handling, which computes
     * a &lt;code&gt;hashCode&lt;/code&gt; value of &lt;code&gt;1231&lt;/code&gt; for &lt;code&gt;java.lang.Boolean&lt;/code&gt; instances
     * that represent &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1237&lt;/code&gt; for &lt;code&gt;java.lang.Boolean&lt;/code&gt; instances
     * that represent &lt;code&gt;false&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This is in accordance with the &lt;quote&gt;Effective Java&lt;/quote&gt; design.
     * &lt;/p&gt;
     *
     * @param value
     *            the boolean to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>value</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;boolean&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">// -------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;byte&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the byte to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">// -------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;byte&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>byte</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;char&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the char to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;char&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>char</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;double&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the double to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>Double</name><operator>.</operator><name>doubleToLongBits</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;double&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>double</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;float&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the float to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <call><name><name>Float</name><operator>.</operator><name>floatToIntBits</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;float&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>float</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for an &lt;code&gt;int&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the int to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for an &lt;code&gt;int&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>int</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;long&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the long to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <comment type="line">// NOTE: This method uses &gt;&gt; and not &gt;&gt;&gt; as Effective Java and</comment>
    <comment type="line">//       Long.hashCode do. Ideally we should switch to &gt;&gt;&gt; at</comment>
    <comment type="line">//       some stage. There are backwards compat issues, so</comment>
    <comment type="line">//       that will have to wait for the time being. cf LANG-342.</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <operator>(</operator><call>(<name>int</name>) <argument_list>(<argument><expr><name>value</name> <operator>^</operator> <operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;long&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>long</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>

        }</block></then> <else>else <block>{
            <if>if<condition>(<expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// 'Switch' on type of array, to dispatch to the correct handler</comment>
                <comment type="line">// This handles multi dimensional arrays</comment>
                <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>long</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>int</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>short</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>char</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>byte</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>double</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>float</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>object</name> <operator>instanceof</operator> <name><name>boolean</name><index>[]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif> <else>else <block>{
                    <comment type="line">// Not an array of primitives</comment>
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <call><name><name>object</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Object</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;short&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param value
     *            the short to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append a &lt;code&gt;hashCode&lt;/code&gt; for a &lt;code&gt;short&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;hashCode&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>short</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Adds the result of super.hashCode() to this builder.
     * &lt;/p&gt;
     *
     * @param superHashCode
     *            the result of calling &lt;code&gt;super.hashCode()&lt;/code&gt;
     * @return this HashCodeBuilder, used to chain calls.
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>HashCodeBuilder</name></type> <name>appendSuper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>superHashCode</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>iTotal</name> <operator>=</operator> <name>iTotal</name> <operator>*</operator> <name>iConstant</name> <operator>+</operator> <name>superHashCode</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Return the computed &lt;code&gt;hashCode&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @return &lt;code&gt;hashCode&lt;/code&gt; based on the fields appended
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>toHashCode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>iTotal</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the computed &lt;code&gt;hashCode&lt;/code&gt;.
     *
     * @return &lt;code&gt;hashCode&lt;/code&gt; based on the fields appended
     *
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>Integer</name></type> <name>build</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name>toHashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The computed &lt;code&gt;hashCode&lt;/code&gt; from toHashCode() is returned due to the likelihood
     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for
     * HashCodeBuilder itself is.&lt;/p&gt;
     *
     * @return &lt;code&gt;hashCode&lt;/code&gt; based on the fields appended
     * @since 2.5
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>toHashCode</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

}


<comment type="block" format="javadoc">/**
 * &lt;p&gt;Assists in implementing {@link Object#equals(Object)} methods.&lt;/p&gt;
 *
 * &lt;p&gt; This class provides methods to build a good equals method for any
 * class. It follows rules laid out in
 * &lt;a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html"&gt;Effective Java&lt;/a&gt;
 * , by Joshua Bloch. In particular the rule for comparing &lt;code&gt;doubles&lt;/code&gt;,
 * &lt;code&gt;floats&lt;/code&gt;, and arrays can be tricky. Also, making sure that
 * &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; are consistent can be
 * difficult.&lt;/p&gt;
 *
 * &lt;p&gt;Two Objects that compare as equals must generate the same hash code,
 * but two Objects with the same hash code do not have to be equal.&lt;/p&gt;
 *
 * &lt;p&gt;All relevant fields should be included in the calculation of equals.
 * Derived fields may be ignored. In particular, any field used in
 * generating a hash code must be used in the equals method, and vice
 * versa.&lt;/p&gt;
 *
 * &lt;p&gt;Typical use for the code is as follows:&lt;/p&gt;
 * &lt;pre&gt;
 * public boolean equals(Object obj) {
 *   if (obj == null) { return false; }
 *   if (obj == this) { return true; }
 *   if (obj.getClass() != getClass()) {
 *     return false;
 *   }
 *   MyClass rhs = (MyClass) obj;
 *   return new EqualsBuilder()
 *                 .appendSuper(super.equals(obj))
 *                 .append(field1, rhs.field1)
 *                 .append(field2, rhs.field2)
 *                 .append(field3, rhs.field3)
 *                 .isEquals();
 *  }
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Alternatively, there is a method that uses reflection to determine
 * the fields to test. Because these fields are usually private, the method,
 * &lt;code&gt;reflectionEquals&lt;/code&gt;, uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to
 * change the visibility of the fields. This will fail under a security
 * manager, unless the appropriate permissions are set up correctly. It is
 * also slower than testing explicitly.&lt;/p&gt;
 *
 * &lt;p&gt; A typical invocation for this method would look like:&lt;/p&gt;
 * &lt;pre&gt;
 * public boolean equals(Object obj) {
 *   return EqualsBuilder.reflectionEquals(this, obj);
 * }
 * &lt;/pre&gt;
 *
 * @since 1.0
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>EqualsBuilder</name> implements <name><name>Builder</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name> <block>{

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.
     * &lt;/p&gt;
     *
     * @since 3.0
     */</comment>
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name> <name>REGISTRY</name> <operator>=</operator> <operator>new</operator> <call><name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;

    <comment type="block">/*
     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()
     * we are in the process of calculating.
     *
     * So we generate a one-to-one mapping from the original object to a new object.
     *
     * Now HashSet uses equals() to determine if two elements with the same hashcode really
     * are equal, so we also need to ensure that the replacement objects are only equal
     * if the original objects are identical.
     *
     * The original implementation (2.4 and before) used the System.indentityHashCode()
     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)
     *
     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)
     * to disambiguate the duplicate ids.
     */</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns the registry of object pairs being traversed by the reflection
     * methods in the current thread.
     * &lt;/p&gt;
     *
     * @return Set the registry of objects being traversed
     * @since 3.0
     */</comment>
    <expr><specifier>static</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name> <call><name>getRegistry</name><argument_list>()</argument_list></call> <block>{
        <return>return <expr><call><name><name>REGISTRY</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
    }</block>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Converters value pair into a register pair.
     * &lt;/p&gt;
     *
     * @param lhs &lt;code&gt;this&lt;/code&gt; object
     * @param rhs the other object
     *
     * @return the pair
     */</comment>
    <specifier>static</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name> <call><name>getRegisterPair</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>lhs</name></expr></argument>, <argument><expr><name>final</name> <name>Object</name> <name>rhs</name></expr></argument>)</argument_list></call> <block>{
        <expr><name>final</name> <name>IDKey</name> <name>left</name> <operator>=</operator> <operator>new</operator> <call><name>IDKey</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>final</name> <name>IDKey</name> <name>right</name> <operator>=</operator> <operator>new</operator> <call><name>IDKey</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name><name>Pair</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Returns &lt;code&gt;true&lt;/code&gt; if the registry contains the given object pair.
     * Used by the reflection methods to avoid infinite loops.
     * Objects might be swapped therefore a check is needed if the object pair
     * is registered in given or swapped order.
     * &lt;/p&gt;
     *
     * @param lhs &lt;code&gt;this&lt;/code&gt; object to lookup in registry
     * @param rhs the other object to lookup on registry
     * @return boolean &lt;code&gt;true&lt;/code&gt; if the registry contains the given object.
     * @since 3.0
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>isRegistered</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>registry</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></type> <name>pair</name> <init>= <expr><call><name>getRegisterPair</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></type> <name>swappedPair</name> <init>= <expr><call><name><name>Pair</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><call><name><name>pair</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pair</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>registry</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>registry</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>swappedPair</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Registers the given object pair.
     * Used by the reflection methods to avoid infinite loops.
     * &lt;/p&gt;
     *
     * @param lhs &lt;code&gt;this&lt;/code&gt; object to register
     * @param rhs the other object to register
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>register</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <synchronized>synchronized <init>(<expr><name><name>EqualsBuilder</name><operator>.</operator><name>class</name></name></expr>)</init> <block>{
            <if>if <condition>(<expr><call><name>getRegistry</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></synchronized>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>registry</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></type> <name>pair</name> <init>= <expr><call><name>getRegisterPair</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>registry</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Unregisters the given object pair.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Used by the reflection methods to avoid infinite loops.
     *
     * @param lhs &lt;code&gt;this&lt;/code&gt; object to unregister
     * @param rhs the other object to unregister
     * @since 3.0
     */</comment>
    <function><specifier>static</specifier> <type><name>void</name></type> <name>unregister</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>registry</name> <init>= <expr><call><name>getRegistry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>IDKey</name></argument>, <argument><name>IDKey</name></argument>&gt;</argument_list></name></type> <name>pair</name> <init>= <expr><call><name>getRegisterPair</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>registry</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <synchronized>synchronized <init>(<expr><name><name>EqualsBuilder</name><operator>.</operator><name>class</name></name></expr>)</init> <block>{
                <comment type="line">//read again</comment>
                <expr_stmt><expr><name>registry</name> <operator>=</operator> <call><name>getRegistry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>registry</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>registry</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>REGISTRY</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></synchronized>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * If the fields tested are equals.
     * The default value is &lt;code&gt;true&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>isEquals</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructor for EqualsBuilder.&lt;/p&gt;
     *
     * &lt;p&gt;Starts off assuming that equals is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     * @see Object#equals(Object)
     */</comment>
    <constructor><specifier>public</specifier> <name>EqualsBuilder</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// do nothing for now.</comment>
    }</block></constructor>

    <comment type="line">//-------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s
     * are equal.&lt;/p&gt;
     *
     * &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private
     * fields. This means that it will throw a security exception if run under
     * a security manager, if the permissions are not set up correctly. It is also
     * not as efficient as testing explicitly.&lt;/p&gt;
     *
     * &lt;p&gt;Transient members will be not be tested, as they are likely derived
     * fields, and not part of the value of the Object.&lt;/p&gt;
     *
     * &lt;p&gt;Static fields will not be tested. Superclass fields will be included.&lt;/p&gt;
     *
     * @param lhs  &lt;code&gt;this&lt;/code&gt; object
     * @param rhs  the other object
     * @param excludeFields  Collection of String field names to exclude from testing
     * @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>reflectionEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionEquals</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toNoNullStringArray</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s
     * are equal.&lt;/p&gt;
     *
     * &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private
     * fields. This means that it will throw a security exception if run under
     * a security manager, if the permissions are not set up correctly. It is also
     * not as efficient as testing explicitly.&lt;/p&gt;
     *
     * &lt;p&gt;Transient members will be not be tested, as they are likely derived
     * fields, and not part of the value of the Object.&lt;/p&gt;
     *
     * &lt;p&gt;Static fields will not be tested. Superclass fields will be included.&lt;/p&gt;
     *
     * @param lhs  &lt;code&gt;this&lt;/code&gt; object
     * @param rhs  the other object
     * @param excludeFields  array of field names to exclude from testing
     * @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>reflectionEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionEquals</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s
     * are equal.&lt;/p&gt;
     *
     * &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private
     * fields. This means that it will throw a security exception if run under
     * a security manager, if the permissions are not set up correctly. It is also
     * not as efficient as testing explicitly.&lt;/p&gt;
     *
     * &lt;p&gt;If the TestTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient
     * members will be tested, otherwise they are ignored, as they are likely
     * derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Static fields will not be tested. Superclass fields will be included.&lt;/p&gt;
     *
     * @param lhs  &lt;code&gt;this&lt;/code&gt; object
     * @param rhs  the other object
     * @param testTransients  whether to include transient fields
     * @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>reflectionEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>testTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionEquals</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s
     * are equal.&lt;/p&gt;
     *
     * &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private
     * fields. This means that it will throw a security exception if run under
     * a security manager, if the permissions are not set up correctly. It is also
     * not as efficient as testing explicitly.&lt;/p&gt;
     *
     * &lt;p&gt;If the testTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient
     * members will be tested, otherwise they are ignored, as they are likely
     * derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Static fields will not be included. Superclass fields will be appended
     * up to and including the specified superclass. A null superclass is treated
     * as java.lang.Object.&lt;/p&gt;
     *
     * @param lhs  &lt;code&gt;this&lt;/code&gt; object
     * @param rhs  the other object
     * @param testTransients  whether to include transient fields
     * @param reflectUpToClass  the superclass to reflect up to (inclusive),
     *  may be &lt;code&gt;null&lt;/code&gt;
     * @param excludeFields  array of field names to exclude from testing
     * @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>reflectionEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>testTransients</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>,
                                           <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// Find the leaf class since there may be transients in the leaf</comment>
        <comment type="line">// class or in classes between the leaf and root.</comment>
        <comment type="line">// If we are not testing transients or a subclass has no ivars,</comment>
        <comment type="line">// then a subclass can test equals to a superclass.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>lhsClass</name> <init>= <expr><call><name><name>lhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rhsClass</name> <init>= <expr><call><name><name>rhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>testClass</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>lhsClass</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>testClass</name> <operator>=</operator> <name>lhsClass</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>rhsClass</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// rhsClass is a subclass of lhsClass</comment>
                <expr_stmt><expr><name>testClass</name> <operator>=</operator> <name>rhsClass</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>rhsClass</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>testClass</name> <operator>=</operator> <name>rhsClass</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>lhsClass</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// lhsClass is a subclass of rhsClass</comment>
                <expr_stmt><expr><name>testClass</name> <operator>=</operator> <name>lhsClass</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="line">// The two classes are not related.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></else></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>EqualsBuilder</name></type> <name>equalsBuilder</name> <init>= <expr><operator>new</operator> <call><name>EqualsBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>testClass</name></expr></argument>, <argument><expr><name>equalsBuilder</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name><name>testClass</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>testClass</name> <operator>!=</operator> <name>reflectUpToClass</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>testClass</name> <operator>=</operator> <call><name><name>testClass</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>testClass</name></expr></argument>, <argument><expr><name>equalsBuilder</name></expr></argument>, <argument><expr><name>testTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalArgumentException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
            <comment type="line">// In this case, we tried to test a subclass vs. a superclass and</comment>
            <comment type="line">// the subclass has ivars or the ivars are transient and</comment>
            <comment type="line">// we are testing transients.</comment>
            <comment type="line">// If a subclass has ivars that we are trying to test them, we get an</comment>
            <comment type="line">// exception and we know that the objects are not equal.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></catch></try>
        <return>return <expr><call><name><name>equalsBuilder</name><operator>.</operator><name>isEquals</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends the fields and values defined by the given object of the
     * given Class.&lt;/p&gt;
     *
     * @param lhs  the left hand object
     * @param rhs  the right hand object
     * @param clazz  the class to append details of
     * @param builder  the builder to append to
     * @param useTransients  whether to test transient fields
     * @param excludeFields  array of field names to exclude from testing
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reflectionAppend</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>EqualsBuilder</name></type> <name>builder</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useTransients</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{

        <if>if <condition>(<expr><call><name>isRegistered</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <try>try <block>{
            <expr_stmt><expr><call><name>register</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Field</name><index>[]</index></name></type> <name>fields</name> <init>= <expr><call><name><name>clazz</name><operator>.</operator><name>getDeclaredFields</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>AccessibleObject</name><operator>.</operator><name>setAccessible</name></name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fields</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name><name>builder</name><operator>.</operator><name>isEquals</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>Field</name></type> <name>f</name> <init>= <expr><name><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><call><name><name>ArrayUtils</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                        <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>f</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><name>useTransients</name> <operator>||</operator> <operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isTransient</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isStatic</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                    <try>try <block>{
                        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalAccessException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                        <comment type="line">//this can't happen. Would get a Security exception instead</comment>
                        <comment type="line">//throw a runtime exception in case the impossible happens.</comment>
                        <throw>throw <expr><operator>new</operator> <call><name>InternalError</name><argument_list>(<argument><expr><literal type="string">"Unexpected IllegalAccessException"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                }</block></then></if>
            }</block></for>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name>unregister</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="line">//-------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Adds the result of &lt;code&gt;super.equals()&lt;/code&gt; to this builder.&lt;/p&gt;
     *
     * @param superEquals  the result of calling &lt;code&gt;super.equals()&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>appendSuper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>superEquals</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <name>superEquals</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;Object&lt;/code&gt;s are equal using their
     * &lt;code&gt;equals&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param lhs  the left hand object
     * @param rhs  the right hand object
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>lhsClass</name> <init>= <expr><call><name><name>lhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>lhsClass</name><operator>.</operator><name>isArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// The simple case, not an array, just test the element</comment>
            <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <call><name><name>lhs</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>lhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>rhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Here when we compare different dimensions, for example: a boolean[][] to a boolean[]</comment>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif>
        <comment type="line">// 'Switch' on type of array, to dispatch to the correct handler</comment>
        <comment type="line">// This handles multi dimensional arrays of the same depth</comment>
        <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>long</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>int</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>short</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>char</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>byte</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>double</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>float</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>boolean</name><index>[]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="line">// Not an array of primitives</comment>
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Test if two &lt;code&gt;long&lt;/code&gt; s are equal.
     * &lt;/p&gt;
     *
     * @param lhs
     *                  the left hand &lt;code&gt;long&lt;/code&gt;
     * @param rhs
     *                  the right hand &lt;code&gt;long&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;int&lt;/code&gt;s are equal.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;int&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;int&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;short&lt;/code&gt;s are equal.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;short&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;short&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;char&lt;/code&gt;s are equal.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;char&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;char&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;byte&lt;/code&gt;s are equal.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;byte&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;byte&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;double&lt;/code&gt;s are equal by testing that the
     * pattern of bits returned by &lt;code&gt;doubleToLong&lt;/code&gt; are equal.&lt;/p&gt;
     *
     * &lt;p&gt;This handles NaNs, Infinities, and &lt;code&gt;-0.0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;It is compatible with the hash code generated by
     * &lt;code&gt;HashCodeBuilder&lt;/code&gt;.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;double&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;double&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>Double</name><operator>.</operator><name>doubleToLongBits</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Double</name><operator>.</operator><name>doubleToLongBits</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;float&lt;/code&gt;s are equal byt testing that the
     * pattern of bits returned by doubleToLong are equal.&lt;/p&gt;
     *
     * &lt;p&gt;This handles NaNs, Infinities, and &lt;code&gt;-0.0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;It is compatible with the hash code generated by
     * &lt;code&gt;HashCodeBuilder&lt;/code&gt;.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;float&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;float&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>Float</name><operator>.</operator><name>floatToIntBits</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Float</name><operator>.</operator><name>floatToIntBits</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Test if two &lt;code&gt;booleans&lt;/code&gt;s are equal.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;boolean&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;boolean&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>isEquals</name> <operator>=</operator> <operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Performs a deep comparison of two &lt;code&gt;Object&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;p&gt;This also will be called for the top level of
     * multi-dimensional, ragged, and multi-typed arrays.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;Object[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;Object[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;long&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(long, long)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;long[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;long[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;int&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(int, int)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;int[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;int[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;short&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(short, short)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;short[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;short[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;char&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(char, char)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;char[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;char[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;byte&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(byte, byte)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;byte[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;byte[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;double&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(double, double)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;double[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;double[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;float&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(float, float)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;float[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;float[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Deep comparison of array of &lt;code&gt;boolean&lt;/code&gt;. Length and all
     * values are compared.&lt;/p&gt;
     *
     * &lt;p&gt;The method {@link #append(boolean, boolean)} is used.&lt;/p&gt;
     *
     * @param lhs  the left hand &lt;code&gt;boolean[]&lt;/code&gt;
     * @param rhs  the right hand &lt;code&gt;boolean[]&lt;/code&gt;
     * @return EqualsBuilder - used to chain calls.
     */</comment>
    <function><specifier>public</specifier> <type><name>EqualsBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>isEquals</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setEquals</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>isEquals</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if the fields that have been checked
     * are all equal.&lt;/p&gt;
     *
     * @return boolean
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isEquals</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>isEquals</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if the fields that have been checked
     * are all equal.&lt;/p&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all of the fields that have been checked
     *         are equal, &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>Boolean</name></type> <name>build</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>Boolean</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name>isEquals</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the &lt;code&gt;isEquals&lt;/code&gt; value.
     *
     * @param isEquals The value to set.
     * @since 2.1
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>setEquals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isEquals</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isEquals</name></name> <operator>=</operator> <name>isEquals</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Reset the EqualsBuilder so you can use the same object again
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isEquals</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    }</block></function>
}


<comment type="block" format="javadoc">/**
 * A mutable &lt;code&gt;int&lt;/code&gt; wrapper.
 * &lt;p&gt;
 * Note that as MutableInt does not extend Integer, it is not treated by String.format as an Integer parameter.
 *
 * @see Integer
 * @since 2.1
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>MutableInt</name> extends <name>Number</name> implements <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>MutableInt</name></argument>&gt;</argument_list></name></expr><operator>,</operator> <expr><name><name>Mutable</name><argument_list type="generic">&lt;<argument><name>Number</name></argument>&gt;</argument_list></name> <block>{

    <comment type="block" format="javadoc">/**
     * Required for serialization support.
     *
     * @see java.io.Serializable
     */</comment>
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>long</name> <name>serialVersionUID</name> <operator>=</operator> <literal type="number">512176391864L</literal></expr>;

    <comment type="block" format="javadoc">/** The mutable value. */</comment>
    <expr><specifier>private</specifier> <name>int</name> <name>value</name></expr>;

    <comment type="block" format="javadoc">/**
     * Constructs a new MutableInt with the default value of zero.
     */</comment>
    <expr><specifier>public</specifier> <call><name>MutableInt</name><argument_list>()</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Constructs a new MutableInt with the specified value.
     *
     * @param value  the initial value to store
     */</comment>
    <specifier>public</specifier> <call><name>MutableInt</name><argument_list>(<argument><expr><name>final</name> <name>int</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
        <expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Constructs a new MutableInt with the specified value.
     *
     * @param value  the initial value to store, not null
     * @throws NullPointerException if the object is null
     */</comment>
    <specifier>public</specifier> <call><name>MutableInt</name><argument_list>(<argument><expr><name>final</name> <name>Number</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
        <expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name><name>value</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Constructs a new MutableInt parsing the given string.
     *
     * @param value  the string to parse, not null
     * @throws NumberFormatException if the string cannot be parsed into an int
     * @since 2.5
     */</comment>
    <specifier>public</specifier> <call><name>MutableInt</name><argument_list>(<argument><expr><name>final</name> <name>String</name> <name>value</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>NumberFormatException</name> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
        <expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the value as a Integer instance.
     *
     * @return the value as a Integer, never null
     */</comment>
    @<name>Override</name>
    <specifier>public</specifier> <name>Integer</name> <call><name>getValue</name><argument_list>()</argument_list></call> <block>{
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block" format="javadoc">/**
     * Sets the value.
     *
     * @param value  the value to set
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the value from any Number instance.
     *
     * @param value  the value to set, not null
     * @throws NullPointerException if the object is null
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>void</name></type> <name>setValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Number</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name><name>value</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Increments the value.
     *
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>increment</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>value</name><operator>++</operator></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Decrements the value.
     *
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>decrement</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>value</name><operator>--</operator></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Adds a value to the value of this instance.
     *
     * @param operand  the value to add, not null
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>operand</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>+=</operator> <name>operand</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Adds a value to the value of this instance.
     *
     * @param operand  the value to add, not null
     * @throws NullPointerException if the object is null
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Number</name></type> <name>operand</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>+=</operator> <call><name><name>operand</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Subtracts a value from the value of this instance.
     *
     * @param operand  the value to subtract, not null
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>subtract</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>operand</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>-=</operator> <name>operand</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Subtracts a value from the value of this instance.
     *
     * @param operand  the value to subtract, not null
     * @throws NullPointerException if the object is null
     * @since Commons Lang 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>subtract</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Number</name></type> <name>operand</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>-=</operator> <call><name><name>operand</name><operator>.</operator><name>intValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="line">// shortValue and byteValue rely on Number implementation</comment>
    <comment type="block" format="javadoc">/**
     * Returns the value of this MutableInt as an int.
     *
     * @return the numeric value represented by this object after conversion to type int.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>intValue</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the value of this MutableInt as a long.
     *
     * @return the numeric value represented by this object after conversion to type long.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>long</name></type> <name>longValue</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the value of this MutableInt as a float.
     *
     * @return the numeric value represented by this object after conversion to type float.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>float</name></type> <name>floatValue</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the value of this MutableInt as a double.
     *
     * @return the numeric value represented by this object after conversion to type double.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>double</name></type> <name>doubleValue</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets this mutable as an instance of Integer.
     *
     * @return a Integer instance containing the value from this mutable, never null
     */</comment>
    <function><specifier>public</specifier> <type><name>Integer</name></type> <name>toInteger</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name>intValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Compares this object to the specified object. The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
     * not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;MutableInt&lt;/code&gt; object that contains the same &lt;code&gt;int&lt;/code&gt; value
     * as this object.
     *
     * @param obj  the object to compare with, null returns false
     * @return &lt;code&gt;true&lt;/code&gt; if the objects are the same; &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>instanceof</operator> <name>MutableInt</name></expr>)</condition><then> <block>{
            <return>return <expr><name>value</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>MutableInt</name><operator>)</operator> <name>obj</name><operator>)</operator><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a suitable hash code for this mutable.
     *
     * @return a suitable hash code
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Compares this mutable to another in ascending order.
     *
     * @param other  the other mutable to compare to, not null
     * @return negative if this is less, zero if equal, positive if greater
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>MutableInt</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>anotherVal</name> <init>= <expr><name><name>other</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>value</name> <operator>&lt;</operator> <name>anotherVal</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>value</name> <operator>==</operator> <name>anotherVal</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Returns the String value of this mutable.
     *
     * @return the mutable value as a string
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

}


<comment type="block" format="javadoc">/**
 * Builds a string from constituent parts providing a more flexible and powerful API
 * than StringBuffer.
 * &lt;p&gt;
 * The main differences from StringBuffer/StringBuilder are:
 * &lt;ul&gt;
 * &lt;li&gt;Not synchronized&lt;/li&gt;
 * &lt;li&gt;Not final&lt;/li&gt;
 * &lt;li&gt;Subclasses have direct access to character array&lt;/li&gt;
 * &lt;li&gt;Additional methods
 *  &lt;ul&gt;
 *   &lt;li&gt;appendWithSeparators - adds an array of values, with a separator&lt;/li&gt;
 *   &lt;li&gt;appendPadding - adds a length padding characters&lt;/li&gt;
 *   &lt;li&gt;appendFixedLength - adds a fixed width field to the builder&lt;/li&gt;
 *   &lt;li&gt;toCharArray/getChars - simpler ways to get a range of the character array&lt;/li&gt;
 *   &lt;li&gt;delete - delete char or string&lt;/li&gt;
 *   &lt;li&gt;replace - search and replace for a char or string&lt;/li&gt;
 *   &lt;li&gt;leftString/rightString/midString - substring without exceptions&lt;/li&gt;
 *   &lt;li&gt;contains - whether the builder contains a char or string&lt;/li&gt;
 *   &lt;li&gt;size/clear/isEmpty - collections style API methods&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;li&gt;Views
 *  &lt;ul&gt;
 *   &lt;li&gt;asTokenizer - uses the internal buffer as the source of a StrTokenizer&lt;/li&gt;
 *   &lt;li&gt;asReader - uses the internal buffer as the source of a Reader&lt;/li&gt;
 *   &lt;li&gt;asWriter - allows a Writer to write directly to the internal buffer&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The aim has been to provide an API that mimics very closely what StringBuffer
 * provides, but with additional methods. It should be noted that some edge cases,
 * with invalid indices or null input, have been altered - see individual methods.
 * The biggest of these changes is that by default, null will not output the text
 * 'null'. This can be controlled by a property, {@link #setNullText(String)}.
 * &lt;p&gt;
 * Prior to 3.0, this class implemented Cloneable but did not implement the
 * clone method so could not be used. From 3.0 onwards it no longer implements
 * the interface.
 *
 * @since 2.2
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>StrBuilder</name> implements <name>CharSequence</name></expr><operator>,</operator> <expr><name>Appendable</name></expr><operator>,</operator> <expr><name>Serializable</name></expr><operator>,</operator> <expr><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name> <block>{

    <comment type="block" format="javadoc">/**
     * The extra capacity for new builders.
     */</comment>
    <expr><specifier>static</specifier> <name>final</name> <name>int</name> <name>CAPACITY</name> <operator>=</operator> <literal type="number">32</literal></expr>;

    <comment type="block" format="javadoc">/**
     * Required for serialization support.
     *
     * @see java.io.Serializable
     */</comment>
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>long</name> <name>serialVersionUID</name> <operator>=</operator> <literal type="number">7628716375283629643L</literal></expr>;

    <comment type="block" format="javadoc">/** Internal data storage. */</comment>
    <expr><specifier>protected</specifier> <name><name>char</name><index>[]</index></name> <name>buffer</name></expr>; <comment type="line">// TODO make private?</comment>
    <comment type="block" format="javadoc">/** Current size of the buffer. */</comment>
    <expr><specifier>protected</specifier> <name>int</name> <name>size</name></expr>; <comment type="line">// TODO make private?</comment>
    <comment type="block" format="javadoc">/** The new line. */</comment>
    <expr><specifier>private</specifier> <name>String</name> <name>newLine</name></expr>;
    <comment type="block" format="javadoc">/** The null text. */</comment>
    <expr><specifier>private</specifier> <name>String</name> <name>nullText</name></expr>;

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Constructor that creates an empty builder initial capacity 32 characters.
     */</comment>
    <expr><specifier>public</specifier> <call><name>StrBuilder</name><argument_list>()</argument_list></call> <block>{
        <expr><call><name>this</name><argument_list>(<argument><expr><name>CAPACITY</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Constructor that creates an empty builder the specified initial capacity.
     *
     * @param initialCapacity  the initial capacity, zero or less will be converted to 32
     */</comment>
    <specifier>public</specifier> <call><name>StrBuilder</name><argument_list>(<argument><expr><name>int</name> <name>initialCapacity</name></expr></argument>)</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
        <if>if <condition>(<expr><name>initialCapacity</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>initialCapacity</name> <operator>=</operator> <name>CAPACITY</name></expr>;</expr_stmt>
        <expr_stmt/></block></then></if>}</block>
        <name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name>initialCapacity</name></expr>]</index></name></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Constructor that creates a builder from the string, allocating
     * 32 extra characters for growth.
     *
     * @param str  the string to copy, null treated as blank string
     */</comment>
    <specifier>public</specifier> <call><name>StrBuilder</name><argument_list>(<argument><expr><name>final</name> <name>String</name> <name>str</name></expr></argument>)</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name>CAPACITY</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt/></block></then></if>}</block></expr></expr_stmt> <else>else <block>{
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>CAPACITY</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else>
    }

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the text to be appended when a new line is added.
     *
     * @return the new line text, null means use system default
     */</comment>
    public <function><type><name>String</name></type> <name>getNewLineText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>newLine</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the text to be appended when a new line is added.
     *
     * @param newLine  the new line text, null means use system default
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>setNewLineText</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>newLine</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>newLine</name></name> <operator>=</operator> <name>newLine</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the text to be appended when null is added.
     *
     * @return the null text, null means no append
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>getNullText</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>nullText</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the text to be appended when null is added.
     *
     * @param nullText  the null text, null means no append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>setNullText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>nullText</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>nullText</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>nullText</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>nullText</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nullText</name></name> <operator>=</operator> <name>nullText</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the length of the string builder.
     *
     * @return the length
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>length</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>size</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Updates the length of the builder by either dropping the last characters
     * or adding filler of Unicode zero.
     *
     * @param length  the length to set to, must be zero or positive
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the length is negative
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>setLength</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>oldEnd</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newEnd</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>oldEnd</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>newEnd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if></elseif></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the current size of the internal character array buffer.
     *
     * @return the capacity
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>capacity</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>buffer</name><operator>.</operator><name>length</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks the capacity and ensures that it is at least the size specified.
     *
     * @param capacity  the capacity to ensure
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>ensureCapacity</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>capacity</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>capacity</name> <operator>&gt;</operator> <name><name>buffer</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>old</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name>capacity</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Minimizes the capacity to the actual length of the string.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>minimizeCapacity</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>buffer</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <call><name>length</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>old</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><call><name>length</name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the length of the string builder.
     * &lt;p&gt;
     * This method is the same as {@link #length()} and is provided to match the
     * API of Collections.
     *
     * @return the length
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>size</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks is the string builder is empty (convenience Collections API style method).
     * &lt;p&gt;
     * This method is the same as checking {@link #length()} and is provided to match the
     * API of Collections.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the size is &lt;code&gt;0&lt;/code&gt;.
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isEmpty</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Clears the string builder (convenience Collections API style method).
     * &lt;p&gt;
     * This method does not reduce the size of the internal character buffer.
     * To do that, call &lt;code&gt;clear()&lt;/code&gt; followed by {@link #minimizeCapacity()}.
     * &lt;p&gt;
     * This method is the same as {@link #setLength(int)} called with zero
     * and is provided to match the API of Collections.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the character at the specified index.
     *
     * @see #setCharAt(int, char)
     * @see #deleteCharAt(int)
     * @param index  the index to retrieve, must be valid
     * @return the character at the index
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>char</name></type> <name>charAt</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <call><name>length</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name><name>buffer</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the character at the specified index.
     *
     * @see #charAt(int)
     * @see #deleteCharAt(int)
     * @param index  the index to set
     * @param ch  the new character
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>setCharAt</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <call><name>length</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Deletes the character at the specified index.
     *
     * @see #charAt(int)
     * @see #setCharAt(int, char)
     * @param index  the index to delete
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteCharAt</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Copies the builder's character array into a new character array.
     *
     * @return a new array that represents the contents of the builder
     */</comment>
    <function><specifier>public</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>toCharArray</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_CHAR_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>chars</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>chars</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Copies part of the builder's character array into a new character array.
     *
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except that
     *  if too large it is treated as end of string
     * @return a new array that holds part of the contents of the builder
     * @throws IndexOutOfBoundsException if startIndex is invalid,
     *  or if endIndex is invalid (but endIndex greater than size is valid)
     */</comment>
    <function><specifier>public</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>toCharArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <call><name>validateRange</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_CHAR_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>chars</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>chars</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Copies the character array into the specified array.
     *
     * @param destination  the destination array, null will cause an array to be created
     * @return the input array, unless that was null or too small
     */</comment>
    <function><specifier>public</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>getChars</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>destination</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>destination</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>destination</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>destination</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>destination</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Copies the character array into the specified array.
     *
     * @param startIndex  first index to copy, inclusive, must be valid
     * @param endIndex  last index, exclusive, must be valid
     * @param destination  the destination array, must not be null or too small
     * @param destinationIndex  the index to start copying in destination
     * @throws NullPointerException if the array is null
     * @throws IndexOutOfBoundsException if any index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>getChars</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>destination</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>destinationIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>endIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>endIndex</name></argument> &gt;</argument_list></name> <call><name>length</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;</operator> <name>endIndex</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"end &lt; start"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>destinationIndex</name></expr></argument>, <argument><expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends the new line string to this string builder.
     * &lt;p&gt;
     * The new line string can be altered using {@link #setNewLineText(String)}.
     * This might be used to force the output to always use Unix line endings
     * even when on Windows.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendNewLine</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>newLine</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>  <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>SystemUtils</name><operator>.</operator><name>LINE_SEPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>newLine</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends the text representing &lt;code&gt;null&lt;/code&gt; to this string builder.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendNull</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>nullText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>  <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>nullText</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an object to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param obj  the object to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a CharSequence to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param seq  the CharSequence to append
     * @return this, to enable chaining
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>seq</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a CharSequence to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param seq  the CharSequence to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>seq</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>seq</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a string to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Appends part of a string to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>startIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>startIndex</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"startIndex must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>startIndex</name> <operator>+</operator> <name>length</name><operator>)</operator></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"length must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>startIndex</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calls {@link String#format(String, Object...)} and appends the result.
     *
     * @param format the format string
     * @param objs the objects to use in the format string
     * @return {@code this} to enable chaining
     * @see String#format(String, Object...)
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>objs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a string buffer to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string buffer to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string buffer to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>startIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>startIndex</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"startIndex must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>startIndex</name> <operator>+</operator> <name>length</name><operator>)</operator></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"length must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>startIndex</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a StringBuilder to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str the StringBuilder to append
     * @return this, to enable chaining
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a StringBuilder to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str the StringBuilder to append
     * @param startIndex the start index, inclusive, must be valid
     * @param length the length to append, must be valid
     * @return this, to enable chaining
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>startIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>startIndex</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"startIndex must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>startIndex</name> <operator>+</operator> <name>length</name><operator>)</operator></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"length must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>startIndex</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends another string builder to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string builder to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string builder to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>startIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>startIndex</name></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"startIndex must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>startIndex</name> <operator>+</operator> <name>length</name><operator>)</operator></argument> &gt;</argument_list></name> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"length must be valid"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>startIndex</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char array to the string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param chars  the char array to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><name><name>chars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char array to the string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param chars  the char array to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>appendNull</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>startIndex</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>startIndex</name></argument> &gt;</argument_list></name> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Invalid startIndex: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>startIndex</name> <operator>+</operator> <name>length</name><operator>)</operator></argument> &gt;</argument_list></name> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Invalid length: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a boolean value to the string builder.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char value to the string builder.
     *
     * @param ch  the value to append
     * @return this, to enable chaining
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an int value to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a long value to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a float value to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a double value to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends an object followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param obj  the object to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a string followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calls {@link String#format(String, Object...)} and appends the result.
     *
     * @param format the format string
     * @param objs the objects to use in the format string
     * @return {@code this} to enable chaining
     * @see String#format(String, Object...)
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>objs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a string buffer followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string buffer to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a string builder followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string builder to append
     * @return this, to enable chaining
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string builder followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string builder to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string buffer followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends another string builder followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string builder to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends part of a string builder followed by a new line to this string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param str  the string to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char array followed by a new line to the string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param chars  the char array to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char array followed by a new line to the string builder.
     * Appending null will call {@link #appendNull()}.
     *
     * @param chars  the char array to append
     * @param startIndex  the start index, inclusive, must be valid
     * @param length  the length to append, must be valid
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a boolean value followed by a new line to the string builder.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a char value followed by a new line to the string builder.
     *
     * @param ch  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an int value followed by a new line to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a long value followed by a new line to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a float value followed by a new line to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a double value followed by a new line to the string builder using &lt;code&gt;String.valueOf&lt;/code&gt;.
     *
     * @param value  the value to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendln</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>appendNewLine</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends each item in an array to the builder without any separators.
     * Appending a null array will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param &lt;T&gt;  the element type
     * @param array  the array to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>StrBuilder</name></type> <name>appendAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name><modifier>...</modifier></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Object</name></type> <name>element</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends each item in a iterable to the builder without any separators.
     * Appending a null iterable will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param iterable  the iterable to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterable</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>iterable</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Object</name></type> <name>o</name> <range>: <expr><name>iterable</name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends each item in an iterator to the builder without any separators.
     * Appending a null iterator will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param it  the iterator to append
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>it</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>it</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends an array placing separators between each value, but
     * not before the first or after the last.
     * Appending a null array will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param array  the array to append
     * @param separator  the separator to use, null means no separator
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendWithSeparators</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>array</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name><name>ObjectUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a iterable placing separators between each value, but
     * not before the first or after the last.
     * Appending a null iterable will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param iterable  the iterable to append
     * @param separator  the separator to use, null means no separator
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendWithSeparators</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>iterable</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>iterable</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name><name>ObjectUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>iterable</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an iterator placing separators between each value, but
     * not before the first or after the last.
     * Appending a null iterator will have no effect.
     * Each object is appended using {@link #append(Object)}.
     *
     * @param it  the iterator to append
     * @param separator  the separator to use, null means no separator
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendWithSeparators</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>it</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>it</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name><name>ObjectUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends a separator if the builder is currently non-empty.
     * Appending a null separator will have no effect.
     * The separator is appended using {@link #append(String)}.
     * &lt;p&gt;
     * This method is useful for adding a separator each time around the
     * loop except the first.
     * &lt;pre&gt;
     * for (Iterator it = list.iterator(); it.hasNext(); ) {
     *   appendSeparator(",");
     *   append(it.next());
     * }
     * &lt;/pre&gt;
     * Note that for this simple example, you should use
     * {@link #appendWithSeparators(Iterable, String)}.
     *
     * @param separator  the separator to use, null means no separator
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>appendSeparator</name><argument_list>(<argument><expr><name>separator</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends one of both separators to the StrBuilder.
     * If the builder is currently empty it will append the defaultIfEmpty-separator
     * Otherwise it will append the standard-separator
     *
     * Appending a null separator will have no effect.
     * The separator is appended using {@link #append(String)}.
     * &lt;p&gt;
     * This method is for example useful for constructing queries
     * &lt;pre&gt;
     * StrBuilder whereClause = new StrBuilder();
     * if(searchCommand.getPriority() != null) {
     *  whereClause.appendSeparator(" and", " where");
     *  whereClause.append(" priority = ?")
     * }
     * if(searchCommand.getComponent() != null) {
     *  whereClause.appendSeparator(" and", " where");
     *  whereClause.append(" component = ?")
     * }
     * selectClause.append(whereClause)
     * &lt;/pre&gt;
     *
     * @param standard the separator if builder is not empty, null means no separator
     * @param defaultIfEmpty the separator if builder is empty, null means no separator
     * @return this, to enable chaining
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>standard</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>defaultIfEmpty</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name> <init>= <expr><ternary><condition><expr><call><name>isEmpty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>defaultIfEmpty</name></expr> </then><else>: <expr><name>standard</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a separator if the builder is currently non-empty.
     * The separator is appended using {@link #append(char)}.
     * &lt;p&gt;
     * This method is useful for adding a separator each time around the
     * loop except the first.
     * &lt;pre&gt;
     * for (Iterator it = list.iterator(); it.hasNext(); ) {
     *   appendSeparator(',');
     *   append(it.next());
     * }
     * &lt;/pre&gt;
     * Note that for this simple example, you should use
     * {@link #appendWithSeparators(Iterable, String)}.
     *
     * @param separator  the separator to use
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Append one of both separators to the builder
     * If the builder is currently empty it will append the defaultIfEmpty-separator
     * Otherwise it will append the standard-separator
     *
     * The separator is appended using {@link #append(char)}.
     * @param standard the separator if builder is not empty
     * @param defaultIfEmpty the separator if builder is empty
     * @return this, to enable chaining
     * @since 2.5
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>standard</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>defaultIfEmpty</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>standard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>defaultIfEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>
    <comment type="block" format="javadoc">/**
     * Appends a separator to the builder if the loop index is greater than zero.
     * Appending a null separator will have no effect.
     * The separator is appended using {@link #append(String)}.
     * &lt;p&gt;
     * This method is useful for adding a separator each time around the
     * loop except the first.
     * &lt;pre&gt;
     * for (int i = 0; i &lt; list.size(); i++) {
     *   appendSeparator(",", i);
     *   append(list.get(i));
     * }
     * &lt;/pre&gt;
     * Note that for this simple example, you should use
     * {@link #appendWithSeparators(Iterable, String)}.
     *
     * @param separator  the separator to use, null means no separator
     * @param loopIndex  the loop index
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>loopIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>separator</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>loopIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends a separator to the builder if the loop index is greater than zero.
     * The separator is appended using {@link #append(char)}.
     * &lt;p&gt;
     * This method is useful for adding a separator each time around the
     * loop except the first.
     * &lt;pre&gt;
     * for (int i = 0; i &lt; list.size(); i++) {
     *   appendSeparator(",", i);
     *   append(list.get(i));
     * }
     * &lt;/pre&gt;
     * Note that for this simple example, you should use
     * {@link #appendWithSeparators(Iterable, String)}.
     *
     * @param separator  the separator to use
     * @param loopIndex  the loop index
     * @return this, to enable chaining
     * @since 2.3
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendSeparator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>loopIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>loopIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends the pad character to the builder the specified number of times.
     *
     * @param length  the length to append, negative means no append
     * @param padChar  the character to append
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendPadding</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>padChar</name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends an object to the builder padding on the left to a fixed width.
     * The &lt;code&gt;toString&lt;/code&gt; of the object is used.
     * If the object is larger than the length, the left hand side is lost.
     * If the object is null, the null text value is used.
     *
     * @param obj  the object to append, null uses null text
     * @param width  the fixed field width, zero or negative has no effect
     * @param padChar  the pad character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendFixedWidthPadLeft</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>str</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name>getNullText</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>strLen</name> <operator>&gt;=</operator> <name>width</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>strLen</name> <operator>-</operator> <name>width</name></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>padLen</name> <init>= <expr><name>width</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>padLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>padChar</name></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <name>padLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>width</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an object to the builder padding on the left to a fixed width.
     * The &lt;code&gt;String.valueOf&lt;/code&gt; of the &lt;code&gt;int&lt;/code&gt; value is used.
     * If the formatted value is larger than the length, the left hand side is lost.
     *
     * @param value  the value to append
     * @param width  the fixed field width, zero or negative has no effect
     * @param padChar  the pad character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendFixedWidthPadLeft</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>appendFixedWidthPadLeft</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an object to the builder padding on the right to a fixed length.
     * The &lt;code&gt;toString&lt;/code&gt; of the object is used.
     * If the object is larger than the length, the right hand side is lost.
     * If the object is null, null text value is used.
     *
     * @param obj  the object to append, null uses null text
     * @param width  the fixed field width, zero or negative has no effect
     * @param padChar  the pad character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendFixedWidthPadRight</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>str</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name>getNullText</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>strLen</name> <operator>&gt;=</operator> <name>width</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>padLen</name> <init>= <expr><name>width</name> <operator>-</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>padLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name> <operator>+</operator> <name>strLen</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>padChar</name></expr>;</expr_stmt>
                }</block></for>
            }</block></else></if>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>width</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends an object to the builder padding on the right to a fixed length.
     * The &lt;code&gt;String.valueOf&lt;/code&gt; of the &lt;code&gt;int&lt;/code&gt; value is used.
     * If the object is larger than the length, the right hand side is lost.
     *
     * @param value  the value to append
     * @param width  the fixed field width, zero or negative has no effect
     * @param padChar  the pad character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>appendFixedWidthPadRight</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>padChar</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>appendFixedWidthPadRight</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>padChar</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Inserts the string representation of an object into this builder.
     * Inserting null will use the stored null text value.
     *
     * @param index  the index to add at, must be valid
     * @param obj  the object to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>nullText</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>obj</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the string into this builder.
     * Inserting null will use the stored null text value.
     *
     * @param index  the index to add at, must be valid
     * @param str  the string to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>validateIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>str</name> <operator>=</operator> <name>nullText</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>str</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>size</name> <operator>+</operator> <name>strLen</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>strLen</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>size</name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>strLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the character array into this builder.
     * Inserting null will use the stored null text value.
     *
     * @param index  the index to add at, must be valid
     * @param chars  the char array to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>chars</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>validateIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>nullText</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name><name>chars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts part of the character array into this builder.
     * Inserting null will use the stored null text value.
     *
     * @param index  the index to add at, must be valid
     * @param chars  the char array to insert
     * @param offset  the offset into the character array to start at, must be valid
     * @param length  the length of the character array part to copy, must be positive
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if any index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>chars</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>validateIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>nullText</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>offset</name></argument> &gt;</argument_list></name> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Invalid offset: "</literal> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>offset</name> <operator>+</operator> <name>length</name></argument> &gt;</argument_list></name> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"Invalid length: "</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>validateIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>validateIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Inserts the value into this builder.
     *
     * @param index  the index to add at, must be valid
     * @param value  the value to insert
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>insert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>insert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Internal method to delete a range without validation.
     *
     * @param startIndex  the start index, must be valid
     * @param endIndex  the end index (exclusive), must be valid
     * @param len  the length, must be valid
     * @throws IndexOutOfBoundsException if any index is invalid
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>deleteImpl</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Deletes the characters between the two specified indices.
     *
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except
     *  that if too large it is treated as end of string
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <call><name>validateRange</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Deletes the character wherever it occurs in the builder.
     *
     * @param ch  the character to delete
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>ch</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                }</block></while>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>i</name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Deletes the character wherever it occurs in the builder.
     *
     * @param ch  the character to delete
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Deletes the string wherever it occurs in the builder.
     *
     * @param str  the string to delete, null causes no action
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Deletes the string wherever it occurs in the builder.
     *
     * @param str  the string to delete, null causes no action
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>deleteImpl</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Deletes all parts of the builder that the matcher matches.
     * &lt;p&gt;
     * Matchers can be used to perform advanced deletion behaviour.
     * For example you could write a matcher to delete all occurrences
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Deletes the first match within the builder using the specified matcher.
     * &lt;p&gt;
     * Matchers can be used to perform advanced deletion behaviour.
     * For example you could write a matcher to delete
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>deleteFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Internal method to delete a range without validation.
     *
     * @param startIndex  the start index, must be valid
     * @param endIndex  the end index (exclusive), must be valid
     * @param removeLen  the length to remove (endIndex - startIndex), must be valid
     * @param insertStr  the string to replace with, null means delete range
     * @param insertLen  the length of the insert string, must be valid
     * @throws IndexOutOfBoundsException if any index is invalid
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>replaceImpl</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>removeLen</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>insertStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>insertLen</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newSize</name> <init>= <expr><name>size</name> <operator>-</operator> <name>removeLen</name> <operator>+</operator> <name>insertLen</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>insertLen</name> <operator>!=</operator> <name>removeLen</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ensureCapacity</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name> <operator>+</operator> <name>insertLen</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>insertLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>insertStr</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>insertLen</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces a portion of the string builder with another string.
     * The length of the inserted string does not have to match the removed length.
     *
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except
     *  that if too large it is treated as end of string
     * @param replaceStr  the string to replace with, null means delete range
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replace</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <call><name>validateRange</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>insertLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>replaceStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>replaceStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>replaceImpl</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><name>insertLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Replaces the search character with the replace character
     * throughout the builder.
     *
     * @param search  the search character
     * @param replace  the replace character
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>search</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>replace</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>search</name> <operator>!=</operator> <name>replace</name></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>search</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces the first instance of the search character with the
     * replace character in the builder.
     *
     * @param search  the search character
     * @param replace  the replace character
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>search</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>replace</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>search</name> <operator>!=</operator> <name>replace</name></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>search</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Replaces the search string with the replace string throughout the builder.
     *
     * @param searchStr  the search string, null causes no action to occur
     * @param replaceStr  the replace string, null is equivalent to an empty string
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>searchLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replaceLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>replaceStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>replaceStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>replaceImpl</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>searchLen</name></expr></argument>, <argument><expr><name>searchLen</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><name>replaceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>indexOf</name><argument_list>(<argument><expr><name>searchStr</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>replaceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces the first instance of the search string with the replace string.
     *
     * @param searchStr  the search string, null causes no action to occur
     * @param replaceStr  the replace string, null is equivalent to an empty string
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>searchStr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>searchLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>searchStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>searchStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>searchLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>searchStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replaceLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>replaceStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>replaceStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>replaceImpl</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <name>searchLen</name></expr></argument>, <argument><expr><name>searchLen</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><name>replaceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Replaces all matches within the builder with the replace string.
     * &lt;p&gt;
     * Matchers can be used to perform advanced replace behaviour.
     * For example you could write a matcher to replace all occurrences
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @param replaceStr  the replace string, null is equivalent to an empty string
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceAll</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces the first match within the builder with the replace string.
     * &lt;p&gt;
     * Matchers can be used to perform advanced replace behaviour.
     * For example you could write a matcher to replace
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @param replaceStr  the replace string, null is equivalent to an empty string
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replaceFirst</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>replace</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Advanced search and replaces within the builder using a matcher.
     * &lt;p&gt;
     * Matchers can be used to perform advanced behaviour.
     * For example you could write a matcher to delete all occurrences
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @param replaceStr  the string to replace the match with, null is a delete
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except
     *  that if too large it is treated as end of string
     * @param replaceCount  the number of times to replace, -1 for replace all
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if start index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>replace</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>replaceCount</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <call><name>validateRange</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>replaceImpl</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name>replaceCount</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Replaces within the builder using a matcher.
     * &lt;p&gt;
     * Matchers can be used to perform advanced behaviour.
     * For example you could write a matcher to delete all occurrences
     * where the character 'a' is followed by a number.
     *
     * @param matcher  the matcher to use to find the deletion, null causes no action
     * @param replaceStr  the string to replace the match with, null is a delete
     * @param from  the start index, must be valid
     * @param to  the end index (exclusive), must be valid
     * @param replaceCount  the number of times to replace, -1 for replace all
     * @return this, to enable chaining
     * @throws IndexOutOfBoundsException if any index is invalid
     */</comment>
    <function><specifier>private</specifier> <type><name>StrBuilder</name></type> <name>replaceImpl</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>replaceStr</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replaceCount</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>matcher</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>replaceLen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>replaceStr</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>replaceStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>from</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <name>replaceCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>removeLen</name> <init>= <expr><call><name><name>matcher</name><operator>.</operator><name>isMatch</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>removeLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>replaceImpl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>removeLen</name></expr></argument>, <argument><expr><name>removeLen</name></expr></argument>, <argument><expr><name>replaceStr</name></expr></argument>, <argument><expr><name>replaceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>to</name> <operator>=</operator> <name>to</name> <operator>-</operator> <name>removeLen</name> <operator>+</operator> <name>replaceLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>replaceLen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>replaceCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>replaceCount</name><operator>--</operator></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Reverses the string builder placing each character in the opposite index.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>reverse</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>half</name> <init>= <expr><name>size</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>leftIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightIdx</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>leftIdx</name> <operator>&lt;</operator> <name>half</name></expr>;</condition> <incr><expr><name>leftIdx</name><operator>++</operator></expr><operator>,</operator><expr><name>rightIdx</name><operator>--</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>swap</name> <init>= <expr><name><name>buf</name><index>[<expr><name>leftIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>leftIdx</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>rightIdx</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>rightIdx</name></expr>]</index></name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Trims the builder by removing characters less than or equal to a space
     * from the beginning and end.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrBuilder</name></type> <name>trim</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
        <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>delete</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>delete</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Checks whether this builder starts with the specified string.
     * &lt;p&gt;
     * Note that this method handles null input quietly, unlike String.
     *
     * @param str  the string to search for, null returns false
     * @return true if the builder starts with the string
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>startsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks whether this builder ends with the specified string.
     * &lt;p&gt;
     * Note that this method handles null input quietly, unlike String.
     *
     * @param str  the string to search for, null returns false
     * @return true if the builder ends with the string
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>endsWith</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>size</name> <operator>-</operator> <name>len</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * {@inheritDoc}
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>CharSequence</name></type> <name>subSequence</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndex</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;</operator> <name>endIndex</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>substring</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Extracts a portion of this string builder as a string.
     *
     * @param start  the start index, inclusive, must be valid
     * @return the new string
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>substring</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>substring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Extracts a portion of this string builder as a string.
     * &lt;p&gt;
     * Note: This method treats an endIndex greater than the length of the
     * builder as equal to the length of the builder, and continues
     * without error, unlike StringBuffer or String.
     *
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except
     *  that if too large it is treated as end of string
     * @return the new string
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>substring</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <call><name>validateRange</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Extracts the leftmost characters from the string builder without
     * throwing an exception.
     * &lt;p&gt;
     * This method extracts the left &lt;code&gt;length&lt;/code&gt; characters from
     * the builder. If this many characters are not available, the whole
     * builder is returned. Thus the returned string may be shorter than the
     * length requested.
     *
     * @param length  the number of characters to extract, negative returns empty string
     * @return the new string
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>leftString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">""</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Extracts the rightmost characters from the string builder without
     * throwing an exception.
     * &lt;p&gt;
     * This method extracts the right &lt;code&gt;length&lt;/code&gt; characters from
     * the builder. If this many characters are not available, the whole
     * builder is returned. Thus the returned string may be shorter than the
     * length requested.
     *
     * @param length  the number of characters to extract, negative returns empty string
     * @return the new string
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>rightString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">""</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>length</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Extracts some characters from the middle of the string builder without
     * throwing an exception.
     * &lt;p&gt;
     * This method extracts &lt;code&gt;length&lt;/code&gt; characters from the builder
     * at the specified index.
     * If the index is negative it is treated as zero.
     * If the index is greater than the builder size, it is treated as the builder size.
     * If the length is negative, the empty string is returned.
     * If insufficient characters are available in the builder, as much as possible is returned.
     * Thus the returned string may be shorter than the length requested.
     *
     * @param index  the index to start at, negative means zero
     * @param length  the number of characters to extract, negative returns empty string
     * @return the new string
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>midString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">""</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>index</name> <operator>+</operator> <name>length</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Checks if the string builder contains the specified char.
     *
     * @param ch  the character to find
     * @return true if the builder contains the character
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>thisBuf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>this</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>thisBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the string builder contains the specified string.
     *
     * @param str  the string to find
     * @return true if the builder contains the string
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the string builder contains a string matched using the
     * specified matcher.
     * &lt;p&gt;
     * Matchers can be used to perform advanced searching behaviour.
     * For example you could write a matcher to search for the character
     * 'a' followed by a number.
     *
     * @param matcher  the matcher to use, null returns -1
     * @return true if the matcher finds a match in the builder
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the first reference to the specified char.
     *
     * @param ch  the character to find
     * @return the first index of the character, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the first reference to the specified char.
     *
     * @param ch  the character to find
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the first index of the character, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>thisBuf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>thisBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the first reference to the specified string.
     * &lt;p&gt;
     * Note that a null input string will return -1, whereas the JDK throws an exception.
     *
     * @param str  the string to find, null returns -1
     * @return the first index of the string, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the first reference to the specified
     * string starting searching from the given index.
     * &lt;p&gt;
     * Note that a null input string will return -1, whereas the JDK throws an exception.
     *
     * @param str  the string to find, null returns -1
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the first index of the string, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>strLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>startIndex</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>thisBuf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>size</name> <operator>-</operator> <name>strLen</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <label><name>outer</name>:</label>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>strLen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>thisBuf</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <continue>continue <name>outer</name>;</continue>
                }</block></then></if>
            }</block></for>
            <return>return <expr><name>i</name></expr>;</return>
        }</block></for>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder using the matcher to find the first match.
     * &lt;p&gt;
     * Matchers can be used to perform advanced searching behaviour.
     * For example you could write a matcher to find the character 'a'
     * followed by a number.
     *
     * @param matcher  the matcher to use, null returns -1
     * @return the first index matched, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>indexOf</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder using the matcher to find the first
     * match searching from the given index.
     * &lt;p&gt;
     * Matchers can be used to perform advanced searching behaviour.
     * For example you could write a matcher to find the character 'a'
     * followed by a number.
     *
     * @param matcher  the matcher to use, null returns -1
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the first index matched, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>indexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>matcher</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>matcher</name><operator>.</operator><name>isMatch</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the last reference to the specified char.
     *
     * @param ch  the character to find
     * @return the last index of the character, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the last reference to the specified char.
     *
     * @param ch  the character to find
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the last index of the character, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr> ?</condition><then> <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ch</name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the last reference to the specified string.
     * &lt;p&gt;
     * Note that a null input string will return -1, whereas the JDK throws an exception.
     *
     * @param str  the string to find, null returns -1
     * @return the last index of the string, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder to find the last reference to the specified
     * string starting searching from the given index.
     * &lt;p&gt;
     * Note that a null input string will return -1, whereas the JDK throws an exception.
     *
     * @param str  the string to find, null returns -1
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the last index of the string, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr> ?</condition><then> <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>strLen</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>strLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>strLen</name> <operator>&lt;=</operator> <name>size</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>strLen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
                <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <label><name>outer</name>:</label>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name> <operator>-</operator> <name>strLen</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>strLen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                    <if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>buffer</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
                        <continue>continue <name>outer</name>;</continue>
                    }</block></then></if>
                }</block></for>
                <return>return <expr><name>i</name></expr>;</return>
            }</block></for>

        }</block></then> <elseif>else <if>if <condition>(<expr><name>strLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>startIndex</name></expr>;</return>
        }</block></then></if></elseif></if>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder using the matcher to find the last match.
     * &lt;p&gt;
     * Matchers can be used to perform advanced searching behaviour.
     * For example you could write a matcher to find the character 'a'
     * followed by a number.
     *
     * @param matcher  the matcher to use, null returns -1
     * @return the last index matched, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>lastIndexOf</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Searches the string builder using the matcher to find the last
     * match searching from the given index.
     * &lt;p&gt;
     * Matchers can be used to perform advanced searching behaviour.
     * For example you could write a matcher to find the character 'a'
     * followed by a number.
     *
     * @param matcher  the matcher to use, null returns -1
     * @param startIndex  the index to start at, invalid index rounded to edge
     * @return the last index matched, or -1 if not found
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>lastIndexOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>startIndex</name> <operator>&gt;=</operator> <name>size</name></expr> ?</condition><then> <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>startIndex</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>matcher</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>endIndex</name> <init>= <expr><name>startIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>matcher</name><operator>.</operator><name>isMatch</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Creates a tokenizer that can tokenize the contents of this builder.
     * &lt;p&gt;
     * This method allows the contents of this builder to be tokenized.
     * The tokenizer will be setup by default to tokenize on space, tab,
     * newline and formfeed (as per StringTokenizer). These values can be
     * changed on the tokenizer class, before retrieving the tokens.
     * &lt;p&gt;
     * The returned tokenizer is linked to this builder. You may intermix
     * calls to the buider and tokenizer within certain limits, however
     * there is no synchronization. Once the tokenizer has been used once,
     * it must be {@link StrTokenizer#reset() reset} to pickup the latest
     * changes in the builder. For example:
     * &lt;pre&gt;
     * StrBuilder b = new StrBuilder();
     * b.append("a b ");
     * StrTokenizer t = b.asTokenizer();
     * String[] tokens1 = t.getTokenArray();  // returns a,b
     * b.append("c d ");
     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)
     * t.reset();              // reset causes builder changes to be picked up
     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d
     * &lt;/pre&gt;
     * In addition to simply intermixing appends and tokenization, you can also
     * call the set methods on the tokenizer to alter how it tokenizes. Just
     * remember to call reset when you want to pickup builder changes.
     * &lt;p&gt;
     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}
     * with a non-null value will break the link with the builder.
     *
     * @return a tokenizer that is linked to this builder
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>asTokenizer</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StrBuilderTokenizer</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the contents of this builder as a Reader.
     * &lt;p&gt;
     * This method allows the contents of the builder to be read
     * using any standard method that expects a Reader.
     * &lt;p&gt;
     * To use, simply create a &lt;code&gt;StrBuilder&lt;/code&gt;, populate it with
     * data, call &lt;code&gt;asReader&lt;/code&gt;, and then read away.
     * &lt;p&gt;
     * The internal character array is shared between the builder and the reader.
     * This allows you to append to the builder after creating the reader,
     * and the changes will be picked up.
     * Note however, that no synchronization occurs, so you must perform
     * all operations with the builder and the reader in one thread.
     * &lt;p&gt;
     * The returned reader supports marking, and ignores the flush method.
     *
     * @return a reader that reads from this builder
     */</comment>
    <function><specifier>public</specifier> <type><name>Reader</name></type> <name>asReader</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StrBuilderReader</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets this builder as a Writer that can be written to.
     * &lt;p&gt;
     * This method allows you to populate the contents of the builder
     * using any standard method that takes a Writer.
     * &lt;p&gt;
     * To use, simply create a &lt;code&gt;StrBuilder&lt;/code&gt;,
     * call &lt;code&gt;asWriter&lt;/code&gt;, and populate away. The data is available
     * at any time using the methods of the &lt;code&gt;StrBuilder&lt;/code&gt;.
     * &lt;p&gt;
     * The internal character array is shared between the builder and the writer.
     * This allows you to intermix calls that append to the builder and
     * write using the writer and the changes will be occur correctly.
     * Note however, that no synchronization occurs, so you must perform
     * all operations with the builder and the writer in one thread.
     * &lt;p&gt;
     * The returned writer ignores the close and flush methods.
     *
     * @return a writer that populates this builder
     */</comment>
    <function><specifier>public</specifier> <type><name>Writer</name></type> <name>asWriter</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StrBuilderWriter</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
<comment type="line">//    /**</comment>
<comment type="line">//     * Gets a String version of the string builder by calling the internal</comment>
<comment type="line">//     * constructor of String by reflection.</comment>
<comment type="line">//     * &lt;p&gt;</comment>
<comment type="line">//     * WARNING: You must not use the StrBuilder after calling this method</comment>
<comment type="line">//     * as the buffer is now shared with the String object. To ensure this,</comment>
<comment type="line">//     * the internal character array is set to null, so you will get</comment>
<comment type="line">//     * NullPointerExceptions on all method calls.</comment>
<comment type="line">//     *</comment>
<comment type="line">//     * @return the builder as a String</comment>
<comment type="line">//     */</comment>
<comment type="line">//    public String toSharedString() {</comment>
<comment type="line">//        try {</comment>
<comment type="line">//            Constructor con = String.class.getDeclaredConstructor(</comment>
<comment type="line">//                new Class[] {int.class, int.class, char[].class});</comment>
<comment type="line">//            con.setAccessible(true);</comment>
<comment type="line">//            char[] buffer = buf;</comment>
<comment type="line">//            buf = null;</comment>
<comment type="line">//            size = -1;</comment>
<comment type="line">//            nullText = null;</comment>
<comment type="line">//            return (String) con.newInstance(</comment>
<comment type="line">//                new Object[] {Integer.valueOf(0), Integer.valueOf(size), buffer});</comment>
<comment type="line">//</comment>
<comment type="line">//        } catch (Exception ex) {</comment>
<comment type="line">//            ex.printStackTrace();</comment>
<comment type="line">//            throw new UnsupportedOperationException("StrBuilder.toSharedString is unsupported: " + ex.getMessage());</comment>
<comment type="line">//        }</comment>
<comment type="line">//    }</comment>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Checks the contents of this builder against another to see if they
     * contain the same character content ignoring case.
     *
     * @param other  the object to check, null returns false
     * @return true if the builders contain the same characters in the same order
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>equalsIgnoreCase</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>other</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <name><name>other</name><operator>.</operator><name>size</name></name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>thisBuf</name><index>[]</index></name> <init>= <expr><name><name>this</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>otherBuf</name><index>[]</index></name> <init>= <expr><name><name>other</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>c1</name> <init>= <expr><name><name>thisBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>c2</name> <init>= <expr><name><name>otherBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Character</name><operator>.</operator><name>toUpperCase</name></name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks the contents of this builder against another to see if they
     * contain the same character content.
     *
     * @param other  the object to check, null returns false
     * @return true if the builders contain the same characters in the same order
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>other</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <name><name>other</name><operator>.</operator><name>size</name></name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>thisBuf</name><index>[]</index></name> <init>= <expr><name><name>this</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>otherBuf</name><index>[]</index></name> <init>= <expr><name><name>other</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>thisBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>otherBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks the contents of this builder against another to see if they
     * contain the same character content.
     *
     * @param obj  the object to check, null returns false
     * @return true if the builders contain the same characters in the same order
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>instanceof</operator> <name>StrBuilder</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>equals</name><argument_list>(<argument><expr><operator>(</operator><name>StrBuilder</name><operator>)</operator> <name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a suitable hash code for this builder.
     *
     * @return a hash code
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>buf</name><index>[]</index></name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>hash</name> <operator>=</operator> <literal type="number">31</literal> <operator>*</operator> <name>hash</name> <operator>+</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>hash</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets a String version of the string builder, creating a new instance
     * each time the method is called.
     * &lt;p&gt;
     * Note that unlike StringBuffer, the string version returned is
     * independent of the string builder.
     *
     * @return the builder as a String
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a StringBuffer version of the string builder, creating a
     * new instance each time the method is called.
     *
     * @return the builder as a StringBuffer
     */</comment>
    <function><specifier>public</specifier> <type><name>StringBuffer</name></type> <name>toStringBuffer</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a StringBuilder version of the string builder, creating a
     * new instance each time the method is called.
     *
     * @return the builder as a StringBuilder
     * @since Apache Commons Lang 3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>StringBuilder</name></type> <name>toStringBuilder</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Implement the {@link Builder} interface.
     * @return the builder as a String
     * @since Apache Commons Lang 3.2
     * @see #toString()
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>build</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Validates parameters defining a range of the builder.
     *
     * @param startIndex  the start index, inclusive, must be valid
     * @param endIndex  the end index, exclusive, must be valid except
     *  that if too large it is treated as end of string
     * @return the new string
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>protected</specifier> <type><name>int</name></type> <name>validateRange</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>endIndex</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>startIndex</name> <operator>&gt;</operator> <name>endIndex</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><literal type="string">"end &lt; start"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>endIndex</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Validates parameters defining a single index in the builder.
     *
     * @param index  the index, must be valid
     * @throws IndexOutOfBoundsException if the index is invalid
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>validateIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>index</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>index</name></argument> &gt;</argument_list></name> <name>size</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>StringIndexOutOfBoundsException</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Inner class to allow StrBuilder to operate as a tokenizer.
     */</comment>
    <class>class <name>StrBuilderTokenizer</name> <super><extends>extends <name>StrTokenizer</name></extends></super> <block>{

        <comment type="block" format="javadoc">/**
         * Default constructor.
         */</comment>
        <constructor><name>StrBuilderTokenizer</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>protected</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenize</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>super</name><operator>.</operator><name>tokenize</name></name><argument_list>(<argument><expr><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <return>return <expr><call><name><name>super</name><operator>.</operator><name>tokenize</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>String</name></type> <name>getContent</name><parameter_list>()</parameter_list> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name> <init>= <expr><call><name><name>super</name><operator>.</operator><name>getContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>str</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></then></if>
            <return>return <expr><name>str</name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Inner class to allow StrBuilder to operate as a writer.
     */</comment>
    <class>class <name>StrBuilderReader</name> <super><extends>extends <name>Reader</name></extends></super> <block>{
        <comment type="block" format="javadoc">/** The current stream position. */</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
        <comment type="block" format="javadoc">/** The last mark position. */</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mark</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Default constructor.
         */</comment>
        <constructor><name>StrBuilderReader</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <block>{
            <comment type="line">// do nothing</comment>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>read</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><call><name>ready</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            }</block></then></if>
            <return>return <expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>read</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>b</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
            <if>if <condition>(<expr><name><name>off</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name><name>len</name> <argument_list type="generic">&lt; <argument><literal type="number">0</literal> <operator>||</operator> <name>off</name></argument> &gt;</argument_list></name> <name><name>b</name><operator>.</operator><name>length</name></name> <operator>||</operator>
                    <operator>(</operator><name>off</name> <operator>+</operator> <name>len</name><operator>)</operator></argument> &gt;</argument_list></name> <name><name>b</name><operator>.</operator><name>length</name></name> <operator>||</operator> <operator>(</operator><name>off</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>()</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>pos</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>getChars</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            <return>return <expr><name>len</name></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>long</name></type> <name>skip</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>pos</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <return>return <expr><name>n</name></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>boolean</name></type> <name>ready</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>pos</name> <operator>&lt;</operator> <call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>boolean</name></type> <name>markSupported</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>mark</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>readAheadLimit</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><name>mark</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>mark</name></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Inner class to allow StrBuilder to operate as a writer.
     */</comment>
    <class>class <name>StrBuilderWriter</name> <super><extends>extends <name>Writer</name></extends></super> <block>{

        <comment type="block" format="javadoc">/**
         * Default constructor.
         */</comment>
        <constructor><name>StrBuilderWriter</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <block>{
            <comment type="line">// do nothing</comment>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>flush</name><parameter_list>()</parameter_list> <block>{
            <comment type="line">// do nothing</comment>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>cbuf</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>cbuf</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="javadoc">/** {@inheritDoc} */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>StrBuilder</name><operator>.</operator><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

}


<comment type="block" format="javadoc">/**
 * &lt;p&gt;This class assists in validating arguments. The validation methods are
 * based along the following principles:
 * &lt;ul&gt;
 *   &lt;li&gt;An invalid {@code null} argument causes a {@link NullPointerException}.&lt;/li&gt;
 *   &lt;li&gt;A non-{@code null} argument causes an {@link IllegalArgumentException}.&lt;/li&gt;
 *   &lt;li&gt;An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All exceptions messages are
 * &lt;a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html#syntax"&gt;format strings&lt;/a&gt;
 * as defined by the Java platform. For example:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * Validate.isTrue(i &gt; 0, "The value must be greater than zero: %d", i);
 * Validate.notNull(surname, "The surname must not be %s", null);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @version $Id$
 * @see java.lang.String#format(String, Object...)
 * @since 2.0
 */</comment>
class <expr_stmt><expr><name>Validate</name> <block>{

    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The value %s is not in the specified exclusive range of %s to %s"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The value %s is not in the specified inclusive range of %s to %s"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_MATCHES_PATTERN_EX</name> <operator>=</operator> <literal type="string">"The string %s does not match the pattern %s"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_IS_NULL_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated object is null"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_IS_TRUE_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated expression is false"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The validated array contains null element at index: %d"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The validated collection contains null element at index: %d"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NOT_BLANK_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated character sequence is blank"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated array is empty"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The validated character sequence is empty"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated collection is empty"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated map is empty"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated array index is invalid: %d"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The validated character sequence index is invalid: %d"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE</name> <operator>=</operator>
            <literal type="string">"The validated collection index is invalid: %d"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_VALID_STATE_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"The validated state is false"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_IS_ASSIGNABLE_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"Cannot assign a %s to a %s"</literal></expr>;
    <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DEFAULT_IS_INSTANCE_OF_EX_MESSAGE</name> <operator>=</operator> <literal type="string">"Expected type: %s, actual: %s"</literal></expr>;

    <comment type="block" format="javadoc">/**
     * Constructor. This class should not normally be instantiated.
     */</comment>
    <expr><specifier>public</specifier> <call><name>Validate</name><argument_list>()</argument_list></call> <block>{
        <expr><call><name>super</name><argument_list>()</argument_list></call></expr>;
    }</block>

    <comment type="line">// isTrue</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(i &gt; 0.0, "The value must be greater than zero: %d", i);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the long value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */</comment>
    <specifier>public</specifier> <specifier>static</specifier> <name>void</name> <call><name>isTrue</name><argument_list>(<argument><expr><name>final</name> <name>boolean</name> <name>expression</name></expr></argument>, <argument><expr><name>final</name> <name>String</name> <name>message</name></expr></argument>, <argument><expr><name>final</name> <name>long</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        <expr_stmt/></block></then></if>}</block></expr>
    }</block>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(d &gt; 0.0, "The value must be greater than zero: %s", d);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the double value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, Object...)
     */</comment>
    <specifier>public</specifier> <specifier>static</specifier> <name>void</name> <call><name>isTrue</name><argument_list>(<argument><expr><name>final</name> <name>boolean</name> <name>expression</name></expr></argument>, <argument><expr><name>final</name> <name>String</name> <name>message</name></expr></argument>, <argument><expr><name>final</name> <name>double</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><call><name><name>Double</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
    }

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt;= min &amp;&amp; i &lt;= max, "The value must be between %d and %d", min, max);
     * Validate.isTrue(myObject.isOk(), "The object is not okay");&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     */</comment>
    public <function><specifier>static</specifier> <type><name>void</name></type> <name>isTrue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>expression</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt; 0);
     * Validate.isTrue(myObject.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated expression is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>isTrue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>expression</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><name>DEFAULT_IS_TRUE_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// notNull</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notNull(myObject, "The object must not be null");&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notNull</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>DEFAULT_IS_NULL_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notNull(myObject, "The object must not be null");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>object</name></expr>;</return>
    }</block></function>

    <comment type="line">// notEmpty array</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray, "The array must not be empty");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[])
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated array is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[], String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notEmpty</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// notEmpty collection</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection, "The collection must not be empty");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Object[])
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>collection</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>collection</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>collection</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>collection</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated collection is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Collection, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>collection</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notEmpty</name><argument_list>(<argument><expr><name>collection</name></expr></argument>, <argument><expr><name>DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// notEmpty map</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap, "The map must not be empty");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Object[])
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>map</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>map</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>map</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated map is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Map, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Map</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>map</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notEmpty</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// notEmpty string</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString, "The string must not be empty");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>chars</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>chars</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated
     * character sequence is empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notEmpty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notEmpty</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// notBlank string</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception with the specified
     * message.
     *
     * &lt;pre&gt;Validate.notBlank(myString, "The string must not be blank");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notBlank</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isBlank</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>chars</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notBlank(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated character
     * sequence is blank&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>notBlank</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>notBlank</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>DEFAULT_NOT_BLANK_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// noNullElements array</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray, "The array contain null at position %d");&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[])
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>noNullElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>values2</name> <init>= <expr><call><name><name>ArrayUtils</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated array contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[], String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>noNullElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>noNullElements</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// noNullElements iterable</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection, "The collection contains null at position %d");&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the iterable has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>noNullElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>iterable</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>iterable</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>values2</name> <init>= <expr><call><name><name>ArrayUtils</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>iterable</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated iterable contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable, String, Object...)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>noNullElements</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>iterable</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>noNullElements</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>, <argument><expr><name>DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// validIndex array</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2, "The array index is invalid: ");&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>array</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception is
     * &amp;quot;The validated array index is invalid: &amp;quot; followed by the
     * index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>T</name><index>[]</index></name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>validIndex</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// validIndex collection</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2, "The collection index is invalid: ");&lt;/pre&gt;
     *
     * &lt;p&gt;If the collection is {@code null}, then the message of the
     * exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>collection</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>collection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <call><name><name>collection</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>collection</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated collection index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @return the validated collection (never {@code null} for method chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>collection</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>validIndex</name><argument_list>(<argument><expr><name>collection</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// validIndex string</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2, "The string index is invalid: ");&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>Validate</name><operator>.</operator><name>notNull</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <call><name><name>chars</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>chars</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated character sequence index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name>CharSequence</name></extends></parameter>&gt;</parameter_list> <type><name>T</name></type> <name>validIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>validIndex</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// validState</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.validState(field &gt; 0);
     * Validate.validState(this.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated state is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>validState</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>expression</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><name>DEFAULT_VALID_STATE_EX_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validState(this.isOk(), "The state is not OK: %s", myObject);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>validState</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>expression</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>expression</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// matchesPattern</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern("hi", "[a-z]*");&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>matchesPattern</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>pattern</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning input</comment>
        <if>if <condition>(<expr><call><name><name>Pattern</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>DEFAULT_MATCHES_PATTERN_EX</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern("hi", "[a-z]*", "%s does not match %s", "hi" "[a-z]*");&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>matchesPattern</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning input</comment>
        <if>if <condition>(<expr><call><name><name>Pattern</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// inclusiveBetween</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>void</name></type> <name>inclusiveBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning value</comment>
        <if>if <condition>(<expr><call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, "Not in boundaries");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>void</name></type> <name>inclusiveBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning value</comment>
        <if>if <condition>(<expr><call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// exclusiveBetween</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>void</name></type> <name>exclusiveBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning value</comment>
        <if>if <condition>(<expr><call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1, "Not in boundaries");&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>void</name></type> <name>exclusiveBetween</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning value</comment>
        <if>if <condition>(<expr><call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>value</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// isInstanceOf</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * Validates that the argument is an instance of the specified class, if not throws an exception.
     *
     * &lt;p&gt;This method is useful when validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.class, object);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;Expected type: {type}, actual: {obj_type}&amp;quot;&lt;/p&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>isInstanceOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning obj</comment>
        <if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>DEFAULT_IS_INSTANCE_OF_EX_MESSAGE</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">"null"</literal></expr> </then><else>: <expr><call><name><name>obj</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Validate that the argument is an instance of the specified class; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.classs, object, "Wrong class, object is of class %s",
     *   object.getClass().getName());&lt;/pre&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>isInstanceOf</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning obj</comment>
        <if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="line">// isAssignableFrom</comment>
    <comment type="line">//---------------------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * Validates that the argument can be converted to the specified class, if not, throws an exception.
     *
     * &lt;p&gt;This method is useful when validating that there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message format of the exception is &amp;quot;Cannot assign {type} to {superType}&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @throws IllegalArgumentException if type argument is not assignable to the specified superType
     * @see #isAssignableFrom(Class, Class, String, Object...)
     *
     * @since 3.0
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>isAssignableFrom</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>superType</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning type</comment>
        <if>if <condition>(<expr><call><name><name>superType</name><operator>.</operator><name>isAssignableFrom</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>DEFAULT_IS_ASSIGNABLE_EX_MESSAGE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">"null"</literal></expr> </then><else>: <expr><call><name><name>type</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
                    <argument><expr><call><name><name>superType</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Validates that the argument can be converted to the specified class, if not throws an exception.
     *
     * &lt;p&gt;This method is useful when validating if there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object can not be converted to the&amp;quot;
     * followed by the name of the class and &amp;quot;class&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument can not be converted to the specified class
     * @see #isAssignableFrom(Class, Class)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>isAssignableFrom</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>superType</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// TODO when breaking BC, consider returning type</comment>
        <if>if <condition>(<expr><call><name><name>superType</name><operator>.</operator><name>isAssignableFrom</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>
}



<comment type="block" format="javadoc">/**
 * &lt;p&gt;Operates on classes without using reflection.&lt;/p&gt;
 *
 * &lt;p&gt;This class handles invalid {@code null} inputs as best it can.
 * Each method documents its behaviour in more detail.&lt;/p&gt;
 *
 * &lt;p&gt;The notion of a {@code canonical name} includes the human
 * readable name for the type, for example {@code int[]}. The
 * non-canonical method variants work with the JVM names, such as
 * {@code [I}. &lt;/p&gt;
 *
 * @since 2.0
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>ClassUtils</name> <block>{

    <comment type="block" format="javadoc">/**
     * The package separator character: &lt;code&gt;'&amp;#x2e;' == {@value}&lt;/code&gt;.
     */</comment>
    <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>char</name> <name>PACKAGE_SEPARATOR_CHAR</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;

    <comment type="block" format="javadoc">/**
     * The package separator String: &lt;code&gt;"&amp;#x2e;"&lt;/code&gt;.
     */</comment>
    <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>PACKAGE_SEPARATOR</name> <operator>=</operator> <call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>PACKAGE_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block" format="javadoc">/**
     * The inner class separator character: &lt;code&gt;'$' == {@value}&lt;/code&gt;.
     */</comment>
    <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>char</name> <name>INNER_CLASS_SEPARATOR_CHAR</name> <operator>=</operator> <literal type="char">'$'</literal></expr>;

    <comment type="block" format="javadoc">/**
     * The inner class separator String: {@code "$"}.
     */</comment>
    <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>INNER_CLASS_SEPARATOR</name> <operator>=</operator> <call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>INNER_CLASS_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block" format="javadoc">/**
     * Maps primitive {@code Class}es to their corresponding wrapper {@code Class}.
     */</comment>
    <expr><ternary><condition><expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name><name>Map</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name> <name>primitiveWrapperMap</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></condition></ternary></expr>;
    <expr><specifier>static</specifier> <block>{
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Boolean</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Boolean</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Byte</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Byte</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Character</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Character</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Short</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Short</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Integer</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Long</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Double</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Double</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Float</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Float</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>Void</name><operator>.</operator><name>TYPE</name></name></expr></argument>, <argument><expr><name><name>Void</name><operator>.</operator><name>TYPE</name></name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * Maps wrapper {@code Class}es to their corresponding primitive types.
     */</comment>
    <ternary><condition><expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name><name>Map</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name> <name>wrapperPrimitiveMap</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></condition></ternary></expr>;
    <expr><specifier>static</specifier> <block>{
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>primitiveClass</name> <range>: <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>wrapperClass</name> <init>= <expr><call><name><name>primitiveWrapperMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>primitiveClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>primitiveClass</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>wrapperClass</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>wrapperPrimitiveMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>wrapperClass</name></expr></argument>, <argument><expr><name>primitiveClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt/></block></then></if></block></for>}</block></expr>
        }</block></expr></expr_stmt>
    }

    <comment type="block" format="javadoc">/**
     * Maps a primitive class name to its corresponding abbreviation used in array class names.
     */</comment>
    private <decl_stmt><decl><specifier>static</specifier> <type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>abbreviationMap</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Maps an abbreviation used in array class names to corresponding primitive class name.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>reverseAbbreviationMap</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Add primitive type abbreviation to maps of abbreviations.
     *
     * @param primitive Canonical name of primitive type
     * @param abbreviation Corresponding abbreviation of primitive type
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>addAbbreviation</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>primitive</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>abbreviation</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>abbreviationMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>primitive</name></expr></argument>, <argument><expr><name>abbreviation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>reverseAbbreviationMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>abbreviation</name></expr></argument>, <argument><expr><name>primitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Feed abbreviation maps
     */</comment>
    <static>static <block>{
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"int"</literal></expr></argument>, <argument><expr><literal type="string">"I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"boolean"</literal></expr></argument>, <argument><expr><literal type="string">"Z"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"float"</literal></expr></argument>, <argument><expr><literal type="string">"F"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"long"</literal></expr></argument>, <argument><expr><literal type="string">"J"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"short"</literal></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"byte"</literal></expr></argument>, <argument><expr><literal type="string">"B"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"double"</literal></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addAbbreviation</name><argument_list>(<argument><expr><literal type="string">"char"</literal></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></static>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;ClassUtils instances should NOT be constructed in standard programming.
     * Instead, the class should be used as
     * {@code ClassUtils.getShortClassName(cls)}.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
     * instance to operate.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ClassUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">// Short class name</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the class name minus the package name for an {@code Object}.&lt;/p&gt;
     *
     * @param object  the class to get the short name for, may be null
     * @param valueIfNull  the value to return if null
     * @return the class name of the object without the package name, or the null value
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>valueIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>valueIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getShortClassName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the class name minus the package name from a {@code Class}.&lt;/p&gt;
     *
     * &lt;p&gt;Consider using the Java 5 API {@link Class#getSimpleName()} instead.
     * The one known difference is that this code will return {@code "Map.Entry"} while
     * the {@code java.lang.Class} variant will simply return {@code "Entry"}. &lt;/p&gt;
     *
     * @param cls  the class to get the short name for.
     * @return the class name without the package name or an empty string
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortClassName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getShortClassName</name><argument_list>(<argument><expr><call><name><name>cls</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the class name minus the package name from a String.&lt;/p&gt;
     *
     * &lt;p&gt;The string passed in is assumed to be a class name - it is not checked.&lt;/p&gt;

     * &lt;p&gt;Note that this method differs from Class.getSimpleName() in that this will
     * return {@code "Map.Entry"} whilst the {@code java.lang.Class} variant will simply
     * return {@code "Entry"}. &lt;/p&gt;
     *
     * @param className  the className to get the short name for
     * @return the class name of the class without the package name or an empty string
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortClassName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>arrayPrefix</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Handle array encoding</comment>
        <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{
                <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>arrayPrefix</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <comment type="line">// Strip Object type encoding</comment>
            <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'L'</literal> <operator>&amp;&amp;</operator> <call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>reverseAbbreviationMap</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>reverseAbbreviationMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastDotIdx</name> <init>= <expr><call><name><name>className</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>PACKAGE_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>innerIdx</name> <init>= <expr><call><name><name>className</name><operator>.</operator><name>indexOf</name></name><argument_list>(
                <argument><expr><name>INNER_CLASS_SEPARATOR_CHAR</name></expr></argument>, <argument><expr><ternary><condition><expr><name>lastDotIdx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>lastDotIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>out</name> <init>= <expr><call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>lastDotIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>innerIdx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name><name>out</name><operator>.</operator><name>replace</name></name><argument_list>(<argument><expr><name>INNER_CLASS_SEPARATOR_CHAR</name></expr></argument>, <argument><expr><name>PACKAGE_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>out</name> <operator>+</operator> <name>arrayPrefix</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null-safe version of &lt;code&gt;aClass.getSimpleName()&lt;/code&gt;&lt;/p&gt;
     *
     * @param cls the class for which to get the simple name.
     * @return the simple class name.
     * @since 3.0
     * @see Class#getSimpleName()
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getSimpleName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>cls</name><operator>.</operator><name>getSimpleName</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Null-safe version of &lt;code&gt;aClass.getSimpleName()&lt;/code&gt;&lt;/p&gt;
     *
     * @param object the object for which to get the simple class name.
     * @param valueIfNull the value to return if &lt;code&gt;object&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @return the simple class name.
     * @since 3.0
     * @see Class#getSimpleName()
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getSimpleName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>valueIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>valueIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getSimpleName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Package name</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name of an {@code Object}.&lt;/p&gt;
     *
     * @param object  the class to get the package name for, may be null
     * @param valueIfNull  the value to return if null
     * @return the package name of the object, or the null value
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>valueIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>valueIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getPackageName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name of a {@code Class}.&lt;/p&gt;
     *
     * @param cls  the class to get the package name for, may be {@code null}.
     * @return the package name or an empty string
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getPackageName</name><argument_list>(<argument><expr><call><name><name>cls</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name from a {@code String}.&lt;/p&gt;
     *
     * &lt;p&gt;The string passed in is assumed to be a class name - it is not checked.&lt;/p&gt;
     * &lt;p&gt;If the class is unpackaged, return an empty string.&lt;/p&gt;
     *
     * @param className  the className to get the package name for, may be {@code null}
     * @return the package name or an empty string
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>

        <comment type="line">// Strip array encoding</comment>
        <while>while <condition>(<expr><call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <comment type="line">// Strip Object type encoding</comment>
        <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'L'</literal> <operator>&amp;&amp;</operator> <call><name><name>className</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>i</name> <init>= <expr><call><name><name>className</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>PACKAGE_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Superclasses/Superinterfaces</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets a {@code List} of superclasses for the given class.&lt;/p&gt;
     *
     * @param cls  the class to look up, may be {@code null}
     * @return the {@code List} of superclasses in order going up from this one
     *  {@code null} if null input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getAllSuperclasses</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>classes</name> <init>= <expr><ternary><condition><expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></condition></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>superclass</name> <init>= <expr><call><name><name>cls</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>superclass</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>classes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>superclass</name> <operator>=</operator> <call><name><name>superclass</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>classes</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets a {@code List} of all interfaces implemented by the given
     * class and its superclasses.&lt;/p&gt;
     *
     * &lt;p&gt;The order is determined by looking through each interface in turn as
     * declared in the source file and following its hierarchy up. Then each
     * superclass is considered in the same way. Later duplicates are ignored,
     * so the order is maintained.&lt;/p&gt;
     *
     * @param cls  the class to look up, may be {@code null}
     * @return the {@code List} of interfaces in order,
     *  {@code null} if null input
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getAllInterfaces</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>LinkedHashSet</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>interfacesFound</name> <init>= <expr><ternary><condition><expr><operator>new</operator> <call><name><name>LinkedHashSet</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></condition></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>getAllInterfaces</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>interfacesFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><ternary><condition><expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>interfacesFound</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the interfaces for the specified class.
     *
     * @param cls  the class to look up, may be {@code null}
     * @param interfacesFound the {@code Set} of interfaces for the class
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>getAllInterfaces</name><parameter_list>(<parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>interfacesFound</name></decl></parameter>)</parameter_list> <block>{
        <while>while <condition>(<expr><name>cls</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>interfaces</name> <init>= <expr><call><name><name>cls</name><operator>.</operator><name>getInterfaces</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>i</name> <range>: <expr><name>interfaces</name></expr></range></decl></init>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>interfacesFound</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>getAllInterfaces</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>interfacesFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <expr_stmt><expr><name>cls</name> <operator>=</operator> <call><name><name>cls</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="line">// Convert list</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Given a {@code List} of class names, this method converts them into classes.&lt;/p&gt;
     *
     * &lt;p&gt;A new {@code List} is returned. If the class name cannot be found, {@code null}
     * is stored in the {@code List}. If the class name in the {@code List} is
     * {@code null}, {@code null} is stored in the output {@code List}.&lt;/p&gt;
     *
     * @param classNames  the classNames to change
     * @return a {@code List} of Class objects corresponding to the class names,
     *  {@code null} if null input
     * @throws ClassCastException if classNames contains a non String entry
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>convertClassNamesToClasses</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>classNames</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>classNames</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>classes</name> <init>= <expr><ternary><condition><expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>classNames</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></condition></ternary></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>className</name> <range>: <expr><name>classNames</name></expr></range></decl></init>)</control> <block>{
            <try>try <block>{
                <expr_stmt><expr><call><name><name>classes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>Class</name><operator>.</operator><name>forName</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Exception</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
                <expr_stmt><expr><call><name><name>classes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>
        <return>return <expr><name>classes</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Given a {@code List} of {@code Class} objects, this method converts
     * them into class names.&lt;/p&gt;
     *
     * &lt;p&gt;A new {@code List} is returned. {@code null} objects will be copied into
     * the returned list as {@code null}.&lt;/p&gt;
     *
     * @param classes  the classes to change
     * @return a {@code List} of class names corresponding to the Class objects,
     *  {@code null} if null input
     * @throws ClassCastException if {@code classes} contains a non-{@code Class} entry
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>convertClassesToClassNames</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>classes</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>classes</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>classNames</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>classes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name> <range>: <expr><name>classes</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classNames</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>classNames</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>cls</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>classNames</name></expr>;</return>
    }</block></function>

    <comment type="line">// Is assignable</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of Classes can be assigned to another array of Classes.&lt;/p&gt;
     *
     * &lt;p&gt;This method calls {@link #isAssignable(Class, Class) isAssignable} for each
     * Class pair in the input arrays. It can be used to check if a set of arguments
     * (the first parameter) are suitably compatible with a set of method parameter types
     * (the second parameter).&lt;/p&gt;
     *
     * &lt;p&gt;Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
     * method takes into account widenings of primitive classes and
     * {@code null}s.&lt;/p&gt;
     *
     * &lt;p&gt;Primitive widenings allow an int to be assigned to a {@code long},
     * {@code float} or {@code double}. This method returns the correct
     * result for these cases.&lt;/p&gt;
     *
     * &lt;p&gt;{@code Null} may be assigned to any reference type. This method will
     * return {@code true} if {@code null} is passed in and the toClass is
     * non-primitive.&lt;/p&gt;
     *
     * &lt;p&gt;Specifically, this method tests whether the type represented by the
     * specified {@code Class} parameter can be converted to the type
     * represented by this {@code Class} object via an identity conversion
     * widening primitive or widening reference conversion. See
     * &lt;em&gt;&lt;a href="http://docs.oracle.com/javase/specs/"&gt;The Java Language Specification&lt;/a&gt;&lt;/em&gt;,
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Since Lang 3.0,&lt;/strong&gt; this method will default behavior for
     * calculating assignability between primitive and wrapper types &lt;em&gt;corresponding
     * to the running Java version&lt;/em&gt;; i.e. autoboxing will be the default
     * behavior in VMs running Java versions &gt;= 1.5.&lt;/p&gt;
     *
     * @param classArray  the array of Classes to check, may be {@code null}
     * @param toClassArray  the array of Classes to try to assign into, may be {@code null}
     * @return {@code true} if assignment possible
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAssignable</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>classArray</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><modifier>...</modifier></type> <name>toClassArray</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isAssignable</name><argument_list>(<argument><expr><name>classArray</name></expr></argument>, <argument><expr><name>toClassArray</name></expr></argument>, <argument><expr><call><name><name>SystemUtils</name><operator>.</operator><name>isJavaVersionAtLeast</name></name><argument_list>(<argument><expr><name><name>JavaVersion</name><operator>.</operator><name>JAVA_1_5</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if an array of Classes can be assigned to another array of Classes.&lt;/p&gt;
     *
     * &lt;p&gt;This method calls {@link #isAssignable(Class, Class) isAssignable} for each
     * Class pair in the input arrays. It can be used to check if a set of arguments
     * (the first parameter) are suitably compatible with a set of method parameter types
     * (the second parameter).&lt;/p&gt;
     *
     * &lt;p&gt;Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
     * method takes into account widenings of primitive classes and
     * {@code null}s.&lt;/p&gt;
     *
     * &lt;p&gt;Primitive widenings allow an int to be assigned to a {@code long},
     * {@code float} or {@code double}. This method returns the correct
     * result for these cases.&lt;/p&gt;
     *
     * &lt;p&gt;{@code Null} may be assigned to any reference type. This method will
     * return {@code true} if {@code null} is passed in and the toClass is
     * non-primitive.&lt;/p&gt;
     *
     * &lt;p&gt;Specifically, this method tests whether the type represented by the
     * specified {@code Class} parameter can be converted to the type
     * represented by this {@code Class} object via an identity conversion
     * widening primitive or widening reference conversion. See
     * &lt;em&gt;&lt;a href="http://docs.oracle.com/javase/specs/"&gt;The Java Language Specification&lt;/a&gt;&lt;/em&gt;,
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.&lt;/p&gt;
     *
     * @param classArray  the array of Classes to check, may be {@code null}
     * @param toClassArray  the array of Classes to try to assign into, may be {@code null}
     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
     * @return {@code true} if assignment possible
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAssignable</name><parameter_list>(<parameter><decl><type><name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>classArray</name></decl></parameter>, <parameter><decl><type><name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>toClassArray</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>autoboxing</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ArrayUtils</name><operator>.</operator><name>isSameLength</name></name><argument_list>(<argument><expr><name>classArray</name></expr></argument>, <argument><expr><name>toClassArray</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>classArray</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>classArray</name> <operator>=</operator> <name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_CLASS_ARRAY</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>toClassArray</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>toClassArray</name> <operator>=</operator> <name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_CLASS_ARRAY</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>classArray</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name>isAssignable</name><argument_list>(<argument><expr><name><name>classArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>toClassArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>autoboxing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},
     * {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).
     *
     * @param type
     *            The class to query or null.
     * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},
     *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).
     * @since 3.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isPrimitiveOrWrapper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>type</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isPrimitiveWrapper</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character}, {@link Short},
     * {@link Integer}, {@link Long}, {@link Double}, {@link Float}).
     *
     * @param type
     *            The class to query or null.
     * @return true if the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character}, {@link Short},
     *         {@link Integer}, {@link Long}, {@link Double}, {@link Float}).
     * @since 3.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isPrimitiveWrapper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>wrapperPrimitiveMap</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if one {@code Class} can be assigned to a variable of
     * another {@code Class}.&lt;/p&gt;
     *
     * &lt;p&gt;Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
     * this method takes into account widenings of primitive classes and
     * {@code null}s.&lt;/p&gt;
     *
     * &lt;p&gt;Primitive widenings allow an int to be assigned to a long, float or
     * double. This method returns the correct result for these cases.&lt;/p&gt;
     *
     * &lt;p&gt;{@code Null} may be assigned to any reference type. This method
     * will return {@code true} if {@code null} is passed in and the
     * toClass is non-primitive.&lt;/p&gt;
     *
     * &lt;p&gt;Specifically, this method tests whether the type represented by the
     * specified {@code Class} parameter can be converted to the type
     * represented by this {@code Class} object via an identity conversion
     * widening primitive or widening reference conversion. See
     * &lt;em&gt;&lt;a href="http://docs.oracle.com/javase/specs/"&gt;The Java Language Specification&lt;/a&gt;&lt;/em&gt;,
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Since Lang 3.0,&lt;/strong&gt; this method will default behavior for
     * calculating assignability between primitive and wrapper types &lt;em&gt;corresponding
     * to the running Java version&lt;/em&gt;; i.e. autoboxing will be the default
     * behavior in VMs running Java versions &gt;= 1.5.&lt;/p&gt;
     *
     * @param cls  the Class to check, may be null
     * @param toClass  the Class to try to assign into, returns false if null
     * @return {@code true} if assignment possible
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAssignable</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>toClass</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isAssignable</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>toClass</name></expr></argument>, <argument><expr><call><name><name>SystemUtils</name><operator>.</operator><name>isJavaVersionAtLeast</name></name><argument_list>(<argument><expr><name><name>JavaVersion</name><operator>.</operator><name>JAVA_1_5</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Checks if one {@code Class} can be assigned to a variable of
     * another {@code Class}.&lt;/p&gt;
     *
     * &lt;p&gt;Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
     * this method takes into account widenings of primitive classes and
     * {@code null}s.&lt;/p&gt;
     *
     * &lt;p&gt;Primitive widenings allow an int to be assigned to a long, float or
     * double. This method returns the correct result for these cases.&lt;/p&gt;
     *
     * &lt;p&gt;{@code Null} may be assigned to any reference type. This method
     * will return {@code true} if {@code null} is passed in and the
     * toClass is non-primitive.&lt;/p&gt;
     *
     * &lt;p&gt;Specifically, this method tests whether the type represented by the
     * specified {@code Class} parameter can be converted to the type
     * represented by this {@code Class} object via an identity conversion
     * widening primitive or widening reference conversion. See
     * &lt;em&gt;&lt;a href="http://docs.oracle.com/javase/specs/"&gt;The Java Language Specification&lt;/a&gt;&lt;/em&gt;,
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.&lt;/p&gt;
     *
     * @param cls  the Class to check, may be null
     * @param toClass  the Class to try to assign into, returns false if null
     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
     * @return {@code true} if assignment possible
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isAssignable</name><parameter_list>(<parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>toClass</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>autoboxing</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>toClass</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// have to check for null, as isAssignableFrom doesn't</comment>
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>!</operator><call><name><name>toClass</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="line">//autoboxing:</comment>
        <if>if <condition>(<expr><name>autoboxing</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>cls</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>toClass</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cls</name> <operator>=</operator> <call><name>primitiveToWrapper</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>toClass</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>cls</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cls</name> <operator>=</operator> <call><name>wrapperToPrimitive</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>cls</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>cls</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>toClass</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Integer</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Long</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Long</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Boolean</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Long</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Short</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Long</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>Byte</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>Short</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Integer</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Long</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Float</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call>
                        <operator>||</operator> <call><name><name>Double</name><operator>.</operator><name>TYPE</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>toClass</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <comment type="line">// should never get here</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>toClass</name><operator>.</operator><name>isAssignableFrom</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the specified primitive Class object to its corresponding
     * wrapper Class object.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: From v2.2, this method handles {@code Void.TYPE},
     * returning {@code Void.TYPE}.&lt;/p&gt;
     *
     * @param cls  the class to convert, may be null
     * @return the wrapper class for {@code cls} or {@code cls} if
     * {@code cls} is not a primitive. {@code null} if null input.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>primitiveToWrapper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>convertedClass</name> <init>= <expr><name>cls</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cls</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>cls</name><operator>.</operator><name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>convertedClass</name> <operator>=</operator> <call><name><name>primitiveWrapperMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>convertedClass</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the specified array of primitive Class objects to an array of
     * its corresponding wrapper Class objects.&lt;/p&gt;
     *
     * @param classes  the class array to convert, may be null or empty
     * @return an array which contains for each given class, the wrapper class or
     * the original class if class is not a primitive. {@code null} if null input.
     * Empty array if an empty array passed in.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>primitivesToWrappers</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><modifier>...</modifier></type> <name>classes</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>classes</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>classes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>classes</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>convertedClasses</name> <init>= <expr><operator>new</operator> <name><name>Class</name><index>[<expr><name><name>classes</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>classes</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>convertedClasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>primitiveToWrapper</name><argument_list>(<argument><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>convertedClasses</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the specified wrapper class to its corresponding primitive
     * class.&lt;/p&gt;
     *
     * &lt;p&gt;This method is the counter part of {@code primitiveToWrapper()}.
     * If the passed in class is a wrapper class for a primitive type, this
     * primitive type will be returned (e.g. {@code Integer.TYPE} for
     * {@code Integer.class}). For other classes, or if the parameter is
     * &lt;b&gt;null&lt;/b&gt;, the return value is &lt;b&gt;null&lt;/b&gt;.&lt;/p&gt;
     *
     * @param cls the class to convert, may be &lt;b&gt;null&lt;/b&gt;
     * @return the corresponding primitive type if {@code cls} is a
     * wrapper class, &lt;b&gt;null&lt;/b&gt; otherwise
     * @see #primitiveToWrapper(Class)
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>wrapperToPrimitive</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>wrapperPrimitiveMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts the specified array of wrapper Class objects to an array of
     * its corresponding primitive Class objects.&lt;/p&gt;
     *
     * &lt;p&gt;This method invokes {@code wrapperToPrimitive()} for each element
     * of the passed in array.&lt;/p&gt;
     *
     * @param classes  the class array to convert, may be null or empty
     * @return an array which contains for each given class, the primitive class or
     * &lt;b&gt;null&lt;/b&gt; if the original class is not a wrapper class. {@code null} if null input.
     * Empty array if an empty array passed in.
     * @see #wrapperToPrimitive(Class)
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>wrappersToPrimitives</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><modifier>...</modifier></type> <name>classes</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>classes</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>classes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>classes</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>convertedClasses</name> <init>= <expr><operator>new</operator> <name><name>Class</name><index>[<expr><name><name>classes</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>classes</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>convertedClasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>wrapperToPrimitive</name><argument_list>(<argument><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>convertedClasses</name></expr>;</return>
    }</block></function>

    <comment type="line">// Inner class</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Is the specified class an inner class or static nested class.&lt;/p&gt;
     *
     * @param cls  the class to check, may be null
     * @return {@code true} if the class is an inner or static nested class,
     *  false if not or {@code null}
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isInnerClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name>cls</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>cls</name><operator>.</operator><name>getEnclosingClass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="line">// Class loading</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Returns the class represented by {@code className} using the
     * {@code classLoader}.  This implementation supports the syntaxes
     * "{@code java.util.Map.Entry[]}", "{@code java.util.Map$Entry[]}",
     * "{@code [Ljava.util.Map.Entry;}", and "{@code [Ljava.util.Map$Entry;}".
     *
     * @param classLoader  the class loader to use to load the class
     * @param className  the class name
     * @param initialize  whether the class must be initialized
     * @return the class represented by {@code className} using the {@code classLoader}
     * @throws ClassNotFoundException if the class is not found
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getClass</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>ClassLoader</name></type> <name>classLoader</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>className</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>initialize</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ClassNotFoundException</name></expr></argument></throws> <block>{
        <try>try <block>{
            <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>abbreviationMap</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>clsName</name> <init>= <expr><literal type="string">"["</literal> <operator>+</operator> <call><name><name>abbreviationMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>clazz</name> <operator>=</operator> <call><name><name>Class</name><operator>.</operator><name>forName</name></name><argument_list>(<argument><expr><name>clsName</name></expr></argument>, <argument><expr><name>initialize</name></expr></argument>, <argument><expr><name>classLoader</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getComponentType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>clazz</name> <operator>=</operator> <call><name><name>Class</name><operator>.</operator><name>forName</name></name><argument_list>(<argument><expr><call><name>toCanonicalName</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initialize</name></expr></argument>, <argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>clazz</name></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ClassNotFoundException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
            <comment type="line">// allow path separators (.) as inner class name separators</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastDotIndex</name> <init>= <expr><call><name><name>className</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><name>PACKAGE_SEPARATOR_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>lastDotIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
                <try>try <block>{
                    <return>return <expr><call><name>getClass</name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>, <argument><expr><call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lastDotIndex</name></expr></argument>)</argument_list></call> <operator>+</operator>
                                    <name>INNER_CLASS_SEPARATOR_CHAR</name> <operator>+</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>lastDotIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>initialize</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ClassNotFoundException</name></type> <name>ex2</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">// NOPMD</comment>
                    <comment type="line">// ignore exception</comment>
                }</block></catch></try>
            }</block></then></if>

            <throw>throw <expr><name>ex</name></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the (initialized) class represented by {@code className}
     * using the {@code classLoader}.  This implementation supports
     * the syntaxes "{@code java.util.Map.Entry[]}",
     * "{@code java.util.Map$Entry[]}", "{@code [Ljava.util.Map.Entry;}",
     * and "{@code [Ljava.util.Map$Entry;}".
     *
     * @param classLoader  the class loader to use to load the class
     * @param className  the class name
     * @return the class represented by {@code className} using the {@code classLoader}
     * @throws ClassNotFoundException if the class is not found
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ClassLoader</name></type> <name>classLoader</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ClassNotFoundException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>getClass</name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>, <argument><expr><name>className</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the (initialized) class represented by {@code className}
     * using the current thread's context class loader. This implementation
     * supports the syntaxes "{@code java.util.Map.Entry[]}",
     * "{@code java.util.Map$Entry[]}", "{@code [Ljava.util.Map.Entry;}",
     * and "{@code [Ljava.util.Map$Entry;}".
     *
     * @param className  the class name
     * @return the class represented by {@code className} using the current thread's context class loader
     * @throws ClassNotFoundException if the class is not found
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ClassNotFoundException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>getClass</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the class represented by {@code className} using the
     * current thread's context class loader. This implementation supports the
     * syntaxes "{@code java.util.Map.Entry[]}", "{@code java.util.Map$Entry[]}",
     * "{@code [Ljava.util.Map.Entry;}", and "{@code [Ljava.util.Map$Entry;}".
     *
     * @param className  the class name
     * @param initialize  whether the class must be initialized
     * @return the class represented by {@code className} using the current thread's context class loader
     * @throws ClassNotFoundException if the class is not found
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>className</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>initialize</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ClassNotFoundException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassLoader</name></type> <name>contextCL</name> <init>= <expr><call><name><name>Thread</name><operator>.</operator><name>currentThread</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getContextClassLoader</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassLoader</name></type> <name>loader</name> <init>= <expr><ternary><condition><expr><name>contextCL</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>ClassUtils</name><operator>.</operator><name><name>class</name><operator>.</operator><name>getClassLoader</name></name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>contextCL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getClass</name><argument_list>(<argument><expr><name>loader</name></expr></argument>, <argument><expr><name>className</name></expr></argument>, <argument><expr><name>initialize</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Public method</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns the desired Method much like {@code Class.getMethod}, however
     * it ensures that the returned Method is from a public class or interface and not
     * from an anonymous inner class. This means that the Method is invokable and
     * doesn't fall foul of Java bug
     * &lt;a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957"&gt;4071957&lt;/a&gt;).
     *
     *  &lt;code&gt;&lt;pre&gt;Set set = Collections.unmodifiableSet(...);
     *  Method method = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]);
     *  Object result = method.invoke(set, new Object[]);&lt;/pre&gt;&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param cls  the class to check, not null
     * @param methodName  the name of the method
     * @param parameterTypes  the list of parameters
     * @return the method
     * @throws NullPointerException if the class is null
     * @throws SecurityException if a security violation occurred
     * @throws NoSuchMethodException if the method is not found in the given class
     *  or if the metothod doen't conform with the requirements
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>Method</name></type> <name>getPublicMethod</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>methodName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><modifier>...</modifier></type> <name>parameterTypes</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>SecurityException</name></expr></argument>, <argument><expr><name>NoSuchMethodException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><specifier>final</specifier> <name>Method</name></type> <name>declaredMethod</name> <init>= <expr><call><name><name>cls</name><operator>.</operator><name>getMethod</name></name><argument_list>(<argument><expr><name>methodName</name></expr></argument>, <argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>Modifier</name><operator>.</operator><name>isPublic</name></name><argument_list>(<argument><expr><call><name><name>declaredMethod</name><operator>.</operator><name>getDeclaringClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getModifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>declaredMethod</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>candidateClasses</name> <init>= <expr><ternary><condition><expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></condition></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>candidateClasses</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name>getAllInterfaces</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>candidateClasses</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name>getAllSuperclasses</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>candidateClass</name> <range>: <expr><name>candidateClasses</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isPublic</name></name><argument_list>(<argument><expr><call><name><name>candidateClass</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><name>Method</name></type> <name>candidateMethod</name></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>candidateMethod</name> <operator>=</operator> <call><name><name>candidateClass</name><operator>.</operator><name>getMethod</name></name><argument_list>(<argument><expr><name>methodName</name></expr></argument>, <argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>NoSuchMethodException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
                <continue>continue;</continue>
            }</block></catch></try>
            <if>if <condition>(<expr><call><name><name>Modifier</name><operator>.</operator><name>isPublic</name></name><argument_list>(<argument><expr><call><name><name>candidateMethod</name><operator>.</operator><name>getDeclaringClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getModifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>candidateMethod</name></expr>;</return>
            }</block></then></if>
        }</block></for>

        <throw>throw <expr><operator>new</operator> <call><name>NoSuchMethodException</name><argument_list>(<argument><expr><literal type="string">"Can't find a public method for "</literal> <operator>+</operator>
                <name>methodName</name> <operator>+</operator> <literal type="string">" "</literal> <operator>+</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Converts a class name to a JLS style class name.
     *
     * @param className  the class name
     * @return the converted name
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toCanonicalName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>StringUtils</name><operator>.</operator><name>deleteWhitespace</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>className</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>(<argument><expr><literal type="string">"className must not be null."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>classNameBuffer</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>className</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>classNameBuffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>abbreviation</name> <init>= <expr><call><name><name>abbreviationMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>abbreviation</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classNameBuffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>abbreviation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>classNameBuffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"L"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>classNameBuffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
        <return>return <expr><name>className</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts an array of {@code Object} in to an array of {@code Class} objects.
     * If any of these objects is null, a null element will be inserted into the array.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns {@code null} for a {@code null} input array.&lt;/p&gt;
     *
     * @param array an {@code Object} array
     * @return a {@code Class} array, {@code null} if null array input
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>toClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name><modifier>...</modifier></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>array</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>array</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_CLASS_ARRAY</name></name></expr>;</return>
        }</block></then></if></elseif></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>classes</name> <init>= <expr><operator>new</operator> <name><name>Class</name><index>[<expr><name><name>array</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>classes</name></expr>;</return>
    }</block></function>

    <comment type="line">// Short canonical name</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the canonical name minus the package name for an {@code Object}.&lt;/p&gt;
     *
     * @param object  the class to get the short name for, may be null
     * @param valueIfNull  the value to return if null
     * @return the canonical name of the object without the package name, or the null value
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>valueIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>valueIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getShortCanonicalName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the canonical name minus the package name from a {@code Class}.&lt;/p&gt;
     *
     * @param cls  the class to get the short name for.
     * @return the canonical name without the package name or an empty string
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getShortCanonicalName</name><argument_list>(<argument><expr><call><name><name>cls</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the canonical name minus the package name from a String.&lt;/p&gt;
     *
     * &lt;p&gt;The string passed in is assumed to be a canonical name - it is not checked.&lt;/p&gt;
     *
     * @param canonicalName  the class name to get the short name for
     * @return the canonical name of the class without the package name or an empty string
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getShortCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>canonicalName</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ClassUtils</name><operator>.</operator><name>getShortClassName</name></name><argument_list>(<argument><expr><call><name>getCanonicalName</name><argument_list>(<argument><expr><name>canonicalName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Package name</comment>
    <comment type="line">// ----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name from the canonical name of an {@code Object}.&lt;/p&gt;
     *
     * @param object  the class to get the package name for, may be null
     * @param valueIfNull  the value to return if null
     * @return the package name of the object, or the null value
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>valueIfNull</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>object</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>valueIfNull</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getPackageCanonicalName</name><argument_list>(<argument><expr><call><name><name>object</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name from the canonical name of a {@code Class}.&lt;/p&gt;
     *
     * @param cls  the class to get the package name for, may be {@code null}.
     * @return the package name or an empty string
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cls</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>cls</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>StringUtils</name><operator>.</operator><name>EMPTY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>getPackageCanonicalName</name><argument_list>(<argument><expr><call><name><name>cls</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the package name from the canonical name. &lt;/p&gt;
     *
     * &lt;p&gt;The string passed in is assumed to be a canonical name - it is not checked.&lt;/p&gt;
     * &lt;p&gt;If the class is unpackaged, return an empty string.&lt;/p&gt;
     *
     * @param canonicalName  the canonical name to get the package name for, may be {@code null}
     * @return the package name or an empty string
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getPackageCanonicalName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>canonicalName</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ClassUtils</name><operator>.</operator><name>getPackageName</name></name><argument_list>(<argument><expr><call><name>getCanonicalName</name><argument_list>(<argument><expr><name>canonicalName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Converts a given name of class into canonical format.
     * If name of class is not a name of array class it returns
     * unchanged name.&lt;/p&gt;
     * &lt;p&gt;Example:
     * &lt;ul&gt;
     * &lt;li&gt;{@code getCanonicalName("[I") = "int[]"}&lt;/li&gt;
     * &lt;li&gt;{@code getCanonicalName("[Ljava.lang.String;") = "java.lang.String[]"}&lt;/li&gt;
     * &lt;li&gt;{@code getCanonicalName("java.lang.String") = "java.lang.String"}&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param className the name of class
     * @return canonical form of class name
     * @since 2.4
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getCanonicalName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>className</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>StringUtils</name><operator>.</operator><name>deleteWhitespace</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>className</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>dim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>className</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>dim</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr><name>dim</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>className</name></expr>;</return>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"L"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(
                            <argument><expr><literal type="number">1</literal></expr></argument>,
                            <argument><expr><ternary><condition><expr><call><name><name>className</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>
                                    ?</condition><then> <expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>
                                    </then><else>: <expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><call><name><name>className</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>className</name> <operator>=</operator> <call><name><name>reverseAbbreviationMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>className</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
                <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>canonicalClassNameBuffer</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><call><name><name>canonicalClassNameBuffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <return>return <expr><call><name><name>canonicalClassNameBuffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></else></if>
    }</block></function>

}



<comment type="block" format="javadoc">/**
 * &lt;p&gt;
 * Assists in implementing {@link Object#toString()} methods using reflection.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class uses reflection to determine the fields to append. Because these fields are usually private, the class
 * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to
 * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are
 * set up correctly.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these
 * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use
 * synchronization consistent with the class' lock management around the invocation of the method. Take special care to
 * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if
 * modified while the toString method is executing.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A typical invocation for this method would look like:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * public String toString() {
 *     return ReflectionToStringBuilder.toString(this);
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * You can also use the builder to debug 3rd party objects:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * System.out.println(&amp;quot;An object: &amp;quot; + ReflectionToStringBuilder.toString(anObject));
 * &lt;/pre&gt;
 * &lt;p&gt;
 * A subclass can control field output by overriding the methods:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #accept(java.lang.reflect.Field)}&lt;/li&gt;
 * &lt;li&gt;{@link #getValue(java.lang.reflect.Field)}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, this method does &lt;i&gt;not&lt;/i&gt; include the &lt;code&gt;password&lt;/code&gt; field in the returned &lt;code&gt;String&lt;/code&gt;:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * public String toString() {
 *     return (new ReflectionToStringBuilder(this) {
 *         protected boolean accept(Field f) {
 *             return super.accept(f) &amp;amp;&amp;amp; !f.getName().equals(&amp;quot;password&amp;quot;);
 *         }
 *     }).toString();
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The exact format of the &lt;code&gt;toString&lt;/code&gt; is determined by the {@link ToStringStyle} passed into the constructor.
 * &lt;/p&gt;
 *
 * @since 2.0
 * @version $Id$
 */</comment>
class <expr_stmt><expr><name>ReflectionToStringBuilder</name> extends <name>ToStringBuilder</name> <block>{

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Builds a &lt;code&gt;toString&lt;/code&gt; value using the default &lt;code&gt;ToStringStyle&lt;/code&gt; through reflection.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Transient members will be not be included, as they are likely derived. Static fields will not be included.
     * Superclass fields will be appended.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to be output
     * @return the String result
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <expr><specifier>public</specifier> <specifier>static</specifier> <name>String</name> <call><name>toString</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>object</name></expr></argument>)</argument_list></call> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return></block></expr>
    }</block>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Builds a &lt;code&gt;toString&lt;/code&gt; value through reflection.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Transient members will be not be included, as they are likely derived. Static fields will not be included.
     * Superclass fields will be appended.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default &lt;code&gt;ToStringStyle&lt;/code&gt; is used.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to be output
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @return the String result
     * @throws IllegalArgumentException
     *             if the Object or &lt;code&gt;ToStringStyle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <specifier>public</specifier> <specifier>static</specifier> <name>String</name> <call><name>toString</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>object</name></expr></argument>, <argument><expr><name>final</name> <name>ToStringStyle</name> <name>style</name></expr></argument>)</argument_list></call> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Builds a &lt;code&gt;toString&lt;/code&gt; value through reflection.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the &lt;code&gt;outputTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, transient members will be output, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the Object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be included. Superclass fields will be appended.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default &lt;code&gt;ToStringStyle&lt;/code&gt; is used.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to be output
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients
     *            whether to include transient fields
     * @return the String result
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>outputTransients</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Builds a &lt;code&gt;toString&lt;/code&gt; value through reflection.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the &lt;code&gt;outputTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, transient fields will be output, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the Object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the &lt;code&gt;outputStatics&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, static fields will be output, otherwise they are
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Static fields will not be included. Superclass fields will be appended.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default &lt;code&gt;ToStringStyle&lt;/code&gt; is used.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to be output
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients
     *            whether to include transient fields
     * @param outputStatics
     *            whether to include transient fields
     * @return the String result
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputStatics</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>outputTransients</name></expr></argument>, <argument><expr><name>outputStatics</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Builds a &lt;code&gt;toString&lt;/code&gt; value through reflection.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private fields. This means that it will
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is
     * also not as efficient as testing explicitly.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the &lt;code&gt;outputTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, transient fields will be output, otherwise they
     * are ignored, as they are likely derived fields, and not part of the value of the Object.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the &lt;code&gt;outputStatics&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, static fields will be output, otherwise they are
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as
     * &lt;code&gt;java.lang.Object&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default &lt;code&gt;ToStringStyle&lt;/code&gt; is used.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt;
     *            the type of the object
     * @param object
     *            the Object to be output
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients
     *            whether to include transient fields
     * @param outputStatics
     *            whether to include static fields
     * @param reflectUpToClass
     *            the superclass to reflect up to (inclusive), may be &lt;code&gt;null&lt;/code&gt;
     * @return the String result
     * @throws IllegalArgumentException
     *             if the Object is &lt;code&gt;null&lt;/code&gt;
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name>String</name></type> <name>toString</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputStatics</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>ReflectionToStringBuilder</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>reflectUpToClass</name></expr></argument>, <argument><expr><name>outputTransients</name></expr></argument>, <argument><expr><name>outputStatics</name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Builds a String for a toString method excluding the given field names.
     *
     * @param object
     *            The object to "toString".
     * @param excludeFieldNames
     *            The field names to exclude. Null excludes nothing.
     * @return The toString value.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toStringExclude</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>excludeFieldNames</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>toStringExclude</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><call><name>toNoNullStringArray</name><argument_list>(<argument><expr><name>excludeFieldNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Converts the given Collection into an array of Strings. The returned array does not contain &lt;code&gt;null&lt;/code&gt;
     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param collection
     *            The collection to convert
     * @return A new array of Strings.
     */</comment>
    <function><specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>toNoNullStringArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>collection</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>collection</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>toNoNullStringArray</name><argument_list>(<argument><expr><call><name><name>collection</name><operator>.</operator><name>toArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists
     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}
     * if an array element is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param array
     *            The array to check
     * @return The given array or a new array without null.
     */</comment>
    <function><specifier>static</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>toNoNullStringArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>array</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Object</name></type> <name>e</name> <range>: <expr><name>array</name></expr></range></decl></init>)</control> <block>{
            <if>if <condition>(<expr><name>e</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><name><name>ArrayUtils</name><operator>.</operator><name>EMPTY_STRING_ARRAY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Builds a String for a toString method excluding the given field names.
     *
     * @param object
     *            The object to "toString".
     * @param excludeFieldNames
     *            The field names to exclude
     * @return The toString value.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>toStringExclude</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFieldNames</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>ReflectionToStringBuilder</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>setExcludeFieldNames</name><argument_list>(<argument><expr><name>excludeFieldNames</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Whether or not to append static fields.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>appendStatics</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether or not to append transient fields.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>appendTransients</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Which field names to exclude from output. Intended for fields like &lt;code&gt;"password"&lt;/code&gt;.
     *
     * @since 3.0 this is protected instead of private
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>excludeFieldNames</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The last super class to stop appending fields for.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>upToClass</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Constructor.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This constructor outputs using the default style set with &lt;code&gt;setDefaultStyle&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to build a &lt;code&gt;toString&lt;/code&gt; for, must not be &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the Object passed in is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ReflectionToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Constructor.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default style is used.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to build a &lt;code&gt;toString&lt;/code&gt; for, must not be &lt;code&gt;null&lt;/code&gt;
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the Object passed in is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ReflectionToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Constructor.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the style is &lt;code&gt;null&lt;/code&gt;, the default style is used.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the buffer is &lt;code&gt;null&lt;/code&gt;, a new one is created.
     * &lt;/p&gt;
     *
     * @param object
     *            the Object to build a &lt;code&gt;toString&lt;/code&gt; for
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param buffer
     *            the &lt;code&gt;StringBuffer&lt;/code&gt; to populate, may be &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException
     *             if the Object passed in is &lt;code&gt;null&lt;/code&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>ReflectionToStringBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructor.
     *
     * @param &lt;T&gt;
     *            the type of the object
     * @param object
     *            the Object to build a &lt;code&gt;toString&lt;/code&gt; for
     * @param style
     *            the style of the &lt;code&gt;toString&lt;/code&gt; to create, may be &lt;code&gt;null&lt;/code&gt;
     * @param buffer
     *            the &lt;code&gt;StringBuffer&lt;/code&gt; to populate, may be &lt;code&gt;null&lt;/code&gt;
     * @param reflectUpToClass
     *            the superclass to reflect up to (inclusive), may be &lt;code&gt;null&lt;/code&gt;
     * @param outputTransients
     *            whether to include transient fields
     * @param outputStatics
     *            whether to include static fields
     * @since 2.1
     */</comment>
    <constructor><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <name>ReflectionToStringBuilder</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>T</name></type> <name>object</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>ToStringStyle</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StringBuffer</name></type> <name>buffer</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>T</name></super></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputTransients</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>outputStatics</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setUpToClass</name></name><argument_list>(<argument><expr><name>reflectUpToClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setAppendTransients</name></name><argument_list>(<argument><expr><name>outputTransients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>setAppendStatics</name></name><argument_list>(<argument><expr><name>outputStatics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Returns whether or not to append the given &lt;code&gt;Field&lt;/code&gt;.
     * &lt;ul&gt;
     * &lt;li&gt;Transient fields are appended only if {@link #isAppendTransients()} returns &lt;code&gt;true&lt;/code&gt;.
     * &lt;li&gt;Static fields are appended only if {@link #isAppendStatics()} returns &lt;code&gt;true&lt;/code&gt;.
     * &lt;li&gt;Inner class fields are not appended.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param field
     *            The Field to test.
     * @return Whether or not to append the given &lt;code&gt;Field&lt;/code&gt;.
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>accept</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Field</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>field</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><name><name>ClassUtils</name><operator>.</operator><name>INNER_CLASS_SEPARATOR_CHAR</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
            <comment type="line">// Reject field from inner class.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>Modifier</name><operator>.</operator><name>isTransient</name></name><argument_list>(<argument><expr><call><name><name>field</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>this</name><operator>.</operator><name>isAppendTransients</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Reject transient fields.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>Modifier</name><operator>.</operator><name>isStatic</name></name><argument_list>(<argument><expr><call><name><name>field</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>this</name><operator>.</operator><name>isAppendStatics</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Reject static fields.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>excludeFieldNames</name></name> <operator>!=</operator> <literal type="null">null</literal>
                <operator>&amp;&amp;</operator> <call><name><name>Arrays</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>excludeFieldNames</name></name></expr></argument>, <argument><expr><call><name><name>field</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <comment type="line">// Reject fields from the getExcludeFieldNames list.</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Appends the fields and values defined by the given object of the given Class.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If a cycle is detected as an object is &amp;quot;toString()'ed&amp;quot;, such an object is rendered as if
     * &lt;code&gt;Object.toString()&lt;/code&gt; had been called and not implemented by the object.
     * &lt;/p&gt;
     *
     * @param clazz
     *            The class of object parameter
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>appendFieldsIn</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>clazz</name><operator>.</operator><name>isArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>reflectionAppendArray</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Field</name><index>[]</index></name></type> <name>fields</name> <init>= <expr><call><name><name>clazz</name><operator>.</operator><name>getDeclaredFields</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>AccessibleObject</name><operator>.</operator><name>setAccessible</name></name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Field</name></type> <name>field</name> <range>: <expr><name>fields</name></expr></range></decl></init>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name> <init>= <expr><call><name><name>field</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <try>try <block>{
                    <comment type="line">// Warning: Field.get(Object) creates wrappers objects</comment>
                    <comment type="line">// for primitive types.</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>fieldValue</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>fieldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalAccessException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
                    <comment type="line">//this can't happen. Would get a Security exception</comment>
                    <comment type="line">// instead</comment>
                    <comment type="line">//throw a runtime exception in case the impossible</comment>
                    <comment type="line">// happens.</comment>
                    <throw>throw <expr><operator>new</operator> <call><name>InternalError</name><argument_list>(<argument><expr><literal type="string">"Unexpected IllegalAccessException: "</literal> <operator>+</operator> <call><name><name>ex</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></then></if>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return Returns the excludeFieldNames.
     */</comment>
    <function><specifier>public</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>getExcludeFieldNames</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>excludeFieldNames</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the last super class to stop appending fields for.
     * &lt;/p&gt;
     *
     * @return The last super class to stop appending fields for.
     */</comment>
    <function><specifier>public</specifier> <type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getUpToClass</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>upToClass</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Calls &lt;code&gt;java.lang.reflect.Field.get(Object)&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param field
     *            The Field to query.
     * @return The Object from the given Field.
     *
     * @throws IllegalArgumentException
     *             see {@link java.lang.reflect.Field#get(Object)}
     * @throws IllegalAccessException
     *             see {@link java.lang.reflect.Field#get(Object)}
     *
     * @see java.lang.reflect.Field#get(Object)
     */</comment>
    <function><specifier>protected</specifier> <type><name>Object</name></type> <name>getValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Field</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IllegalArgumentException</name></expr></argument>, <argument><expr><name>IllegalAccessException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name><name>field</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets whether or not to append static fields.
     * &lt;/p&gt;
     *
     * @return Whether or not to append static fields.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isAppendStatics</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>appendStatics</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets whether or not to append transient fields.
     * &lt;/p&gt;
     *
     * @return Whether or not to append transient fields.
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isAppendTransients</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>appendTransients</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Append to the &lt;code&gt;toString&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt; array.
     * &lt;/p&gt;
     *
     * @param array
     *            the array to add to the &lt;code&gt;toString&lt;/code&gt;
     * @return this
     */</comment>
    <function><specifier>public</specifier> <type><name>ReflectionToStringBuilder</name></type> <name>reflectionAppendArray</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>array</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>getStyle</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>reflectionAppendArrayDetail</name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getStringBuffer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Sets whether or not to append static fields.
     * &lt;/p&gt;
     *
     * @param appendStatics
     *            Whether or not to append static fields.
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setAppendStatics</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>appendStatics</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>appendStatics</name></name> <operator>=</operator> <name>appendStatics</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Sets whether or not to append transient fields.
     * &lt;/p&gt;
     *
     * @param appendTransients
     *            Whether or not to append transient fields.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setAppendTransients</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>appendTransients</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>appendTransients</name></name> <operator>=</operator> <name>appendTransients</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the field names to exclude.
     *
     * @param excludeFieldNamesParam
     *            The excludeFieldNames to excluding from toString or &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;this&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>ReflectionToStringBuilder</name></type> <name>setExcludeFieldNames</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFieldNamesParam</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>excludeFieldNamesParam</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>excludeFieldNames</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">//clone and remove nulls</comment>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>excludeFieldNames</name></name> <operator>=</operator> <call><name>toNoNullStringArray</name><argument_list>(<argument><expr><name>excludeFieldNamesParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>excludeFieldNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Sets the last super class to stop appending fields for.
     * &lt;/p&gt;
     *
     * @param clazz
     *            The last super class to stop appending fields for.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setUpToClass</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>clazz</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>object</name> <init>= <expr><call><name>getObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>object</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>clazz</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Specified class is not a superclass of the object"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>upToClass</name></name> <operator>=</operator> <name>clazz</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the String built by this builder.
     * &lt;/p&gt;
     *
     * @return the built string
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>this</name><operator>.</operator><name>getStyle</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNullText</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>getObject</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>appendFieldsIn</name></name><argument_list>(<argument><expr><name>clazz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>clazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>clazz</name> <operator>!=</operator> <call><name><name>this</name><operator>.</operator><name>getUpToClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>clazz</name> <operator>=</operator> <call><name><name>clazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>appendFieldsIn</name></name><argument_list>(<argument><expr><name>clazz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><call><name><name>super</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

}


<comment type="block" format="javadoc">/**
 * &lt;p&gt;
 * The Builder interface is designed to designate a class as a &lt;em&gt;builder&lt;/em&gt;
 * object in the Builder design pattern. Builders are capable of creating and
 * configuring objects or results that normally take multiple steps to construct
 * or are very complex to derive.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The builder interface defines a single method, {@link #build()}, that
 * classes must implement. The result of this method should be the final
 * configured object or result after all building operations are performed.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * It is a recommended practice that the methods supplied to configure the
 * object or result being built return a reference to {@code this} so that
 * method calls can be chained together.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Example Builder:
 * &lt;code&gt;&lt;pre&gt;
 * class FontBuilder implements Builder&amp;lt;Font&amp;gt; {
 *     private Font font;
 *
 *     public FontBuilder(String fontName) {
 *         this.font = new Font(fontName, Font.PLAIN, 12);
 *     }
 *
 *     public FontBuilder bold() {
 *         this.font = this.font.deriveFont(Font.BOLD);
 *         return this; // Reference returned so calls can be chained
 *     }
 *
 *     public FontBuilder size(float pointSize) {
 *         this.font = this.font.deriveFont(pointSize);
 *         return this; // Reference returned so calls can be chained
 *     }
 *
 *     // Other Font construction methods
 *
 *     public Font build() {
 *         return this.font;
 *     }
 * }
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * Example Builder Usage:
 * &lt;code&gt;&lt;pre&gt;
 * Font bold14ptSansSerifFont = new FontBuilder(Font.SANS_SERIF).bold()
 *                                                              .size(14.0f)
 *                                                              .build();
 * &lt;/pre&gt;&lt;/code&gt;
 * &lt;/p&gt;
 *
 * @param &lt;T&gt; the type of object that the builder will construct or compute.
 *
 * @since 3.0
 * @version $Id$
 */</comment>
interface <expr_stmt><expr><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name> <block>{

    <comment type="block" format="javadoc">/**
     * Returns a reference to the object being constructed or result being
     * calculated by the builder.
     *
     * @return the object constructed or result calculated by the builder.
     */</comment>
    <expr><name>T</name> <call><name>build</name><argument_list>()</argument_list></call></expr>;
}</block>



<comment type="line">// adapted from org.apache.axis.utils.IDKey</comment>

<comment type="block" format="javadoc">/**
 * Wrap an identity key (System.identityHashCode())
 * so that an object can only be equal() to itself.
 *
 * This is necessary to disambiguate the occasional duplicate
 * identityHashCodes that can occur.
 *
 */</comment>
<name>final</name> <name>class</name> <name>IDKey</name> <block>{
    <expr><specifier>private</specifier> <name>final</name> <name>Object</name> <name>value</name></expr>;
    <expr><specifier>private</specifier> <name>final</name> <name>int</name> <name>id</name></expr>;

    <comment type="block" format="javadoc">/**
     * Constructor for IDKey
     * @param _value The value
     */</comment>
    <expr><specifier>public</specifier> <call><name>IDKey</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>_value</name></expr></argument>)</argument_list></call> <block>{
        <comment type="line">// This is the Object hashcode</comment>
        <expr><name>id</name> <operator>=</operator> <call><name><name>System</name><operator>.</operator><name>identityHashCode</name></name><argument_list>(<argument><expr><name>_value</name></expr></argument>)</argument_list></call></expr>;
        <comment type="line">// There have been some cases (LANG-459) that return the</comment>
        <comment type="line">// same identity hash code for different objects.  So</comment>
        <comment type="line">// the value is also added to disambiguate these cases.</comment>
        <expr><name>value</name> <operator>=</operator> <name>_value</name></expr>;
    }</block>

    <comment type="block" format="javadoc">/**
     * returns hashcode - i.e. the system identity hashcode.
     * @return the hashcode
     */</comment>
    @<name>Override</name>
    <specifier>public</specifier> <name>int</name> <call><name>hashCode</name><argument_list>()</argument_list></call> <block>{
        <return>return <expr><name>id</name></expr>;</return></block></expr>
    }</block>

    <comment type="block" format="javadoc">/**
     * checks if instances are equal
     * @param other The other object to compare to
     * @return if the instances are for the same object
     */</comment>
    @<name>Override</name>
    <specifier>public</specifier> <name>boolean</name> <call><name>equals</name><argument_list>(<argument><expr><name>final</name> <name>Object</name> <name>other</name></expr></argument>)</argument_list></call> <block>{
        <if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>other</name> <operator>instanceof</operator> <name>IDKey</name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        <expr_stmt/></block></then></if>}</block>
        <name>final</name> <name>IDKey</name> <name>idKey</name> <operator>=</operator> <operator>(</operator><name>IDKey</name><operator>)</operator> <name>other</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>id</name> <operator>!=</operator> <name><name>idKey</name><operator>.</operator><name>id</name></name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <comment type="line">// Note that identity equals is used.</comment>
        <return>return <expr><name>value</name> <operator>==</operator> <name><name>idKey</name><operator>.</operator><name>value</name></name></expr>;</return>
    }
}



<comment type="block" format="javadoc">/**
 * &lt;p&gt;A pair consisting of two elements.&lt;/p&gt;
 *
 * &lt;p&gt;This class is an abstract implementation defining the basic API.
 * It refers to the elements as 'left' and 'right'. It also implements the
 * {@code Map.Entry} interface where the key is 'left' and the value is 'right'.&lt;/p&gt;
 *
 * &lt;p&gt;Subclass implementations may be mutable or immutable.
 * However, there is no restriction on the type of the stored objects that may be stored.
 * If mutable objects are stored in the pair, then the pair itself effectively becomes mutable.&lt;/p&gt;
 *
 * @param &lt;L&gt; the left element type
 * @param &lt;R&gt; the right element type
 *
 * @since Lang 3.0
 * @version $Id$
 */</comment>
<class><specifier>abstract</specifier> class <name><name>Pair</name><parameter_list>&lt;<parameter><name>L</name></parameter>, <parameter><name>R</name></parameter>&gt;</parameter_list></name> <super><implements>implements <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></name>, <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name>, <name>Serializable</name></implements></super> <block>{

    <comment type="block" format="javadoc">/** Serialization version */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">4954918890077093841L</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Obtains an immutable pair of from two objects inferring the generic types.&lt;/p&gt;
     *
     * &lt;p&gt;This factory allows the pair to be created using inference to
     * obtain the generic types.&lt;/p&gt;
     *
     * @param &lt;L&gt; the left element type
     * @param &lt;R&gt; the right element type
     * @param left  the left element, may be null
     * @param right  the right element, may be null
     * @return a pair formed from the two parameters, not null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>L</name></parameter>, <parameter><name>R</name></parameter>&gt;</parameter_list> <type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></type> <name>of</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>L</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>R</name></type> <name>right</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name><name>ImmutablePair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the left element from this pair.&lt;/p&gt;
     *
     * &lt;p&gt;When treated as a key-value pair, this is the key.&lt;/p&gt;
     *
     * @return the left element, may be null
     */</comment>
    <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>L</name></type> <name>getLeft</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the right element from this pair.&lt;/p&gt;
     *
     * &lt;p&gt;When treated as a key-value pair, this is the value.&lt;/p&gt;
     *
     * @return the right element, may be null
     */</comment>
    <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>R</name></type> <name>getRight</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the key from this pair.&lt;/p&gt;
     *
     * &lt;p&gt;This method implements the {@code Map.Entry} interface returning the
     * left element as the key.&lt;/p&gt;
     *
     * @return the left element as the key, may be null
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <specifier>final</specifier> <type><name>L</name></type> <name>getKey</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getLeft</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Gets the value from this pair.&lt;/p&gt;
     *
     * &lt;p&gt;This method implements the {@code Map.Entry} interface returning the
     * right element as the value.&lt;/p&gt;
     *
     * @return the right element as the value, may be null
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>R</name></type> <name>getValue</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getRight</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares the pair based on the left element followed by the right element.
     * The types must be {@code Comparable}.&lt;/p&gt;
     *
     * @param other  the other pair, not null
     * @return negative if this is less, zero if equal, positive if greater
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>CompareToBuilder</name><argument_list>()</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>getLeft</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>getRight</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>toComparison</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares this pair to another based on the two elements.&lt;/p&gt;
     *
     * @param obj  the object to compare to, null returns false
     * @return true if the elements of the pair are equal
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>this</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><ternary><condition><expr><name>obj</name> <operator>instanceof</operator> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></name></expr>)</condition> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>other</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></name></expr></condition></ternary><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>ObjectUtils</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name>getKey</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                    <operator>&amp;&amp;</operator> <call><name><name>ObjectUtils</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></ternary></expr></condition></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns a suitable hash code.
     * The hash code follows the definition in {@code Map.Entry}.&lt;/p&gt;
     *
     * @return the hash code
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// see Map.Entry API specification</comment>
        <return>return <expr><operator>(</operator><ternary><condition><expr><call><name>getKey</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>getKey</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hashCode</name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator> <operator>^</operator>
                <operator>(</operator><ternary><condition><expr><call><name>getValue</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>getValue</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hashCode</name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Returns a String representation of this pair using the format {@code ($left,$right)}.&lt;/p&gt;
     *
     * @return a string describing this object, not null
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>getLeft</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>getRight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Formats the receiver using the given format.&lt;/p&gt;
     *
     * &lt;p&gt;This uses {@link java.util.Formattable} to perform the formatting. Two variables may
     * be used to embed the left and right elements. Use {@code %1$s} for the left
     * element (key) and {@code %2$s} for the right element (value).
     * The default format used by {@code toString()} is {@code (%1$s,%2$s)}.&lt;/p&gt;
     *
     * @param format  the format string, optionally containing {@code %1$s} and {@code %2$s}, not null
     * @return the formatted string, not null
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>format</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><call><name>getLeft</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>


<comment type="block" format="javadoc">/**
 * A matcher class that can be queried to determine if a character array
 * portion matches.
 * &lt;p&gt;
 * This class comes complete with various factory methods.
 * If these do not suffice, you can subclass and implement your own matcher.
 *
 * @since 2.2
 * @version $Id$
 */</comment>
<class><specifier>abstract</specifier> class <name>StrMatcher</name> <block>{

    <comment type="block" format="javadoc">/**
     * Matches the comma character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>COMMA_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the tab character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>TAB_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the space character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>SPACE_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the same characters as StringTokenizer,
     * namely space, tab, newline, formfeed.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>SPLIT_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharSetMatcher</name><argument_list>(<argument><expr><literal type="string">" \t\n\r\f"</literal><operator>.</operator><call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the String trim() whitespace characters.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>TRIM_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>TrimMatcher</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the double quote character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>SINGLE_QUOTE_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the double quote character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>DOUBLE_QUOTE_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches the single or double quote character.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>QUOTE_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>CharSetMatcher</name><argument_list>(<argument><expr><literal type="string">"'\""</literal><operator>.</operator><call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * Matches no characters.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrMatcher</name></type> <name>NONE_MATCHER</name> <init>= <expr><operator>new</operator> <call><name>NoMatcher</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// -----------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the comma character.
     *
     * @return a matcher for a comma
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>commaMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>COMMA_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the tab character.
     *
     * @return a matcher for a tab
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>tabMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>TAB_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the space character.
     *
     * @return a matcher for a space
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>spaceMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>SPACE_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Matches the same characters as StringTokenizer,
     * namely space, tab, newline and formfeed.
     *
     * @return the split matcher
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>splitMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>SPLIT_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Matches the String trim() whitespace characters.
     *
     * @return the trim matcher
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>trimMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>TRIM_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the single quote character.
     *
     * @return a matcher for a single quote
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>singleQuoteMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>SINGLE_QUOTE_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the double quote character.
     *
     * @return a matcher for a double quote
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>doubleQuoteMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>DOUBLE_QUOTE_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a matcher which matches the single or double quote character.
     *
     * @return a matcher for a single or double quote
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>quoteMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>QUOTE_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Matches no characters.
     *
     * @return a matcher that matches nothing
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>noneMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>NONE_MATCHER</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Constructor that creates a matcher from a character.
     *
     * @param ch  the character to match, must not be null
     * @return a new Matcher for the given char
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>charMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Constructor that creates a matcher from a set of characters.
     *
     * @param chars  the characters to match, null or empty matches nothing
     * @return a new matcher for the given char[]
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>charSetMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name><modifier>...</modifier></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>chars</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>NONE_MATCHER</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>chars</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>CharSetMatcher</name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Constructor that creates a matcher from a string representing a set of characters.
     *
     * @param chars  the characters to match, null or empty matches nothing
     * @return a new Matcher for the given characters
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>charSetMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NONE_MATCHER</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>chars</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <return>return <expr><operator>new</operator> <call><name>CharMatcher</name><argument_list>(<argument><expr><call><name><name>chars</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>CharSetMatcher</name><argument_list>(<argument><expr><call><name><name>chars</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Constructor that creates a matcher from a string.
     *
     * @param str  the string to match, null or empty matches nothing
     * @return a new Matcher for the given String
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrMatcher</name></type> <name>stringMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NONE_MATCHER</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>StringMatcher</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Constructor.
     */</comment>
    <constructor><specifier>protected</specifier> <name>StrMatcher</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Returns the number of matching characters, zero for no match.
     * &lt;p&gt;
     * This method is called to check for a match.
     * The parameter &lt;code&gt;pos&lt;/code&gt; represents the current position to be
     * checked in the string &lt;code&gt;buffer&lt;/code&gt; (a character array which must
     * not be changed).
     * The API guarantees that &lt;code&gt;pos&lt;/code&gt; is a valid index for &lt;code&gt;buffer&lt;/code&gt;.
     * &lt;p&gt;
     * The character array may be larger than the active area to be matched.
     * Only values in the buffer between the specifed indices may be accessed.
     * &lt;p&gt;
     * The matching code may check one character or many.
     * It may check characters preceding &lt;code&gt;pos&lt;/code&gt; as well as those
     * after, so long as no checks exceed the bounds specified.
     * &lt;p&gt;
     * It must return zero for no match, or a positive number if a match was found.
     * The number indicates the number of characters that matched.
     *
     * @param buffer  the text content to match against, do not change
     * @param pos  the starting position for the match, valid for buffer
     * @param bufferStart  the first active index in the buffer, valid for buffer
     * @param bufferEnd  the end index (exclusive) of the active buffer, valid for buffer
     * @return the number of matching characters, zero for no match
     */</comment>
    <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Returns the number of matching characters, zero for no match.
     * &lt;p&gt;
     * This method is called to check for a match.
     * The parameter &lt;code&gt;pos&lt;/code&gt; represents the current position to be
     * checked in the string &lt;code&gt;buffer&lt;/code&gt; (a character array which must
     * not be changed).
     * The API guarantees that &lt;code&gt;pos&lt;/code&gt; is a valid index for &lt;code&gt;buffer&lt;/code&gt;.
     * &lt;p&gt;
     * The matching code may check one character or many.
     * It may check characters preceding &lt;code&gt;pos&lt;/code&gt; as well as those after.
     * &lt;p&gt;
     * It must return zero for no match, or a positive number if a match was found.
     * The number indicates the number of characters that matched.
     *
     * @param buffer  the text content to match against, do not change
     * @param pos  the starting position for the match, valid for buffer
     * @return the number of matching characters, zero for no match
     * @since 2.4
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isMatch</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Class used to define a set of characters for matching purposes.
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>CharSetMatcher</name> <super><extends>extends <name>StrMatcher</name></extends></super> <block>{
        <comment type="block" format="javadoc">/** The set of characters to match. */</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Constructor that creates a matcher from a character array.
         *
         * @param chars  the characters to match, must not be null
         */</comment>
        <constructor><name>CharSetMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name><name>chars</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <call><name><name>chars</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>chars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * Returns whether or not the given character matches.
         *
         * @param buffer  the text content to match against, do not change
         * @param pos  the starting position for the match, valid for buffer
         * @param bufferStart  the first active index in the buffer, valid for buffer
         * @param bufferEnd  the end index of the active buffer, valid for buffer
         * @return the number of matching characters, zero for no match
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><ternary><condition><expr><call><name><name>Arrays</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Class used to define a character for matching purposes.
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>CharMatcher</name> <super><extends>extends <name>StrMatcher</name></extends></super> <block>{
        <comment type="block" format="javadoc">/** The character to match. */</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Constructor that creates a matcher that matches a single character.
         *
         * @param ch  the character to match
         */</comment>
        <constructor><name>CharMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ch</name></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * Returns whether or not the given character matches.
         *
         * @param buffer  the text content to match against, do not change
         * @param pos  the starting position for the match, valid for buffer
         * @param bufferStart  the first active index in the buffer, valid for buffer
         * @param bufferEnd  the end index of the active buffer, valid for buffer
         * @return the number of matching characters, zero for no match
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><ternary><condition><expr><name>ch</name> <operator>==</operator> <name><name>buffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Class used to define a set of characters for matching purposes.
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>StringMatcher</name> <super><extends>extends <name>StrMatcher</name></extends></super> <block>{
        <comment type="block" format="javadoc">/** The string to match, as a character array. */</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Constructor that creates a matcher from a String.
         *
         * @param str  the string to match, must not be null
         */</comment>
        <constructor><name>StringMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * Returns whether or not the given text matches the stored string.
         *
         * @param buffer  the text content to match against, do not change
         * @param pos  the starting position for the match, valid for buffer
         * @param bufferStart  the first active index in the buffer, valid for buffer
         * @param bufferEnd  the end index of the active buffer, valid for buffer
         * @return the number of matching characters, zero for no match
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name><name>chars</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>pos</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>bufferEnd</name></expr>)</condition><then> <block>{
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            }</block></then></if>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>buffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr><name>len</name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Class used to match no characters.
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>NoMatcher</name> <super><extends>extends <name>StrMatcher</name></extends></super> <block>{

        <comment type="block" format="javadoc">/**
         * Constructs a new instance of &lt;code&gt;NoMatcher&lt;/code&gt;.
         */</comment>
        <constructor><name>NoMatcher</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * Always returns &lt;code&gt;false&lt;/code&gt;.
         *
         * @param buffer  the text content to match against, do not change
         * @param pos  the starting position for the match, valid for buffer
         * @param bufferStart  the first active index in the buffer, valid for buffer
         * @param bufferEnd  the end index of the active buffer, valid for buffer
         * @return the number of matching characters, zero for no match
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Class used to match whitespace as per trim().
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>TrimMatcher</name> <super><extends>extends <name>StrMatcher</name></extends></super> <block>{

        <comment type="block" format="javadoc">/**
         * Constructs a new instance of &lt;code&gt;TrimMatcher&lt;/code&gt;.
         */</comment>
        <constructor><name>TrimMatcher</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="block" format="javadoc">/**
         * Returns whether or not the given character matches.
         *
         * @param buffer  the text content to match against, do not change
         * @param pos  the starting position for the match, valid for buffer
         * @param bufferStart  the first active index in the buffer, valid for buffer
         * @param bufferEnd  the end index of the active buffer, valid for buffer
         * @return the number of matching characters, zero for no match
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>int</name></type> <name>isMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>bufferEnd</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><ternary><condition><expr><name><name>buffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">32</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
        }</block></function>
    }</block></class>

}</block></class>



<comment type="block" format="javadoc">/**
 * &lt;p&gt;
 * Helpers for {@code java.lang.System}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If a system property cannot be read due to security restrictions, the corresponding field in this class will be set
 * to {@code null} and a message will be written to {@code System.err}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * #ThreadSafe#
 * &lt;/p&gt;
 *
 * @since 1.0
 * @version $Id$
 */</comment>
<class>class <name>SystemUtils</name> <block>{

    <comment type="block" format="javadoc">/**
     * The prefix String for all Windows OS.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>OS_NAME_WINDOWS_PREFIX</name> <init>= <expr><literal type="string">"Windows"</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// System property constants</comment>
    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="line">// These MUST be declared first. Other constants depend on this.</comment>

    <comment type="block" format="javadoc">/**
     * The System property key for the user home directory.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_HOME_KEY</name> <init>= <expr><literal type="string">"user.home"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The System property key for the user directory.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_DIR_KEY</name> <init>= <expr><literal type="string">"user.dir"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The System property key for the Java IO temporary directory.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_IO_TMPDIR_KEY</name> <init>= <expr><literal type="string">"java.io.tmpdir"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The System property key for the Java home directory.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_HOME_KEY</name> <init>= <expr><literal type="string">"java.home"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code awt.toolkit} System Property.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Holds a class name, on Windows XP this is {@code sun.awt.windows.WToolkit}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;b&gt;On platforms without a GUI, this value is {@code null}.&lt;/b&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>AWT_TOOLKIT</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"awt.toolkit"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code file.encoding} System Property.
     * &lt;/p&gt;
     * &lt;p&gt;
     * File encoding, such as {@code Cp1252}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>FILE_ENCODING</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"file.encoding"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code file.separator} System Property.
     * The file separator is:
     * &lt;ul&gt;
     * &lt;li&gt;{@code "/"}&lt;/code&gt; on UNIX&lt;/li&gt;
     * &lt;li&gt;{@code "\"}&lt;/code&gt; on Windows.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>FILE_SEPARATOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"file.separator"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.awt.fonts} System Property.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_AWT_FONTS</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.awt.fonts"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.awt.graphicsenv} System Property.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_AWT_GRAPHICSENV</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.awt.graphicsenv"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.awt.headless} System Property. The value of this property is the String {@code "true"} or
     * {@code "false"}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @see #isJavaAwtHeadless()
     * @since 2.1
     * @since Java 1.4
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_AWT_HEADLESS</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.awt.headless"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.awt.printerjob} System Property.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_AWT_PRINTERJOB</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.awt.printerjob"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.class.path} System Property. Java class path.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_CLASS_PATH</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.class.path"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.class.version} System Property. Java class format version number.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_CLASS_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.class.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.compiler} System Property. Name of JIT compiler to use. First in JDK version 1.2. Not used in Sun
     * JDKs after 1.2.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2. Not used in Sun versions after 1.2.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_COMPILER</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.compiler"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.endorsed.dirs} System Property. Path of endorsed directory or directories.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.4
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_ENDORSED_DIRS</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.endorsed.dirs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.ext.dirs} System Property. Path of extension directory or directories.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.3
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_EXT_DIRS</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.ext.dirs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.home} System Property. Java installation directory.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_HOME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><name>JAVA_HOME_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.io.tmpdir} System Property. Default temp file path.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_IO_TMPDIR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><name>JAVA_IO_TMPDIR_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.library.path} System Property. List of paths to search when loading libraries.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_LIBRARY_PATH</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.library.path"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.runtime.name} System Property. Java Runtime Environment name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.3
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_RUNTIME_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.runtime.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.runtime.version} System Property. Java Runtime Environment version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.3
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_RUNTIME_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.runtime.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.specification.name} System Property. Java Runtime Environment specification name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_SPECIFICATION_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.specification.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.specification.vendor} System Property. Java Runtime Environment specification vendor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_SPECIFICATION_VENDOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.specification.vendor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.specification.version} System Property. Java Runtime Environment specification version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.3
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_SPECIFICATION_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.specification.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>JavaVersion</name></type> <name>JAVA_SPECIFICATION_VERSION_AS_ENUM</name> <init>= <expr><call><name><name>JavaVersion</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>JAVA_SPECIFICATION_VERSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.util.prefs.PreferencesFactory} System Property. A class name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     * @since Java 1.4
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_UTIL_PREFS_PREFERENCES_FACTORY</name> <init>=
            <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.util.prefs.PreferencesFactory"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vendor} System Property. Java vendor-specific string.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VENDOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vendor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vendor.url} System Property. Java vendor URL.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VENDOR_URL</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vendor.url"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.version} System Property. Java version number.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.info} System Property. Java Virtual Machine implementation info.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_INFO</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.info"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.name} System Property. Java Virtual Machine implementation name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.specification.name} System Property. Java Virtual Machine specification name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_SPECIFICATION_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.specification.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.specification.vendor} System Property. Java Virtual Machine specification vendor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_SPECIFICATION_VENDOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.specification.vendor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.specification.version} System Property. Java Virtual Machine specification version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_SPECIFICATION_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.specification.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.vendor} System Property. Java Virtual Machine implementation vendor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_VENDOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.vendor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code java.vm.version} System Property. Java Virtual Machine implementation version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>JAVA_VM_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"java.vm.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code line.separator} System Property. Line separator (&lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt; on UNIX).
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>LINE_SEPARATOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"line.separator"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code os.arch} System Property. Operating system architecture.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>OS_ARCH</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"os.arch"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code os.name} System Property. Operating system name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>OS_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"os.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code os.version} System Property. Operating system version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>OS_VERSION</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"os.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code path.separator} System Property. Path separator (&lt;code&gt;&amp;quot;:&amp;quot;&lt;/code&gt; on UNIX).
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>PATH_SEPARATOR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"path.separator"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.country} or {@code user.region} System Property. User's country code, such as {@code GB}. First
     * in Java version 1.2 as {@code user.region}. Renamed to {@code user.country} in 1.4
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_COUNTRY</name> <init>= <expr><ternary><condition><expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.country"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then>
            <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.region"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.country"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.dir} System Property. User's current working directory.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_DIR</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><name>USER_DIR_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.home} System Property. User's home directory.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_HOME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><name>USER_HOME_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.language} System Property. User's language code, such as {@code "en"}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.0
     * @since Java 1.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_LANGUAGE</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.language"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.name} System Property. User's account name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since Java 1.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_NAME</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * The {@code user.timezone} System Property. For example: {@code "America/Los_Angeles"}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does
     * not exist.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of
     * sync with that System property.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>USER_TIMEZONE</name> <init>= <expr><call><name>getSystemProperty</name><argument_list>(<argument><expr><literal type="string">"user.timezone"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Java version checks</comment>
    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="line">// These MUST be declared after those above as they depend on the</comment>
    <comment type="line">// values being set up</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.1 (also 1.1.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_1</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.2 (also 1.2.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_2</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.3 (also 1.3.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_3</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.3"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.4 (also 1.4.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_4</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.5 (also 1.5.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_5</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.5"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.6 (also 1.6.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_6</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.6"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Java version 1.7 (also 1.7.x versions).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_JAVA_1_7</name> <init>= <expr><call><name>getJavaVersionMatches</name><argument_list>(<argument><expr><literal type="string">"1.7"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Operating system checks</comment>
    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="line">// These MUST be declared after those above as they depend on the</comment>
    <comment type="line">// values being set up</comment>
    <comment type="line">// OS names from http://www.vamphq.com/os.html</comment>
    <comment type="line">// Selected ones included - please advise dev@commons.apache.org</comment>
    <comment type="line">// if you want another added or a mistake corrected</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is AIX.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_AIX</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"AIX"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is HP-UX.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_HP_UX</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"HP-UX"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Irix.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_IRIX</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"Irix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Linux.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_LINUX</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"Linux"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"LINUX"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Mac.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_MAC</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"Mac"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Mac.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_MAC_OSX</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"Mac OS X"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is FreeBSD.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_FREE_BSD</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is OpenBSD.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_OPEN_BSD</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"OpenBSD"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is NetBSD.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_NET_BSD</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"NetBSD"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is OS/2.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_OS2</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"OS/2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Solaris.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_SOLARIS</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"Solaris"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is SunOS.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_SUN_OS</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><literal type="string">"SunOS"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is a UNIX like system, as in any of AIX, HP-UX, Irix, Linux, MacOSX, Solaris or SUN OS.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_UNIX</name> <init>= <expr><name>IS_OS_AIX</name> <operator>||</operator> <name>IS_OS_HP_UX</name> <operator>||</operator> <name>IS_OS_IRIX</name> <operator>||</operator> <name>IS_OS_LINUX</name> <operator>||</operator> <name>IS_OS_MAC_OSX</name>
            <operator>||</operator> <name>IS_OS_SOLARIS</name> <operator>||</operator> <name>IS_OS_SUN_OS</name> <operator>||</operator> <name>IS_OS_FREE_BSD</name> <operator>||</operator> <name>IS_OS_OPEN_BSD</name> <operator>||</operator> <name>IS_OS_NET_BSD</name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 2000.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_2000</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"5.0"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 2003.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_2003</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"5.2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 2008.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_2008</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name> <operator>+</operator> <literal type="string">" Server 2008"</literal></expr></argument>, <argument><expr><literal type="string">"6.1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 95.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_95</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name> <operator>+</operator> <literal type="string">" 9"</literal></expr></argument>, <argument><expr><literal type="string">"4.0"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Java 1.2 running on Windows98 returns 'Windows 95', hence the above</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 98.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_98</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name> <operator>+</operator> <literal type="string">" 9"</literal></expr></argument>, <argument><expr><literal type="string">"4.1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Java 1.2 running on Windows98 returns 'Windows 95', hence the above</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows ME.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_ME</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"4.9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Java 1.2 running on WindowsME may return 'Windows 95', hence the above</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows NT.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_NT</name> <init>= <expr><call><name>getOSMatchesName</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name> <operator>+</operator> <literal type="string">" NT"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Windows 2000 returns 'Windows 2000' but may suffer from same Java1.2 problem</comment>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows XP.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_XP</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"5.1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows Vista.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 2.4
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_VISTA</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"6.0"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 7.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.0
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_7</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"6.1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is {@code true} if this is Windows 8.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.
     * &lt;/p&gt;
     *
     * @since 3.2
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>boolean</name></type> <name>IS_OS_WINDOWS_8</name> <init>= <expr><call><name>getOSMatches</name><argument_list>(<argument><expr><name>OS_NAME_WINDOWS_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"6.2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the Java home directory as a {@code File}.
     * &lt;/p&gt;
     *
     * @return a directory
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow
     * access to the specified system property.
     * @see System#getProperty(String)
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>File</name></type> <name>getJavaHome</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><name>JAVA_HOME_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the Java IO temporary directory as a {@code File}.
     * &lt;/p&gt;
     *
     * @return a directory
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow
     * access to the specified system property.
     * @see System#getProperty(String)
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>File</name></type> <name>getJavaIoTmpDir</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><name>JAVA_IO_TMPDIR_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Decides if the Java version matches.
     * &lt;/p&gt;
     *
     * @param versionPrefix the prefix for the java version
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>getJavaVersionMatches</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>versionPrefix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isJavaVersionMatch</name><argument_list>(<argument><expr><name>JAVA_SPECIFICATION_VERSION</name></expr></argument>, <argument><expr><name>versionPrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Decides if the operating system matches.
     *
     * @param osNamePrefix the prefix for the os name
     * @param osVersionPrefix the prefix for the version
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>getOSMatches</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osNamePrefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osVersionPrefix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isOSMatch</name><argument_list>(<argument><expr><name>OS_NAME</name></expr></argument>, <argument><expr><name>OS_VERSION</name></expr></argument>, <argument><expr><name>osNamePrefix</name></expr></argument>, <argument><expr><name>osVersionPrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Decides if the operating system matches.
     *
     * @param osNamePrefix the prefix for the os name
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>getOSMatchesName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osNamePrefix</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isOSNameMatch</name><argument_list>(<argument><expr><name>OS_NAME</name></expr></argument>, <argument><expr><name>osNamePrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets a System property, defaulting to {@code null} if the property cannot be read.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If a {@code SecurityException} is caught, the return value is {@code null} and a message is written to
     * {@code System.err}.
     * &lt;/p&gt;
     *
     * @param property the system property name
     * @return the system property value or {@code null} if a security problem occurs
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>String</name></type> <name>getSystemProperty</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>property</name></decl></parameter>)</parameter_list> <block>{
        <try>try <block>{
            <return>return <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>SecurityException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
            <comment type="line">// we are not allowed to look at this property</comment>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>err</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Caught a SecurityException reading the system property '"</literal> <operator>+</operator> <name>property</name>
                    <operator>+</operator> <literal type="string">"'; the SystemUtils property value will default to null."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the user directory as a {@code File}.
     * &lt;/p&gt;
     *
     * @return a directory
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow
     * access to the specified system property.
     * @see System#getProperty(String)
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>File</name></type> <name>getUserDir</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><name>USER_DIR_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Gets the user home directory as a {@code File}.
     * &lt;/p&gt;
     *
     * @return a directory
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow
     * access to the specified system property.
     * @see System#getProperty(String)
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>File</name></type> <name>getUserHome</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><name>USER_HOME_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether the {@link #JAVA_AWT_HEADLESS} value is {@code true}.
     *
     * @return {@code true} if {@code JAVA_AWT_HEADLESS} is {@code "true"}, {@code false} otherwise.
     * @see #JAVA_AWT_HEADLESS
     * @since 2.1
     * @since Java 1.4
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isJavaAwtHeadless</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><ternary><condition><expr><name>JAVA_AWT_HEADLESS</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>JAVA_AWT_HEADLESS</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>Boolean</name><operator>.</operator><name>TRUE</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Is the Java version at least the requested version.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Example input:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@code 1.2f} to test for Java 1.2&lt;/li&gt;
     * &lt;li&gt;{@code 1.31f} to test for Java 1.3.1&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param requiredVersion the required version, for example 1.31f
     * @return {@code true} if the actual version is equal or greater than the required version
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>boolean</name></type> <name>isJavaVersionAtLeast</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>JavaVersion</name></type> <name>requiredVersion</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>JAVA_SPECIFICATION_VERSION_AS_ENUM</name><operator>.</operator><name>atLeast</name></name><argument_list>(<argument><expr><name>requiredVersion</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * Decides if the Java version matches.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method is package private instead of private to support unit test invocation.
     * &lt;/p&gt;
     *
     * @param version the actual Java version
     * @param versionPrefix the prefix for the expected Java version
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>isJavaVersionMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>versionPrefix</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>version</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>versionPrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Decides if the operating system matches.
     * &lt;p&gt;
     * This method is package private instead of private to support unit test invocation.
     * &lt;/p&gt;
     *
     * @param osName the actual OS name
     * @param osVersion the actual OS version
     * @param osNamePrefix the prefix for the expected OS name
     * @param osVersionPrefix the prefix for the expected OS version
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>isOSMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osVersion</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osNamePrefix</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osVersionPrefix</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>osName</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>osVersion</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>osName</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>osNamePrefix</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>osVersion</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>osVersionPrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Decides if the operating system matches.
     * &lt;p&gt;
     * This method is package private instead of private to support unit test invocation.
     * &lt;/p&gt;
     *
     * @param osName the actual OS name
     * @param osNamePrefix the prefix for the expected OS name
     * @return true if matches, or false if not or can't determine
     */</comment>
    <function><specifier>static</specifier> <type><name>boolean</name></type> <name>isOSNameMatch</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osName</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>osNamePrefix</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>osName</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>osName</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>osNamePrefix</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// -----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;
     * SystemUtils instances should NOT be constructed in standard programming. Instead, the class should be used as
     * {@code SystemUtils.FILE_SEPARATOR}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This constructor is public to permit tools that require a JavaBean instance to operate.
     * &lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>SystemUtils</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

}</block></class>



<comment type="block" format="javadoc">/**
 * Provides mutable access to a value.
 * &lt;p&gt;
 * &lt;code&gt;Mutable&lt;/code&gt; is used as a generic interface to the implementations in this package.
 * &lt;p&gt;
 * A typical use case would be to enable a primitive or string to be passed to a method and allow that method to
 * effectively change the value of the primitive/string. Another use case is to store a frequently changing primitive in
 * a collection (for example a total in a map) without needing to create new Integer/Long wrapper objects.
 *
 * @param &lt;T&gt; the type to set and get
 * @since 2.1
 * @version $Id$
 */</comment>
<interface>interface <name><name>Mutable</name><parameter_list>&lt;<parameter><name>T</name></parameter>&gt;</parameter_list></name> <block>{

    <comment type="block" format="javadoc">/**
     * Gets the value of this mutable.
     *
     * @return the stored value
     */</comment>
    <function_decl><type><name>T</name></type> <name>getValue</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Sets the value of this mutable.
     *
     * @param value
     *            the value to store
     * @throws NullPointerException
     *             if the object is null and null is invalid
     * @throws ClassCastException
     *             if the type is invalid
     */</comment>
    <function_decl><type><name>void</name></type> <name>setValue</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

}</block></interface>


<comment type="block" format="javadoc">/**
 * Tokenizes a string based based on delimiters (separators)
 * and supporting quoting and ignored character concepts.
 * &lt;p&gt;
 * This class can split a String into many smaller strings. It aims
 * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},
 * however it offers much more control and flexibility including implementing
 * the &lt;code&gt;ListIterator&lt;/code&gt; interface. By default, it is set up
 * like &lt;code&gt;StringTokenizer&lt;/code&gt;.
 * &lt;p&gt;
 * The input String is split into a number of &lt;i&gt;tokens&lt;/i&gt;.
 * Each token is separated from the next String by a &lt;i&gt;delimiter&lt;/i&gt;.
 * One or more delimiter characters must be specified.
 * &lt;p&gt;
 * Each token may be surrounded by quotes.
 * The &lt;i&gt;quote&lt;/i&gt; matcher specifies the quote character(s).
 * A quote may be escaped within a quoted section by duplicating itself.
 * &lt;p&gt;
 * Between each token and the delimiter are potentially characters that need trimming.
 * The &lt;i&gt;trimmer&lt;/i&gt; matcher specifies these characters.
 * One usage might be to trim whitespace characters.
 * &lt;p&gt;
 * At any point outside the quotes there might potentially be invalid characters.
 * The &lt;i&gt;ignored&lt;/i&gt; matcher specifies these characters to be removed.
 * One usage might be to remove new line characters.
 * &lt;p&gt;
 * Empty tokens may be removed or returned as null.
 * &lt;pre&gt;
 * "a,b,c"         - Three tokens "a","b","c"   (comma delimiter)
 * " a, b , c "    - Three tokens "a","b","c"   (default CSV processing trims whitespace)
 * "a, ", b ,", c" - Three tokens "a, " , " b ", ", c" (quoted text untouched)
 * &lt;/pre&gt;
 * &lt;p&gt;
 *
 * This tokenizer has the following properties and options:
 *
 * &lt;table&gt;
 *  &lt;tr&gt;
 *   &lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Default&lt;/th&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;delim&lt;/td&gt;&lt;td&gt;CharSetMatcher&lt;/td&gt;&lt;td&gt;{ \t\n\r\f}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;quote&lt;/td&gt;&lt;td&gt;NoneMatcher&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;ignore&lt;/td&gt;&lt;td&gt;NoneMatcher&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;emptyTokenAsNull&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;ignoreEmptyTokens&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;
 *  &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @since 2.2
 * @version $Id$
 */</comment>
<class>class <name>StrTokenizer</name> <super><implements>implements <name><name>ListIterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name>, <name>Cloneable</name></implements></super> <block>{

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>CSV_TOKENIZER_PROTOTYPE</name></decl>;</decl_stmt>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>TSV_TOKENIZER_PROTOTYPE</name></decl>;</decl_stmt>
    <static>static <block>{
        <expr_stmt><expr><name>CSV_TOKENIZER_PROTOTYPE</name> <operator>=</operator> <operator>new</operator> <call><name>StrTokenizer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setDelimiterMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>commaMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setQuoteMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>doubleQuoteMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setIgnoredMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setTrimmerMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>trimMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setEmptyTokenAsNull</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setIgnoreEmptyTokens</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>TSV_TOKENIZER_PROTOTYPE</name> <operator>=</operator> <operator>new</operator> <call><name>StrTokenizer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setDelimiterMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>tabMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setQuoteMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>doubleQuoteMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setIgnoredMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setTrimmerMatcher</name></name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>trimMatcher</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setEmptyTokenAsNull</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>setIgnoreEmptyTokens</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></static>

    <comment type="block" format="javadoc">/** The text to work on. */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>char</name></type> <name><name>chars</name><index>[]</index></name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** The parsed tokens */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name><name>tokens</name><index>[]</index></name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** The current iteration position */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>tokenPos</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The delimiter matcher */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>StrMatcher</name></type> <name>delimMatcher</name> <init>= <expr><call><name><name>StrMatcher</name><operator>.</operator><name>splitMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** The quote matcher */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>StrMatcher</name></type> <name>quoteMatcher</name> <init>= <expr><call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** The ignored matcher */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>StrMatcher</name></type> <name>ignoredMatcher</name> <init>= <expr><call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** The trimmer matcher */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>StrMatcher</name></type> <name>trimmerMatcher</name> <init>= <expr><call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** Whether to return empty tokens as null */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>emptyAsNull</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Whether to ignore empty tokens */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>ignoreEmptyTokens</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">//-----------------------------------------------------------------------</comment>

    <comment type="block" format="javadoc">/**
     * Returns a clone of &lt;code&gt;CSV_TOKENIZER_PROTOTYPE&lt;/code&gt;.
     *
     * @return a clone of &lt;code&gt;CSV_TOKENIZER_PROTOTYPE&lt;/code&gt;.
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getCSVClone</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>StrTokenizer</name><operator>)</operator> <call><name><name>CSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Comma Separated Value strings
     * initializing it with the given input.  The default for CSV processing
     * will be trim whitespace from both ends (which can be overridden with
     * the setTrimmer method).
     * &lt;p&gt;
     * You must call a "reset" method to set the string which you want to parse.
     * @return a new tokenizer instance which parses Comma Separated Value strings
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getCSVInstance</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getCSVClone</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Comma Separated Value strings
     * initializing it with the given input.  The default for CSV processing
     * will be trim whitespace from both ends (which can be overridden with
     * the setTrimmer method).
     *
     * @param input  the text to parse
     * @return a new tokenizer instance which parses Comma Separated Value strings
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getCSVInstance</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>tok</name> <init>= <expr><call><name>getCSVClone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tok</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tok</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Comma Separated Value strings
     * initializing it with the given input.  The default for CSV processing
     * will be trim whitespace from both ends (which can be overridden with
     * the setTrimmer method).
     *
     * @param input  the text to parse
     * @return a new tokenizer instance which parses Comma Separated Value strings
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getCSVInstance</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>tok</name> <init>= <expr><call><name>getCSVClone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tok</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tok</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a clone of &lt;code&gt;TSV_TOKENIZER_PROTOTYPE&lt;/code&gt;.
     *
     * @return a clone of &lt;code&gt;TSV_TOKENIZER_PROTOTYPE&lt;/code&gt;.
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getTSVClone</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>StrTokenizer</name><operator>)</operator> <call><name><name>TSV_TOKENIZER_PROTOTYPE</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Tab Separated Value strings.
     * The default for CSV processing will be trim whitespace from both ends
     * (which can be overridden with the setTrimmer method).
     * &lt;p&gt;
     * You must call a "reset" method to set the string which you want to parse.
     * @return a new tokenizer instance which parses Tab Separated Value strings.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getTSVInstance</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getTSVClone</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Tab Separated Value strings.
     * The default for CSV processing will be trim whitespace from both ends
     * (which can be overridden with the setTrimmer method).
     * @param input  the string to parse
     * @return a new tokenizer instance which parses Tab Separated Value strings.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getTSVInstance</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>tok</name> <init>= <expr><call><name>getTSVClone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tok</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tok</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a new tokenizer instance which parses Tab Separated Value strings.
     * The default for CSV processing will be trim whitespace from both ends
     * (which can be overridden with the setTrimmer method).
     * @param input  the string to parse
     * @return a new tokenizer instance which parses Tab Separated Value strings.
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>StrTokenizer</name></type> <name>getTSVInstance</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>tok</name> <init>= <expr><call><name>getTSVClone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tok</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tok</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on space, tab, newline and formfeed
     * as per StringTokenizer, but with no text to tokenize.
     * &lt;p&gt;
     * This constructor is normally used with {@link #reset(String)}.
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on space, tab, newline and formfeed
     * as per StringTokenizer.
     *
     * @param input  the string which is to be parsed
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>input</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name><name>input</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>chars</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></else></if>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified delimiter character.
     *
     * @param input  the string which is to be parsed
     * @param delim  the field delimiter character
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterChar</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified delimiter string.
     *
     * @param input  the string which is to be parsed
     * @param delim  the field delimiter string
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterString</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting using the specified delimiter matcher.
     *
     * @param input  the string which is to be parsed
     * @param delim  the field delimiter matcher
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterMatcher</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified delimiter character
     * and handling quotes using the specified quote character.
     *
     * @param input  the string which is to be parsed
     * @param delim  the field delimiter character
     * @param quote  the field quoted string character
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>delim</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setQuoteChar</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting using the specified delimiter matcher
     * and handling quotes using the specified quote matcher.
     *
     * @param input  the string which is to be parsed
     * @param delim  the field delimiter matcher
     * @param quote  the field quoted string matcher
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>delim</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setQuoteMatcher</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on space, tab, newline and formfeed
     * as per StringTokenizer.
     *
     * @param input  the string which is to be parsed, not cloned
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>clone</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified character.
     *
     * @param input  the string which is to be parsed, not cloned
     * @param delim the field delimiter character
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterChar</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified string.
     *
     * @param input  the string which is to be parsed, not cloned
     * @param delim the field delimiter string
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterString</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting using the specified delimiter matcher.
     *
     * @param input  the string which is to be parsed, not cloned
     * @param delim  the field delimiter matcher
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDelimiterMatcher</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting on the specified delimiter character
     * and handling quotes using the specified quote character.
     *
     * @param input  the string which is to be parsed, not cloned
     * @param delim  the field delimiter character
     * @param quote  the field quoted string character
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>delim</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setQuoteChar</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Constructs a tokenizer splitting using the specified delimiter matcher
     * and handling quotes using the specified quote matcher.
     *
     * @param input  the string which is to be parsed, not cloned
     * @param delim  the field delimiter character
     * @param quote  the field quoted string character
     */</comment>
    <constructor><specifier>public</specifier> <name>StrTokenizer</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>delim</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setQuoteMatcher</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">// API</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the number of tokens found in the String.
     *
     * @return the number of matched tokens
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTokenized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>tokens</name><operator>.</operator><name>length</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the next token from the String.
     * Equivalent to {@link #next()} except it returns null rather than
     * throwing {@link NoSuchElementException} when no tokens remain.
     *
     * @return the next sequential token, or null when no more tokens are found
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>nextToken</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>hasNext</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>tokens</name><index>[<expr><name>tokenPos</name><operator>++</operator></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the previous token from the String.
     *
     * @return the previous sequential token, or null when no more tokens are found
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>previousToken</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>hasPrevious</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>tokens</name><index>[<expr><operator>--</operator><name>tokenPos</name></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a copy of the full token list as an independent modifiable array.
     *
     * @return the tokens as a String array
     */</comment>
    <function><specifier>public</specifier> <type><name><name>String</name><index>[]</index></name></type> <name>getTokenArray</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTokenized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>tokens</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets a copy of the full token list as an independent modifiable list.
     *
     * @return the tokens as a String array
     */</comment>
    <function><specifier>public</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokenList</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTokenized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>tokens</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>element</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>list</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Resets this tokenizer, forgetting all parsing and iteration already completed.
     * &lt;p&gt;
     * This method allows the same tokenizer to be reused for the same String.
     *
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>tokenPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tokens</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Reset this tokenizer, giving it a new input string to parse.
     * In this manner you can re-use a tokenizer with the same settings
     * on multiple input lines.
     *
     * @param input  the new string to tokenize, null sets no text to parse
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>input</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <call><name><name>input</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Reset this tokenizer, giving it a new input string to parse.
     * In this manner you can re-use a tokenizer with the same settings
     * on multiple input lines.
     *
     * @param input  the new character array to tokenize, not cloned, null sets no text to parse
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <call><name><name>ArrayUtils</name><operator>.</operator><name>clone</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">// ListIterator</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Checks whether there are any more tokens.
     *
     * @return true if there are more tokens
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTokenized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tokenPos</name> <operator>&lt;</operator> <name><name>tokens</name><operator>.</operator><name>length</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the next token.
     *
     * @return the next String token
     * @throws NoSuchElementException if there are no more elements
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>hasNext</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>tokens</name><index>[<expr><name>tokenPos</name><operator>++</operator></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <throw>throw <expr><operator>new</operator> <call><name>NoSuchElementException</name><argument_list>()</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the index of the next token to return.
     *
     * @return the next token index
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>nextIndex</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>tokenPos</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks whether there are any previous tokens that can be iterated to.
     *
     * @return true if there are previous tokens
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>hasPrevious</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTokenized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tokenPos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the token previous to the last returned token.
     *
     * @return the previous token
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>previous</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>hasPrevious</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>tokens</name><index>[<expr><operator>--</operator><name>tokenPos</name></expr>]</index></name></expr>;</return>
        }</block></then></if>
        <throw>throw <expr><operator>new</operator> <call><name>NoSuchElementException</name><argument_list>()</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gets the index of the previous token.
     *
     * @return the previous token index
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>previousIndex</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>tokenPos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Unsupported ListIterator operation.
     *
     * @throws UnsupportedOperationException always
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>void</name></type> <name>remove</name><parameter_list>()</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"remove() is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Unsupported ListIterator operation.
     * @param obj this parameter ignored.
     * @throws UnsupportedOperationException always
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"set() is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Unsupported ListIterator operation.
     * @param obj this parameter ignored.
     * @throws UnsupportedOperationException always
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"add() is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="line">// Implementation</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Checks if tokenization has been done, and if not then do it.
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>checkTokenized</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>tokens</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <comment type="line">// still call tokenize as subclass may do some work</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>split</name> <init>= <expr><call><name>tokenize</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name><name>split</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>split</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>split</name> <init>= <expr><call><name>tokenize</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>chars</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name><name>split</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>split</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Internal method to performs the tokenization.
     * &lt;p&gt;
     * Most users of this class do not need to call this method. This method
     * will be called automatically by other (public) methods when required.
     * &lt;p&gt;
     * This method exists to allow subclasses to add code before or after the
     * tokenization. For example, a subclass could alter the character array,
     * offset or count to be parsed, or call the tokenizer multiple times on
     * multiple strings. It is also be possible to filter the results.
     * &lt;p&gt;
     * &lt;code&gt;StrTokenizer&lt;/code&gt; will always pass a zero offset and a count
     * equal to the length of the array to this method, however a subclass
     * may pass other values, or even an entirely different array.
     *
     * @param chars  the character array being tokenized, may be null
     * @param offset  the start position within the character array, must be valid
     * @param count  the number of characters to tokenize, must be valid
     * @return the modifiable list of String tokens, unmodifiable if null array or zero count
     */</comment>
    <function><specifier>protected</specifier> <type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenize</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StrBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// loop around the entire buffer</comment>
        <while>while <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{
            <comment type="line">// find next token</comment>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>readNextToken</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// handle case where end of string is a delimiter</comment>
            <if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>addToken</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
        <return>return <expr><name>tokens</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Adds a token to a list, paying attention to the parameters we've set.
     *
     * @param list  the list to add to
     * @param tok  the token to add
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>addToken</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>tok</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>StringUtils</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>isIgnoreEmptyTokens</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>isEmptyTokenAsNull</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>tok</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Reads character by character through the String to get the next token.
     *
     * @param chars  the character array being tokenized
     * @param start  the first character of field
     * @param len  the length of the character array being tokenized
     * @param workArea  a temporary work area
     * @param tokens  the list of parsed tokens
     * @return the starting position of the next field (the character
     *  immediately after the delimiter), or -1 if end of string found
     */</comment>
    <function><specifier>private</specifier> <type><name>int</name></type> <name>readNextToken</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>workArea</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// skip all leading whitespace, unless it is the</comment>
        <comment type="line">// field delimiter or the quote character</comment>
        <while>while <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>removeLen</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(
                    <argument><expr><call><name>getIgnoredMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>getTrimmerMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>removeLen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>getDelimiterMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>getQuoteMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>removeLen</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="line">// handle reaching end</comment>
        <if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>addToken</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        }</block></then></if>

        <comment type="line">// handle empty token</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>delimLen</name> <init>= <expr><call><name>getDelimiterMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>delimLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>addToken</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>start</name> <operator>+</operator> <name>delimLen</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// handle found token</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>quoteLen</name> <init>= <expr><call><name>getQuoteMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>quoteLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name>readWithQuotes</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <name>quoteLen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>workArea</name></expr></argument>, <argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>quoteLen</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>readWithQuotes</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>workArea</name></expr></argument>, <argument><expr><name>tokens</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Reads a possibly quoted string token.
     *
     * @param chars  the character array being tokenized
     * @param start  the first character of field
     * @param len  the length of the character array being tokenized
     * @param workArea  a temporary work area
     * @param tokens  the list of parsed tokens
     * @param quoteStart  the start position of the matched quote, 0 if no quoting
     * @param quoteLen  the length of the matched quote, 0 if no quoting
     * @return the starting position of the next field (the character
     *  immediately after the delimiter, or if end of string found,
     *  then the length of string
     */</comment>
    <function><specifier>private</specifier> <type><name>int</name></type> <name>readWithQuotes</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>StrBuilder</name></type> <name>workArea</name></decl></parameter>,
                               <parameter><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>quoteStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>quoteLen</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Loop until we've found the end of the quoted</comment>
        <comment type="line">// string or the end of the input</comment>
        <expr_stmt><expr><call><name><name>workArea</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>quoting</name> <init>= <expr><name>quoteLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>trimStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{
            <comment type="line">// quoting mode can occur several times throughout a string</comment>
            <comment type="line">// we must switch between quoting and non-quoting until we</comment>
            <comment type="line">// encounter a non-quoted delimiter, or end of string</comment>
            <if>if <condition>(<expr><name>quoting</name></expr>)</condition><then> <block>{
                <comment type="line">// In quoting mode</comment>

                <comment type="line">// If we've found a quote character, see if it's</comment>
                <comment type="line">// followed by a second quote.  If so, then we need</comment>
                <comment type="line">// to actually put the quote character into the token</comment>
                <comment type="line">// rather than end the token.</comment>
                <if>if <condition>(<expr><call><name>isQuote</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>quoteStart</name></expr></argument>, <argument><expr><name>quoteLen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>isQuote</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <name>quoteLen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>quoteStart</name></expr></argument>, <argument><expr><name>quoteLen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// matched pair of quotes, thus an escaped quote</comment>
                        <expr_stmt><expr><call><name><name>workArea</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>quoteLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>quoteLen</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>trimStart</name> <operator>=</operator> <call><name><name>workArea</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <comment type="line">// end of quoting</comment>
                    <expr_stmt><expr><name>quoting</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>quoteLen</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// copy regular character from inside quotes</comment>
                <expr_stmt><expr><call><name><name>workArea</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>trimStart</name> <operator>=</operator> <call><name><name>workArea</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            }</block></then> <else>else <block>{
                <comment type="line">// Not in quoting mode</comment>

                <comment type="line">// check for delimiter, and thus end of token</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>delimLen</name> <init>= <expr><call><name>getDelimiterMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>delimLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <comment type="line">// return condition when end of token found</comment>
                    <expr_stmt><expr><call><name>addToken</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name><name>workArea</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>pos</name> <operator>+</operator> <name>delimLen</name></expr>;</return>
                }</block></then></if>

                <comment type="line">// check for quote, and thus back into quoting mode</comment>
                <if>if <condition>(<expr><name>quoteLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isQuote</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>quoteStart</name></expr></argument>, <argument><expr><name>quoteLen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>quoting</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>quoteLen</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// check for ignored (outside quotes), and ignore</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ignoredLen</name> <init>= <expr><call><name>getIgnoredMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>ignoredLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>ignoredLen</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// check for trimmed character</comment>
                <comment type="line">// don't yet know if its at the end, so copy to workArea</comment>
                <comment type="line">// use trimStart to keep track of trim at the end</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>trimmedLen</name> <init>= <expr><call><name>getTrimmerMatcher</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>trimmedLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>workArea</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>trimmedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>trimmedLen</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// copy regular character from outside quotes</comment>
                <expr_stmt><expr><call><name><name>workArea</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>trimStart</name> <operator>=</operator> <call><name><name>workArea</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>

        <comment type="line">// return condition when end of string found</comment>
        <expr_stmt><expr><call><name>addToken</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name><name>workArea</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the characters at the index specified match the quote
     * already matched in readNextToken().
     *
     * @param chars  the character array being tokenized
     * @param pos  the position to check for a quote
     * @param len  the length of the character array being tokenized
     * @param quoteStart  the start position of the matched quote, 0 if no quoting
     * @param quoteLen  the length of the matched quote, 0 if no quoting
     * @return true if a quote is matched
     */</comment>
    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>isQuote</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>quoteStart</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>quoteLen</name></decl></parameter>)</parameter_list> <block>{
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>quoteLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><name>pos</name> <operator>+</operator> <name>i</name> <operator>&gt;=</operator> <name>len</name> <operator>||</operator> <name><name>chars</name><index>[<expr><name>pos</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>chars</name><index>[<expr><name>quoteStart</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">// Delimiter</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the field delimiter matcher.
     *
     * @return the delimiter matcher in use
     */</comment>
    <function><specifier>public</specifier> <type><name>StrMatcher</name></type> <name>getDelimiterMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>delimMatcher</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the field delimiter matcher.
     * &lt;p&gt;
     * The delimitier is used to separate one token from another.
     *
     * @param delim  the delimiter matcher to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setDelimiterMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>delim</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>delimMatcher</name></name> <operator>=</operator> <call><name><name>StrMatcher</name><operator>.</operator><name>noneMatcher</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>delimMatcher</name></name> <operator>=</operator> <name>delim</name></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the field delimiter character.
     *
     * @param delim  the delimiter character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setDelimiterChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>setDelimiterMatcher</name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>charMatcher</name></name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the field delimiter string.
     *
     * @param delim  the delimiter string to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setDelimiterString</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>setDelimiterMatcher</name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>stringMatcher</name></name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Quote</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the quote matcher currently in use.
     * &lt;p&gt;
     * The quote character is used to wrap data between the tokens.
     * This enables delimiters to be entered as data.
     * The default value is '"' (double quote).
     *
     * @return the quote matcher in use
     */</comment>
    <function><specifier>public</specifier> <type><name>StrMatcher</name></type> <name>getQuoteMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>quoteMatcher</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the quote matcher to use.
     * &lt;p&gt;
     * The quote character is used to wrap data between the tokens.
     * This enables delimiters to be entered as data.
     *
     * @param quote  the quote matcher to use, null ignored
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setQuoteMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>quote</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>quoteMatcher</name></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the quote character to use.
     * &lt;p&gt;
     * The quote character is used to wrap data between the tokens.
     * This enables delimiters to be entered as data.
     *
     * @param quote  the quote character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setQuoteChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>quote</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>setQuoteMatcher</name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>charMatcher</name></name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Ignored</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the ignored character matcher.
     * &lt;p&gt;
     * These characters are ignored when parsing the String, unless they are
     * within a quoted region.
     * The default value is not to ignore anything.
     *
     * @return the ignored matcher in use
     */</comment>
    <function><specifier>public</specifier> <type><name>StrMatcher</name></type> <name>getIgnoredMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>ignoredMatcher</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the matcher for characters to ignore.
     * &lt;p&gt;
     * These characters are ignored when parsing the String, unless they are
     * within a quoted region.
     *
     * @param ignored  the ignored matcher to use, null ignored
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setIgnoredMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ignored</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ignoredMatcher</name></name> <operator>=</operator> <name>ignored</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the character to ignore.
     * &lt;p&gt;
     * This character is ignored when parsing the String, unless it is
     * within a quoted region.
     *
     * @param ignored  the ignored character to use
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setIgnoredChar</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>setIgnoredMatcher</name><argument_list>(<argument><expr><call><name><name>StrMatcher</name><operator>.</operator><name>charMatcher</name></name><argument_list>(<argument><expr><name>ignored</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Trimmer</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the trimmer character matcher.
     * &lt;p&gt;
     * These characters are trimmed off on each side of the delimiter
     * until the token or quote is found.
     * The default value is not to trim anything.
     *
     * @return the trimmer matcher in use
     */</comment>
    <function><specifier>public</specifier> <type><name>StrMatcher</name></type> <name>getTrimmerMatcher</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>trimmerMatcher</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the matcher for characters to trim.
     * &lt;p&gt;
     * These characters are trimmed off on each side of the delimiter
     * until the token or quote is found.
     *
     * @param trimmer  the trimmer matcher to use, null ignored
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setTrimmerMatcher</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>StrMatcher</name></type> <name>trimmer</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>trimmer</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>trimmerMatcher</name></name> <operator>=</operator> <name>trimmer</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets whether the tokenizer currently returns empty tokens as null.
     * The default for this property is false.
     *
     * @return true if empty tokens are returned as null
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isEmptyTokenAsNull</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>emptyAsNull</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets whether the tokenizer should return empty tokens as null.
     * The default for this property is false.
     *
     * @param emptyAsNull  whether empty tokens are returned as null
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setEmptyTokenAsNull</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>emptyAsNull</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>emptyAsNull</name></name> <operator>=</operator> <name>emptyAsNull</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets whether the tokenizer currently ignores empty tokens.
     * The default for this property is true.
     *
     * @return true if empty tokens are not returned
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isIgnoreEmptyTokens</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>ignoreEmptyTokens</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sets whether the tokenizer should ignore and not return empty tokens.
     * The default for this property is true.
     *
     * @param ignoreEmptyTokens  whether empty tokens are not returned
     * @return this, to enable chaining
     */</comment>
    <function><specifier>public</specifier> <type><name>StrTokenizer</name></type> <name>setIgnoreEmptyTokens</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>ignoreEmptyTokens</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ignoreEmptyTokens</name></name> <operator>=</operator> <name>ignoreEmptyTokens</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the String content that the tokenizer is parsing.
     *
     * @return the string content being parsed
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>getContent</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Creates a new instance of this Tokenizer. The new instance is reset so
     * that it will be at the start of the token list.
     * If a {@link CloneNotSupportedException} is caught, return &lt;code&gt;null&lt;/code&gt;.
     *
     * @return a new instance of this Tokenizer which has been reset.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>Object</name></type> <name>clone</name><parameter_list>()</parameter_list> <block>{
        <try>try <block>{
            <return>return <expr><call><name>cloneReset</name><argument_list>()</argument_list></call></expr>;</return>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>CloneNotSupportedException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Creates a new instance of this Tokenizer. The new instance is reset so that
     * it will be at the start of the token list.
     *
     * @return a new instance of this Tokenizer which has been reset.
     * @throws CloneNotSupportedException if there is a problem cloning
     */</comment>
    <function><type><name>Object</name></type> <name>cloneReset</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>CloneNotSupportedException</name></expr></argument></throws> <block>{
        <comment type="line">// this method exists to enable 100% test coverage</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StrTokenizer</name></type> <name>cloned</name> <init>= <expr><operator>(</operator><name>StrTokenizer</name><operator>)</operator> <call><name><name>super</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>cloned</name><operator>.</operator><name>chars</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cloned</name><operator>.</operator><name>chars</name></name> <operator>=</operator> <call><name><name>cloned</name><operator>.</operator><name>chars</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>cloned</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cloned</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Gets the String content that the tokenizer is parsing.
     *
     * @return the string content being parsed
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>tokens</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="string">"StrTokenizer[not tokenized yet]"</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="string">"StrTokenizer"</literal> <operator>+</operator> <call><name>getTokenList</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;An enum representing all the versions of the Java specification.
 * This is intended to mirror available values from the
 * &lt;em&gt;java.specification.version&lt;/em&gt; System property. &lt;/p&gt;
 *
 * @since 3.0
 * @version $Id: $
 */</comment>
<enum>enum <name>JavaVersion</name> <block>{

    <comment type="block" format="javadoc">/**
     * The Java version reported by Android. This is not an official Java version number.
     */</comment>
    <decl><name>JAVA_0_9</name><argument_list>(<argument><expr><literal type="number">1.5f</literal></expr></argument>, <argument><expr><literal type="string">"0.9"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.1.
     */</comment>
    <decl><name>JAVA_1_1</name><argument_list>(<argument><expr><literal type="number">1.1f</literal></expr></argument>, <argument><expr><literal type="string">"1.1"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.2.
     */</comment>
    <decl><name>JAVA_1_2</name><argument_list>(<argument><expr><literal type="number">1.2f</literal></expr></argument>, <argument><expr><literal type="string">"1.2"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.3.
     */</comment>
    <decl><name>JAVA_1_3</name><argument_list>(<argument><expr><literal type="number">1.3f</literal></expr></argument>, <argument><expr><literal type="string">"1.3"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.4.
     */</comment>
    <decl><name>JAVA_1_4</name><argument_list>(<argument><expr><literal type="number">1.4f</literal></expr></argument>, <argument><expr><literal type="string">"1.4"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.5.
     */</comment>
    <decl><name>JAVA_1_5</name><argument_list>(<argument><expr><literal type="number">1.5f</literal></expr></argument>, <argument><expr><literal type="string">"1.5"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.6.
     */</comment>
    <decl><name>JAVA_1_6</name><argument_list>(<argument><expr><literal type="number">1.6f</literal></expr></argument>, <argument><expr><literal type="string">"1.6"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.7.
     */</comment>
    <decl><name>JAVA_1_7</name><argument_list>(<argument><expr><literal type="number">1.7f</literal></expr></argument>, <argument><expr><literal type="string">"1.7"</literal></expr></argument>)</argument_list></decl>,

    <comment type="block" format="javadoc">/**
     * Java 1.8.
     */</comment>
    <decl><name>JAVA_1_8</name><argument_list>(<argument><expr><literal type="number">1.8f</literal></expr></argument>, <argument><expr><literal type="string">"1.8"</literal></expr></argument>)</argument_list></decl>;

    <comment type="block" format="javadoc">/**
     * The float value.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * The standard name.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>name</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Constructor.
     *
     * @param value  the float value
     * @param name  the standard name, not null
     */</comment>
    <constructor><name>JavaVersion</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Whether this version of Java is at least the version of Java passed in.&lt;/p&gt;
     *
     * &lt;p&gt;For example:&lt;br /&gt;
     *  {@code myVersion.atLeast(JavaVersion.JAVA_1_4)}&lt;p&gt;
     *
     * @param requiredVersion  the version to check against, not null
     * @return true if this version is equal to or greater than the specified version
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>atLeast</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>JavaVersion</name></type> <name>requiredVersion</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>&gt;=</operator> <name><name>requiredVersion</name><operator>.</operator><name>value</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Transforms the given string with a Java version number to the
     * corresponding constant of this enumeration class. This method is used
     * internally.
     *
     * @param nom the Java version as string
     * @return the corresponding enumeration constant or &lt;b&gt;null&lt;/b&gt; if the
     * version is unknown
     */</comment>
    <comment type="line">// helper for static importing</comment>
    <function><specifier>static</specifier> <type><name>JavaVersion</name></type> <name>getJavaVersion</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>nom</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>get</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Transforms the given string with a Java version number to the
     * corresponding constant of this enumeration class. This method is used
     * internally.
     *
     * @param nom the Java version as string
     * @return the corresponding enumeration constant or &lt;b&gt;null&lt;/b&gt; if the
     * version is unknown
     */</comment>
    <function><specifier>static</specifier> <type><name>JavaVersion</name></type> <name>get</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>nom</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><literal type="string">"0.9"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_0_9</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><literal type="string">"1.1"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_1</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.2"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_2</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.3"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_3</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.4"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_4</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.5"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_5</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.6"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_6</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.7"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_7</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><literal type="string">"1.8"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JAVA_1_8</name></expr>;</return>
        }</block></then></if></elseif> <else>else <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;The string value is overridden to return the standard name.&lt;/p&gt;
     *
     * &lt;p&gt;For example, &lt;code&gt;"1.5"&lt;/code&gt;.&lt;/p&gt;
     *
     * @return the name, not null
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>name</name></expr>;</return>
    }</block></function>

}</block></enum>


<comment type="block" format="javadoc">/**
 * &lt;p&gt;An immutable pair consisting of two {@code Object} elements.&lt;/p&gt;
 *
 * &lt;p&gt;Although the implementation is immutable, there is no restriction on the objects
 * that may be stored. If mutable objects are stored in the pair, then the pair
 * itself effectively becomes mutable. The class is also not {@code final}, so a subclass
 * could add undesirable behaviour.&lt;/p&gt;
 *
 * &lt;p&gt;#ThreadSafe# if both paired objects are thread-safe&lt;/p&gt;
 *
 * @param &lt;L&gt; the left element type
 * @param &lt;R&gt; the right element type
 *
 * @since Lang 3.0
 * @version $Id$
 */</comment>
<class><specifier>final</specifier> class <name><name>ImmutablePair</name><parameter_list>&lt;<parameter><name>L</name></parameter>, <parameter><name>R</name></parameter>&gt;</parameter_list></name> <super><extends>extends <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></extends></super> <block>{

    <comment type="block" format="javadoc">/** Serialization version */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">4954918890077093841L</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** Left object */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>L</name></type> <name>left</name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** Right object */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>R</name></type> <name>right</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Obtains an immutable pair of from two objects inferring the generic types.&lt;/p&gt;
     *
     * &lt;p&gt;This factory allows the pair to be created using inference to
     * obtain the generic types.&lt;/p&gt;
     *
     * @param &lt;L&gt; the left element type
     * @param &lt;R&gt; the right element type
     * @param left  the left element, may be null
     * @param right  the right element, may be null
     * @return a pair formed from the two parameters, not null
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>L</name></parameter>, <parameter><name>R</name></parameter>&gt;</parameter_list> <type><name><name>ImmutablePair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></type> <name>of</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>L</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>R</name></type> <name>right</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name><name>ImmutablePair</name><argument_list type="generic">&lt;<argument><name>L</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Create a new pair instance.
     *
     * @param left  the left value, may be null
     * @param right  the right value, may be null
     */</comment>
    <constructor><specifier>public</specifier> <name>ImmutablePair</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>L</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>R</name></type> <name>right</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * {@inheritDoc}
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>L</name></type> <name>getLeft</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>left</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * {@inheritDoc}
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>R</name></type> <name>getRight</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>right</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Throws {@code UnsupportedOperationException}.&lt;/p&gt;
     *
     * &lt;p&gt;This pair is immutable, so this operation is not supported.&lt;/p&gt;
     *
     * @param value  the value to set
     * @return never
     * @throws UnsupportedOperationException as this operation is not supported
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>R</name></type> <name>setValue</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>R</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
    }</block></function>

}</block></class>



<comment type="block" format="javadoc">/**
 * Assists in implementing {@link java.lang.Comparable#compareTo(Object)} methods.
 *
 * It is consistent with &lt;code&gt;equals(Object)&lt;/code&gt; and
 * &lt;code&gt;hashcode()&lt;/code&gt; built with {@link EqualsBuilder} and
 * {@link HashCodeBuilder}.&lt;/p&gt;
 *
 * &lt;p&gt;Two Objects that compare equal using &lt;code&gt;equals(Object)&lt;/code&gt; should normally
 * also compare equal using &lt;code&gt;compareTo(Object)&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;All relevant fields should be included in the calculation of the
 * comparison. Derived fields may be ignored. The same fields, in the same
 * order, should be used in both &lt;code&gt;compareTo(Object)&lt;/code&gt; and
 * &lt;code&gt;equals(Object)&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;To use this class write code as follows:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class MyClass {
 *   String field1;
 *   int field2;
 *   boolean field3;
 *
 *   ...
 *
 *   public int compareTo(Object o) {
 *     MyClass myClass = (MyClass) o;
 *     return new CompareToBuilder()
 *       .appendSuper(super.compareTo(o)
 *       .append(this.field1, myClass.field1)
 *       .append(this.field2, myClass.field2)
 *       .append(this.field3, myClass.field3)
 *       .toComparison();
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use
 * reflection to determine the fields to append. Because fields can be private,
 * &lt;code&gt;reflectionCompare&lt;/code&gt; uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to
 * bypass normal access control checks. This will fail under a security manager,
 * unless the appropriate permissions are set up correctly. It is also
 * slower than appending explicitly.&lt;/p&gt;
 *
 * &lt;p&gt;A typical implementation of &lt;code&gt;compareTo(Object)&lt;/code&gt; using
 * &lt;code&gt;reflectionCompare&lt;/code&gt; looks like:&lt;/p&gt;

 * &lt;pre&gt;
 * public int compareTo(Object o) {
 *   return CompareToBuilder.reflectionCompare(this, o);
 * }
 * &lt;/pre&gt;
 *
 * @see java.lang.Comparable
 * @see java.lang.Object#equals(Object)
 * @see java.lang.Object#hashCode()
 * @see EqualsBuilder
 * @see HashCodeBuilder
 * @since 1.0
 * @version $Id$
 */</comment>
<class>class <name>CompareToBuilder</name> <super><implements>implements <name><name>Builder</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></implements></super> <block>{

    <comment type="block" format="javadoc">/**
     * Current state of the comparison as appended fields are checked.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>comparison</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Constructor for CompareToBuilder.&lt;/p&gt;
     *
     * &lt;p&gt;Starts off assuming that the objects are equal. Multiple calls are
     * then made to the various append methods, followed by a call to
     * {@link #toComparison} to get the result.&lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>CompareToBuilder</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two &lt;code&gt;Object&lt;/code&gt;s via reflection.&lt;/p&gt;
     *
     * &lt;p&gt;Fields can be private, thus &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
     * is used to bypass normal access control checks. This will fail under a
     * security manager unless the appropriate permissions are set.&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;Static fields will not be compared&lt;/li&gt;
     * &lt;li&gt;Transient members will be not be compared, as they are likely derived
     *     fields&lt;/li&gt;
     * &lt;li&gt;Superclass fields will be compared&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;,
     * they are considered equal.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @return a negative integer, zero, or a positive integer as &lt;code&gt;lhs&lt;/code&gt;
     *  is less than, equal to, or greater than &lt;code&gt;rhs&lt;/code&gt;
     * @throws NullPointerException  if either (but not both) parameters are
     *  &lt;code&gt;null&lt;/code&gt;
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionCompare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionCompare</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two &lt;code&gt;Object&lt;/code&gt;s via reflection.&lt;/p&gt;
     *
     * &lt;p&gt;Fields can be private, thus &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
     * is used to bypass normal access control checks. This will fail under a
     * security manager unless the appropriate permissions are set.&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;Static fields will not be compared&lt;/li&gt;
     * &lt;li&gt;If &lt;code&gt;compareTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     *     compares transient members.  Otherwise ignores them, as they
     *     are likely derived fields.&lt;/li&gt;
     * &lt;li&gt;Superclass fields will be compared&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;,
     * they are considered equal.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param compareTransients  whether to compare transient fields
     * @return a negative integer, zero, or a positive integer as &lt;code&gt;lhs&lt;/code&gt;
     *  is less than, equal to, or greater than &lt;code&gt;rhs&lt;/code&gt;
     * @throws NullPointerException  if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;
     *  (but not both) is &lt;code&gt;null&lt;/code&gt;
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionCompare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>compareTransients</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionCompare</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>compareTransients</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two &lt;code&gt;Object&lt;/code&gt;s via reflection.&lt;/p&gt;
     *
     * &lt;p&gt;Fields can be private, thus &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
     * is used to bypass normal access control checks. This will fail under a
     * security manager unless the appropriate permissions are set.&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;Static fields will not be compared&lt;/li&gt;
     * &lt;li&gt;If &lt;code&gt;compareTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     *     compares transient members.  Otherwise ignores them, as they
     *     are likely derived fields.&lt;/li&gt;
     * &lt;li&gt;Superclass fields will be compared&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;,
     * they are considered equal.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param excludeFields  Collection of String fields to exclude
     * @return a negative integer, zero, or a positive integer as &lt;code&gt;lhs&lt;/code&gt;
     *  is less than, equal to, or greater than &lt;code&gt;rhs&lt;/code&gt;
     * @throws NullPointerException  if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;
     *  (but not both) is &lt;code&gt;null&lt;/code&gt;
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionCompare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionCompare</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><call><name><name>ReflectionToStringBuilder</name><operator>.</operator><name>toNoNullStringArray</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two &lt;code&gt;Object&lt;/code&gt;s via reflection.&lt;/p&gt;
     *
     * &lt;p&gt;Fields can be private, thus &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
     * is used to bypass normal access control checks. This will fail under a
     * security manager unless the appropriate permissions are set.&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;Static fields will not be compared&lt;/li&gt;
     * &lt;li&gt;If &lt;code&gt;compareTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     *     compares transient members.  Otherwise ignores them, as they
     *     are likely derived fields.&lt;/li&gt;
     * &lt;li&gt;Superclass fields will be compared&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;,
     * they are considered equal.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param excludeFields  array of fields to exclude
     * @return a negative integer, zero, or a positive integer as &lt;code&gt;lhs&lt;/code&gt;
     *  is less than, equal to, or greater than &lt;code&gt;rhs&lt;/code&gt;
     * @throws NullPointerException  if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;
     *  (but not both) is &lt;code&gt;null&lt;/code&gt;
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionCompare</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>reflectionCompare</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Compares two &lt;code&gt;Object&lt;/code&gt;s via reflection.&lt;/p&gt;
     *
     * &lt;p&gt;Fields can be private, thus &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;
     * is used to bypass normal access control checks. This will fail under a
     * security manager unless the appropriate permissions are set.&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;Static fields will not be compared&lt;/li&gt;
     * &lt;li&gt;If the &lt;code&gt;compareTransients&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     *     compares transient members.  Otherwise ignores them, as they
     *     are likely derived fields.&lt;/li&gt;
     * &lt;li&gt;Compares superclass fields up to and including &lt;code&gt;reflectUpToClass&lt;/code&gt;.
     *     If &lt;code&gt;reflectUpToClass&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, compares all superclass fields.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;,
     * they are considered equal.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param compareTransients  whether to compare transient fields
     * @param reflectUpToClass  last superclass for which fields are compared
     * @param excludeFields  fields to exclude
     * @return a negative integer, zero, or a positive integer as &lt;code&gt;lhs&lt;/code&gt;
     *  is less than, equal to, or greater than &lt;code&gt;rhs&lt;/code&gt;
     * @throws NullPointerException  if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;
     *  (but not both) is &lt;code&gt;null&lt;/code&gt;
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     * @since 2.2 (2.0 as &lt;code&gt;reflectionCompare(Object, Object, boolean, Class)&lt;/code&gt;)
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>reflectionCompare</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>compareTransients</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>reflectUpToClass</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>String</name><modifier>...</modifier></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>NullPointerException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>lhsClazz</name> <init>= <expr><call><name><name>lhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>lhsClazz</name><operator>.</operator><name>isInstance</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>ClassCastException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>CompareToBuilder</name></type> <name>compareToBuilder</name> <init>= <expr><operator>new</operator> <call><name>CompareToBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>lhsClazz</name></expr></argument>, <argument><expr><name>compareToBuilder</name></expr></argument>, <argument><expr><name>compareTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>lhsClazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>lhsClazz</name> <operator>!=</operator> <name>reflectUpToClass</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>lhsClazz</name> <operator>=</operator> <call><name><name>lhsClazz</name><operator>.</operator><name>getSuperclass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>reflectionAppend</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>lhsClazz</name></expr></argument>, <argument><expr><name>compareToBuilder</name></expr></argument>, <argument><expr><name>compareTransients</name></expr></argument>, <argument><expr><name>excludeFields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><call><name><name>compareToBuilder</name><operator>.</operator><name>toComparison</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to &lt;code&gt;builder&lt;/code&gt; the comparison of &lt;code&gt;lhs&lt;/code&gt;
     * to &lt;code&gt;rhs&lt;/code&gt; using the fields defined in &lt;code&gt;clazz&lt;/code&gt;.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param clazz  &lt;code&gt;Class&lt;/code&gt; that defines fields to be compared
     * @param builder  &lt;code&gt;CompareToBuilder&lt;/code&gt; to append to
     * @param useTransients  whether to compare transient fields
     * @param excludeFields  fields to exclude
     */</comment>
    <function><specifier>private</specifier> <specifier>static</specifier> <type><name>void</name></type> <name>reflectionAppend</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>CompareToBuilder</name></type> <name>builder</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useTransients</name></decl></parameter>,
            <parameter><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>excludeFields</name></decl></parameter>)</parameter_list> <block>{

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Field</name><index>[]</index></name></type> <name>fields</name> <init>= <expr><call><name><name>clazz</name><operator>.</operator><name>getDeclaredFields</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>AccessibleObject</name><operator>.</operator><name>setAccessible</name></name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fields</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name><name>builder</name><operator>.</operator><name>comparison</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Field</name></type> <name>f</name> <init>= <expr><name><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>ArrayUtils</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>excludeFields</name></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                    <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>f</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexOf</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>(</operator><name>useTransients</name> <operator>||</operator> <operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isTransient</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>Modifier</name><operator>.</operator><name>isStatic</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                <try>try <block>{
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IllegalAccessException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                    <comment type="line">// This can't happen. Would get a Security exception instead.</comment>
                    <comment type="line">// Throw a runtime exception in case the impossible happens.</comment>
                    <throw>throw <expr><operator>new</operator> <call><name>InternalError</name><argument_list>(<argument><expr><literal type="string">"Unexpected IllegalAccessException"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></then></if>
        }</block></for>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the &lt;code&gt;compareTo(Object)&lt;/code&gt;
     * result of the superclass.&lt;/p&gt;
     *
     * @param superCompareTo  result of calling &lt;code&gt;super.compareTo(Object)&lt;/code&gt;
     * @return this - used to chain append calls
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>appendSuper</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>superCompareTo</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <name>superCompareTo</name></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;Object&lt;/code&gt;s.&lt;/p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;Check if &lt;code&gt;lhs == rhs&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Check if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *     a &lt;code&gt;null&lt;/code&gt; object is less than a non-&lt;code&gt;null&lt;/code&gt; object&lt;/li&gt;
     * &lt;li&gt;Check the object contents&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;&lt;code&gt;lhs&lt;/code&gt; must either be an array or implement {@link Comparable}.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @return this - used to chain append calls
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;Object&lt;/code&gt;s.&lt;/p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;Check if &lt;code&gt;lhs == rhs&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Check if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *     a &lt;code&gt;null&lt;/code&gt; object is less than a non-&lt;code&gt;null&lt;/code&gt; object&lt;/li&gt;
     * &lt;li&gt;Check the object contents&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;If &lt;code&gt;lhs&lt;/code&gt; is an array, array comparison methods will be used.
     * Otherwise &lt;code&gt;comparator&lt;/code&gt; will be used to compare the objects.
     * If &lt;code&gt;comparator&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt; must
     * implement {@link Comparable} instead.&lt;/p&gt;
     *
     * @param lhs  left-hand object
     * @param rhs  right-hand object
     * @param comparator  &lt;code&gt;Comparator&lt;/code&gt; used to compare the objects,
     *  &lt;code&gt;null&lt;/code&gt; means treat lhs as &lt;code&gt;Comparable&lt;/code&gt;
     * @return this - used to chain append calls
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>Object</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>lhs</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// switch on type of array, to dispatch to the correct handler</comment>
            <comment type="line">// handles multi dimensional arrays</comment>
            <comment type="line">// throws a ClassCastException if rhs is not the correct array type</comment>
            <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>long</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>long</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>int</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>short</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>short</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>char</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>byte</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>byte</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>double</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>double</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>float</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>float</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>lhs</name> <operator>instanceof</operator> <name><name>boolean</name><index>[]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>boolean</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <else>else <block>{
                <comment type="line">// not an array of primitives</comment>
                <comment type="line">// throws a ClassCastException if rhs is not an array</comment>
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><operator>(</operator><name><name>Object</name><index>[]</index></name><operator>)</operator> <name>rhs</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <comment type="line">// the simple case, not an array, just test the element</comment>
            <if>if <condition>(<expr><name>comparator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// assume this can be done; if not throw CCE as per Javadoc</comment>
                <type><specifier>final</specifier> <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>comparable</name> <init>= <expr><operator>(</operator><name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><operator>)</operator> <name>lhs</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>comparison</name> <operator>=</operator> <call><name><name>comparable</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// assume this can be done; if not throw CCE as per Javadoc</comment>
                <type><specifier>final</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>comparator2</name> <init>= <expr><operator>(</operator><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><operator>)</operator> <name>comparator</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>comparison</name> <operator>=</operator> <call><name><name>comparator2</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-------------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;long&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&gt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;int&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&gt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;short&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>short</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&gt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;char&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>char</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&gt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;byte&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>byte</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>lhs</name> <operator>&gt;</operator> <name>rhs</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;double&lt;/code&gt;s.&lt;/p&gt;
     *
     * &lt;p&gt;This handles NaNs, Infinities, and &lt;code&gt;-0.0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;It is compatible with the hash code generated by
     * &lt;code&gt;HashCodeBuilder&lt;/code&gt;.&lt;/p&gt;
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <call><name><name>Double</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;float&lt;/code&gt;s.&lt;/p&gt;
     *
     * &lt;p&gt;This handles NaNs, Infinities, and &lt;code&gt;-0.0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;It is compatible with the hash code generated by
     * &lt;code&gt;HashCodeBuilder&lt;/code&gt;.&lt;/p&gt;
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>float</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>comparison</name> <operator>=</operator> <call><name><name>Float</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Appends to the &lt;code&gt;builder&lt;/code&gt; the comparison of
     * two &lt;code&gt;booleans&lt;/code&gt;s.
     *
     * @param lhs  left-hand value
     * @param rhs  right-hand value
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;Object&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a short length array is less than a long length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(Object, Object, Comparator)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;This method will also will be called for the top level of multi-dimensional,
     * ragged, and multi-typed arrays.&lt;/p&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>append</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;Object&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a short length array is less than a long length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(Object, Object, Comparator)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;This method will also will be called for the top level of multi-dimensional,
     * ragged, and multi-typed arrays.&lt;/p&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @param comparator  &lt;code&gt;Comparator&lt;/code&gt; to use to compare the array elements,
     *  &lt;code&gt;null&lt;/code&gt; means to treat &lt;code&gt;lhs&lt;/code&gt; elements as &lt;code&gt;Comparable&lt;/code&gt;.
     * @return this - used to chain append calls
     * @throws ClassCastException  if &lt;code&gt;rhs&lt;/code&gt; is not assignment-compatible
     *  with &lt;code&gt;lhs&lt;/code&gt;
     * @since 2.0
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Object</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;long&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(long, long)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;int&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(int, int)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;short&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(short, short)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>short</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;char&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(char, char)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;byte&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(byte, byte)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;double&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(double, double)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;float&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(float, float)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * &lt;p&gt;Appends to the &lt;code&gt;builder&lt;/code&gt; the deep comparison of
     * two &lt;code&gt;boolean&lt;/code&gt; arrays.&lt;/p&gt;
     *
     * &lt;ol&gt;
     *  &lt;li&gt;Check if arrays are the same using &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check if for &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is less than non-&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;Check array length, a shorter length array is less than a longer length array&lt;/li&gt;
     *  &lt;li&gt;Check array contents element by element using {@link #append(boolean, boolean)}&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param lhs  left-hand array
     * @param rhs  right-hand array
     * @return this - used to chain append calls
     */</comment>
    <function><specifier>public</specifier> <type><name>CompareToBuilder</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>comparison</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition><then> <block>{
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>rhs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>comparison</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>length</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lhs</name><operator>.</operator><name>length</name></name> <operator>&amp;&amp;</operator> <name>comparison</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="block" format="javadoc">/**
     * Returns a negative integer, a positive integer, or zero as
     * the &lt;code&gt;builder&lt;/code&gt; has judged the "left-hand" side
     * as less than, greater than, or equal to the "right-hand"
     * side.
     *
     * @return final comparison result
     * @see #build()
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>toComparison</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>comparison</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a negative Integer, a positive Integer, or zero as
     * the &lt;code&gt;builder&lt;/code&gt; has judged the "left-hand" side
     * as less than, greater than, or equal to the "right-hand"
     * side.
     *
     * @return final comparison result as an Integer
     * @see #toComparison()
     * @since 3.0
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>Integer</name></type> <name>build</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name>toComparison</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></class>

</unit>
