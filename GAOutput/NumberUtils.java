/*//LC:1
 * Licensed to the Apache Software Foundation (ASF) under one or more//LC:2
 * contributor license agreements.  See the NOTICE file distributed with//LC:3
 * this work for additional information regarding copyright ownership.//LC:4
 * The ASF licenses this file to You under the Apache License, Version 2.0//LC:5
 * (the "License"); you may not use this file except in compliance with//LC:6
 * the License.  You may obtain a copy of the License at//LC:7
 *//LC:8
 *      http://www.apache.org/licenses/LICENSE-2.0//LC:9
 *//LC:10
 * Unless required by applicable law or agreed to in writing, software//LC:11
 * distributed under the License is distributed on an "AS IS" BASIS,//LC:12
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.//LC:13
 * See the License for the specific language governing permissions and//LC:14
 * limitations under the License.//LC:15
 *///LC:16
//LC:17
import java.io.*;//LC:18
import java.lang.reflect.*;//LC:19
import java.math.BigDecimal;//LC:20
import java.math.BigInteger;//LC:21
import java.text.Normalizer;//LC:22
import java.util.*;//LC:23
import java.util.regex.Pattern;//LC:24
import java.lang.reflect.Array;//LC:25
import java.util.Arrays;//LC:26
//LC:27
//LC:28
//import org.apache.commons.lang3.StringUtils;//LC:29
//LC:30
/**//LC:31
 * <p>Provides extra functionality for Java Number classes.</p>//LC:32
 *//LC:33
 * @since 2.0//LC:34
 * @version $Id$//LC:35
 *///LC:36
public class NumberUtils {//LC:37
//LC:38
    /** Reusable Long constant for zero. *///LC:39
    public static final Long LONG_ZERO = Long.valueOf(0L);//LC:40
    /** Reusable Long constant for one. *///LC:41
    public static final Long LONG_ONE = Long.valueOf(1L);//LC:42
    /** Reusable Long constant for minus one. *///LC:43
    public static final Long LONG_MINUS_ONE = Long.valueOf(-1L);//LC:44
    /** Reusable Integer constant for zero. *///LC:45
    public static final Integer INTEGER_ZERO = Integer.valueOf(0);//LC:46
    /** Reusable Integer constant for one. *///LC:47
    public static final Integer INTEGER_ONE = Integer.valueOf(1);//LC:48
    /** Reusable Integer constant for minus one. *///LC:49
    public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);//LC:50
    /** Reusable Short constant for zero. *///LC:51
    public static final Short SHORT_ZERO = Short.valueOf((short) 0);//LC:52
    /** Reusable Short constant for one. *///LC:53
    public static final Short SHORT_ONE = Short.valueOf((short) 1);//LC:54
    /** Reusable Short constant for minus one. *///LC:55
    public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);//LC:56
    /** Reusable Byte constant for zero. *///LC:57
    public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);//LC:58
    /** Reusable Byte constant for one. *///LC:59
    public static final Byte BYTE_ONE = Byte.valueOf((byte) 1);//LC:60
    /** Reusable Byte constant for minus one. *///LC:61
    public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);//LC:62
    /** Reusable Double constant for zero. *///LC:63
    public static final Double DOUBLE_ZERO = Double.valueOf(0.0d);//LC:64
    /** Reusable Double constant for one. *///LC:65
    public static final Double DOUBLE_ONE = Double.valueOf(1.0d);//LC:66
    /** Reusable Double constant for minus one. *///LC:67
    public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);//LC:68
    /** Reusable Float constant for zero. *///LC:69
    public static final Float FLOAT_ZERO = Float.valueOf(0.0f);//LC:70
    /** Reusable Float constant for one. *///LC:71
    public static final Float FLOAT_ONE = Float.valueOf(1.0f);//LC:72
    /** Reusable Float constant for minus one. *///LC:73
    public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);//LC:74
//LC:75
    /**//LC:76
     * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.//LC:77
     * Instead, the class should be used as <code>NumberUtils.toInt("6");</code>.</p>//LC:78
     *//LC:79
     * <p>This constructor is public to permit tools that require a JavaBean instance//LC:80
     * to operate.</p>//LC:81
     *///LC:82
    public NumberUtils() {//LC:83
        super();//LC:84
    }//LC:85
//LC:86
    //-----------------------------------------------------------------------//LC:87
    /**//LC:88
     * <p>Convert a <code>String</code> to an <code>int</code>, returning//LC:89
     * <code>zero</code> if the conversion fails.</p>//LC:90
     *//LC:91
     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>//LC:92
     *//LC:93
     * <pre>//LC:94
     *   NumberUtils.toInt(null) = 0//LC:95
     *   NumberUtils.toInt("")   = 0//LC:96
     *   NumberUtils.toInt("1")  = 1//LC:97
     * </pre>//LC:98
     *//LC:99
     * @param str  the string to convert, may be null//LC:100
     * @return the int represented by the string, or <code>zero</code> if//LC:101
     *  conversion fails//LC:102
     * @since 2.1//LC:103
     *///LC:104
    public static int toInt(final String str) {//LC:105
        return toInt(str, 0);//LC:106
    }//LC:107
//LC:108
//LC:109
    /**//LC:110
     * <p>Convert a <code>String</code> to an <code>int</code>, returning a//LC:111
     * default value if the conversion fails.</p>//LC:112
     *//LC:113
     * <p>If the string is <code>null</code>, the default value is returned.</p>//LC:114
     *//LC:115
     * <pre>//LC:116
     *   NumberUtils.toInt(null, 1) = 1//LC:117
     *   NumberUtils.toInt("", 1)   = 1//LC:118
     *   NumberUtils.toInt("1", 0)  = 1//LC:119
     * </pre>//LC:120
     *//LC:121
     * @param str  the string to convert, may be null//LC:122
     * @param defaultValue  the default value//LC:123
     * @return the int represented by the string, or the default if conversion fails//LC:124
     * @since 2.1//LC:125
     *///LC:126
    public static int toInt(final String str, final int defaultValue) {//LC:127
        if(str == null) {//LC:128
            return defaultValue;//LC:129
        }//LC:130
        try {//LC:131
            return Integer.parseInt(str);//LC:132
        } catch (final NumberFormatException nfe) {//LC:133
            return defaultValue;//LC:134
        }//LC:135
    }//LC:136
//LC:137
    /**//LC:138
     * <p>Convert a <code>String</code> to a <code>long</code>, returning//LC:139
     * <code>zero</code> if the conversion fails.</p>//LC:140
     *//LC:141
     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>//LC:142
     *//LC:143
     * <pre>//LC:144
     *   NumberUtils.toLong(null) = 0L//LC:145
     *   NumberUtils.toLong("")   = 0L//LC:146
     *   NumberUtils.toLong("1")  = 1L//LC:147
     * </pre>//LC:148
     *//LC:149
     * @param str  the string to convert, may be null//LC:150
     * @return the long represented by the string, or <code>0</code> if//LC:151
     *  conversion fails//LC:152
     * @since 2.1//LC:153
     *///LC:154
    public static long toLong(final String str) {//LC:155
        return toLong(str, 0L);//LC:156
    }//LC:157
//LC:158
    /**//LC:159
     * <p>Convert a <code>String</code> to a <code>long</code>, returning a//LC:160
     * default value if the conversion fails.</p>//LC:161
     *//LC:162
     * <p>If the string is <code>null</code>, the default value is returned.</p>//LC:163
     *//LC:164
     * <pre>//LC:165
     *   NumberUtils.toLong(null, 1L) = 1L//LC:166
     *   NumberUtils.toLong("", 1L)   = 1L//LC:167
     *   NumberUtils.toLong("1", 0L)  = 1L//LC:168
     * </pre>//LC:169
     *//LC:170
     * @param str  the string to convert, may be null//LC:171
     * @param defaultValue  the default value//LC:172
     * @return the long represented by the string, or the default if conversion fails//LC:173
     * @since 2.1//LC:174
     *///LC:175
    public static long toLong(final String str, final long defaultValue) {//LC:176
        if (str == null) {//LC:177
            return defaultValue;//LC:178
        }//LC:179
        try {//LC:180
            return Long.parseLong(str);//LC:181
        } catch (final NumberFormatException nfe) {//LC:182
            return defaultValue;//LC:183
        }//LC:184
    }//LC:185
//LC:186
    /**//LC:187
     * <p>Convert a <code>String</code> to a <code>float</code>, returning//LC:188
     * <code>0.0f</code> if the conversion fails.</p>//LC:189
     *//LC:190
     * <p>If the string <code>str</code> is <code>null</code>,//LC:191
     * <code>0.0f</code> is returned.</p>//LC:192
     *//LC:193
     * <pre>//LC:194
     *   NumberUtils.toFloat(null)   = 0.0f//LC:195
     *   NumberUtils.toFloat("")     = 0.0f//LC:196
     *   NumberUtils.toFloat("1.5")  = 1.5f//LC:197
     * </pre>//LC:198
     *//LC:199
     * @param str the string to convert, may be <code>null</code>//LC:200
     * @return the float represented by the string, or <code>0.0f</code>//LC:201
     *  if conversion fails//LC:202
     * @since 2.1//LC:203
     *///LC:204
    public static float toFloat(final String str) {//LC:205
        return toFloat(str, 0.0f);//LC:206
    }//LC:207
//LC:208
    /**//LC:209
     * <p>Convert a <code>String</code> to a <code>float</code>, returning a//LC:210
     * default value if the conversion fails.</p>//LC:211
     *//LC:212
     * <p>If the string <code>str</code> is <code>null</code>, the default//LC:213
     * value is returned.</p>//LC:214
     *//LC:215
     * <pre>//LC:216
     *   NumberUtils.toFloat(null, 1.1f)   = 1.0f//LC:217
     *   NumberUtils.toFloat("", 1.1f)     = 1.1f//LC:218
     *   NumberUtils.toFloat("1.5", 0.0f)  = 1.5f//LC:219
     * </pre>//LC:220
     *//LC:221
     * @param str the string to convert, may be <code>null</code>//LC:222
     * @param defaultValue the default value//LC:223
     * @return the float represented by the string, or defaultValue//LC:224
     *  if conversion fails//LC:225
     * @since 2.1//LC:226
     *///LC:227
    public static float toFloat(final String str, final float defaultValue) {//LC:228
        if (str == null) {//LC:229
            return defaultValue;//LC:230
        }//LC:231
        try {//LC:232
            return Float.parseFloat(str);//LC:233
        } catch (final NumberFormatException nfe) {//LC:234
            return defaultValue;//LC:235
        }//LC:236
    }//LC:237
//LC:238
    /**//LC:239
     * <p>Convert a <code>String</code> to a <code>double</code>, returning//LC:240
     * <code>0.0d</code> if the conversion fails.</p>//LC:241
     *//LC:242
     * <p>If the string <code>str</code> is <code>null</code>,//LC:243
     * <code>0.0d</code> is returned.</p>//LC:244
     *//LC:245
     * <pre>//LC:246
     *   NumberUtils.toDouble(null)   = 0.0d//LC:247
     *   NumberUtils.toDouble("")     = 0.0d//LC:248
     *   NumberUtils.toDouble("1.5")  = 1.5d//LC:249
     * </pre>//LC:250
     *//LC:251
     * @param str the string to convert, may be <code>null</code>//LC:252
     * @return the double represented by the string, or <code>0.0d</code>//LC:253
     *  if conversion fails//LC:254
     * @since 2.1//LC:255
     *///LC:256
    public static double toDouble(final String str) {//LC:257
        return toDouble(str, 0.0d);//LC:258
    }//LC:259
//LC:260
    /**//LC:261
     * <p>Convert a <code>String</code> to a <code>double</code>, returning a//LC:262
     * default value if the conversion fails.</p>//LC:263
     *//LC:264
     * <p>If the string <code>str</code> is <code>null</code>, the default//LC:265
     * value is returned.</p>//LC:266
     *//LC:267
     * <pre>//LC:268
     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d//LC:269
     *   NumberUtils.toDouble("", 1.1d)     = 1.1d//LC:270
     *   NumberUtils.toDouble("1.5", 0.0d)  = 1.5d//LC:271
     * </pre>//LC:272
     *//LC:273
     * @param str the string to convert, may be <code>null</code>//LC:274
     * @param defaultValue the default value//LC:275
     * @return the double represented by the string, or defaultValue//LC:276
     *  if conversion fails//LC:277
     * @since 2.1//LC:278
     *///LC:279
    public static double toDouble(final String str, final double defaultValue) {//LC:280
        if (str == null) {//LC:281
            return defaultValue;//LC:282
        }//LC:283
        try {//LC:284
            return Double.parseDouble(str);//LC:285
        } catch (final NumberFormatException nfe) {//LC:286
            return defaultValue;//LC:287
        }//LC:288
    }//LC:289
//LC:290
    //-----------------------------------------------------------------------//LC:291
    /**//LC:292
     * <p>Convert a <code>String</code> to a <code>byte</code>, returning//LC:293
     * <code>zero</code> if the conversion fails.</p>//LC:294
     *//LC:295
     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>//LC:296
     *//LC:297
     * <pre>//LC:298
     *   NumberUtils.toByte(null) = 0//LC:299
     *   NumberUtils.toByte("")   = 0//LC:300
     *   NumberUtils.toByte("1")  = 1//LC:301
     * </pre>//LC:302
     *//LC:303
     * @param str  the string to convert, may be null//LC:304
     * @return the byte represented by the string, or <code>zero</code> if//LC:305
     *  conversion fails//LC:306
     * @since 2.5//LC:307
     *///LC:308
    public static byte toByte(final String str) {//LC:309
        return toByte(str, (byte) 0);//LC:310
    }//LC:311
//LC:312
    /**//LC:313
     * <p>Convert a <code>String</code> to a <code>byte</code>, returning a//LC:314
     * default value if the conversion fails.</p>//LC:315
     *//LC:316
     * <p>If the string is <code>null</code>, the default value is returned.</p>//LC:317
     *//LC:318
     * <pre>//LC:319
     *   NumberUtils.toByte(null, 1) = 1//LC:320
     *   NumberUtils.toByte("", 1)   = 1//LC:321
     *   NumberUtils.toByte("1", 0)  = 1//LC:322
     * </pre>//LC:323
     *//LC:324
     * @param str  the string to convert, may be null//LC:325
     * @param defaultValue  the default value//LC:326
     * @return the byte represented by the string, or the default if conversion fails//LC:327
     * @since 2.5//LC:328
     *///LC:329
    public static byte toByte(final String str, final byte defaultValue) {//LC:330
        if(str == null) {//LC:331
            return defaultValue;//LC:332
        }//LC:333
        try {//LC:334
            return Byte.parseByte(str);//LC:335
        } catch (final NumberFormatException nfe) {//LC:336
            return defaultValue;//LC:337
        }//LC:338
    }//LC:339
//LC:340
    /**//LC:341
     * <p>Convert a <code>String</code> to a <code>short</code>, returning//LC:342
     * <code>zero</code> if the conversion fails.</p>//LC:343
     *//LC:344
     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>//LC:345
     *//LC:346
     * <pre>//LC:347
     *   NumberUtils.toShort(null) = 0//LC:348
     *   NumberUtils.toShort("")   = 0//LC:349
     *   NumberUtils.toShort("1")  = 1//LC:350
     * </pre>//LC:351
     *//LC:352
     * @param str  the string to convert, may be null//LC:353
     * @return the short represented by the string, or <code>zero</code> if//LC:354
     *  conversion fails//LC:355
     * @since 2.5//LC:356
     *///LC:357
    public static short toShort(final String str) {//LC:358
        return toShort(str, (short) 0);//LC:359
    }//LC:360
//LC:361
    /**//LC:362
     * <p>Convert a <code>String</code> to an <code>short</code>, returning a//LC:363
     * default value if the conversion fails.</p>//LC:364
     *//LC:365
     * <p>If the string is <code>null</code>, the default value is returned.</p>//LC:366
     *//LC:367
     * <pre>//LC:368
     *   NumberUtils.toShort(null, 1) = 1//LC:369
     *   NumberUtils.toShort("", 1)   = 1//LC:370
     *   NumberUtils.toShort("1", 0)  = 1//LC:371
     * </pre>//LC:372
     *//LC:373
     * @param str  the string to convert, may be null//LC:374
     * @param defaultValue  the default value//LC:375
     * @return the short represented by the string, or the default if conversion fails//LC:376
     * @since 2.5//LC:377
     *///LC:378
    public static short toShort(final String str, final short defaultValue) {//LC:379
        if(str == null) {//LC:380
            return defaultValue;//LC:381
        }//LC:382
        try {//LC:383
            return Short.parseShort(str);//LC:384
        } catch (final NumberFormatException nfe) {//LC:385
            return defaultValue;//LC:386
        }//LC:387
    }//LC:388
//LC:389
    //-----------------------------------------------------------------------//LC:390
    // must handle Long, Float, Integer, Float, Short,//LC:391
    //                  BigDecimal, BigInteger and Byte//LC:392
    // useful methods://LC:393
    // Byte.decode(String)//LC:394
    // Byte.valueOf(String,int radix)//LC:395
    // Byte.valueOf(String)//LC:396
    // Double.valueOf(String)//LC:397
    // Float.valueOf(String)//LC:398
    // Float.valueOf(String)//LC:399
    // Integer.valueOf(String,int radix)//LC:400
    // Integer.valueOf(String)//LC:401
    // Integer.decode(String)//LC:402
    // Integer.getInteger(String)//LC:403
    // Integer.getInteger(String,int val)//LC:404
    // Integer.getInteger(String,Integer val)//LC:405
    // Integer.valueOf(String)//LC:406
    // Double.valueOf(String)//LC:407
    // new Byte(String)//LC:408
    // Long.valueOf(String)//LC:409
    // Long.getLong(String)//LC:410
    // Long.getLong(String,int)//LC:411
    // Long.getLong(String,Integer)//LC:412
    // Long.valueOf(String,int)//LC:413
    // Long.valueOf(String)//LC:414
    // Short.valueOf(String)//LC:415
    // Short.decode(String)//LC:416
    // Short.valueOf(String,int)//LC:417
    // Short.valueOf(String)//LC:418
    // new BigDecimal(String)//LC:419
    // new BigInteger(String)//LC:420
    // new BigInteger(String,int radix)//LC:421
    // Possible inputs://LC:422
    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd//LC:423
    // plus minus everything. Prolly more. A lot are not separable.//LC:424
//LC:425
    /**//LC:426
     * <p>Turns a string value into a java.lang.Number.</p>//LC:427
     *//LC:428
     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it//LC:429
     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the//LC:430
     * prefix is more than 8 - or BigInteger if there are more than 16 digits.//LC:431
     * </p>//LC:432
     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of//LC:433
     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts //LC:434
     * trying to create successively larger types from the type specified//LC:435
     * until one is found that can represent the value.</p>//LC:436
     *//LC:437
     * <p>If a type specifier is not found, it will check for a decimal point//LC:438
     * and then try successively larger types from <code>Integer</code> to//LC:439
     * <code>BigInteger</code> and from <code>Float</code> to//LC:440
     * <code>BigDecimal</code>.</p>//LC:441
     *//LC:442
     * <p>//LC:443
     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will//LC:444
     * be Integer, Long or BigDecimal as appropriate.//LC:445
     * </p>//LC:446
     *//LC:447
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:448
     *//LC:449
     * <p>This method does not trim the input string, i.e., strings with leading//LC:450
     * or trailing spaces will generate NumberFormatExceptions.</p>//LC:451
     *//LC:452
     * @param str  String containing a number, may be null//LC:453
     * @return Number created from the string (or null if the input is null)//LC:454
     * @throws NumberFormatException if the value cannot be converted//LC:455
     *///LC:456
    public static Number createNumber(final String str) throws NumberFormatException {//LC:457
        if (str == null) {//LC:458
            return null;//LC:459
        }//LC:460
        // Current tests fail because StringUtils() cant be resolved//LC:461
//        if (StringUtils.isBlank(str)) {//LC:462
//            throw new NumberFormatException("A blank string is not a valid number");//LC:463
//        }//LC:464
//LC:465
        int strLen;//LC:466
        if (str == null || (strLen = str.length()) == 0) {//LC:467
            throw new NumberFormatException("A blank string is not a valid number");//LC:468
        }//LC:469
//LC:470
        // Need to deal with all possible hex prefixes here//LC:471
        final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"};//LC:472
        int pfxLen = 0;//LC:473
        for(final String pfx : hex_prefixes) {//LC:474
            if (str.startsWith(pfx)) {//LC:475
                pfxLen += pfx.length();//LC:476
                break;//LC:477
            }//LC:478
        }//LC:479
//LC:480
        /* bug fix//LC:481
        if (pfxLen > 0) { // we have a hex number//LC:482
            char firstSigDigit = 0; // strip leading zeroes//LC:483
            for(int i = pfxLen; i < str.length(); i++) {//LC:484
                firstSigDigit = str.charAt(i);//LC:485
                if (firstSigDigit == '0') { // count leading zeroes//LC:486
                    pfxLen++;//LC:487
                } else {//LC:488
                    break;//LC:489
                }//LC:490
            }//LC:491
            final int hexDigits = str.length() - pfxLen;//LC:492
            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long//LC:493
                return createBigInteger(str);//LC:494
            }//LC:495
            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int//LC:496
                return createLong(str);//LC:497
            }//LC:498
            return createInteger(str);//LC:499
        }//LC:500
         *///LC:501
        //bug, gzoltar likelihood faulty//LC:502
        if (pfxLen > 0) { // we have a hex number//LC:503
            final int hexDigits = str.length() - pfxLen;//LC:504
            if (hexDigits > 16) { // too many for Long//LC:505
                return createBigInteger(str);//LC:506
            }//LC:507
            if (hexDigits > 8) { // too many for an int//LC:508
                return createLong(str);//LC:509
            }//LC:510
//LC:511
            if (str == null) {//LC:512
                return null;//LC:513
            }//LC:514
            // decode() handles 0xAABD and 0777 (hex and octal) as well.//LC:515
            return Integer.decode(str);//LC:516
//LC:517
//LC:518
//            return createInteger(str);//LC:519
        }return substring(start, size);//LC:520
        //bug//LC:521
//LC:522
//LC:523
        final char lastChar = str.charAt(str.length() - 1);//LC:524
        String mant;//LC:525
        String dec;//LC:526
        String exp;//LC:527
        final int decPos = str.indexOf('.');//LC:528
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present//LC:529
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)//LC:530
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset//LC:531
//LC:532
        int numDecimals = 0; // Check required precision (LANG-693)//LC:533
        if (decPos > -1) { // there is a decimal point//LC:534
//LC:535
            if (expPos > -1) { // there is an exponent//LC:536
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE//LC:537
                    throw new NumberFormatException(str + " is not a valid number.");//LC:538
                }//LC:539
                dec = str.substring(decPos + 1, expPos);//LC:540
            } else {//LC:541
                dec = str.substring(decPos + 1);//LC:542
            }//LC:543
            mant = str.substring(0, decPos);//LC:544
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.//LC:545
        } else {//LC:546
            if (expPos > -1) {//LC:547
                if (expPos > str.length()) { // prevents double exponent causing IOOBE//LC:548
                    throw new NumberFormatException(str + " is not a valid number.");//LC:549
                }//LC:550
                mant = str.substring(0, expPos);//LC:551
            } else {//LC:552
                mant = str;//LC:553
            }//LC:554
            dec = null;//LC:555
        }//LC:556
        if (!Character.isDigit(lastChar) && lastChar != '.') {//LC:557
            if (expPos > -1 && expPos < str.length() - 1) {//LC:558
                exp = str.substring(expPos + 1, str.length() - 1);//LC:559
            } else {//LC:560
                exp = null;//LC:561
            }//LC:562
            //Requesting a specific type..//LC:563
            final String numeric = str.substring(0, str.length() - 1);//LC:564
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);//LC:565
            switch (lastChar) {//LC:566
                case 'l' ://LC:567
                case 'L' ://LC:568
                    if (dec == null//LC:569
                            && exp == null//LC:570
                            && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {//LC:571
                        try {//LC:572
                            return createLong(numeric);//LC:573
                        } catch (final NumberFormatException nfe) { // NOPMD//LC:574
                            // Too big for a long//LC:575
                        }//LC:576
                        return createBigInteger(numeric);//LC:577
//LC:578
                    }//LC:579
                    throw new NumberFormatException(str + " is not a valid number.");//LC:580
                case 'f' ://LC:581
                case 'F' ://LC:582
                    try {//LC:583
                        final Float f = NumberUtils.createFloat(numeric);//LC:584
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {//LC:585
                            //If it's too big for a float or the float value = 0 and the string//LC:586
                            //has non-zeros in it, then float does not have the precision we want//LC:587
                            return f;//LC:588
                        }//LC:589
//LC:590
                    } catch (final NumberFormatException nfe) { // NOPMD//LC:591
                        // ignore the bad number//LC:592
                    }//LC:593
                    //$FALL-THROUGH$//LC:594
                case 'd' ://LC:595
                case 'D' ://LC:596
                    try {//LC:597
                        final Double d = NumberUtils.createDouble(numeric);//LC:598
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {//LC:599
                            return d;//LC:600
                        }//LC:601
                    } catch (final NumberFormatException nfe) { // NOPMD//LC:602
                        // ignore the bad number//LC:603
                    }//LC:604
                    try {//LC:605
                        return createBigDecimal(numeric);//LC:606
                    } catch (final NumberFormatException e) { // NOPMD//LC:607
                        // ignore the bad number//LC:608
                    }//LC:609
                    //$FALL-THROUGH$//LC:610
                default ://LC:611
                    throw new NumberFormatException(str + " is not a valid number.");//LC:612
//LC:613
            }//LC:614
        }//LC:615
        //User doesn't have a preference on the return type, so let's start//LC:616
        //small and go from there...//LC:617
        if (expPos > -1 && expPos < str.length() - 1) {//LC:618
            exp = str.substring(expPos + 1, str.length());//LC:619
        } else {//LC:620
            exp = null;//LC:621
        }//LC:622
        if (dec == null && exp == null) { // no decimal point and no exponent//LC:623
            //Must be an Integer, Long, Biginteger//LC:624
            try {//LC:625
                return createInteger(str);//LC:626
            } catch (final NumberFormatException nfe) { // NOPMD//LC:627
                // ignore the bad number//LC:628
            }//LC:629
            try {//LC:630
                return createLong(str);//LC:631
            } catch (final NumberFormatException nfe) { // NOPMD//LC:632
                // ignore the bad number//LC:633
            }//LC:634
            return createBigInteger(str);//LC:635
        }//LC:636
//LC:637
        //Must be a Float, Double, BigDecimal//LC:638
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);//LC:639
        try {//LC:640
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float//LC:641
                final Float f = createFloat(str);//LC:642
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {//LC:643
                    return f;//LC:644
                }//LC:645
            }//LC:646
        } catch (final NumberFormatException nfe) { // NOPMD//LC:647
            // ignore the bad number//LC:648
        }//LC:649
        try {//LC:650
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double//LC:651
                final Double d = createDouble(str);//LC:652
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {//LC:653
                    return d;//LC:654
                }//LC:655
            }//LC:656
        } catch (final NumberFormatException nfe) { // NOPMD//LC:657
            // ignore the bad number//LC:658
        }//LC:659
//LC:660
        return createBigDecimal(str);//LC:661
    }//LC:662
//LC:663
    /**//LC:664
     * <p>Utility method for {@link #createNumber(String)}.</p>//LC:665
     *//LC:666
     * <p>Returns <code>true</code> if s is <code>null</code>.</p>//LC:667
     *//LC:668
     * @param str  the String to check//LC:669
     * @return if it is all zeros or <code>null</code>//LC:670
     *///LC:671
    private static boolean isAllZeros(final String str) {//LC:672
        if (str == null) {//LC:673
            return true;//LC:674
        }//LC:675
        for (int i = str.length() - 1; i >= 0; i--) {//LC:676
            if (str.charAt(i) != '0') {//LC:677
                return false;//LC:678
            }//LC:679
        }//LC:680
        return str.length() > 0;//LC:681
    }//LC:682
//LC:683
    //-----------------------------------------------------------------------//LC:684
    /**//LC:685
     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>//LC:686
     *//LC:687
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:688
     *//LC:689
     * @param str  a <code>String</code> to convert, may be null//LC:690
     * @return converted <code>Float</code> (or null if the input is null)//LC:691
     * @throws NumberFormatException if the value cannot be converted//LC:692
     *///LC:693
    public static Float createFloat(final String str) {//LC:694
        if (str == null) {//LC:695
            return null;//LC:696
        }//LC:697
        return Float.valueOf(str);//LC:698
    }//LC:699
//LC:700
    /**//LC:701
     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>//LC:702
     *//LC:703
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:704
     *//LC:705
     * @param str  a <code>String</code> to convert, may be null//LC:706
     * @return converted <code>Double</code> (or null if the input is null)//LC:707
     * @throws NumberFormatException if the value cannot be converted//LC:708
     *///LC:709
    public static Double createDouble(final String str) {//LC:710
        if (str == null) {//LC:711
            return null;//LC:712
        }//LC:713
        return Double.valueOf(str);//LC:714
    }//LC:715
//LC:716
    /**//LC:717
     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling//LC:718
     * hex and octal notations.</p>//LC:719
     *//LC:720
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:721
     *//LC:722
     * @param str  a <code>String</code> to convert, may be null//LC:723
     * @return converted <code>Integer</code> (or null if the input is null)//LC:724
     * @throws NumberFormatException if the value cannot be converted//LC:725
     *///LC:726
    public static Integer createInteger(final String str) {//LC:727
        if (str == null) {//LC:728
            return null;//LC:729
        }//LC:730
        // decode() handles 0xAABD and 0777 (hex and octal) as well.//LC:731
        return Integer.decode(str);//LC:732
    }//LC:733
//LC:734
    /**//LC:735
     * <p>Convert a <code>String</code> to a <code>Long</code>;//LC:736
     * since 3.1 it handles hex and octal notations.</p>//LC:737
     *//LC:738
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:739
     *//LC:740
     * @param str  a <code>String</code> to convert, may be null//LC:741
     * @return converted <code>Long</code> (or null if the input is null)//LC:742
     * @throws NumberFormatException if the value cannot be converted//LC:743
     *///LC:744
    public static Long createLong(final String str) {//LC:745
        if (str == null) {//LC:746
            return null;//LC:747
        }//LC:748
        return Long.decode(str);//LC:749
    }//LC:750
//LC:751
    /**//LC:752
     * <p>Convert a <code>String</code> to a <code>BigInteger</code>;//LC:753
     * since 3.2 it handles hex (0x or #) and octal (0) notations.</p>//LC:754
     *//LC:755
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:756
     *//LC:757
     * @param str  a <code>String</code> to convert, may be null//LC:758
     * @return converted <code>BigInteger</code> (or null if the input is null)//LC:759
     * @throws NumberFormatException if the value cannot be converted//LC:760
     *///LC:761
    public static BigInteger createBigInteger(final String str) {//LC:762
        if (str == null) {//LC:763
            return null;//LC:764
        }//LC:765
        int pos = 0; // offset within string//LC:766
        int radix = 10;//LC:767
        boolean negate = false; // need to negate later?//LC:768
        if (str.startsWith("-")) {//LC:769
            negate = true;//LC:770
            pos = 1;//LC:771
        }//LC:772
        if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { // hex//LC:773
            radix = 16;//LC:774
            pos += 2;//LC:775
        } else if (str.startsWith("#", pos)) { // alternative hex (allowed by Long/Integer)//LC:776
            radix = 16;//LC:777
            pos ++;//LC:778
        } else if (str.startsWith("0", pos) && str.length() > pos + 1) { // octal; so long as there are additional digits//LC:779
            radix = 8;//LC:780
            pos ++;//LC:781
        } // default is to treat as decimal//LC:782
//LC:783
        final BigInteger value = new BigInteger(str.substring(pos), radix);//LC:784
        return negate ? value.negate() : value;//LC:785
    }//LC:786
//LC:787
    /**//LC:788
     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>//LC:789
     *//LC:790
     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>//LC:791
     *//LC:792
     * @param str  a <code>String</code> to convert, may be null//LC:793
     * @return converted <code>BigDecimal</code> (or null if the input is null)//LC:794
     * @throws NumberFormatException if the value cannot be converted//LC:795
     *///LC:796
    public static BigDecimal createBigDecimal(final String str) {//LC:797
        if (str == null) {//LC:798
            return null;//LC:799
        }//LC:800
        // handle JDK1.3.1 bug where "" throws IndexOutOfBoundsException//LC:801
        if (StringUtils.isBlank(str)) {//LC:802
            throw new NumberFormatException("A blank string is not a valid number");//LC:803
        }//LC:804
        if (str.trim().startsWith("--")) {//LC:805
            // this is protection for poorness in java.lang.BigDecimal.//LC:806
            // it accepts this as a legal value, but it does not appear//LC:807
            // to be in specification of class. OS X Java parses it to//LC:808
            // a wrong value.//LC:809
            throw new NumberFormatException(str + " is not a valid number.");//LC:810
        }//LC:811
        return new BigDecimal(str);//LC:812
    }//LC:813
//LC:814
    // Min in array//LC:815
    //--------------------------------------------------------------------//LC:816
    /**//LC:817
     * <p>Returns the minimum value in an array.</p>//LC:818
     *//LC:819
     * @param array  an array, must not be null or empty//LC:820
     * @return the minimum value in the array//LC:821
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:822
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:823
     *///LC:824
    public static long min(final long[] array) {//LC:825
        // Validates input//LC:826
        validateArray(array);//LC:827
//LC:828
        // Finds and returns min//LC:829
        long min = array[0];//LC:830
        for (int i = 1; i < array.length; i++) {//LC:831
            if (array[i] < min) {//LC:832
                min = array[i];//LC:833
            }//LC:834
        }//LC:835
//LC:836
        return min;//LC:837
    }//LC:838
//LC:839
    /**//LC:840
     * <p>Returns the minimum value in an array.</p>//LC:841
     *//LC:842
     * @param array  an array, must not be null or empty//LC:843
     * @return the minimum value in the array//LC:844
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:845
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:846
     *///LC:847
    public static int min(final int[] array) {//LC:848
        // Validates input//LC:849
        validateArray(array);//LC:850
//LC:851
        // Finds and returns min//LC:852
        int min = array[0];//LC:853
        for (int j = 1; j < array.length; j++) {//LC:854
            if (array[j] < min) {//LC:855
                min = array[j];//LC:856
            }//LC:857
        }//LC:858
//LC:859
        return min;//LC:860
    }//LC:861
//LC:862
    /**//LC:863
     * <p>Returns the minimum value in an array.</p>//LC:864
     *//LC:865
     * @param array  an array, must not be null or empty//LC:866
     * @return the minimum value in the array//LC:867
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:868
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:869
     *///LC:870
    public static short min(final short[] array) {//LC:871
        // Validates input//LC:872
        validateArray(array);//LC:873
//LC:874
        // Finds and returns min//LC:875
        short min = array[0];//LC:876
        for (int i = 1; i < array.length; i++) {//LC:877
            if (array[i] < min) {//LC:878
                min = array[i];//LC:879
            }//LC:880
        }//LC:881
//LC:882
        return min;//LC:883
    }//LC:884
//LC:885
    /**//LC:886
     * <p>Returns the minimum value in an array.</p>//LC:887
     *//LC:888
     * @param array  an array, must not be null or empty//LC:889
     * @return the minimum value in the array//LC:890
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:891
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:892
     *///LC:893
    public static byte min(final byte[] array) {//LC:894
        // Validates input//LC:895
        validateArray(array);//LC:896
//LC:897
        // Finds and returns min//LC:898
        byte min = array[0];//LC:899
        for (int i = 1; i < array.length; i++) {//LC:900
            if (array[i] < min) {//LC:901
                min = array[i];//LC:902
            }//LC:903
        }//LC:904
//LC:905
        return min;//LC:906
    }//LC:907
//LC:908
    /**//LC:909
     * <p>Returns the minimum value in an array.</p>//LC:910
     *//LC:911
     * @param array  an array, must not be null or empty//LC:912
     * @return the minimum value in the array//LC:913
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:914
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:915
     * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently//LC:916
     *///LC:917
    public static double min(final double[] array) {//LC:918
        // Validates input//LC:919
        validateArray(array);//LC:920
//LC:921
        // Finds and returns min//LC:922
        double min = array[0];//LC:923
        for (int i = 1; i < array.length; i++) {//LC:924
            if (Double.isNaN(array[i])) {//LC:925
                return Double.NaN;//LC:926
            }//LC:927
            if (array[i] < min) {//LC:928
                min = array[i];//LC:929
            }//LC:930
        }//LC:931
//LC:932
        return min;//LC:933
    }//LC:934
//LC:935
    /**//LC:936
     * <p>Returns the minimum value in an array.</p>//LC:937
     *//LC:938
     * @param array  an array, must not be null or empty//LC:939
     * @return the minimum value in the array//LC:940
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:941
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:942
     * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently//LC:943
     *///LC:944
    public static float min(final float[] array) {//LC:945
        // Validates input//LC:946
        validateArray(array);//LC:947
//LC:948
        // Finds and returns min//LC:949
        float min = array[0];//LC:950
        for (int i = 1; i < array.length; i++) {//LC:951
            if (Float.isNaN(array[i])) {//LC:952
                return Float.NaN;//LC:953
            }//LC:954
            if (array[i] < min) {//LC:955
                min = array[i];//LC:956
            }//LC:957
        }//LC:958
//LC:959
        return min;//LC:960
    }//LC:961
//LC:962
    // Max in array//LC:963
    //--------------------------------------------------------------------//LC:964
    /**//LC:965
     * <p>Returns the maximum value in an array.</p>//LC:966
     *//LC:967
     * @param array  an array, must not be null or empty//LC:968
     * @return the minimum value in the array//LC:969
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:970
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:971
     *///LC:972
    public static long max(final long[] array) {//LC:973
        // Validates input//LC:974
        validateArray(array);//LC:975
//LC:976
        // Finds and returns max//LC:977
        long max = array[0];//LC:978
        for (int j = 1; j < array.length; j++) {//LC:979
            if (array[j] > max) {//LC:980
                max = array[j];//LC:981
            }//LC:982
        }//LC:983
//LC:984
        return max;//LC:985
    }//LC:986
//LC:987
    /**//LC:988
     * <p>Returns the maximum value in an array.</p>//LC:989
     *//LC:990
     * @param array  an array, must not be null or empty//LC:991
     * @return the minimum value in the array//LC:992
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:993
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:994
     *///LC:995
    public static int max(final int[] array) {//LC:996
        // Validates input//LC:997
        validateArray(array);//LC:998
//LC:999
        // Finds and returns max//LC:1000
        int max = array[0];//LC:1001
        for (int j = 1; j < array.length; j++) {//LC:1002
            if (array[j] > max) {//LC:1003
                max = array[j];//LC:1004
            }//LC:1005
        }//LC:1006
//LC:1007
        return max;//LC:1008
    }//LC:1009
//LC:1010
    /**//LC:1011
     * <p>Returns the maximum value in an array.</p>//LC:1012
     *//LC:1013
     * @param array  an array, must not be null or empty//LC:1014
     * @return the minimum value in the array//LC:1015
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:1016
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:1017
     *///LC:1018
    public static short max(final short[] array) {//LC:1019
        // Validates input//LC:1020
        validateArray(array);//LC:1021
//LC:1022
        // Finds and returns max//LC:1023
        short max = array[0];//LC:1024
        for (int i = 1; i < array.length; i++) {//LC:1025
            if (array[i] > max) {//LC:1026
                max = array[i];//LC:1027
            }//LC:1028
        }//LC:1029
//LC:1030
        return max;//LC:1031
    }//LC:1032
//LC:1033
    /**//LC:1034
     * <p>Returns the maximum value in an array.</p>//LC:1035
     *//LC:1036
     * @param array  an array, must not be null or empty//LC:1037
     * @return the minimum value in the array//LC:1038
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:1039
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:1040
     *///LC:1041
    public static byte max(final byte[] array) {//LC:1042
        // Validates input//LC:1043
        validateArray(array);//LC:1044
//LC:1045
        // Finds and returns max//LC:1046
        byte max = array[0];//LC:1047
        for (int i = 1; i < array.length; i++) {//LC:1048
            if (array[i] > max) {//LC:1049
                max = array[i];//LC:1050
            }//LC:1051
        }//LC:1052
//LC:1053
        return max;//LC:1054
    }//LC:1055
//LC:1056
    /**//LC:1057
     * <p>Returns the maximum value in an array.</p>//LC:1058
     *//LC:1059
     * @param array  an array, must not be null or empty//LC:1060
     * @return the minimum value in the array//LC:1061
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:1062
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:1063
     * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently//LC:1064
     *///LC:1065
    public static double max(final double[] array) {//LC:1066
        // Validates input//LC:1067
        validateArray(array);//LC:1068
//LC:1069
        // Finds and returns max//LC:1070
        double max = array[0];//LC:1071
        for (int j = 1; j < array.length; j++) {//LC:1072
            if (Double.isNaN(array[j])) {//LC:1073
                return Double.NaN;//LC:1074
            }//LC:1075
            if (array[j] > max) {//LC:1076
                max = array[j];//LC:1077
            }//LC:1078
        }//LC:1079
//LC:1080
        return max;//LC:1081
    }//LC:1082
//LC:1083
    /**//LC:1084
     * <p>Returns the maximum value in an array.</p>//LC:1085
     *//LC:1086
     * @param array  an array, must not be null or empty//LC:1087
     * @return the minimum value in the array//LC:1088
     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>//LC:1089
     * @throws IllegalArgumentException if <code>array</code> is empty//LC:1090
     * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently//LC:1091
     *///LC:1092
    public static float max(final float[] array) {//LC:1093
        // Validates input//LC:1094
        validateArray(array);//LC:1095
//LC:1096
        // Finds and returns max//LC:1097
        float max = array[0];//LC:1098
        for (int j = 1; j < array.length; j++) {//LC:1099
            if (Float.isNaN(array[j])) {//LC:1100
                return Float.NaN;//LC:1101
            }//LC:1102
            if (array[j] > max) {//LC:1103
                max = array[j];//LC:1104
            }//LC:1105
        }//LC:1106
//LC:1107
        return max;//LC:1108
    }//LC:1109
//LC:1110
    /**//LC:1111
     * Checks if the specified array is neither null nor empty.//LC:1112
     *//LC:1113
     * @param array  the array to check//LC:1114
     * @throws IllegalArgumentException if {@code array} is either {@code null} or empty//LC:1115
     *///LC:1116
    private static void validateArray(final Object array) {//LC:1117
        if (array == null) {//LC:1118
            throw new IllegalArgumentException("The Array must not be null");//LC:1119
        } else if (Array.getLength(array) == 0) {//LC:1120
            throw new IllegalArgumentException("Array cannot be empty.");//LC:1121
        }//LC:1122
    }//LC:1123
//LC:1124
    // 3 param min//LC:1125
    //-----------------------------------------------------------------------//LC:1126
    /**//LC:1127
     * <p>Gets the minimum of three <code>long</code> values.</p>//LC:1128
     *//LC:1129
     * @param a  value 1//LC:1130
     * @param b  value 2//LC:1131
     * @param c  value 3//LC:1132
     * @return  the smallest of the values//LC:1133
     *///LC:1134
    public static long min(long a, final long b, final long c) {//LC:1135
        if (b < a) {//LC:1136
            a = b;//LC:1137
        }//LC:1138
        if (c < a) {//LC:1139
            a = c;//LC:1140
        }//LC:1141
        return a;//LC:1142
    }//LC:1143
//LC:1144
    /**//LC:1145
     * <p>Gets the minimum of three <code>int</code> values.</p>//LC:1146
     *//LC:1147
     * @param a  value 1//LC:1148
     * @param b  value 2//LC:1149
     * @param c  value 3//LC:1150
     * @return  the smallest of the values//LC:1151
     *///LC:1152
    public static int min(int a, final int b, final int c) {//LC:1153
        if (b < a) {//LC:1154
            a = b;//LC:1155
        }//LC:1156
        if (c < a) {//LC:1157
            a = c;//LC:1158
        }//LC:1159
        return a;//LC:1160
    }//LC:1161
//LC:1162
    /**//LC:1163
     * <p>Gets the minimum of three <code>short</code> values.</p>//LC:1164
     *//LC:1165
     * @param a  value 1//LC:1166
     * @param b  value 2//LC:1167
     * @param c  value 3//LC:1168
     * @return  the smallest of the values//LC:1169
     *///LC:1170
    public static short min(short a, final short b, final short c) {//LC:1171
        if (b < a) {//LC:1172
            a = b;//LC:1173
        }//LC:1174
        if (c < a) {//LC:1175
            a = c;//LC:1176
        }//LC:1177
        return a;//LC:1178
    }//LC:1179
//LC:1180
    /**//LC:1181
     * <p>Gets the minimum of three <code>byte</code> values.</p>//LC:1182
     *//LC:1183
     * @param a  value 1//LC:1184
     * @param b  value 2//LC:1185
     * @param c  value 3//LC:1186
     * @return  the smallest of the values//LC:1187
     *///LC:1188
    public static byte min(byte a, final byte b, final byte c) {//LC:1189
        if (b < a) {//LC:1190
            a = b;//LC:1191
        }//LC:1192
        if (c < a) {//LC:1193
            a = c;//LC:1194
        }//LC:1195
        return a;//LC:1196
    }//LC:1197
//LC:1198
    /**//LC:1199
     * <p>Gets the minimum of three <code>double</code> values.</p>//LC:1200
     *//LC:1201
     * <p>If any value is <code>NaN</code>, <code>NaN</code> is//LC:1202
     * returned. Infinity is handled.</p>//LC:1203
     *//LC:1204
     * @param a  value 1//LC:1205
     * @param b  value 2//LC:1206
     * @param c  value 3//LC:1207
     * @return  the smallest of the values//LC:1208
     * @see IEEE754rUtils#min(double, double, double) for a version of this method that handles NaN differently//LC:1209
     *///LC:1210
    public static double min(final double a, final double b, final double c) {//LC:1211
        return Math.min(Math.min(a, b), c);//LC:1212
    }//LC:1213
//LC:1214
    /**//LC:1215
     * <p>Gets the minimum of three <code>float</code> values.</p>//LC:1216
     *//LC:1217
     * <p>If any value is <code>NaN</code>, <code>NaN</code> is//LC:1218
     * returned. Infinity is handled.</p>//LC:1219
     *//LC:1220
     * @param a  value 1//LC:1221
     * @param b  value 2//LC:1222
     * @param c  value 3//LC:1223
     * @return  the smallest of the values//LC:1224
     * @see IEEE754rUtils#min(float, float, float) for a version of this method that handles NaN differently//LC:1225
     *///LC:1226
    public static float min(final float a, final float b, final float c) {//LC:1227
        return Math.min(Math.min(a, b), c);//LC:1228
    }//LC:1229
//LC:1230
    // 3 param max//LC:1231
    //-----------------------------------------------------------------------//LC:1232
    /**//LC:1233
     * <p>Gets the maximum of three <code>long</code> values.</p>//LC:1234
     *//LC:1235
     * @param a  value 1//LC:1236
     * @param b  value 2//LC:1237
     * @param c  value 3//LC:1238
     * @return  the largest of the values//LC:1239
     *///LC:1240
    public static long max(long a, final long b, final long c) {//LC:1241
        if (b > a) {//LC:1242
            a = b;//LC:1243
        }//LC:1244
        if (c > a) {//LC:1245
            a = c;//LC:1246
        }//LC:1247
        return a;//LC:1248
    }//LC:1249
//LC:1250
    /**//LC:1251
     * <p>Gets the maximum of three <code>int</code> values.</p>//LC:1252
     *//LC:1253
     * @param a  value 1//LC:1254
     * @param b  value 2//LC:1255
     * @param c  value 3//LC:1256
     * @return  the largest of the values//LC:1257
     *///LC:1258
    public static int max(int a, final int b, final int c) {//LC:1259
        if (b > a) {//LC:1260
            a = b;//LC:1261
        }//LC:1262
        if (c > a) {//LC:1263
            a = c;//LC:1264
        }//LC:1265
        return a;//LC:1266
    }//LC:1267
//LC:1268
    /**//LC:1269
     * <p>Gets the maximum of three <code>short</code> values.</p>//LC:1270
     *//LC:1271
     * @param a  value 1//LC:1272
     * @param b  value 2//LC:1273
     * @param c  value 3//LC:1274
     * @return  the largest of the values//LC:1275
     *///LC:1276
    public static short max(short a, final short b, final short c) {//LC:1277
        if (b > a) {//LC:1278
            a = b;//LC:1279
        }//LC:1280
        if (c > a) {//LC:1281
            a = c;//LC:1282
        }//LC:1283
        return a;//LC:1284
    }//LC:1285
//LC:1286
    /**//LC:1287
     * <p>Gets the maximum of three <code>byte</code> values.</p>//LC:1288
     *//LC:1289
     * @param a  value 1//LC:1290
     * @param b  value 2//LC:1291
     * @param c  value 3//LC:1292
     * @return  the largest of the values//LC:1293
     *///LC:1294
    public static byte max(byte a, final byte b, final byte c) {//LC:1295
        if (b > a) {//LC:1296
            a = b;//LC:1297
        }//LC:1298
        if (c > a) {//LC:1299
            a = c;//LC:1300
        }//LC:1301
        return a;//LC:1302
    }//LC:1303
//LC:1304
    /**//LC:1305
     * <p>Gets the maximum of three <code>double</code> values.</p>//LC:1306
     *//LC:1307
     * <p>If any value is <code>NaN</code>, <code>NaN</code> is//LC:1308
     * returned. Infinity is handled.</p>//LC:1309
     *//LC:1310
     * @param a  value 1//LC:1311
     * @param b  value 2//LC:1312
     * @param c  value 3//LC:1313
     * @return  the largest of the values//LC:1314
     * @see IEEE754rUtils#max(double, double, double) for a version of this method that handles NaN differently//LC:1315
     *///LC:1316
    public static double max(final double a, final double b, final double c) {//LC:1317
        return Math.max(Math.max(a, b), c);//LC:1318
    }//LC:1319
//LC:1320
    /**//LC:1321
     * <p>Gets the maximum of three <code>float</code> values.</p>//LC:1322
     *//LC:1323
     * <p>If any value is <code>NaN</code>, <code>NaN</code> is//LC:1324
     * returned. Infinity is handled.</p>//LC:1325
     *//LC:1326
     * @param a  value 1//LC:1327
     * @param b  value 2//LC:1328
     * @param c  value 3//LC:1329
     * @return  the largest of the values//LC:1330
     * @see IEEE754rUtils#max(float, float, float) for a version of this method that handles NaN differently//LC:1331
     *///LC:1332
    public static float max(final float a, final float b, final float c) {//LC:1333
        return Math.max(Math.max(a, b), c);//LC:1334
    }//LC:1335
//LC:1336
    //-----------------------------------------------------------------------//LC:1337
    /**//LC:1338
     * <p>Checks whether the <code>String</code> contains only//LC:1339
     * digit characters.</p>//LC:1340
     *//LC:1341
     * <p><code>Null</code> and empty String will return//LC:1342
     * <code>false</code>.</p>//LC:1343
     *//LC:1344
     * @param str  the <code>String</code> to check//LC:1345
     * @return <code>true</code> if str contains only Unicode numeric//LC:1346
     *///LC:1347
    public static boolean isDigits(final String str) {//LC:1348
        if (StringUtils.isEmpty(str)) {//LC:1349
            return false;//LC:1350
        }//LC:1351
        for (int i = 0; i < str.length(); i++) {//LC:1352
            if (!Character.isDigit(str.charAt(i))) {//LC:1353
                return false;//LC:1354
            }//LC:1355
        }//LC:1356
        return true;//LC:1357
    }//LC:1358
//LC:1359
    /**//LC:1360
     * <p>Checks whether the String a valid Java number.</p>//LC:1361
     *//LC:1362
     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>//LC:1363
     * qualifier, scientific notation and numbers marked with a type//LC:1364
     * qualifier (e.g. 123L).</p>//LC:1365
     *//LC:1366
     * <p><code>Null</code> and empty String will return//LC:1367
     * <code>false</code>.</p>//LC:1368
     *//LC:1369
     * @param str  the <code>String</code> to check//LC:1370
     * @return <code>true</code> if the string is a correctly formatted number//LC:1371
     *///LC:1372
    public static boolean isNumber(final String str) {//LC:1373
        if (StringUtils.isEmpty(str)) {//LC:1374
            return false;//LC:1375
        }//LC:1376
        final char[] chars = str.toCharArray();//LC:1377
        int sz = chars.length;//LC:1378
        boolean hasExp = false;//LC:1379
        boolean hasDecPoint = false;//LC:1380
        boolean allowSigns = false;//LC:1381
        boolean foundDigit = false;//LC:1382
        // deal with any possible sign up front//LC:1383
        final int start = (chars[0] == '-') ? 1 : 0;//LC:1384
        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {//LC:1385
            int i = start + 2;//LC:1386
            if (i == sz) {//LC:1387
                return false; // str == "0x"//LC:1388
            }//LC:1389
            // checking hex (it can't be anything else)//LC:1390
            for (; i < chars.length; i++) {//LC:1391
                if ((chars[i] < '0' || chars[i] > '9')//LC:1392
                        && (chars[i] < 'a' || chars[i] > 'f')//LC:1393
                        && (chars[i] < 'A' || chars[i] > 'F')) {//LC:1394
                    return false;//LC:1395
                }//LC:1396
            }//LC:1397
            return true;//LC:1398
        }//LC:1399
        sz--; // don't want to loop to the last char, check it afterwords//LC:1400
        // for type qualifiers//LC:1401
        int i = start;//LC:1402
        // loop to the next to last char or to the last char if we need another digit to//LC:1403
        // make a valid number (e.g. chars[0..5] = "1234E")//LC:1404
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {//LC:1405
            if (chars[i] >= '0' && chars[i] <= '9') {//LC:1406
                foundDigit = true;//LC:1407
                allowSigns = false;//LC:1408
//LC:1409
            } else if (chars[i] == '.') {//LC:1410
                if (hasDecPoint || hasExp) {//LC:1411
                    // two decimal points or dec in exponent//LC:1412
                    return false;//LC:1413
                }//LC:1414
                hasDecPoint = true;//LC:1415
            } else if (chars[i] == 'e' || chars[i] == 'E') {//LC:1416
                // we've already taken care of hex.//LC:1417
                if (hasExp) {//LC:1418
                    // two E's//LC:1419
                    return false;//LC:1420
                }//LC:1421
                if (!foundDigit) {//LC:1422
                    return false;//LC:1423
                }//LC:1424
                hasExp = true;//LC:1425
                allowSigns = true;//LC:1426
            } else if (chars[i] == '+' || chars[i] == '-') {//LC:1427
                if (!allowSigns) {//LC:1428
                    return false;//LC:1429
                }//LC:1430
                allowSigns = false;//LC:1431
                foundDigit = false; // we need a digit after the E//LC:1432
            } else {//LC:1433
                return false;//LC:1434
            }//LC:1435
            i++;//LC:1436
        }//LC:1437
        if (i < chars.length) {//LC:1438
            if (chars[i] >= '0' && chars[i] <= '9') {//LC:1439
                // no type qualifier, OK//LC:1440
                return true;//LC:1441
            }//LC:1442
            if (chars[i] == 'e' || chars[i] == 'E') {//LC:1443
                // can't have an E at the last byte//LC:1444
                return false;//LC:1445
            }//LC:1446
            if (chars[i] == '.') {//LC:1447
                if (hasDecPoint || hasExp) {//LC:1448
                    // two decimal points or dec in exponent//LC:1449
                    return false;//LC:1450
                }//LC:1451
                // single trailing decimal point after non-exponent is ok//LC:1452
                return foundDigit;//LC:1453
            }//LC:1454
            if (!allowSigns//LC:1455
                    && (chars[i] == 'd'//LC:1456
                    || chars[i] == 'D'//LC:1457
                    || chars[i] == 'f'//LC:1458
                    || chars[i] == 'F')) {//LC:1459
                return foundDigit;//LC:1460
            }//LC:1461
            if (chars[i] == 'l'//LC:1462
                    || chars[i] == 'L') {//LC:1463
                // not allowing L with an exponent or decimal point//LC:1464
                return foundDigit && !hasExp && !hasDecPoint;//LC:1465
            }//LC:1466
            // last character is illegal//LC:1467
            return false;//LC:1468
        }//LC:1469
        // allowSigns is true iff the val ends in 'E'//LC:1470
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass//LC:1471
        return !allowSigns && foundDigit;//LC:1472
    }//LC:1473
//LC:1474
}//LC:1475
//LC:1476
//@Immutablestatic//LC:1477
class StringUtils {//LC:1478
    // Performance testing notes (JDK 1.4, Jul03, scolebourne)//LC:1479
    // Whitespace://LC:1480
    // Character.isWhitespace() is faster than WHITESPACE.indexOf()//LC:1481
    // where WHITESPACE is a string of all whitespace characters//LC:1482
    ////LC:1483
    // Character access://LC:1484
    // String.charAt(n) versus toCharArray(), then array[n]//LC:1485
    // String.charAt(n) is about 15% worse for a 10K string//LC:1486
    // They are about equal for a length 50 string//LC:1487
    // String.charAt(n) is about 4 times better for a length 3 string//LC:1488
    // String.charAt(n) is best bet overall//LC:1489
    ////LC:1490
    // Append://LC:1491
    // String.concat about twice as fast as StringBuffer.append//LC:1492
    // (not sure who tested this)//LC:1493
//LC:1494
    /**//LC:1495
     * A String for a space character.//LC:1496
     *//LC:1497
     * @since 3.2//LC:1498
     *///LC:1499
    public static final String SPACE = " ";//LC:1500
//LC:1501
    /**//LC:1502
     * The empty String {@code ""}.//LC:1503
     * @since 2.0//LC:1504
     *///LC:1505
    public static final String EMPTY = "";//LC:1506
//LC:1507
    /**//LC:1508
     * A String for linefeed LF ("\n").//LC:1509
     *//LC:1510
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences//LC:1511
     *      for Character and String Literals</a>//LC:1512
     * @since 3.2//LC:1513
     *///LC:1514
    public static final String LF = "\n";//LC:1515
//LC:1516
    /**//LC:1517
     * A String for carriage return CR ("\r").//LC:1518
     *//LC:1519
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences//LC:1520
     *      for Character and String Literals</a>//LC:1521
     * @since 3.2//LC:1522
     *///LC:1523
    public static final String CR = "\r";//LC:1524
//LC:1525
    /**//LC:1526
     * Represents a failed index search.//LC:1527
     * @since 2.1//LC:1528
     *///LC:1529
    public static final int INDEX_NOT_FOUND = -1;//LC:1530
//LC:1531
    /**//LC:1532
     * <p>The maximum size to which the padding constant(s) can expand.</p>//LC:1533
     *///LC:1534
    private static final int PAD_LIMIT = 8192;//LC:1535
//LC:1536
    /**//LC:1537
     * A regex pattern for recognizing blocks of whitespace characters.//LC:1538
     * The apparent convolutedness of the pattern serves the purpose of//LC:1539
     * ignoring "blocks" consisting of only a single space:  the pattern//LC:1540
     * is used only to normalize whitespace, condensing "blocks" down to a//LC:1541
     * single space, thus matching the same would likely cause a great//LC:1542
     * many noop replacements.//LC:1543
     *///LC:1544
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("(?: \\s|[\\s&&[^ ]])\\s*");//LC:1545
//LC:1546
    /**//LC:1547
     * <p>{@code StringUtils} instances should NOT be constructed in//LC:1548
     * standard programming. Instead, the class should be used as//LC:1549
     * {@code StringUtils.trim(" foo ");}.</p>//LC:1550
     *//LC:1551
     * <p>This constructor is public to permit tools that require a JavaBean//LC:1552
     * instance to operate.</p>//LC:1553
     *///LC:1554
    public StringUtils() {//LC:1555
        super();//LC:1556
    }//LC:1557
//LC:1558
    // Empty checks//LC:1559
    //-----------------------------------------------------------------------//LC:1560
    /**//LC:1561
     * <p>Checks if a CharSequence is empty ("") or null.</p>//LC:1562
     *//LC:1563
     * <pre>//LC:1564
     * StringUtils.isEmpty(null)      = true//LC:1565
     * StringUtils.isEmpty("")        = true//LC:1566
     * StringUtils.isEmpty(" ")       = false//LC:1567
     * StringUtils.isEmpty("bob")     = false//LC:1568
     * StringUtils.isEmpty("  bob  ") = false//LC:1569
     * </pre>//LC:1570
     *//LC:1571
     * <p>NOTE: This method changed in Lang version 2.0.//LC:1572
     * It no longer trims the CharSequence.//LC:1573
     * That functionality is available in isBlank().</p>//LC:1574
     *//LC:1575
     * @param cs  the CharSequence to check, may be null//LC:1576
     * @return {@code true} if the CharSequence is empty or null//LC:1577
     * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)//LC:1578
     *///LC:1579
    public static boolean isEmpty(final CharSequence cs) {//LC:1580
        return cs == null || cs.length() == 0;//LC:1581
    }//LC:1582
//LC:1583
    /**//LC:1584
     * <p>Checks if a CharSequence is not empty ("") and not null.</p>//LC:1585
     *//LC:1586
     * <pre>//LC:1587
     * StringUtils.isNotEmpty(null)      = false//LC:1588
     * StringUtils.isNotEmpty("")        = false//LC:1589
     * StringUtils.isNotEmpty(" ")       = true//LC:1590
     * StringUtils.isNotEmpty("bob")     = true//LC:1591
     * StringUtils.isNotEmpty("  bob  ") = true//LC:1592
     * </pre>//LC:1593
     *//LC:1594
     * @param cs  the CharSequence to check, may be null//LC:1595
     * @return {@code true} if the CharSequence is not empty and not null//LC:1596
     * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)//LC:1597
     *///LC:1598
    public static boolean isNotEmpty(final CharSequence cs) {//LC:1599
        return !StringUtils.isEmpty(cs);//LC:1600
    }//LC:1601
//LC:1602
    /**//LC:1603
     * <p>Checks if a CharSequence is whitespace, empty ("") or null.</p>//LC:1604
     *//LC:1605
     * <pre>//LC:1606
     * StringUtils.isBlank(null)      = true//LC:1607
     * StringUtils.isBlank("")        = true//LC:1608
     * StringUtils.isBlank(" ")       = true//LC:1609
     * StringUtils.isBlank("bob")     = false//LC:1610
     * StringUtils.isBlank("  bob  ") = false//LC:1611
     * </pre>//LC:1612
     *//LC:1613
     * @param cs  the CharSequence to check, may be null//LC:1614
     * @return {@code true} if the CharSequence is null, empty or whitespace//LC:1615
     * @since 2.0//LC:1616
     * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)//LC:1617
     *///LC:1618
    public static boolean isBlank(final CharSequence cs) {//LC:1619
        int strLen;//LC:1620
        if (cs == null || (strLen = cs.length()) == 0) {//LC:1621
            return true;//LC:1622
        }//LC:1623
        for (int i = 0; i < strLen; i++) {//LC:1624
            if (Character.isWhitespace(cs.charAt(i)) == false) {//LC:1625
                return false;//LC:1626
            }//LC:1627
        }//LC:1628
        return true;//LC:1629
    }//LC:1630
//LC:1631
    /**//LC:1632
     * <p>Checks if a CharSequence is not empty (""), not null and not whitespace only.</p>//LC:1633
     *//LC:1634
     * <pre>//LC:1635
     * StringUtils.isNotBlank(null)      = false//LC:1636
     * StringUtils.isNotBlank("")        = false//LC:1637
     * StringUtils.isNotBlank(" ")       = false//LC:1638
     * StringUtils.isNotBlank("bob")     = true//LC:1639
     * StringUtils.isNotBlank("  bob  ") = true//LC:1640
     * </pre>//LC:1641
     *//LC:1642
     * @param cs  the CharSequence to check, may be null//LC:1643
     * @return {@code true} if the CharSequence is//LC:1644
     *  not empty and not null and not whitespace//LC:1645
     * @since 2.0//LC:1646
     * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)//LC:1647
     *///LC:1648
    public static boolean isNotBlank(final CharSequence cs) {//LC:1649
        return !StringUtils.isBlank(cs);//LC:1650
    }//LC:1651
//LC:1652
    // Trim//LC:1653
    //-----------------------------------------------------------------------//LC:1654
    /**//LC:1655
     * <p>Removes control characters (char &lt;= 32) from both//LC:1656
     * ends of this String, handling {@code null} by returning//LC:1657
     * {@code null}.</p>//LC:1658
     *//LC:1659
     * <p>The String is trimmed using {@link String#trim()}.//LC:1660
     * Trim removes start and end characters &lt;= 32.//LC:1661
     * To strip whitespace use {@link #strip(String)}.</p>//LC:1662
     *//LC:1663
     * <p>To trim your choice of characters, use the//LC:1664
     * {@link #strip(String, String)} methods.</p>//LC:1665
     *//LC:1666
     * <pre>//LC:1667
     * StringUtils.trim(null)          = null//LC:1668
     * StringUtils.trim("")            = ""//LC:1669
     * StringUtils.trim("     ")       = ""//LC:1670
     * StringUtils.trim("abc")         = "abc"//LC:1671
     * StringUtils.trim("    abc    ") = "abc"//LC:1672
     * </pre>//LC:1673
     *//LC:1674
     * @param str  the String to be trimmed, may be null//LC:1675
     * @return the trimmed string, {@code null} if null String input//LC:1676
     *///LC:1677
    public static String trim(final String str) {//LC:1678
        return str == null ? null : str.trim();//LC:1679
    }//LC:1680
//LC:1681
    /**//LC:1682
     * <p>Removes control characters (char &lt;= 32) from both//LC:1683
     * ends of this String returning {@code null} if the String is//LC:1684
     * empty ("") after the trim or if it is {@code null}.//LC:1685
     *//LC:1686
     * <p>The String is trimmed using {@link String#trim()}.//LC:1687
     * Trim removes start and end characters &lt;= 32.//LC:1688
     * To strip whitespace use {@link #stripToNull(String)}.</p>//LC:1689
     *//LC:1690
     * <pre>//LC:1691
     * StringUtils.trimToNull(null)          = null//LC:1692
     * StringUtils.trimToNull("")            = null//LC:1693
     * StringUtils.trimToNull("     ")       = null//LC:1694
     * StringUtils.trimToNull("abc")         = "abc"//LC:1695
     * StringUtils.trimToNull("    abc    ") = "abc"//LC:1696
     * </pre>//LC:1697
     *//LC:1698
     * @param str  the String to be trimmed, may be null//LC:1699
     * @return the trimmed String,//LC:1700
     *  {@code null} if only chars &lt;= 32, empty or null String input//LC:1701
     * @since 2.0//LC:1702
     *///LC:1703
    public static String trimToNull(final String str) {//LC:1704
        final String ts = trim(str);//LC:1705
        return isEmpty(ts) ? null : ts;//LC:1706
    }//LC:1707
//LC:1708
    /**//LC:1709
     * <p>Removes control characters (char &lt;= 32) from both//LC:1710
     * ends of this String returning an empty String ("") if the String//LC:1711
     * is empty ("") after the trim or if it is {@code null}.//LC:1712
     *//LC:1713
     * <p>The String is trimmed using {@link String#trim()}.//LC:1714
     * Trim removes start and end characters &lt;= 32.//LC:1715
     * To strip whitespace use {@link #stripToEmpty(String)}.</p>//LC:1716
     *//LC:1717
     * <pre>//LC:1718
     * StringUtils.trimToEmpty(null)          = ""//LC:1719
     * StringUtils.trimToEmpty("")            = ""//LC:1720
     * StringUtils.trimToEmpty("     ")       = ""//LC:1721
     * StringUtils.trimToEmpty("abc")         = "abc"//LC:1722
     * StringUtils.trimToEmpty("    abc    ") = "abc"//LC:1723
     * </pre>//LC:1724
     *//LC:1725
     * @param str  the String to be trimmed, may be null//LC:1726
     * @return the trimmed String, or an empty String if {@code null} input//LC:1727
     * @since 2.0//LC:1728
     *///LC:1729
    public static String trimToEmpty(final String str) {//LC:1730
        return str == null ? EMPTY : str.trim();//LC:1731
    }//LC:1732
//LC:1733
    // Stripping//LC:1734
    //-----------------------------------------------------------------------//LC:1735
    /**//LC:1736
     * <p>Strips whitespace from the start and end of a String.</p>//LC:1737
     *//LC:1738
     * <p>This is similar to {@link #trim(String)} but removes whitespace.//LC:1739
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:1740
     *//LC:1741
     * <p>A {@code null} input String returns {@code null}.</p>//LC:1742
     *//LC:1743
     * <pre>//LC:1744
     * StringUtils.strip(null)     = null//LC:1745
     * StringUtils.strip("")       = ""//LC:1746
     * StringUtils.strip("   ")    = ""//LC:1747
     * StringUtils.strip("abc")    = "abc"//LC:1748
     * StringUtils.strip("  abc")  = "abc"//LC:1749
     * StringUtils.strip("abc  ")  = "abc"//LC:1750
     * StringUtils.strip(" abc ")  = "abc"//LC:1751
     * StringUtils.strip(" ab c ") = "ab c"//LC:1752
     * </pre>//LC:1753
     *//LC:1754
     * @param str  the String to remove whitespace from, may be null//LC:1755
     * @return the stripped String, {@code null} if null String input//LC:1756
     *///LC:1757
    public static String strip(final String str) {//LC:1758
        return strip(str, null);//LC:1759
    }//LC:1760
//LC:1761
    /**//LC:1762
     * <p>Strips whitespace from the start and end of a String  returning//LC:1763
     * {@code null} if the String is empty ("") after the strip.</p>//LC:1764
     *//LC:1765
     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.//LC:1766
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:1767
     *//LC:1768
     * <pre>//LC:1769
     * StringUtils.stripToNull(null)     = null//LC:1770
     * StringUtils.stripToNull("")       = null//LC:1771
     * StringUtils.stripToNull("   ")    = null//LC:1772
     * StringUtils.stripToNull("abc")    = "abc"//LC:1773
     * StringUtils.stripToNull("  abc")  = "abc"//LC:1774
     * StringUtils.stripToNull("abc  ")  = "abc"//LC:1775
     * StringUtils.stripToNull(" abc ")  = "abc"//LC:1776
     * StringUtils.stripToNull(" ab c ") = "ab c"//LC:1777
     * </pre>//LC:1778
     *//LC:1779
     * @param str  the String to be stripped, may be null//LC:1780
     * @return the stripped String,//LC:1781
     *  {@code null} if whitespace, empty or null String input//LC:1782
     * @since 2.0//LC:1783
     *///LC:1784
    public static String stripToNull(String str) {//LC:1785
        if (str == null) {//LC:1786
            return null;//LC:1787
        }//LC:1788
        str = strip(str, null);//LC:1789
        return str.isEmpty() ? null : str;//LC:1790
    }//LC:1791
//LC:1792
    /**//LC:1793
     * <p>Strips whitespace from the start and end of a String  returning//LC:1794
     * an empty String if {@code null} input.</p>//LC:1795
     *//LC:1796
     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.//LC:1797
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:1798
     *//LC:1799
     * <pre>//LC:1800
     * StringUtils.stripToEmpty(null)     = ""//LC:1801
     * StringUtils.stripToEmpty("")       = ""//LC:1802
     * StringUtils.stripToEmpty("   ")    = ""//LC:1803
     * StringUtils.stripToEmpty("abc")    = "abc"//LC:1804
     * StringUtils.stripToEmpty("  abc")  = "abc"//LC:1805
     * StringUtils.stripToEmpty("abc  ")  = "abc"//LC:1806
     * StringUtils.stripToEmpty(" abc ")  = "abc"//LC:1807
     * StringUtils.stripToEmpty(" ab c ") = "ab c"//LC:1808
     * </pre>//LC:1809
     *//LC:1810
     * @param str  the String to be stripped, may be null//LC:1811
     * @return the trimmed String, or an empty String if {@code null} input//LC:1812
     * @since 2.0//LC:1813
     *///LC:1814
    public static String stripToEmpty(final String str) {//LC:1815
        return str == null ? EMPTY : strip(str, null);//LC:1816
    }//LC:1817
//LC:1818
    /**//LC:1819
     * <p>Strips any of a set of characters from the start and end of a String.//LC:1820
     * This is similar to {@link String#trim()} but allows the characters//LC:1821
     * to be stripped to be controlled.</p>//LC:1822
     *//LC:1823
     * <p>A {@code null} input String returns {@code null}.//LC:1824
     * An empty string ("") input returns the empty string.</p>//LC:1825
     *//LC:1826
     * <p>If the stripChars String is {@code null}, whitespace is//LC:1827
     * stripped as defined by {@link Character#isWhitespace(char)}.//LC:1828
     * Alternatively use {@link #strip(String)}.</p>//LC:1829
     *//LC:1830
     * <pre>//LC:1831
     * StringUtils.strip(null, *)          = null//LC:1832
     * StringUtils.strip("", *)            = ""//LC:1833
     * StringUtils.strip("abc", null)      = "abc"//LC:1834
     * StringUtils.strip("  abc", null)    = "abc"//LC:1835
     * StringUtils.strip("abc  ", null)    = "abc"//LC:1836
     * StringUtils.strip(" abc ", null)    = "abc"//LC:1837
     * StringUtils.strip("  abcyx", "xyz") = "  abc"//LC:1838
     * </pre>//LC:1839
     *//LC:1840
     * @param str  the String to remove characters from, may be null//LC:1841
     * @param stripChars  the characters to remove, null treated as whitespace//LC:1842
     * @return the stripped String, {@code null} if null String input//LC:1843
     *///LC:1844
    public static String strip(String str, final String stripChars) {//LC:1845
        if (isEmpty(str)) {//LC:1846
            return str;//LC:1847
        }//LC:1848
        str = stripStart(str, stripChars);//LC:1849
        return stripEnd(str, stripChars);//LC:1850
    }//LC:1851
//LC:1852
    /**//LC:1853
     * <p>Strips any of a set of characters from the start of a String.</p>//LC:1854
     *//LC:1855
     * <p>A {@code null} input String returns {@code null}.//LC:1856
     * An empty string ("") input returns the empty string.</p>//LC:1857
     *//LC:1858
     * <p>If the stripChars String is {@code null}, whitespace is//LC:1859
     * stripped as defined by {@link Character#isWhitespace(char)}.</p>//LC:1860
     *//LC:1861
     * <pre>//LC:1862
     * StringUtils.stripStart(null, *)          = null//LC:1863
     * StringUtils.stripStart("", *)            = ""//LC:1864
     * StringUtils.stripStart("abc", "")        = "abc"//LC:1865
     * StringUtils.stripStart("abc", null)      = "abc"//LC:1866
     * StringUtils.stripStart("  abc", null)    = "abc"//LC:1867
     * StringUtils.stripStart("abc  ", null)    = "abc  "//LC:1868
     * StringUtils.stripStart(" abc ", null)    = "abc "//LC:1869
     * StringUtils.stripStart("yxabc  ", "xyz") = "abc  "//LC:1870
     * </pre>//LC:1871
     *//LC:1872
     * @param str  the String to remove characters from, may be null//LC:1873
     * @param stripChars  the characters to remove, null treated as whitespace//LC:1874
     * @return the stripped String, {@code null} if null String input//LC:1875
     *///LC:1876
    public static String stripStart(final String str, final String stripChars) {//LC:1877
        int strLen;//LC:1878
        if (str == null || (strLen = str.length()) == 0) {//LC:1879
            return str;//LC:1880
        }//LC:1881
        int start = 0;//LC:1882
        if (stripChars == null) {//LC:1883
            while (start != strLen && Character.isWhitespace(str.charAt(start))) {//LC:1884
                start++;//LC:1885
            }//LC:1886
        } else if (stripChars.isEmpty()) {//LC:1887
            return str;//LC:1888
        } else {//LC:1889
            while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {//LC:1890
                start++;//LC:1891
            }//LC:1892
        }//LC:1893
        return str.substring(start);//LC:1894
    }//LC:1895
//LC:1896
    /**//LC:1897
     * <p>Strips any of a set of characters from the end of a String.</p>//LC:1898
     *//LC:1899
     * <p>A {@code null} input String returns {@code null}.//LC:1900
     * An empty string ("") input returns the empty string.</p>//LC:1901
     *//LC:1902
     * <p>If the stripChars String is {@code null}, whitespace is//LC:1903
     * stripped as defined by {@link Character#isWhitespace(char)}.</p>//LC:1904
     *//LC:1905
     * <pre>//LC:1906
     * StringUtils.stripEnd(null, *)          = null//LC:1907
     * StringUtils.stripEnd("", *)            = ""//LC:1908
     * StringUtils.stripEnd("abc", "")        = "abc"//LC:1909
     * StringUtils.stripEnd("abc", null)      = "abc"//LC:1910
     * StringUtils.stripEnd("  abc", null)    = "  abc"//LC:1911
     * StringUtils.stripEnd("abc  ", null)    = "abc"//LC:1912
     * StringUtils.stripEnd(" abc ", null)    = " abc"//LC:1913
     * StringUtils.stripEnd("  abcyx", "xyz") = "  abc"//LC:1914
     * StringUtils.stripEnd("120.00", ".0")   = "12"//LC:1915
     * </pre>//LC:1916
     *//LC:1917
     * @param str  the String to remove characters from, may be null//LC:1918
     * @param stripChars  the set of characters to remove, null treated as whitespace//LC:1919
     * @return the stripped String, {@code null} if null String input//LC:1920
     *///LC:1921
    public static String stripEnd(final String str, final String stripChars) {//LC:1922
        int end;//LC:1923
        if (str == null || (end = str.length()) == 0) {//LC:1924
            return str;//LC:1925
        }//LC:1926
//LC:1927
        if (stripChars == null) {//LC:1928
            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {//LC:1929
                end--;//LC:1930
            }//LC:1931
        } else if (stripChars.isEmpty()) {//LC:1932
            return str;//LC:1933
        } else {//LC:1934
            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {//LC:1935
                end--;//LC:1936
            }//LC:1937
        }//LC:1938
        return str.substring(0, end);//LC:1939
    }//LC:1940
//LC:1941
    // StripAll//LC:1942
    //-----------------------------------------------------------------------//LC:1943
    /**//LC:1944
     * <p>Strips whitespace from the start and end of every String in an array.//LC:1945
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:1946
     *//LC:1947
     * <p>A new array is returned each time, except for length zero.//LC:1948
     * A {@code null} array will return {@code null}.//LC:1949
     * An empty array will return itself.//LC:1950
     * A {@code null} array entry will be ignored.</p>//LC:1951
     *//LC:1952
     * <pre>//LC:1953
     * StringUtils.stripAll(null)             = null//LC:1954
     * StringUtils.stripAll([])               = []//LC:1955
     * StringUtils.stripAll(["abc", "  abc"]) = ["abc", "abc"]//LC:1956
     * StringUtils.stripAll(["abc  ", null])  = ["abc", null]//LC:1957
     * </pre>//LC:1958
     *//LC:1959
     * @param strs  the array to remove whitespace from, may be null//LC:1960
     * @return the stripped Strings, {@code null} if null array input//LC:1961
     *///LC:1962
    public static String[] stripAll(final String... strs) {//LC:1963
        return stripAll(strs, null);//LC:1964
    }//LC:1965
//LC:1966
    /**//LC:1967
     * <p>Strips any of a set of characters from the start and end of every//LC:1968
     * String in an array.</p>//LC:1969
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:1970
     *//LC:1971
     * <p>A new array is returned each time, except for length zero.//LC:1972
     * A {@code null} array will return {@code null}.//LC:1973
     * An empty array will return itself.//LC:1974
     * A {@code null} array entry will be ignored.//LC:1975
     * A {@code null} stripChars will strip whitespace as defined by//LC:1976
     * {@link Character#isWhitespace(char)}.</p>//LC:1977
     *//LC:1978
     * <pre>//LC:1979
     * StringUtils.stripAll(null, *)                = null//LC:1980
     * StringUtils.stripAll([], *)                  = []//LC:1981
     * StringUtils.stripAll(["abc", "  abc"], null) = ["abc", "abc"]//LC:1982
     * StringUtils.stripAll(["abc  ", null], null)  = ["abc", null]//LC:1983
     * StringUtils.stripAll(["abc  ", null], "yz")  = ["abc  ", null]//LC:1984
     * StringUtils.stripAll(["yabcz", null], "yz")  = ["abc", null]//LC:1985
     * </pre>//LC:1986
     *//LC:1987
     * @param strs  the array to remove characters from, may be null//LC:1988
     * @param stripChars  the characters to remove, null treated as whitespace//LC:1989
     * @return the stripped Strings, {@code null} if null array input//LC:1990
     *///LC:1991
    public static String[] stripAll(final String[] strs, final String stripChars) {//LC:1992
        int strsLen;//LC:1993
        if (strs == null || (strsLen = strs.length) == 0) {//LC:1994
            return strs;//LC:1995
        }//LC:1996
        final String[] newArr = new String[strsLen];//LC:1997
        for (int i = 0; i < strsLen; i++) {//LC:1998
            newArr[i] = strip(strs[i], stripChars);//LC:1999
        }//LC:2000
        return newArr;//LC:2001
    }//LC:2002
//LC:2003
    /**//LC:2004
     * <p>Removes diacritics (~= accents) from a string. The case will not be altered.</p>//LC:2005
     * <p>For instance, '&agrave;' will be replaced by 'a'.</p>//LC:2006
     * <p>Note that ligatures will be left as is.</p>//LC:2007
     *//LC:2008
     * <pre>//LC:2009
     * StringUtils.stripAccents(null)                = null//LC:2010
     * StringUtils.stripAccents("")                  = ""//LC:2011
     * StringUtils.stripAccents("control")           = "control"//LC:2012
     * StringUtils.stripAccents("&eacute;clair")     = "eclair"//LC:2013
     * </pre>//LC:2014
     *//LC:2015
     * @param input String to be stripped//LC:2016
     * @return input text with diacritics removed//LC:2017
     *//LC:2018
     * @since 3.0//LC:2019
     *///LC:2020
    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommitted bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).//LC:2021
    public static String stripAccents(final String input) {//LC:2022
        if(input == null) {//LC:2023
            return null;//LC:2024
        }//LC:2025
        final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");//$NON-NLS-1$//LC:2026
        final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);//LC:2027
        // Note that this doesn't correctly remove ligatures...//LC:2028
        return pattern.matcher(decomposed).replaceAll("");//$NON-NLS-1$//LC:2029
    }//LC:2030
//LC:2031
    // Equals//LC:2032
    //-----------------------------------------------------------------------//LC:2033
    /**//LC:2034
     * <p>Compares two CharSequences, returning {@code true} if they represent//LC:2035
     * equal sequences of characters.</p>//LC:2036
     *//LC:2037
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:2038
     * references are considered to be equal. The comparison is case sensitive.</p>//LC:2039
     *//LC:2040
     * <pre>//LC:2041
     * StringUtils.equals(null, null)   = true//LC:2042
     * StringUtils.equals(null, "abc")  = false//LC:2043
     * StringUtils.equals("abc", null)  = false//LC:2044
     * StringUtils.equals("abc", "abc") = true//LC:2045
     * StringUtils.equals("abc", "ABC") = false//LC:2046
     * </pre>//LC:2047
     *//LC:2048
     * @see Object#equals(Object)//LC:2049
     * @param cs1  the first CharSequence, may be {@code null}//LC:2050
     * @param cs2  the second CharSequence, may be {@code null}//LC:2051
     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}//LC:2052
     * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)//LC:2053
     *///LC:2054
    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {//LC:2055
        if (cs1 == cs2) {//LC:2056
            return true;//LC:2057
        }//LC:2058
        if (cs1 == null || cs2 == null) {//LC:2059
            return false;//LC:2060
        }//LC:2061
        if (cs1 instanceof String && cs2 instanceof String) {//LC:2062
            return cs1.equals(cs2);//LC:2063
        }//LC:2064
        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));//LC:2065
    }//LC:2066
//LC:2067
    /**//LC:2068
     * <p>Compares two CharSequences, returning {@code true} if they represent//LC:2069
     * equal sequences of characters, ignoring case.</p>//LC:2070
     *//LC:2071
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:2072
     * references are considered equal. Comparison is case insensitive.</p>//LC:2073
     *//LC:2074
     * <pre>//LC:2075
     * StringUtils.equalsIgnoreCase(null, null)   = true//LC:2076
     * StringUtils.equalsIgnoreCase(null, "abc")  = false//LC:2077
     * StringUtils.equalsIgnoreCase("abc", null)  = false//LC:2078
     * StringUtils.equalsIgnoreCase("abc", "abc") = true//LC:2079
     * StringUtils.equalsIgnoreCase("abc", "ABC") = true//LC:2080
     * </pre>//LC:2081
     *//LC:2082
     * @param str1  the first CharSequence, may be null//LC:2083
     * @param str2  the second CharSequence, may be null//LC:2084
     * @return {@code true} if the CharSequence are equal, case insensitive, or//LC:2085
     *  both {@code null}//LC:2086
     * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)//LC:2087
     *///LC:2088
    public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {//LC:2089
        if (str1 == null || str2 == null) {//LC:2090
            return str1 == str2;//LC:2091
        } else if (str1 == str2) {//LC:2092
            return true;//LC:2093
        } else if (str1.length() != str2.length()) {//LC:2094
            return false;//LC:2095
        } else {//LC:2096
            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());//LC:2097
        }//LC:2098
    }//LC:2099
//LC:2100
    // IndexOf//LC:2101
    //-----------------------------------------------------------------------//LC:2102
    /**//LC:2103
     * <p>Finds the first index within a CharSequence, handling {@code null}.//LC:2104
     * This method uses {@link String#indexOf(int, int)} if possible.</p>//LC:2105
     *//LC:2106
     * <p>A {@code null} or empty ("") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>//LC:2107
     *//LC:2108
     * <pre>//LC:2109
     * StringUtils.indexOf(null, *)         = -1//LC:2110
     * StringUtils.indexOf("", *)           = -1//LC:2111
     * StringUtils.indexOf("aabaabaa", 'a') = 0//LC:2112
     * StringUtils.indexOf("aabaabaa", 'b') = 2//LC:2113
     * </pre>//LC:2114
     *//LC:2115
     * @param seq  the CharSequence to check, may be null//LC:2116
     * @param searchChar  the character to find//LC:2117
     * @return the first index of the search character,//LC:2118
     *  -1 if no match or {@code null} string input//LC:2119
     * @since 2.0//LC:2120
     * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)//LC:2121
     *///LC:2122
    public static int indexOf(final CharSequence seq, final int searchChar) {//LC:2123
        if (isEmpty(seq)) {//LC:2124
            return INDEX_NOT_FOUND;//LC:2125
        }//LC:2126
        return CharSequenceUtils.indexOf(seq, searchChar, 0);//LC:2127
    }//LC:2128
//LC:2129
    /**//LC:2130
     * <p>Finds the first index within a CharSequence from a start position,//LC:2131
     * handling {@code null}.//LC:2132
     * This method uses {@link String#indexOf(int, int)} if possible.</p>//LC:2133
     *//LC:2134
     * <p>A {@code null} or empty ("") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.//LC:2135
     * A negative start position is treated as zero.//LC:2136
     * A start position greater than the string length returns {@code -1}.</p>//LC:2137
     *//LC:2138
     * <pre>//LC:2139
     * StringUtils.indexOf(null, *, *)          = -1//LC:2140
     * StringUtils.indexOf("", *, *)            = -1//LC:2141
     * StringUtils.indexOf("aabaabaa", 'b', 0)  = 2//LC:2142
     * StringUtils.indexOf("aabaabaa", 'b', 3)  = 5//LC:2143
     * StringUtils.indexOf("aabaabaa", 'b', 9)  = -1//LC:2144
     * StringUtils.indexOf("aabaabaa", 'b', -1) = 2//LC:2145
     * </pre>//LC:2146
     *//LC:2147
     * @param seq  the CharSequence to check, may be null//LC:2148
     * @param searchChar  the character to find//LC:2149
     * @param startPos  the start position, negative treated as zero//LC:2150
     * @return the first index of the search character (always &ge; startPos),//LC:2151
     *  -1 if no match or {@code null} string input//LC:2152
     * @since 2.0//LC:2153
     * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)//LC:2154
     *///LC:2155
    public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) {//LC:2156
        if (isEmpty(seq)) {//LC:2157
            return INDEX_NOT_FOUND;//LC:2158
        }//LC:2159
        return CharSequenceUtils.indexOf(seq, searchChar, startPos);//LC:2160
    }//LC:2161
//LC:2162
    /**//LC:2163
     * <p>Finds the first index within a CharSequence, handling {@code null}.//LC:2164
     * This method uses {@link String#indexOf(String, int)} if possible.</p>//LC:2165
     *//LC:2166
     * <p>A {@code null} CharSequence will return {@code -1}.</p>//LC:2167
     *//LC:2168
     * <pre>//LC:2169
     * StringUtils.indexOf(null, *)          = -1//LC:2170
     * StringUtils.indexOf(*, null)          = -1//LC:2171
     * StringUtils.indexOf("", "")           = 0//LC:2172
     * StringUtils.indexOf("", *)            = -1 (except when * = "")//LC:2173
     * StringUtils.indexOf("aabaabaa", "a")  = 0//LC:2174
     * StringUtils.indexOf("aabaabaa", "b")  = 2//LC:2175
     * StringUtils.indexOf("aabaabaa", "ab") = 1//LC:2176
     * StringUtils.indexOf("aabaabaa", "")   = 0//LC:2177
     * </pre>//LC:2178
     *//LC:2179
     * @param seq  the CharSequence to check, may be null//LC:2180
     * @param searchSeq  the CharSequence to find, may be null//LC:2181
     * @return the first index of the search CharSequence,//LC:2182
     *  -1 if no match or {@code null} string input//LC:2183
     * @since 2.0//LC:2184
     * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)//LC:2185
     *///LC:2186
    public static int indexOf(final CharSequence seq, final CharSequence searchSeq) {//LC:2187
        if (seq == null || searchSeq == null) {//LC:2188
            return INDEX_NOT_FOUND;//LC:2189
        }//LC:2190
        return CharSequenceUtils.indexOf(seq, searchSeq, 0);//LC:2191
    }//LC:2192
//LC:2193
    /**//LC:2194
     * <p>Finds the first index within a CharSequence, handling {@code null}.//LC:2195
     * This method uses {@link String#indexOf(String, int)} if possible.</p>//LC:2196
     *//LC:2197
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2198
     * A negative start position is treated as zero.//LC:2199
     * An empty ("") search CharSequence always matches.//LC:2200
     * A start position greater than the string length only matches//LC:2201
     * an empty search CharSequence.</p>//LC:2202
     *//LC:2203
     * <pre>//LC:2204
     * StringUtils.indexOf(null, *, *)          = -1//LC:2205
     * StringUtils.indexOf(*, null, *)          = -1//LC:2206
     * StringUtils.indexOf("", "", 0)           = 0//LC:2207
     * StringUtils.indexOf("", *, 0)            = -1 (except when * = "")//LC:2208
     * StringUtils.indexOf("aabaabaa", "a", 0)  = 0//LC:2209
     * StringUtils.indexOf("aabaabaa", "b", 0)  = 2//LC:2210
     * StringUtils.indexOf("aabaabaa", "ab", 0) = 1//LC:2211
     * StringUtils.indexOf("aabaabaa", "b", 3)  = 5//LC:2212
     * StringUtils.indexOf("aabaabaa", "b", 9)  = -1//LC:2213
     * StringUtils.indexOf("aabaabaa", "b", -1) = 2//LC:2214
     * StringUtils.indexOf("aabaabaa", "", 2)   = 2//LC:2215
     * StringUtils.indexOf("abc", "", 9)        = 3//LC:2216
     * </pre>//LC:2217
     *//LC:2218
     * @param seq  the CharSequence to check, may be null//LC:2219
     * @param searchSeq  the CharSequence to find, may be null//LC:2220
     * @param startPos  the start position, negative treated as zero//LC:2221
     * @return the first index of the search CharSequence (always &ge; startPos),//LC:2222
     *  -1 if no match or {@code null} string input//LC:2223
     * @since 2.0//LC:2224
     * @since 3.0 Changed signature from indexOf(String, String, int) to indexOf(CharSequence, CharSequence, int)//LC:2225
     *///LC:2226
    public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {//LC:2227
        if (seq == null || searchSeq == null) {//LC:2228
            return INDEX_NOT_FOUND;//LC:2229
        }//LC:2230
        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);//LC:2231
    }//LC:2232
//LC:2233
    /**//LC:2234
     * <p>Finds the n-th index within a CharSequence, handling {@code null}.//LC:2235
     * This method uses {@link String#indexOf(String)} if possible.</p>//LC:2236
     *//LC:2237
     * <p>A {@code null} CharSequence will return {@code -1}.</p>//LC:2238
     *//LC:2239
     * <pre>//LC:2240
     * StringUtils.ordinalIndexOf(null, *, *)          = -1//LC:2241
     * StringUtils.ordinalIndexOf(*, null, *)          = -1//LC:2242
     * StringUtils.ordinalIndexOf("", "", *)           = 0//LC:2243
     * StringUtils.ordinalIndexOf("aabaabaa", "a", 1)  = 0//LC:2244
     * StringUtils.ordinalIndexOf("aabaabaa", "a", 2)  = 1//LC:2245
     * StringUtils.ordinalIndexOf("aabaabaa", "b", 1)  = 2//LC:2246
     * StringUtils.ordinalIndexOf("aabaabaa", "b", 2)  = 5//LC:2247
     * StringUtils.ordinalIndexOf("aabaabaa", "ab", 1) = 1//LC:2248
     * StringUtils.ordinalIndexOf("aabaabaa", "ab", 2) = 4//LC:2249
     * StringUtils.ordinalIndexOf("aabaabaa", "", 1)   = 0//LC:2250
     * StringUtils.ordinalIndexOf("aabaabaa", "", 2)   = 0//LC:2251
     * </pre>//LC:2252
     *//LC:2253
     * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>//LC:2254
     *//LC:2255
     * <pre>//LC:2256
     *   str.substring(0, lastOrdinalIndexOf(str, "\n", n))//LC:2257
     * </pre>//LC:2258
     *//LC:2259
     * @param str  the CharSequence to check, may be null//LC:2260
     * @param searchStr  the CharSequence to find, may be null//LC:2261
     * @param ordinal  the n-th {@code searchStr} to find//LC:2262
     * @return the n-th index of the search CharSequence,//LC:2263
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input//LC:2264
     * @since 2.1//LC:2265
     * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)//LC:2266
     *///LC:2267
    public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {//LC:2268
        return ordinalIndexOf(str, searchStr, ordinal, false);//LC:2269
    }//LC:2270
//LC:2271
    /**//LC:2272
     * <p>Finds the n-th index within a String, handling {@code null}.//LC:2273
     * This method uses {@link String#indexOf(String)} if possible.</p>//LC:2274
     *//LC:2275
     * <p>A {@code null} CharSequence will return {@code -1}.</p>//LC:2276
     *//LC:2277
     * @param str  the CharSequence to check, may be null//LC:2278
     * @param searchStr  the CharSequence to find, may be null//LC:2279
     * @param ordinal  the n-th {@code searchStr} to find//LC:2280
     * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()//LC:2281
     * @return the n-th index of the search CharSequence,//LC:2282
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input//LC:2283
     *///LC:2284
    // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)//LC:2285
    private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {//LC:2286
        if (str == null || searchStr == null || ordinal <= 0) {//LC:2287
            return INDEX_NOT_FOUND;//LC:2288
        }//LC:2289
        if (searchStr.length() == 0) {//LC:2290
            return lastIndex ? str.length() : 0;//LC:2291
        }//LC:2292
        int found = 0;//LC:2293
        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;//LC:2294
        do {//LC:2295
            if (lastIndex) {//LC:2296
                index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);//LC:2297
            } else {//LC:2298
                index = CharSequenceUtils.indexOf(str, searchStr, index + 1);//LC:2299
            }//LC:2300
            if (index < 0) {//LC:2301
                return index;//LC:2302
            }//LC:2303
            found++;//LC:2304
        } while (found < ordinal);//LC:2305
        return index;//LC:2306
    }//LC:2307
//LC:2308
    /**//LC:2309
     * <p>Case in-sensitive find of the first index within a CharSequence.</p>//LC:2310
     *//LC:2311
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2312
     * A negative start position is treated as zero.//LC:2313
     * An empty ("") search CharSequence always matches.//LC:2314
     * A start position greater than the string length only matches//LC:2315
     * an empty search CharSequence.</p>//LC:2316
     *//LC:2317
     * <pre>//LC:2318
     * StringUtils.indexOfIgnoreCase(null, *)          = -1//LC:2319
     * StringUtils.indexOfIgnoreCase(*, null)          = -1//LC:2320
     * StringUtils.indexOfIgnoreCase("", "")           = 0//LC:2321
     * StringUtils.indexOfIgnoreCase("aabaabaa", "a")  = 0//LC:2322
     * StringUtils.indexOfIgnoreCase("aabaabaa", "b")  = 2//LC:2323
     * StringUtils.indexOfIgnoreCase("aabaabaa", "ab") = 1//LC:2324
     * </pre>//LC:2325
     *//LC:2326
     * @param str  the CharSequence to check, may be null//LC:2327
     * @param searchStr  the CharSequence to find, may be null//LC:2328
     * @return the first index of the search CharSequence,//LC:2329
     *  -1 if no match or {@code null} string input//LC:2330
     * @since 2.5//LC:2331
     * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)//LC:2332
     *///LC:2333
    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {//LC:2334
        return indexOfIgnoreCase(str, searchStr, 0);//LC:2335
    }//LC:2336
//LC:2337
    /**//LC:2338
     * <p>Case in-sensitive find of the first index within a CharSequence//LC:2339
     * from the specified position.</p>//LC:2340
     *//LC:2341
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2342
     * A negative start position is treated as zero.//LC:2343
     * An empty ("") search CharSequence always matches.//LC:2344
     * A start position greater than the string length only matches//LC:2345
     * an empty search CharSequence.</p>//LC:2346
     *//LC:2347
     * <pre>//LC:2348
     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1//LC:2349
     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1//LC:2350
     * StringUtils.indexOfIgnoreCase("", "", 0)           = 0//LC:2351
     * StringUtils.indexOfIgnoreCase("aabaabaa", "A", 0)  = 0//LC:2352
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 0)  = 2//LC:2353
     * StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0) = 1//LC:2354
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 3)  = 5//LC:2355
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", 9)  = -1//LC:2356
     * StringUtils.indexOfIgnoreCase("aabaabaa", "B", -1) = 2//LC:2357
     * StringUtils.indexOfIgnoreCase("aabaabaa", "", 2)   = 2//LC:2358
     * StringUtils.indexOfIgnoreCase("abc", "", 9)        = 3//LC:2359
     * </pre>//LC:2360
     *//LC:2361
     * @param str  the CharSequence to check, may be null//LC:2362
     * @param searchStr  the CharSequence to find, may be null//LC:2363
     * @param startPos  the start position, negative treated as zero//LC:2364
     * @return the first index of the search CharSequence (always &ge; startPos),//LC:2365
     *  -1 if no match or {@code null} string input//LC:2366
     * @since 2.5//LC:2367
     * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)//LC:2368
     *///LC:2369
    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {//LC:2370
        if (str == null || searchStr == null) {//LC:2371
            return INDEX_NOT_FOUND;//LC:2372
        }//LC:2373
        if (startPos < 0) {//LC:2374
            startPos = 0;//LC:2375
        }//LC:2376
        final int endLimit = str.length() - searchStr.length() + 1;//LC:2377
        if (startPos > endLimit) {//LC:2378
            return INDEX_NOT_FOUND;//LC:2379
        }//LC:2380
        if (searchStr.length() == 0) {//LC:2381
            return startPos;//LC:2382
        }//LC:2383
        for (int i = startPos; i < endLimit; i++) {//LC:2384
            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {//LC:2385
                return i;//LC:2386
            }//LC:2387
        }//LC:2388
        return INDEX_NOT_FOUND;//LC:2389
    }//LC:2390
//LC:2391
    // LastIndexOf//LC:2392
    //-----------------------------------------------------------------------//LC:2393
    /**//LC:2394
     * <p>Finds the last index within a CharSequence, handling {@code null}.//LC:2395
     * This method uses {@link String#lastIndexOf(int)} if possible.</p>//LC:2396
     *//LC:2397
     * <p>A {@code null} or empty ("") CharSequence will return {@code -1}.</p>//LC:2398
     *//LC:2399
     * <pre>//LC:2400
     * StringUtils.lastIndexOf(null, *)         = -1//LC:2401
     * StringUtils.lastIndexOf("", *)           = -1//LC:2402
     * StringUtils.lastIndexOf("aabaabaa", 'a') = 7//LC:2403
     * StringUtils.lastIndexOf("aabaabaa", 'b') = 5//LC:2404
     * </pre>//LC:2405
     *//LC:2406
     * @param seq  the CharSequence to check, may be null//LC:2407
     * @param searchChar  the character to find//LC:2408
     * @return the last index of the search character,//LC:2409
     *  -1 if no match or {@code null} string input//LC:2410
     * @since 2.0//LC:2411
     * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)//LC:2412
     *///LC:2413
    public static int lastIndexOf(final CharSequence seq, final int searchChar) {//LC:2414
        if (isEmpty(seq)) {//LC:2415
            return INDEX_NOT_FOUND;//LC:2416
        }//LC:2417
        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());//LC:2418
    }//LC:2419
//LC:2420
    /**//LC:2421
     * <p>Finds the last index within a CharSequence from a start position,//LC:2422
     * handling {@code null}.//LC:2423
     * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>//LC:2424
     *//LC:2425
     * <p>A {@code null} or empty ("") CharSequence will return {@code -1}.//LC:2426
     * A negative start position returns {@code -1}.//LC:2427
     * A start position greater than the string length searches the whole string.//LC:2428
     * The search starts at the startPos and works backwards; matches starting after the start//LC:2429
     * position are ignored.//LC:2430
     * </p>//LC:2431
     *//LC:2432
     * <pre>//LC:2433
     * StringUtils.lastIndexOf(null, *, *)          = -1//LC:2434
     * StringUtils.lastIndexOf("", *,  *)           = -1//LC:2435
     * StringUtils.lastIndexOf("aabaabaa", 'b', 8)  = 5//LC:2436
     * StringUtils.lastIndexOf("aabaabaa", 'b', 4)  = 2//LC:2437
     * StringUtils.lastIndexOf("aabaabaa", 'b', 0)  = -1//LC:2438
     * StringUtils.lastIndexOf("aabaabaa", 'b', 9)  = 5//LC:2439
     * StringUtils.lastIndexOf("aabaabaa", 'b', -1) = -1//LC:2440
     * StringUtils.lastIndexOf("aabaabaa", 'a', 0)  = 0//LC:2441
     * </pre>//LC:2442
     *//LC:2443
     * @param seq  the CharSequence to check, may be null//LC:2444
     * @param searchChar  the character to find//LC:2445
     * @param startPos  the start position//LC:2446
     * @return the last index of the search character (always &le; startPos),//LC:2447
     *  -1 if no match or {@code null} string input//LC:2448
     * @since 2.0//LC:2449
     * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)//LC:2450
     *///LC:2451
    public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) {//LC:2452
        if (isEmpty(seq)) {//LC:2453
            return INDEX_NOT_FOUND;//LC:2454
        }//LC:2455
        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);//LC:2456
    }//LC:2457
//LC:2458
    /**//LC:2459
     * <p>Finds the last index within a CharSequence, handling {@code null}.//LC:2460
     * This method uses {@link String#lastIndexOf(String)} if possible.</p>//LC:2461
     *//LC:2462
     * <p>A {@code null} CharSequence will return {@code -1}.</p>//LC:2463
     *//LC:2464
     * <pre>//LC:2465
     * StringUtils.lastIndexOf(null, *)          = -1//LC:2466
     * StringUtils.lastIndexOf(*, null)          = -1//LC:2467
     * StringUtils.lastIndexOf("", "")           = 0//LC:2468
     * StringUtils.lastIndexOf("aabaabaa", "a")  = 7//LC:2469
     * StringUtils.lastIndexOf("aabaabaa", "b")  = 5//LC:2470
     * StringUtils.lastIndexOf("aabaabaa", "ab") = 4//LC:2471
     * StringUtils.lastIndexOf("aabaabaa", "")   = 8//LC:2472
     * </pre>//LC:2473
     *//LC:2474
     * @param seq  the CharSequence to check, may be null//LC:2475
     * @param searchSeq  the CharSequence to find, may be null//LC:2476
     * @return the last index of the search String,//LC:2477
     *  -1 if no match or {@code null} string input//LC:2478
     * @since 2.0//LC:2479
     * @since 3.0 Changed signature from lastIndexOf(String, String) to lastIndexOf(CharSequence, CharSequence)//LC:2480
     *///LC:2481
    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq) {//LC:2482
        if (seq == null || searchSeq == null) {//LC:2483
            return INDEX_NOT_FOUND;//LC:2484
        }//LC:2485
        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());//LC:2486
    }//LC:2487
//LC:2488
    /**//LC:2489
     * <p>Finds the n-th last index within a String, handling {@code null}.//LC:2490
     * This method uses {@link String#lastIndexOf(String)}.</p>//LC:2491
     *//LC:2492
     * <p>A {@code null} String will return {@code -1}.</p>//LC:2493
     *//LC:2494
     * <pre>//LC:2495
     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1//LC:2496
     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1//LC:2497
     * StringUtils.lastOrdinalIndexOf("", "", *)           = 0//LC:2498
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 1)  = 7//LC:2499
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 2)  = 6//LC:2500
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 1)  = 5//LC:2501
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 2)  = 2//LC:2502
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 1) = 4//LC:2503
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 2) = 1//LC:2504
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "", 1)   = 8//LC:2505
     * StringUtils.lastOrdinalIndexOf("aabaabaa", "", 2)   = 8//LC:2506
     * </pre>//LC:2507
     *//LC:2508
     * <p>Note that 'tail(CharSequence str, int n)' may be implemented as: </p>//LC:2509
     *//LC:2510
     * <pre>//LC:2511
     *   str.substring(lastOrdinalIndexOf(str, "\n", n) + 1)//LC:2512
     * </pre>//LC:2513
     *//LC:2514
     * @param str  the CharSequence to check, may be null//LC:2515
     * @param searchStr  the CharSequence to find, may be null//LC:2516
     * @param ordinal  the n-th last {@code searchStr} to find//LC:2517
     * @return the n-th last index of the search CharSequence,//LC:2518
     *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input//LC:2519
     * @since 2.5//LC:2520
     * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)//LC:2521
     *///LC:2522
    public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {//LC:2523
        return ordinalIndexOf(str, searchStr, ordinal, true);//LC:2524
    }//LC:2525
//LC:2526
    /**//LC:2527
     * <p>Finds the last index within a CharSequence, handling {@code null}.//LC:2528
     * This method uses {@link String#lastIndexOf(String, int)} if possible.</p>//LC:2529
     *//LC:2530
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2531
     * A negative start position returns {@code -1}.//LC:2532
     * An empty ("") search CharSequence always matches unless the start position is negative.//LC:2533
     * A start position greater than the string length searches the whole string.//LC:2534
     * The search starts at the startPos and works backwards; matches starting after the start//LC:2535
     * position are ignored.//LC:2536
     * </p>//LC:2537
     *//LC:2538
     * <pre>//LC:2539
     * StringUtils.lastIndexOf(null, *, *)          = -1//LC:2540
     * StringUtils.lastIndexOf(*, null, *)          = -1//LC:2541
     * StringUtils.lastIndexOf("aabaabaa", "a", 8)  = 7//LC:2542
     * StringUtils.lastIndexOf("aabaabaa", "b", 8)  = 5//LC:2543
     * StringUtils.lastIndexOf("aabaabaa", "ab", 8) = 4//LC:2544
     * StringUtils.lastIndexOf("aabaabaa", "b", 9)  = 5//LC:2545
     * StringUtils.lastIndexOf("aabaabaa", "b", -1) = -1//LC:2546
     * StringUtils.lastIndexOf("aabaabaa", "a", 0)  = 0//LC:2547
     * StringUtils.lastIndexOf("aabaabaa", "b", 0)  = -1//LC:2548
     * StringUtils.lastIndexOf("aabaabaa", "b", 1)  = -1//LC:2549
     * StringUtils.lastIndexOf("aabaabaa", "b", 2)  = 2//LC:2550
     * StringUtils.lastIndexOf("aabaabaa", "ba", 2)  = -1//LC:2551
     * StringUtils.lastIndexOf("aabaabaa", "ba", 2)  = 2//LC:2552
     * </pre>//LC:2553
     *//LC:2554
     * @param seq  the CharSequence to check, may be null//LC:2555
     * @param searchSeq  the CharSequence to find, may be null//LC:2556
     * @param startPos  the start position, negative treated as zero//LC:2557
     * @return the last index of the search CharSequence (always &le; startPos),//LC:2558
     *  -1 if no match or {@code null} string input//LC:2559
     * @since 2.0//LC:2560
     * @since 3.0 Changed signature from lastIndexOf(String, String, int) to lastIndexOf(CharSequence, CharSequence, int)//LC:2561
     *///LC:2562
    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {//LC:2563
        if (seq == null || searchSeq == null) {//LC:2564
            return INDEX_NOT_FOUND;//LC:2565
        }//LC:2566
        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);//LC:2567
    }//LC:2568
//LC:2569
    /**//LC:2570
     * <p>Case in-sensitive find of the last index within a CharSequence.</p>//LC:2571
     *//LC:2572
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2573
     * A negative start position returns {@code -1}.//LC:2574
     * An empty ("") search CharSequence always matches unless the start position is negative.//LC:2575
     * A start position greater than the string length searches the whole string.</p>//LC:2576
     *//LC:2577
     * <pre>//LC:2578
     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1//LC:2579
     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1//LC:2580
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A")  = 7//LC:2581
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B")  = 5//LC:2582
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB") = 4//LC:2583
     * </pre>//LC:2584
     *//LC:2585
     * @param str  the CharSequence to check, may be null//LC:2586
     * @param searchStr  the CharSequence to find, may be null//LC:2587
     * @return the first index of the search CharSequence,//LC:2588
     *  -1 if no match or {@code null} string input//LC:2589
     * @since 2.5//LC:2590
     * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)//LC:2591
     *///LC:2592
    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {//LC:2593
        if (str == null || searchStr == null) {//LC:2594
            return INDEX_NOT_FOUND;//LC:2595
        }//LC:2596
        return lastIndexOfIgnoreCase(str, searchStr, str.length());//LC:2597
    }//LC:2598
//LC:2599
    /**//LC:2600
     * <p>Case in-sensitive find of the last index within a CharSequence//LC:2601
     * from the specified position.</p>//LC:2602
     *//LC:2603
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2604
     * A negative start position returns {@code -1}.//LC:2605
     * An empty ("") search CharSequence always matches unless the start position is negative.//LC:2606
     * A start position greater than the string length searches the whole string.//LC:2607
     * The search starts at the startPos and works backwards; matches starting after the start//LC:2608
     * position are ignored.//LC:2609
     * </p>//LC:2610
     *//LC:2611
     * <pre>//LC:2612
     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1//LC:2613
     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1//LC:2614
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8)  = 7//LC:2615
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 8)  = 5//LC:2616
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB", 8) = 4//LC:2617
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 9)  = 5//LC:2618
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", -1) = -1//LC:2619
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 0)  = 0//LC:2620
     * StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 0)  = -1//LC:2621
     * </pre>//LC:2622
     *//LC:2623
     * @param str  the CharSequence to check, may be null//LC:2624
     * @param searchStr  the CharSequence to find, may be null//LC:2625
     * @param startPos  the start position//LC:2626
     * @return the last index of the search CharSequence (always &le; startPos),//LC:2627
     *  -1 if no match or {@code null} input//LC:2628
     * @since 2.5//LC:2629
     * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)//LC:2630
     *///LC:2631
    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {//LC:2632
        if (str == null || searchStr == null) {//LC:2633
            return INDEX_NOT_FOUND;//LC:2634
        }//LC:2635
        if (startPos > str.length() - searchStr.length()) {//LC:2636
            startPos = str.length() - searchStr.length();//LC:2637
        }//LC:2638
        if (startPos < 0) {//LC:2639
            return INDEX_NOT_FOUND;//LC:2640
        }//LC:2641
        if (searchStr.length() == 0) {//LC:2642
            return startPos;//LC:2643
        }//LC:2644
//LC:2645
        for (int i = startPos; i >= 0; i--) {//LC:2646
            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {//LC:2647
                return i;//LC:2648
            }//LC:2649
        }//LC:2650
        return INDEX_NOT_FOUND;//LC:2651
    }//LC:2652
//LC:2653
    // Contains//LC:2654
    //-----------------------------------------------------------------------//LC:2655
    /**//LC:2656
     * <p>Checks if CharSequence contains a search character, handling {@code null}.//LC:2657
     * This method uses {@link String#indexOf(int)} if possible.</p>//LC:2658
     *//LC:2659
     * <p>A {@code null} or empty ("") CharSequence will return {@code false}.</p>//LC:2660
     *//LC:2661
     * <pre>//LC:2662
     * StringUtils.contains(null, *)    = false//LC:2663
     * StringUtils.contains("", *)      = false//LC:2664
     * StringUtils.contains("abc", 'a') = true//LC:2665
     * StringUtils.contains("abc", 'z') = false//LC:2666
     * </pre>//LC:2667
     *//LC:2668
     * @param seq  the CharSequence to check, may be null//LC:2669
     * @param searchChar  the character to find//LC:2670
     * @return true if the CharSequence contains the search character,//LC:2671
     *  false if not or {@code null} string input//LC:2672
     * @since 2.0//LC:2673
     * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)//LC:2674
     *///LC:2675
    public static boolean contains(final CharSequence seq, final int searchChar) {//LC:2676
        if (isEmpty(seq)) {//LC:2677
            return false;//LC:2678
        }//LC:2679
        return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;//LC:2680
    }//LC:2681
//LC:2682
    /**//LC:2683
     * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.//LC:2684
     * This method uses {@link String#indexOf(String)} if possible.</p>//LC:2685
     *//LC:2686
     * <p>A {@code null} CharSequence will return {@code false}.</p>//LC:2687
     *//LC:2688
     * <pre>//LC:2689
     * StringUtils.contains(null, *)     = false//LC:2690
     * StringUtils.contains(*, null)     = false//LC:2691
     * StringUtils.contains("", "")      = true//LC:2692
     * StringUtils.contains("abc", "")   = true//LC:2693
     * StringUtils.contains("abc", "a")  = true//LC:2694
     * StringUtils.contains("abc", "z")  = false//LC:2695
     * </pre>//LC:2696
     *//LC:2697
     * @param seq  the CharSequence to check, may be null//LC:2698
     * @param searchSeq  the CharSequence to find, may be null//LC:2699
     * @return true if the CharSequence contains the search CharSequence,//LC:2700
     *  false if not or {@code null} string input//LC:2701
     * @since 2.0//LC:2702
     * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)//LC:2703
     *///LC:2704
    public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {//LC:2705
        if (seq == null || searchSeq == null) {//LC:2706
            return false;//LC:2707
        }//LC:2708
        return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;//LC:2709
    }//LC:2710
//LC:2711
    /**//LC:2712
     * <p>Checks if CharSequence contains a search CharSequence irrespective of case,//LC:2713
     * handling {@code null}. Case-insensitivity is defined as by//LC:2714
     * {@link String#equalsIgnoreCase(String)}.//LC:2715
     *//LC:2716
     * <p>A {@code null} CharSequence will return {@code false}.</p>//LC:2717
     *//LC:2718
     * <pre>//LC:2719
     * StringUtils.contains(null, *) = false//LC:2720
     * StringUtils.contains(*, null) = false//LC:2721
     * StringUtils.contains("", "") = true//LC:2722
     * StringUtils.contains("abc", "") = true//LC:2723
     * StringUtils.contains("abc", "a") = true//LC:2724
     * StringUtils.contains("abc", "z") = false//LC:2725
     * StringUtils.contains("abc", "A") = true//LC:2726
     * StringUtils.contains("abc", "Z") = false//LC:2727
     * </pre>//LC:2728
     *//LC:2729
     * @param str  the CharSequence to check, may be null//LC:2730
     * @param searchStr  the CharSequence to find, may be null//LC:2731
     * @return true if the CharSequence contains the search CharSequence irrespective of//LC:2732
     * case or false if not or {@code null} string input//LC:2733
     * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)//LC:2734
     *///LC:2735
    public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {//LC:2736
        if (str == null || searchStr == null) {//LC:2737
            return false;//LC:2738
        }//LC:2739
        final int len = searchStr.length();//LC:2740
        final int max = str.length() - len;//LC:2741
        for (int i = 0; i <= max; i++) {//LC:2742
            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {//LC:2743
                return true;//LC:2744
            }//LC:2745
        }//LC:2746
        return false;//LC:2747
    }//LC:2748
//LC:2749
    /**//LC:2750
     * Check whether the given CharSequence contains any whitespace characters.//LC:2751
     * @param seq the CharSequence to check (may be {@code null})//LC:2752
     * @return {@code true} if the CharSequence is not empty and//LC:2753
     * contains at least 1 whitespace character//LC:2754
     * @see Character#isWhitespace//LC:2755
     * @since 3.0//LC:2756
     *///LC:2757
    // From org.springframework.util.StringUtils, under Apache License 2.0//LC:2758
    public static boolean containsWhitespace(final CharSequence seq) {//LC:2759
        if (isEmpty(seq)) {//LC:2760
            return false;//LC:2761
        }//LC:2762
        final int strLen = seq.length();//LC:2763
        for (int i = 0; i < strLen; i++) {//LC:2764
            if (Character.isWhitespace(seq.charAt(i))) {//LC:2765
                return true;//LC:2766
            }//LC:2767
        }//LC:2768
        return false;//LC:2769
    }//LC:2770
//LC:2771
    // IndexOfAny chars//LC:2772
    //-----------------------------------------------------------------------//LC:2773
    /**//LC:2774
     * <p>Search a CharSequence to find the first index of any//LC:2775
     * character in the given set of characters.</p>//LC:2776
     *//LC:2777
     * <p>A {@code null} String will return {@code -1}.//LC:2778
     * A {@code null} or zero length search array will return {@code -1}.</p>//LC:2779
     *//LC:2780
     * <pre>//LC:2781
     * StringUtils.indexOfAny(null, *)                = -1//LC:2782
     * StringUtils.indexOfAny("", *)                  = -1//LC:2783
     * StringUtils.indexOfAny(*, null)                = -1//LC:2784
     * StringUtils.indexOfAny(*, [])                  = -1//LC:2785
     * StringUtils.indexOfAny("zzabyycdxx",['z','a']) = 0//LC:2786
     * StringUtils.indexOfAny("zzabyycdxx",['b','y']) = 3//LC:2787
     * StringUtils.indexOfAny("aba", ['z'])           = -1//LC:2788
     * </pre>//LC:2789
     *//LC:2790
     * @param cs  the CharSequence to check, may be null//LC:2791
     * @param searchChars  the chars to search for, may be null//LC:2792
     * @return the index of any of the chars, -1 if no match or null input//LC:2793
     * @since 2.0//LC:2794
     * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)//LC:2795
     *///LC:2796
    public static int indexOfAny(final CharSequence cs, final char... searchChars) {//LC:2797
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {//LC:2798
            return INDEX_NOT_FOUND;//LC:2799
        }//LC:2800
        final int csLen = cs.length();//LC:2801
        final int csLast = csLen - 1;//LC:2802
        final int searchLen = searchChars.length;//LC:2803
        final int searchLast = searchLen - 1;//LC:2804
        for (int i = 0; i < csLen; i++) {//LC:2805
            final char ch = cs.charAt(i);//LC:2806
            for (int j = 0; j < searchLen; j++) {//LC:2807
                if (searchChars[j] == ch) {//LC:2808
                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {//LC:2809
                        // ch is a supplementary character//LC:2810
                        if (searchChars[j + 1] == cs.charAt(i + 1)) {//LC:2811
                            return i;//LC:2812
                        }//LC:2813
                    } else {//LC:2814
                        return i;//LC:2815
                    }//LC:2816
                }//LC:2817
            }//LC:2818
        }//LC:2819
        return INDEX_NOT_FOUND;//LC:2820
    }//LC:2821
//LC:2822
    /**//LC:2823
     * <p>Search a CharSequence to find the first index of any//LC:2824
     * character in the given set of characters.</p>//LC:2825
     *//LC:2826
     * <p>A {@code null} String will return {@code -1}.//LC:2827
     * A {@code null} search string will return {@code -1}.</p>//LC:2828
     *//LC:2829
     * <pre>//LC:2830
     * StringUtils.indexOfAny(null, *)            = -1//LC:2831
     * StringUtils.indexOfAny("", *)              = -1//LC:2832
     * StringUtils.indexOfAny(*, null)            = -1//LC:2833
     * StringUtils.indexOfAny(*, "")              = -1//LC:2834
     * StringUtils.indexOfAny("zzabyycdxx", "za") = 0//LC:2835
     * StringUtils.indexOfAny("zzabyycdxx", "by") = 3//LC:2836
     * StringUtils.indexOfAny("aba","z")          = -1//LC:2837
     * </pre>//LC:2838
     *//LC:2839
     * @param cs  the CharSequence to check, may be null//LC:2840
     * @param searchChars  the chars to search for, may be null//LC:2841
     * @return the index of any of the chars, -1 if no match or null input//LC:2842
     * @since 2.0//LC:2843
     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)//LC:2844
     *///LC:2845
    public static int indexOfAny(final CharSequence cs, final String searchChars) {//LC:2846
        if (isEmpty(cs) || isEmpty(searchChars)) {//LC:2847
            return INDEX_NOT_FOUND;//LC:2848
        }//LC:2849
        return indexOfAny(cs, searchChars.toCharArray());//LC:2850
    }//LC:2851
//LC:2852
    // ContainsAny//LC:2853
    //-----------------------------------------------------------------------//LC:2854
    /**//LC:2855
     * <p>Checks if the CharSequence contains any character in the given//LC:2856
     * set of characters.</p>//LC:2857
     *//LC:2858
     * <p>A {@code null} CharSequence will return {@code false}.//LC:2859
     * A {@code null} or zero length search array will return {@code false}.</p>//LC:2860
     *//LC:2861
     * <pre>//LC:2862
     * StringUtils.containsAny(null, *)                = false//LC:2863
     * StringUtils.containsAny("", *)                  = false//LC:2864
     * StringUtils.containsAny(*, null)                = false//LC:2865
     * StringUtils.containsAny(*, [])                  = false//LC:2866
     * StringUtils.containsAny("zzabyycdxx",['z','a']) = true//LC:2867
     * StringUtils.containsAny("zzabyycdxx",['b','y']) = true//LC:2868
     * StringUtils.containsAny("aba", ['z'])           = false//LC:2869
     * </pre>//LC:2870
     *//LC:2871
     * @param cs  the CharSequence to check, may be null//LC:2872
     * @param searchChars  the chars to search for, may be null//LC:2873
     * @return the {@code true} if any of the chars are found,//LC:2874
     * {@code false} if no match or null input//LC:2875
     * @since 2.4//LC:2876
     * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)//LC:2877
     *///LC:2878
    public static boolean containsAny(final CharSequence cs, final char... searchChars) {//LC:2879
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {//LC:2880
            return false;//LC:2881
        }//LC:2882
        final int csLength = cs.length();//LC:2883
        final int searchLength = searchChars.length;//LC:2884
        final int csLast = csLength - 1;//LC:2885
        final int searchLast = searchLength - 1;//LC:2886
        for (int i = 0; i < csLength; i++) {//LC:2887
            final char ch = cs.charAt(i);//LC:2888
            for (int j = 0; j < searchLength; j++) {//LC:2889
                if (searchChars[j] == ch) {//LC:2890
                    if (Character.isHighSurrogate(ch)) {//LC:2891
                        if (j == searchLast) {//LC:2892
                            // missing low surrogate, fine, like String.indexOf(String)//LC:2893
                            return true;//LC:2894
                        }//LC:2895
                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {//LC:2896
                            return true;//LC:2897
                        }//LC:2898
                    } else {//LC:2899
                        // ch is in the Basic Multilingual Plane//LC:2900
                        return true;//LC:2901
                    }//LC:2902
                }//LC:2903
            }//LC:2904
        }//LC:2905
        return false;//LC:2906
    }//LC:2907
//LC:2908
    /**//LC:2909
     * <p>//LC:2910
     * Checks if the CharSequence contains any character in the given set of characters.//LC:2911
     * </p>//LC:2912
     *//LC:2913
     * <p>//LC:2914
     * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return//LC:2915
     * {@code false}.//LC:2916
     * </p>//LC:2917
     *//LC:2918
     * <pre>//LC:2919
     * StringUtils.containsAny(null, *)            = false//LC:2920
     * StringUtils.containsAny("", *)              = false//LC:2921
     * StringUtils.containsAny(*, null)            = false//LC:2922
     * StringUtils.containsAny(*, "")              = false//LC:2923
     * StringUtils.containsAny("zzabyycdxx", "za") = true//LC:2924
     * StringUtils.containsAny("zzabyycdxx", "by") = true//LC:2925
     * StringUtils.containsAny("aba","z")          = false//LC:2926
     * </pre>//LC:2927
     *//LC:2928
     * @param cs//LC:2929
     *            the CharSequence to check, may be null//LC:2930
     * @param searchChars//LC:2931
     *            the chars to search for, may be null//LC:2932
     * @return the {@code true} if any of the chars are found, {@code false} if no match or null input//LC:2933
     * @since 2.4//LC:2934
     * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)//LC:2935
     *///LC:2936
    public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {//LC:2937
        if (searchChars == null) {//LC:2938
            return false;//LC:2939
        }//LC:2940
        return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));//LC:2941
    }//LC:2942
//LC:2943
    // IndexOfAnyBut chars//LC:2944
    //-----------------------------------------------------------------------//LC:2945
    /**//LC:2946
     * <p>Searches a CharSequence to find the first index of any//LC:2947
     * character not in the given set of characters.</p>//LC:2948
     *//LC:2949
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:2950
     * A {@code null} or zero length search array will return {@code -1}.</p>//LC:2951
     *//LC:2952
     * <pre>//LC:2953
     * StringUtils.indexOfAnyBut(null, *)                              = -1//LC:2954
     * StringUtils.indexOfAnyBut("", *)                                = -1//LC:2955
     * StringUtils.indexOfAnyBut(*, null)                              = -1//LC:2956
     * StringUtils.indexOfAnyBut(*, [])                                = -1//LC:2957
     * StringUtils.indexOfAnyBut("zzabyycdxx", new char[] {'z', 'a'} ) = 3//LC:2958
     * StringUtils.indexOfAnyBut("aba", new char[] {'z'} )             = 0//LC:2959
     * StringUtils.indexOfAnyBut("aba", new char[] {'a', 'b'} )        = -1//LC:2960
//LC:2961
     * </pre>//LC:2962
     *//LC:2963
     * @param cs  the CharSequence to check, may be null//LC:2964
     * @param searchChars  the chars to search for, may be null//LC:2965
     * @return the index of any of the chars, -1 if no match or null input//LC:2966
     * @since 2.0//LC:2967
     * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)//LC:2968
     *///LC:2969
    public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) {//LC:2970
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {//LC:2971
            return INDEX_NOT_FOUND;//LC:2972
        }//LC:2973
        final int csLen = cs.length();//LC:2974
        final int csLast = csLen - 1;//LC:2975
        final int searchLen = searchChars.length;//LC:2976
        final int searchLast = searchLen - 1;//LC:2977
        outer://LC:2978
        for (int i = 0; i < csLen; i++) {//LC:2979
            final char ch = cs.charAt(i);//LC:2980
            for (int j = 0; j < searchLen; j++) {//LC:2981
                if (searchChars[j] == ch) {//LC:2982
                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {//LC:2983
                        if (searchChars[j + 1] == cs.charAt(i + 1)) {//LC:2984
                            continue outer;//LC:2985
                        }//LC:2986
                    } else {//LC:2987
                        continue outer;//LC:2988
                    }//LC:2989
                }//LC:2990
            }//LC:2991
            return i;//LC:2992
        }//LC:2993
        return INDEX_NOT_FOUND;//LC:2994
    }//LC:2995
//LC:2996
    /**//LC:2997
     * <p>Search a CharSequence to find the first index of any//LC:2998
     * character not in the given set of characters.</p>//LC:2999
     *//LC:3000
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:3001
     * A {@code null} or empty search string will return {@code -1}.</p>//LC:3002
     *//LC:3003
     * <pre>//LC:3004
     * StringUtils.indexOfAnyBut(null, *)            = -1//LC:3005
     * StringUtils.indexOfAnyBut("", *)              = -1//LC:3006
     * StringUtils.indexOfAnyBut(*, null)            = -1//LC:3007
     * StringUtils.indexOfAnyBut(*, "")              = -1//LC:3008
     * StringUtils.indexOfAnyBut("zzabyycdxx", "za") = 3//LC:3009
     * StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1//LC:3010
     * StringUtils.indexOfAnyBut("aba","ab")         = -1//LC:3011
     * </pre>//LC:3012
     *//LC:3013
     * @param seq  the CharSequence to check, may be null//LC:3014
     * @param searchChars  the chars to search for, may be null//LC:3015
     * @return the index of any of the chars, -1 if no match or null input//LC:3016
     * @since 2.0//LC:3017
     * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)//LC:3018
     *///LC:3019
    public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {//LC:3020
        if (isEmpty(seq) || isEmpty(searchChars)) {//LC:3021
            return INDEX_NOT_FOUND;//LC:3022
        }//LC:3023
        final int strLen = seq.length();//LC:3024
        for (int i = 0; i < strLen; i++) {//LC:3025
            final char ch = seq.charAt(i);//LC:3026
            final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;//LC:3027
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {//LC:3028
                final char ch2 = seq.charAt(i + 1);//LC:3029
                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {//LC:3030
                    return i;//LC:3031
                }//LC:3032
            } else {//LC:3033
                if (!chFound) {//LC:3034
                    return i;//LC:3035
                }//LC:3036
            }//LC:3037
        }//LC:3038
        return INDEX_NOT_FOUND;//LC:3039
    }//LC:3040
//LC:3041
    // ContainsOnly//LC:3042
    //-----------------------------------------------------------------------//LC:3043
    /**//LC:3044
     * <p>Checks if the CharSequence contains only certain characters.</p>//LC:3045
     *//LC:3046
     * <p>A {@code null} CharSequence will return {@code false}.//LC:3047
     * A {@code null} valid character array will return {@code false}.//LC:3048
     * An empty CharSequence (length()=0) always returns {@code true}.</p>//LC:3049
     *//LC:3050
     * <pre>//LC:3051
     * StringUtils.containsOnly(null, *)       = false//LC:3052
     * StringUtils.containsOnly(*, null)       = false//LC:3053
     * StringUtils.containsOnly("", *)         = true//LC:3054
     * StringUtils.containsOnly("ab", '')      = false//LC:3055
     * StringUtils.containsOnly("abab", 'abc') = true//LC:3056
     * StringUtils.containsOnly("ab1", 'abc')  = false//LC:3057
     * StringUtils.containsOnly("abz", 'abc')  = false//LC:3058
     * </pre>//LC:3059
     *//LC:3060
     * @param cs  the String to check, may be null//LC:3061
     * @param valid  an array of valid chars, may be null//LC:3062
     * @return true if it only contains valid chars and is non-null//LC:3063
     * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)//LC:3064
     *///LC:3065
    public static boolean containsOnly(final CharSequence cs, final char... valid) {//LC:3066
        // All these pre-checks are to maintain API with an older version//LC:3067
        if (valid == null || cs == null) {//LC:3068
            return false;//LC:3069
        }//LC:3070
        if (cs.length() == 0) {//LC:3071
            return true;//LC:3072
        }//LC:3073
        if (valid.length == 0) {//LC:3074
            return false;//LC:3075
        }//LC:3076
        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;//LC:3077
    }//LC:3078
//LC:3079
    /**//LC:3080
     * <p>Checks if the CharSequence contains only certain characters.</p>//LC:3081
     *//LC:3082
     * <p>A {@code null} CharSequence will return {@code false}.//LC:3083
     * A {@code null} valid character String will return {@code false}.//LC:3084
     * An empty String (length()=0) always returns {@code true}.</p>//LC:3085
     *//LC:3086
     * <pre>//LC:3087
     * StringUtils.containsOnly(null, *)       = false//LC:3088
     * StringUtils.containsOnly(*, null)       = false//LC:3089
     * StringUtils.containsOnly("", *)         = true//LC:3090
     * StringUtils.containsOnly("ab", "")      = false//LC:3091
     * StringUtils.containsOnly("abab", "abc") = true//LC:3092
     * StringUtils.containsOnly("ab1", "abc")  = false//LC:3093
     * StringUtils.containsOnly("abz", "abc")  = false//LC:3094
     * </pre>//LC:3095
     *//LC:3096
     * @param cs  the CharSequence to check, may be null//LC:3097
     * @param validChars  a String of valid chars, may be null//LC:3098
     * @return true if it only contains valid chars and is non-null//LC:3099
     * @since 2.0//LC:3100
     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)//LC:3101
     *///LC:3102
    public static boolean containsOnly(final CharSequence cs, final String validChars) {//LC:3103
        if (cs == null || validChars == null) {//LC:3104
            return false;//LC:3105
        }//LC:3106
        return containsOnly(cs, validChars.toCharArray());//LC:3107
    }//LC:3108
//LC:3109
    // ContainsNone//LC:3110
    //-----------------------------------------------------------------------//LC:3111
    /**//LC:3112
     * <p>Checks that the CharSequence does not contain certain characters.</p>//LC:3113
     *//LC:3114
     * <p>A {@code null} CharSequence will return {@code true}.//LC:3115
     * A {@code null} invalid character array will return {@code true}.//LC:3116
     * An empty CharSequence (length()=0) always returns true.</p>//LC:3117
     *//LC:3118
     * <pre>//LC:3119
     * StringUtils.containsNone(null, *)       = true//LC:3120
     * StringUtils.containsNone(*, null)       = true//LC:3121
     * StringUtils.containsNone("", *)         = true//LC:3122
     * StringUtils.containsNone("ab", '')      = true//LC:3123
     * StringUtils.containsNone("abab", 'xyz') = true//LC:3124
     * StringUtils.containsNone("ab1", 'xyz')  = true//LC:3125
     * StringUtils.containsNone("abz", 'xyz')  = false//LC:3126
     * </pre>//LC:3127
     *//LC:3128
     * @param cs  the CharSequence to check, may be null//LC:3129
     * @param searchChars  an array of invalid chars, may be null//LC:3130
     * @return true if it contains none of the invalid chars, or is null//LC:3131
     * @since 2.0//LC:3132
     * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)//LC:3133
     *///LC:3134
    public static boolean containsNone(final CharSequence cs, final char... searchChars) {//LC:3135
        if (cs == null || searchChars == null) {//LC:3136
            return true;//LC:3137
        }//LC:3138
        final int csLen = cs.length();//LC:3139
        final int csLast = csLen - 1;//LC:3140
        final int searchLen = searchChars.length;//LC:3141
        final int searchLast = searchLen - 1;//LC:3142
        for (int i = 0; i < csLen; i++) {//LC:3143
            final char ch = cs.charAt(i);//LC:3144
            for (int j = 0; j < searchLen; j++) {//LC:3145
                if (searchChars[j] == ch) {//LC:3146
                    if (Character.isHighSurrogate(ch)) {//LC:3147
                        if (j == searchLast) {//LC:3148
                            // missing low surrogate, fine, like String.indexOf(String)//LC:3149
                            return false;//LC:3150
                        }//LC:3151
                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {//LC:3152
                            return false;//LC:3153
                        }//LC:3154
                    } else {//LC:3155
                        // ch is in the Basic Multilingual Plane//LC:3156
                        return false;//LC:3157
                    }//LC:3158
                }//LC:3159
            }//LC:3160
        }//LC:3161
        return true;//LC:3162
    }//LC:3163
//LC:3164
    /**//LC:3165
     * <p>Checks that the CharSequence does not contain certain characters.</p>//LC:3166
     *//LC:3167
     * <p>A {@code null} CharSequence will return {@code true}.//LC:3168
     * A {@code null} invalid character array will return {@code true}.//LC:3169
     * An empty String ("") always returns true.</p>//LC:3170
     *//LC:3171
     * <pre>//LC:3172
     * StringUtils.containsNone(null, *)       = true//LC:3173
     * StringUtils.containsNone(*, null)       = true//LC:3174
     * StringUtils.containsNone("", *)         = true//LC:3175
     * StringUtils.containsNone("ab", "")      = true//LC:3176
     * StringUtils.containsNone("abab", "xyz") = true//LC:3177
     * StringUtils.containsNone("ab1", "xyz")  = true//LC:3178
     * StringUtils.containsNone("abz", "xyz")  = false//LC:3179
     * </pre>//LC:3180
     *//LC:3181
     * @param cs  the CharSequence to check, may be null//LC:3182
     * @param invalidChars  a String of invalid chars, may be null//LC:3183
     * @return true if it contains none of the invalid chars, or is null//LC:3184
     * @since 2.0//LC:3185
     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)//LC:3186
     *///LC:3187
    public static boolean containsNone(final CharSequence cs, final String invalidChars) {//LC:3188
        if (cs == null || invalidChars == null) {//LC:3189
            return true;//LC:3190
        }//LC:3191
        return containsNone(cs, invalidChars.toCharArray());//LC:3192
    }//LC:3193
//LC:3194
    // IndexOfAny strings//LC:3195
    //-----------------------------------------------------------------------//LC:3196
    /**//LC:3197
     * <p>Find the first index of any of a set of potential substrings.</p>//LC:3198
     *//LC:3199
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:3200
     * A {@code null} or zero length search array will return {@code -1}.//LC:3201
     * A {@code null} search array entry will be ignored, but a search//LC:3202
     * array containing "" will return {@code 0} if {@code str} is not//LC:3203
     * null. This method uses {@link String#indexOf(String)} if possible.</p>//LC:3204
     *//LC:3205
     * <pre>//LC:3206
     * StringUtils.indexOfAny(null, *)                     = -1//LC:3207
     * StringUtils.indexOfAny(*, null)                     = -1//LC:3208
     * StringUtils.indexOfAny(*, [])                       = -1//LC:3209
     * StringUtils.indexOfAny("zzabyycdxx", ["ab","cd"])   = 2//LC:3210
     * StringUtils.indexOfAny("zzabyycdxx", ["cd","ab"])   = 2//LC:3211
     * StringUtils.indexOfAny("zzabyycdxx", ["mn","op"])   = -1//LC:3212
     * StringUtils.indexOfAny("zzabyycdxx", ["zab","aby"]) = 1//LC:3213
     * StringUtils.indexOfAny("zzabyycdxx", [""])          = 0//LC:3214
     * StringUtils.indexOfAny("", [""])                    = 0//LC:3215
     * StringUtils.indexOfAny("", ["a"])                   = -1//LC:3216
     * </pre>//LC:3217
     *//LC:3218
     * @param str  the CharSequence to check, may be null//LC:3219
     * @param searchStrs  the CharSequences to search for, may be null//LC:3220
     * @return the first index of any of the searchStrs in str, -1 if no match//LC:3221
     * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)//LC:3222
     *///LC:3223
    public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {//LC:3224
        if (str == null || searchStrs == null) {//LC:3225
            return INDEX_NOT_FOUND;//LC:3226
        }//LC:3227
        final int sz = searchStrs.length;//LC:3228
//LC:3229
        // String's can't have a MAX_VALUEth index.//LC:3230
        int ret = Integer.MAX_VALUE;//LC:3231
//LC:3232
        int tmp = 0;//LC:3233
        for (int i = 0; i < sz; i++) {//LC:3234
            final CharSequence search = searchStrs[i];//LC:3235
            if (search == null) {//LC:3236
                continue;//LC:3237
            }//LC:3238
            tmp = CharSequenceUtils.indexOf(str, search, 0);//LC:3239
            if (tmp == INDEX_NOT_FOUND) {//LC:3240
                continue;//LC:3241
            }//LC:3242
//LC:3243
            if (tmp < ret) {//LC:3244
                ret = tmp;//LC:3245
            }//LC:3246
        }//LC:3247
//LC:3248
        return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;//LC:3249
    }//LC:3250
//LC:3251
    /**//LC:3252
     * <p>Find the latest index of any of a set of potential substrings.</p>//LC:3253
     *//LC:3254
     * <p>A {@code null} CharSequence will return {@code -1}.//LC:3255
     * A {@code null} search array will return {@code -1}.//LC:3256
     * A {@code null} or zero length search array entry will be ignored,//LC:3257
     * but a search array containing "" will return the length of {@code str}//LC:3258
     * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>//LC:3259
     *//LC:3260
     * <pre>//LC:3261
     * StringUtils.lastIndexOfAny(null, *)                   = -1//LC:3262
     * StringUtils.lastIndexOfAny(*, null)                   = -1//LC:3263
     * StringUtils.lastIndexOfAny(*, [])                     = -1//LC:3264
     * StringUtils.lastIndexOfAny(*, [null])                 = -1//LC:3265
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["ab","cd"]) = 6//LC:3266
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["cd","ab"]) = 6//LC:3267
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn","op"]) = -1//LC:3268
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn","op"]) = -1//LC:3269
     * StringUtils.lastIndexOfAny("zzabyycdxx", ["mn",""])   = 10//LC:3270
     * </pre>//LC:3271
     *//LC:3272
     * @param str  the CharSequence to check, may be null//LC:3273
     * @param searchStrs  the CharSequences to search for, may be null//LC:3274
     * @return the last index of any of the CharSequences, -1 if no match//LC:3275
     * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)//LC:3276
     *///LC:3277
    public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {//LC:3278
        if (str == null || searchStrs == null) {//LC:3279
            return INDEX_NOT_FOUND;//LC:3280
        }//LC:3281
        final int sz = searchStrs.length;//LC:3282
        int ret = INDEX_NOT_FOUND;//LC:3283
        int tmp = 0;//LC:3284
        for (int i = 0; i < sz; i++) {//LC:3285
            final CharSequence search = searchStrs[i];//LC:3286
            if (search == null) {//LC:3287
                continue;//LC:3288
            }//LC:3289
            tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());//LC:3290
            if (tmp > ret) {//LC:3291
                ret = tmp;//LC:3292
            }//LC:3293
        }//LC:3294
        return ret;//LC:3295
    }//LC:3296
//LC:3297
    // Substring//LC:3298
    //-----------------------------------------------------------------------//LC:3299
    /**//LC:3300
     * <p>Gets a substring from the specified String avoiding exceptions.</p>//LC:3301
     *//LC:3302
     * <p>A negative start position can be used to start {@code n}//LC:3303
     * characters from the end of the String.</p>//LC:3304
     *//LC:3305
     * <p>A {@code null} String will return {@code null}.//LC:3306
     * An empty ("") String will return "".</p>//LC:3307
     *//LC:3308
     * <pre>//LC:3309
     * StringUtils.substring(null, *)   = null//LC:3310
     * StringUtils.substring("", *)     = ""//LC:3311
     * StringUtils.substring("abc", 0)  = "abc"//LC:3312
     * StringUtils.substring("abc", 2)  = "c"//LC:3313
     * StringUtils.substring("abc", 4)  = ""//LC:3314
     * StringUtils.substring("abc", -2) = "bc"//LC:3315
     * StringUtils.substring("abc", -4) = "abc"//LC:3316
     * </pre>//LC:3317
     *//LC:3318
     * @param str  the String to get the substring from, may be null//LC:3319
     * @param start  the position to start from, negative means//LC:3320
     *  count back from the end of the String by this many characters//LC:3321
     * @return substring from start position, {@code null} if null String input//LC:3322
     *///LC:3323
    public static String substring(final String str, int start) {//LC:3324
        if (str == null) {//LC:3325
            return null;//LC:3326
        }//LC:3327
//LC:3328
        // handle negatives, which means last n characters//LC:3329
        if (start < 0) {//LC:3330
            start = str.length() + start; // remember start is negative//LC:3331
        }//LC:3332
//LC:3333
        if (start < 0) {//LC:3334
            start = 0;//LC:3335
        }//LC:3336
        if (start > str.length()) {//LC:3337
            return EMPTY;//LC:3338
        }//LC:3339
//LC:3340
        return str.substring(start);//LC:3341
    }//LC:3342
//LC:3343
    /**//LC:3344
     * <p>Gets a substring from the specified String avoiding exceptions.</p>//LC:3345
     *//LC:3346
     * <p>A negative start position can be used to start/end {@code n}//LC:3347
     * characters from the end of the String.</p>//LC:3348
     *//LC:3349
     * <p>The returned substring starts with the character in the {@code start}//LC:3350
     * position and ends before the {@code end} position. All position counting is//LC:3351
     * zero-based -- i.e., to start at the beginning of the string use//LC:3352
     * {@code start = 0}. Negative start and end positions can be used to//LC:3353
     * specify offsets relative to the end of the String.</p>//LC:3354
     *//LC:3355
     * <p>If {@code start} is not strictly to the left of {@code end}, ""//LC:3356
     * is returned.</p>//LC:3357
     *//LC:3358
     * <pre>//LC:3359
     * StringUtils.substring(null, *, *)    = null//LC:3360
     * StringUtils.substring("", * ,  *)    = "";//LC:3361
     * StringUtils.substring("abc", 0, 2)   = "ab"//LC:3362
     * StringUtils.substring("abc", 2, 0)   = ""//LC:3363
     * StringUtils.substring("abc", 2, 4)   = "c"//LC:3364
     * StringUtils.substring("abc", 4, 6)   = ""//LC:3365
     * StringUtils.substring("abc", 2, 2)   = ""//LC:3366
     * StringUtils.substring("abc", -2, -1) = "b"//LC:3367
     * StringUtils.substring("abc", -4, 2)  = "ab"//LC:3368
     * </pre>//LC:3369
     *//LC:3370
     * @param str  the String to get the substring from, may be null//LC:3371
     * @param start  the position to start from, negative means//LC:3372
     *  count back from the end of the String by this many characters//LC:3373
     * @param end  the position to end at (exclusive), negative means//LC:3374
     *  count back from the end of the String by this many characters//LC:3375
     * @return substring from start position to end position,//LC:3376
     *  {@code null} if null String input//LC:3377
     *///LC:3378
    public static String substring(final String str, int start, int end) {//LC:3379
        if (str == null) {//LC:3380
            return null;//LC:3381
        }//LC:3382
//LC:3383
        // handle negatives//LC:3384
        if (end < 0) {//LC:3385
            end = str.length() + end; // remember end is negative//LC:3386
        }//LC:3387
        if (start < 0) {//LC:3388
            start = str.length() + start; // remember start is negative//LC:3389
        }//LC:3390
//LC:3391
        // check length next//LC:3392
        if (end > str.length()) {//LC:3393
            end = str.length();//LC:3394
        }//LC:3395
//LC:3396
        // if start is greater than end, return ""//LC:3397
        if (start > end) {//LC:3398
            return EMPTY;//LC:3399
        }//LC:3400
//LC:3401
        if (start < 0) {//LC:3402
            start = 0;//LC:3403
        }//LC:3404
        if (end < 0) {//LC:3405
            end = 0;//LC:3406
        }//LC:3407
//LC:3408
        return str.substring(start, end);//LC:3409
    }//LC:3410
//LC:3411
    // Left/Right/Mid//LC:3412
    //-----------------------------------------------------------------------//LC:3413
    /**//LC:3414
     * <p>Gets the leftmost {@code len} characters of a String.</p>//LC:3415
     *//LC:3416
     * <p>If {@code len} characters are not available, or the//LC:3417
     * String is {@code null}, the String will be returned without//LC:3418
     * an exception. An empty String is returned if len is negative.</p>//LC:3419
     *//LC:3420
     * <pre>//LC:3421
     * StringUtils.left(null, *)    = null//LC:3422
     * StringUtils.left(*, -ve)     = ""//LC:3423
     * StringUtils.left("", *)      = ""//LC:3424
     * StringUtils.left("abc", 0)   = ""//LC:3425
     * StringUtils.left("abc", 2)   = "ab"//LC:3426
     * StringUtils.left("abc", 4)   = "abc"//LC:3427
     * </pre>//LC:3428
     *//LC:3429
     * @param str  the String to get the leftmost characters from, may be null//LC:3430
     * @param len  the length of the required String//LC:3431
     * @return the leftmost characters, {@code null} if null String input//LC:3432
     *///LC:3433
    public static String left(final String str, final int len) {//LC:3434
        if (str == null) {//LC:3435
            return null;//LC:3436
        }//LC:3437
        if (len < 0) {//LC:3438
            return EMPTY;//LC:3439
        }//LC:3440
        if (str.length() <= len) {//LC:3441
            return str;//LC:3442
        }//LC:3443
        return str.substring(0, len);//LC:3444
    }//LC:3445
//LC:3446
    /**//LC:3447
     * <p>Gets the rightmost {@code len} characters of a String.</p>//LC:3448
     *//LC:3449
     * <p>If {@code len} characters are not available, or the String//LC:3450
     * is {@code null}, the String will be returned without an//LC:3451
     * an exception. An empty String is returned if len is negative.</p>//LC:3452
     *//LC:3453
     * <pre>//LC:3454
     * StringUtils.right(null, *)    = null//LC:3455
     * StringUtils.right(*, -ve)     = ""//LC:3456
     * StringUtils.right("", *)      = ""//LC:3457
     * StringUtils.right("abc", 0)   = ""//LC:3458
     * StringUtils.right("abc", 2)   = "bc"//LC:3459
     * StringUtils.right("abc", 4)   = "abc"//LC:3460
     * </pre>//LC:3461
     *//LC:3462
     * @param str  the String to get the rightmost characters from, may be null//LC:3463
     * @param len  the length of the required String//LC:3464
     * @return the rightmost characters, {@code null} if null String input//LC:3465
     *///LC:3466
    public static String right(final String str, final int len) {//LC:3467
        if (str == null) {//LC:3468
            return null;//LC:3469
        }//LC:3470
        if (len < 0) {//LC:3471
            return EMPTY;//LC:3472
        }//LC:3473
        if (str.length() <= len) {//LC:3474
            return str;//LC:3475
        }//LC:3476
        return str.substring(str.length() - len);//LC:3477
    }//LC:3478
//LC:3479
    /**//LC:3480
     * <p>Gets {@code len} characters from the middle of a String.</p>//LC:3481
     *//LC:3482
     * <p>If {@code len} characters are not available, the remainder//LC:3483
     * of the String will be returned without an exception. If the//LC:3484
     * String is {@code null}, {@code null} will be returned.//LC:3485
     * An empty String is returned if len is negative or exceeds the//LC:3486
     * length of {@code str}.</p>//LC:3487
     *//LC:3488
     * <pre>//LC:3489
     * StringUtils.mid(null, *, *)    = null//LC:3490
     * StringUtils.mid(*, *, -ve)     = ""//LC:3491
     * StringUtils.mid("", 0, *)      = ""//LC:3492
     * StringUtils.mid("abc", 0, 2)   = "ab"//LC:3493
     * StringUtils.mid("abc", 0, 4)   = "abc"//LC:3494
     * StringUtils.mid("abc", 2, 4)   = "c"//LC:3495
     * StringUtils.mid("abc", 4, 2)   = ""//LC:3496
     * StringUtils.mid("abc", -2, 2)  = "ab"//LC:3497
     * </pre>//LC:3498
     *//LC:3499
     * @param str  the String to get the characters from, may be null//LC:3500
     * @param pos  the position to start from, negative treated as zero//LC:3501
     * @param len  the length of the required String//LC:3502
     * @return the middle characters, {@code null} if null String input//LC:3503
     *///LC:3504
    public static String mid(final String str, int pos, final int len) {//LC:3505
        if (str == null) {//LC:3506
            return null;//LC:3507
        }//LC:3508
        if (len < 0 || pos > str.length()) {//LC:3509
            return EMPTY;//LC:3510
        }//LC:3511
        if (pos < 0) {//LC:3512
            pos = 0;//LC:3513
        }//LC:3514
        if (str.length() <= pos + len) {//LC:3515
            return str.substring(pos);//LC:3516
        }//LC:3517
        return str.substring(pos, pos + len);//LC:3518
    }//LC:3519
//LC:3520
    // SubStringAfter/SubStringBefore//LC:3521
    //-----------------------------------------------------------------------//LC:3522
    /**//LC:3523
     * <p>Gets the substring before the first occurrence of a separator.//LC:3524
     * The separator is not returned.</p>//LC:3525
     *//LC:3526
     * <p>A {@code null} string input will return {@code null}.//LC:3527
     * An empty ("") string input will return the empty string.//LC:3528
     * A {@code null} separator will return the input string.</p>//LC:3529
     *//LC:3530
     * <p>If nothing is found, the string input is returned.</p>//LC:3531
     *//LC:3532
     * <pre>//LC:3533
     * StringUtils.substringBefore(null, *)      = null//LC:3534
     * StringUtils.substringBefore("", *)        = ""//LC:3535
     * StringUtils.substringBefore("abc", "a")   = ""//LC:3536
     * StringUtils.substringBefore("abcba", "b") = "a"//LC:3537
     * StringUtils.substringBefore("abc", "c")   = "ab"//LC:3538
     * StringUtils.substringBefore("abc", "d")   = "abc"//LC:3539
     * StringUtils.substringBefore("abc", "")    = ""//LC:3540
     * StringUtils.substringBefore("abc", null)  = "abc"//LC:3541
     * </pre>//LC:3542
     *//LC:3543
     * @param str  the String to get a substring from, may be null//LC:3544
     * @param separator  the String to search for, may be null//LC:3545
     * @return the substring before the first occurrence of the separator,//LC:3546
     *  {@code null} if null String input//LC:3547
     * @since 2.0//LC:3548
     *///LC:3549
    public static String substringBefore(final String str, final String separator) {//LC:3550
        if (isEmpty(str) || separator == null) {//LC:3551
            return str;//LC:3552
        }//LC:3553
        if (separator.isEmpty()) {//LC:3554
            return EMPTY;//LC:3555
        }//LC:3556
        final int pos = str.indexOf(separator);//LC:3557
        if (pos == INDEX_NOT_FOUND) {//LC:3558
            return str;//LC:3559
        }//LC:3560
        return str.substring(0, pos);//LC:3561
    }//LC:3562
//LC:3563
    /**//LC:3564
     * <p>Gets the substring after the first occurrence of a separator.//LC:3565
     * The separator is not returned.</p>//LC:3566
     *//LC:3567
     * <p>A {@code null} string input will return {@code null}.//LC:3568
     * An empty ("") string input will return the empty string.//LC:3569
     * A {@code null} separator will return the empty string if the//LC:3570
     * input string is not {@code null}.</p>//LC:3571
     *//LC:3572
     * <p>If nothing is found, the empty string is returned.</p>//LC:3573
     *//LC:3574
     * <pre>//LC:3575
     * StringUtils.substringAfter(null, *)      = null//LC:3576
     * StringUtils.substringAfter("", *)        = ""//LC:3577
     * StringUtils.substringAfter(*, null)      = ""//LC:3578
     * StringUtils.substringAfter("abc", "a")   = "bc"//LC:3579
     * StringUtils.substringAfter("abcba", "b") = "cba"//LC:3580
     * StringUtils.substringAfter("abc", "c")   = ""//LC:3581
     * StringUtils.substringAfter("abc", "d")   = ""//LC:3582
     * StringUtils.substringAfter("abc", "")    = "abc"//LC:3583
     * </pre>//LC:3584
     *//LC:3585
     * @param str  the String to get a substring from, may be null//LC:3586
     * @param separator  the String to search for, may be null//LC:3587
     * @return the substring after the first occurrence of the separator,//LC:3588
     *  {@code null} if null String input//LC:3589
     * @since 2.0//LC:3590
     *///LC:3591
    public static String substringAfter(final String str, final String separator) {//LC:3592
        if (isEmpty(str)) {//LC:3593
            return str;//LC:3594
        }//LC:3595
        if (separator == null) {//LC:3596
            return EMPTY;//LC:3597
        }//LC:3598
        final int pos = str.indexOf(separator);//LC:3599
        if (pos == INDEX_NOT_FOUND) {//LC:3600
            return EMPTY;//LC:3601
        }//LC:3602
        return str.substring(pos + separator.length());//LC:3603
    }//LC:3604
//LC:3605
    /**//LC:3606
     * <p>Gets the substring before the last occurrence of a separator.//LC:3607
     * The separator is not returned.</p>//LC:3608
     *//LC:3609
     * <p>A {@code null} string input will return {@code null}.//LC:3610
     * An empty ("") string input will return the empty string.//LC:3611
     * An empty or {@code null} separator will return the input string.</p>//LC:3612
     *//LC:3613
     * <p>If nothing is found, the string input is returned.</p>//LC:3614
     *//LC:3615
     * <pre>//LC:3616
     * StringUtils.substringBeforeLast(null, *)      = null//LC:3617
     * StringUtils.substringBeforeLast("", *)        = ""//LC:3618
     * StringUtils.substringBeforeLast("abcba", "b") = "abc"//LC:3619
     * StringUtils.substringBeforeLast("abc", "c")   = "ab"//LC:3620
     * StringUtils.substringBeforeLast("a", "a")     = ""//LC:3621
     * StringUtils.substringBeforeLast("a", "z")     = "a"//LC:3622
     * StringUtils.substringBeforeLast("a", null)    = "a"//LC:3623
     * StringUtils.substringBeforeLast("a", "")      = "a"//LC:3624
     * </pre>//LC:3625
     *//LC:3626
     * @param str  the String to get a substring from, may be null//LC:3627
     * @param separator  the String to search for, may be null//LC:3628
     * @return the substring before the last occurrence of the separator,//LC:3629
     *  {@code null} if null String input//LC:3630
     * @since 2.0//LC:3631
     *///LC:3632
    public static String substringBeforeLast(final String str, final String separator) {//LC:3633
        if (isEmpty(str) || isEmpty(separator)) {//LC:3634
            return str;//LC:3635
        }//LC:3636
        final int pos = str.lastIndexOf(separator);//LC:3637
        if (pos == INDEX_NOT_FOUND) {//LC:3638
            return str;//LC:3639
        }//LC:3640
        return str.substring(0, pos);//LC:3641
    }//LC:3642
//LC:3643
    /**//LC:3644
     * <p>Gets the substring after the last occurrence of a separator.//LC:3645
     * The separator is not returned.</p>//LC:3646
     *//LC:3647
     * <p>A {@code null} string input will return {@code null}.//LC:3648
     * An empty ("") string input will return the empty string.//LC:3649
     * An empty or {@code null} separator will return the empty string if//LC:3650
     * the input string is not {@code null}.</p>//LC:3651
     *//LC:3652
     * <p>If nothing is found, the empty string is returned.</p>//LC:3653
     *//LC:3654
     * <pre>//LC:3655
     * StringUtils.substringAfterLast(null, *)      = null//LC:3656
     * StringUtils.substringAfterLast("", *)        = ""//LC:3657
     * StringUtils.substringAfterLast(*, "")        = ""//LC:3658
     * StringUtils.substringAfterLast(*, null)      = ""//LC:3659
     * StringUtils.substringAfterLast("abc", "a")   = "bc"//LC:3660
     * StringUtils.substringAfterLast("abcba", "b") = "a"//LC:3661
     * StringUtils.substringAfterLast("abc", "c")   = ""//LC:3662
     * StringUtils.substringAfterLast("a", "a")     = ""//LC:3663
     * StringUtils.substringAfterLast("a", "z")     = ""//LC:3664
     * </pre>//LC:3665
     *//LC:3666
     * @param str  the String to get a substring from, may be null//LC:3667
     * @param separator  the String to search for, may be null//LC:3668
     * @return the substring after the last occurrence of the separator,//LC:3669
     *  {@code null} if null String input//LC:3670
     * @since 2.0//LC:3671
     *///LC:3672
    public static String substringAfterLast(final String str, final String separator) {//LC:3673
        if (isEmpty(str)) {//LC:3674
            return str;//LC:3675
        }//LC:3676
        if (isEmpty(separator)) {//LC:3677
            return EMPTY;//LC:3678
        }//LC:3679
        final int pos = str.lastIndexOf(separator);//LC:3680
        if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {//LC:3681
            return EMPTY;//LC:3682
        }//LC:3683
        return str.substring(pos + separator.length());//LC:3684
    }//LC:3685
//LC:3686
    // Substring between//LC:3687
    //-----------------------------------------------------------------------//LC:3688
    /**//LC:3689
     * <p>Gets the String that is nested in between two instances of the//LC:3690
     * same String.</p>//LC:3691
     *//LC:3692
     * <p>A {@code null} input String returns {@code null}.//LC:3693
     * A {@code null} tag returns {@code null}.</p>//LC:3694
     *//LC:3695
     * <pre>//LC:3696
     * StringUtils.substringBetween(null, *)            = null//LC:3697
     * StringUtils.substringBetween("", "")             = ""//LC:3698
     * StringUtils.substringBetween("", "tag")          = null//LC:3699
     * StringUtils.substringBetween("tagabctag", null)  = null//LC:3700
     * StringUtils.substringBetween("tagabctag", "")    = ""//LC:3701
     * StringUtils.substringBetween("tagabctag", "tag") = "abc"//LC:3702
     * </pre>//LC:3703
     *//LC:3704
     * @param str  the String containing the substring, may be null//LC:3705
     * @param tag  the String before and after the substring, may be null//LC:3706
     * @return the substring, {@code null} if no match//LC:3707
     * @since 2.0//LC:3708
     *///LC:3709
    public static String substringBetween(final String str, final String tag) {//LC:3710
        return substringBetween(str, tag, tag);//LC:3711
    }//LC:3712
//LC:3713
    /**//LC:3714
     * <p>Gets the String that is nested in between two Strings.//LC:3715
     * Only the first match is returned.</p>//LC:3716
     *//LC:3717
     * <p>A {@code null} input String returns {@code null}.//LC:3718
     * A {@code null} open/close returns {@code null} (no match).//LC:3719
     * An empty ("") open and close returns an empty string.</p>//LC:3720
     *//LC:3721
     * <pre>//LC:3722
     * StringUtils.substringBetween("wx[b]yz", "[", "]") = "b"//LC:3723
     * StringUtils.substringBetween(null, *, *)          = null//LC:3724
     * StringUtils.substringBetween(*, null, *)          = null//LC:3725
     * StringUtils.substringBetween(*, *, null)          = null//LC:3726
     * StringUtils.substringBetween("", "", "")          = ""//LC:3727
     * StringUtils.substringBetween("", "", "]")         = null//LC:3728
     * StringUtils.substringBetween("", "[", "]")        = null//LC:3729
     * StringUtils.substringBetween("yabcz", "", "")     = ""//LC:3730
     * StringUtils.substringBetween("yabcz", "y", "z")   = "abc"//LC:3731
     * StringUtils.substringBetween("yabczyabcz", "y", "z")   = "abc"//LC:3732
     * </pre>//LC:3733
     *//LC:3734
     * @param str  the String containing the substring, may be null//LC:3735
     * @param open  the String before the substring, may be null//LC:3736
     * @param close  the String after the substring, may be null//LC:3737
     * @return the substring, {@code null} if no match//LC:3738
     * @since 2.0//LC:3739
     *///LC:3740
    public static String substringBetween(final String str, final String open, final String close) {//LC:3741
        if (str == null || open == null || close == null) {//LC:3742
            return null;//LC:3743
        }//LC:3744
        final int start = str.indexOf(open);//LC:3745
        if (start != INDEX_NOT_FOUND) {//LC:3746
            final int end = str.indexOf(close, start + open.length());//LC:3747
            if (end != INDEX_NOT_FOUND) {//LC:3748
                return str.substring(start + open.length(), end);//LC:3749
            }//LC:3750
        }//LC:3751
        return null;//LC:3752
    }//LC:3753
//LC:3754
    /**//LC:3755
     * <p>Searches a String for substrings delimited by a start and end tag,//LC:3756
     * returning all matching substrings in an array.</p>//LC:3757
     *//LC:3758
     * <p>A {@code null} input String returns {@code null}.//LC:3759
     * A {@code null} open/close returns {@code null} (no match).//LC:3760
     * An empty ("") open/close returns {@code null} (no match).</p>//LC:3761
     *//LC:3762
     * <pre>//LC:3763
     * StringUtils.substringsBetween("[a][b][c]", "[", "]") = ["a","b","c"]//LC:3764
     * StringUtils.substringsBetween(null, *, *)            = null//LC:3765
     * StringUtils.substringsBetween(*, null, *)            = null//LC:3766
     * StringUtils.substringsBetween(*, *, null)            = null//LC:3767
     * StringUtils.substringsBetween("", "[", "]")          = []//LC:3768
     * </pre>//LC:3769
     *//LC:3770
     * @param str  the String containing the substrings, null returns null, empty returns empty//LC:3771
     * @param open  the String identifying the start of the substring, empty returns null//LC:3772
     * @param close  the String identifying the end of the substring, empty returns null//LC:3773
     * @return a String Array of substrings, or {@code null} if no match//LC:3774
     * @since 2.3//LC:3775
     *///LC:3776
    public static String[] substringsBetween(final String str, final String open, final String close) {//LC:3777
        if (str == null || isEmpty(open) || isEmpty(close)) {//LC:3778
            return null;//LC:3779
        }//LC:3780
        final int strLen = str.length();//LC:3781
        if (strLen == 0) {//LC:3782
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:3783
        }//LC:3784
        final int closeLen = close.length();//LC:3785
        final int openLen = open.length();//LC:3786
        final List<String> list = new ArrayList<String>();//LC:3787
        int pos = 0;//LC:3788
        while (pos < strLen - closeLen) {//LC:3789
            int start = str.indexOf(open, pos);//LC:3790
            if (start < 0) {//LC:3791
                break;//LC:3792
            }//LC:3793
            start += openLen;//LC:3794
            final int end = str.indexOf(close, start);//LC:3795
            if (end < 0) {//LC:3796
                break;//LC:3797
            }//LC:3798
            list.add(str.substring(start, end));//LC:3799
            pos = end + closeLen;//LC:3800
        }//LC:3801
        if (list.isEmpty()) {//LC:3802
            return null;//LC:3803
        }//LC:3804
        return list.toArray(new String [list.size()]);//LC:3805
    }//LC:3806
//LC:3807
    // Nested extraction//LC:3808
    //-----------------------------------------------------------------------//LC:3809
//LC:3810
    // Splitting//LC:3811
    //-----------------------------------------------------------------------//LC:3812
    /**//LC:3813
     * <p>Splits the provided text into an array, using whitespace as the//LC:3814
     * separator.//LC:3815
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:3816
     *//LC:3817
     * <p>The separator is not included in the returned String array.//LC:3818
     * Adjacent separators are treated as one separator.//LC:3819
     * For more control over the split use the StrTokenizer class.</p>//LC:3820
     *//LC:3821
     * <p>A {@code null} input String returns {@code null}.</p>//LC:3822
     *//LC:3823
     * <pre>//LC:3824
     * StringUtils.split(null)       = null//LC:3825
     * StringUtils.split("")         = []//LC:3826
     * StringUtils.split("abc def")  = ["abc", "def"]//LC:3827
     * StringUtils.split("abc  def") = ["abc", "def"]//LC:3828
     * StringUtils.split(" abc ")    = ["abc"]//LC:3829
     * </pre>//LC:3830
     *//LC:3831
     * @param str  the String to parse, may be null//LC:3832
     * @return an array of parsed Strings, {@code null} if null String input//LC:3833
     *///LC:3834
    public static String[] split(final String str) {//LC:3835
        return split(str, null, -1);//LC:3836
    }//LC:3837
//LC:3838
    /**//LC:3839
     * <p>Splits the provided text into an array, separator specified.//LC:3840
     * This is an alternative to using StringTokenizer.</p>//LC:3841
     *//LC:3842
     * <p>The separator is not included in the returned String array.//LC:3843
     * Adjacent separators are treated as one separator.//LC:3844
     * For more control over the split use the StrTokenizer class.</p>//LC:3845
     *//LC:3846
     * <p>A {@code null} input String returns {@code null}.</p>//LC:3847
     *//LC:3848
     * <pre>//LC:3849
     * StringUtils.split(null, *)         = null//LC:3850
     * StringUtils.split("", *)           = []//LC:3851
     * StringUtils.split("a.b.c", '.')    = ["a", "b", "c"]//LC:3852
     * StringUtils.split("a..b.c", '.')   = ["a", "b", "c"]//LC:3853
     * StringUtils.split("a:b:c", '.')    = ["a:b:c"]//LC:3854
     * StringUtils.split("a b c", ' ')    = ["a", "b", "c"]//LC:3855
     * </pre>//LC:3856
     *//LC:3857
     * @param str  the String to parse, may be null//LC:3858
     * @param separatorChar  the character used as the delimiter//LC:3859
     * @return an array of parsed Strings, {@code null} if null String input//LC:3860
     * @since 2.0//LC:3861
     *///LC:3862
    public static String[] split(final String str, final char separatorChar) {//LC:3863
        return splitWorker(str, separatorChar, false);//LC:3864
    }//LC:3865
//LC:3866
    /**//LC:3867
     * <p>Splits the provided text into an array, separators specified.//LC:3868
     * This is an alternative to using StringTokenizer.</p>//LC:3869
     *//LC:3870
     * <p>The separator is not included in the returned String array.//LC:3871
     * Adjacent separators are treated as one separator.//LC:3872
     * For more control over the split use the StrTokenizer class.</p>//LC:3873
     *//LC:3874
     * <p>A {@code null} input String returns {@code null}.//LC:3875
     * A {@code null} separatorChars splits on whitespace.</p>//LC:3876
     *//LC:3877
     * <pre>//LC:3878
     * StringUtils.split(null, *)         = null//LC:3879
     * StringUtils.split("", *)           = []//LC:3880
     * StringUtils.split("abc def", null) = ["abc", "def"]//LC:3881
     * StringUtils.split("abc def", " ")  = ["abc", "def"]//LC:3882
     * StringUtils.split("abc  def", " ") = ["abc", "def"]//LC:3883
     * StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"]//LC:3884
     * </pre>//LC:3885
     *//LC:3886
     * @param str  the String to parse, may be null//LC:3887
     * @param separatorChars  the characters used as the delimiters,//LC:3888
     *  {@code null} splits on whitespace//LC:3889
     * @return an array of parsed Strings, {@code null} if null String input//LC:3890
     *///LC:3891
    public static String[] split(final String str, final String separatorChars) {//LC:3892
        return splitWorker(str, separatorChars, -1, false);//LC:3893
    }//LC:3894
//LC:3895
    /**//LC:3896
     * <p>Splits the provided text into an array with a maximum length,//LC:3897
     * separators specified.</p>//LC:3898
     *//LC:3899
     * <p>The separator is not included in the returned String array.//LC:3900
     * Adjacent separators are treated as one separator.</p>//LC:3901
     *//LC:3902
     * <p>A {@code null} input String returns {@code null}.//LC:3903
     * A {@code null} separatorChars splits on whitespace.</p>//LC:3904
     *//LC:3905
     * <p>If more than {@code max} delimited substrings are found, the last//LC:3906
     * returned string includes all characters after the first {@code max - 1}//LC:3907
     * returned strings (including separator characters).</p>//LC:3908
     *//LC:3909
     * <pre>//LC:3910
     * StringUtils.split(null, *, *)            = null//LC:3911
     * StringUtils.split("", *, *)              = []//LC:3912
     * StringUtils.split("ab cd ef", null, 0)   = ["ab", "cd", "ef"]//LC:3913
     * StringUtils.split("ab   cd ef", null, 0) = ["ab", "cd", "ef"]//LC:3914
     * StringUtils.split("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]//LC:3915
     * StringUtils.split("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]//LC:3916
     * </pre>//LC:3917
     *//LC:3918
     * @param str  the String to parse, may be null//LC:3919
     * @param separatorChars  the characters used as the delimiters,//LC:3920
     *  {@code null} splits on whitespace//LC:3921
     * @param max  the maximum number of elements to include in the//LC:3922
     *  array. A zero or negative value implies no limit//LC:3923
     * @return an array of parsed Strings, {@code null} if null String input//LC:3924
     *///LC:3925
    public static String[] split(final String str, final String separatorChars, final int max) {//LC:3926
        return splitWorker(str, separatorChars, max, false);//LC:3927
    }//LC:3928
//LC:3929
    /**//LC:3930
     * <p>Splits the provided text into an array, separator string specified.</p>//LC:3931
     *//LC:3932
     * <p>The separator(s) will not be included in the returned String array.//LC:3933
     * Adjacent separators are treated as one separator.</p>//LC:3934
     *//LC:3935
     * <p>A {@code null} input String returns {@code null}.//LC:3936
     * A {@code null} separator splits on whitespace.</p>//LC:3937
     *//LC:3938
     * <pre>//LC:3939
     * StringUtils.splitByWholeSeparator(null, *)               = null//LC:3940
     * StringUtils.splitByWholeSeparator("", *)                 = []//LC:3941
     * StringUtils.splitByWholeSeparator("ab de fg", null)      = ["ab", "de", "fg"]//LC:3942
     * StringUtils.splitByWholeSeparator("ab   de fg", null)    = ["ab", "de", "fg"]//LC:3943
     * StringUtils.splitByWholeSeparator("ab:cd:ef", ":")       = ["ab", "cd", "ef"]//LC:3944
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-") = ["ab", "cd", "ef"]//LC:3945
     * </pre>//LC:3946
     *//LC:3947
     * @param str  the String to parse, may be null//LC:3948
     * @param separator  String containing the String to be used as a delimiter,//LC:3949
     *  {@code null} splits on whitespace//LC:3950
     * @return an array of parsed Strings, {@code null} if null String was input//LC:3951
     *///LC:3952
    public static String[] splitByWholeSeparator(final String str, final String separator) {//LC:3953
        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;//LC:3954
    }//LC:3955
//LC:3956
    /**//LC:3957
     * <p>Splits the provided text into an array, separator string specified.//LC:3958
     * Returns a maximum of {@code max} substrings.</p>//LC:3959
     *//LC:3960
     * <p>The separator(s) will not be included in the returned String array.//LC:3961
     * Adjacent separators are treated as one separator.</p>//LC:3962
     *//LC:3963
     * <p>A {@code null} input String returns {@code null}.//LC:3964
     * A {@code null} separator splits on whitespace.</p>//LC:3965
     *//LC:3966
     * <pre>//LC:3967
     * StringUtils.splitByWholeSeparator(null, *, *)               = null//LC:3968
     * StringUtils.splitByWholeSeparator("", *, *)                 = []//LC:3969
     * StringUtils.splitByWholeSeparator("ab de fg", null, 0)      = ["ab", "de", "fg"]//LC:3970
     * StringUtils.splitByWholeSeparator("ab   de fg", null, 0)    = ["ab", "de", "fg"]//LC:3971
     * StringUtils.splitByWholeSeparator("ab:cd:ef", ":", 2)       = ["ab", "cd:ef"]//LC:3972
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-", 5) = ["ab", "cd", "ef"]//LC:3973
     * StringUtils.splitByWholeSeparator("ab-!-cd-!-ef", "-!-", 2) = ["ab", "cd-!-ef"]//LC:3974
     * </pre>//LC:3975
     *//LC:3976
     * @param str  the String to parse, may be null//LC:3977
     * @param separator  String containing the String to be used as a delimiter,//LC:3978
     *  {@code null} splits on whitespace//LC:3979
     * @param max  the maximum number of elements to include in the returned//LC:3980
     *  array. A zero or negative value implies no limit.//LC:3981
     * @return an array of parsed Strings, {@code null} if null String was input//LC:3982
     *///LC:3983
    public static String[] splitByWholeSeparator( final String str, final String separator, final int max ) {//LC:3984
        return splitByWholeSeparatorWorker(str, separator, max, false);//LC:3985
    }//LC:3986
//LC:3987
    /**//LC:3988
     * <p>Splits the provided text into an array, separator string specified. </p>//LC:3989
     *//LC:3990
     * <p>The separator is not included in the returned String array.//LC:3991
     * Adjacent separators are treated as separators for empty tokens.//LC:3992
     * For more control over the split use the StrTokenizer class.</p>//LC:3993
     *//LC:3994
     * <p>A {@code null} input String returns {@code null}.//LC:3995
     * A {@code null} separator splits on whitespace.</p>//LC:3996
     *//LC:3997
     * <pre>//LC:3998
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null//LC:3999
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("", *)                 = []//LC:4000
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null)      = ["ab", "de", "fg"]//LC:4001
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab   de fg", null)    = ["ab", "", "", "de", "fg"]//LC:4002
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab:cd:ef", ":")       = ["ab", "cd", "ef"]//LC:4003
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-") = ["ab", "cd", "ef"]//LC:4004
     * </pre>//LC:4005
     *//LC:4006
     * @param str  the String to parse, may be null//LC:4007
     * @param separator  String containing the String to be used as a delimiter,//LC:4008
     *  {@code null} splits on whitespace//LC:4009
     * @return an array of parsed Strings, {@code null} if null String was input//LC:4010
     * @since 2.4//LC:4011
     *///LC:4012
    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {//LC:4013
        return splitByWholeSeparatorWorker(str, separator, -1, true);//LC:4014
    }//LC:4015
//LC:4016
    /**//LC:4017
     * <p>Splits the provided text into an array, separator string specified.//LC:4018
     * Returns a maximum of {@code max} substrings.</p>//LC:4019
     *//LC:4020
     * <p>The separator is not included in the returned String array.//LC:4021
     * Adjacent separators are treated as separators for empty tokens.//LC:4022
     * For more control over the split use the StrTokenizer class.</p>//LC:4023
     *//LC:4024
     * <p>A {@code null} input String returns {@code null}.//LC:4025
     * A {@code null} separator splits on whitespace.</p>//LC:4026
     *//LC:4027
     * <pre>//LC:4028
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null//LC:4029
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("", *, *)                 = []//LC:4030
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null, 0)      = ["ab", "de", "fg"]//LC:4031
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab   de fg", null, 0)    = ["ab", "", "", "de", "fg"]//LC:4032
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab:cd:ef", ":", 2)       = ["ab", "cd:ef"]//LC:4033
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-", 5) = ["ab", "cd", "ef"]//LC:4034
     * StringUtils.splitByWholeSeparatorPreserveAllTokens("ab-!-cd-!-ef", "-!-", 2) = ["ab", "cd-!-ef"]//LC:4035
     * </pre>//LC:4036
     *//LC:4037
     * @param str  the String to parse, may be null//LC:4038
     * @param separator  String containing the String to be used as a delimiter,//LC:4039
     *  {@code null} splits on whitespace//LC:4040
     * @param max  the maximum number of elements to include in the returned//LC:4041
     *  array. A zero or negative value implies no limit.//LC:4042
     * @return an array of parsed Strings, {@code null} if null String was input//LC:4043
     * @since 2.4//LC:4044
     *///LC:4045
    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {//LC:4046
        return splitByWholeSeparatorWorker(str, separator, max, true);//LC:4047
    }//LC:4048
//LC:4049
    /**//LC:4050
     * Performs the logic for the {@code splitByWholeSeparatorPreserveAllTokens} methods.//LC:4051
     *//LC:4052
     * @param str  the String to parse, may be {@code null}//LC:4053
     * @param separator  String containing the String to be used as a delimiter,//LC:4054
     *  {@code null} splits on whitespace//LC:4055
     * @param max  the maximum number of elements to include in the returned//LC:4056
     *  array. A zero or negative value implies no limit.//LC:4057
     * @param preserveAllTokens if {@code true}, adjacent separators are//LC:4058
     * treated as empty token separators; if {@code false}, adjacent//LC:4059
     * separators are treated as one separator.//LC:4060
     * @return an array of parsed Strings, {@code null} if null String input//LC:4061
     * @since 2.4//LC:4062
     *///LC:4063
    private static String[] splitByWholeSeparatorWorker(//LC:4064
            final String str, final String separator, final int max, final boolean preserveAllTokens) {//LC:4065
        if (str == null) {//LC:4066
            return null;//LC:4067
        }//LC:4068
//LC:4069
        final int len = str.length();//LC:4070
//LC:4071
        if (len == 0) {//LC:4072
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:4073
        }//LC:4074
//LC:4075
        if (separator == null || EMPTY.equals(separator)) {//LC:4076
            // Split on whitespace.//LC:4077
            return splitWorker(str, null, max, preserveAllTokens);//LC:4078
        }//LC:4079
//LC:4080
        final int separatorLength = separator.length();//LC:4081
//LC:4082
        final ArrayList<String> substrings = new ArrayList<String>();//LC:4083
        int numberOfSubstrings = 0;//LC:4084
        int beg = 0;//LC:4085
        int end = 0;//LC:4086
        while (end < len) {//LC:4087
            end = str.indexOf(separator, beg);//LC:4088
//LC:4089
            if (end > -1) {//LC:4090
                if (end > beg) {//LC:4091
                    numberOfSubstrings += 1;//LC:4092
//LC:4093
                    if (numberOfSubstrings == max) {//LC:4094
                        end = len;//LC:4095
                        substrings.add(str.substring(beg));//LC:4096
                    } else {//LC:4097
                        // The following is OK, because String.substring( beg, end ) excludes//LC:4098
                        // the character at the position 'end'.//LC:4099
                        substrings.add(str.substring(beg, end));//LC:4100
//LC:4101
                        // Set the starting point for the next search.//LC:4102
                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,//LC:4103
                        // which is the right calculation://LC:4104
                        beg = end + separatorLength;//LC:4105
                    }//LC:4106
                } else {//LC:4107
                    // We found a consecutive occurrence of the separator, so skip it.//LC:4108
                    if (preserveAllTokens) {//LC:4109
                        numberOfSubstrings += 1;//LC:4110
                        if (numberOfSubstrings == max) {//LC:4111
                            end = len;//LC:4112
                            substrings.add(str.substring(beg));//LC:4113
                        } else {//LC:4114
                            substrings.add(EMPTY);//LC:4115
                        }//LC:4116
                    }//LC:4117
                    beg = end + separatorLength;//LC:4118
                }//LC:4119
            } else {//LC:4120
                // String.substring( beg ) goes from 'beg' to the end of the String.//LC:4121
                substrings.add(str.substring(beg));//LC:4122
                end = len;//LC:4123
            }//LC:4124
        }//LC:4125
//LC:4126
        return substrings.toArray(new String[substrings.size()]);//LC:4127
    }//LC:4128
//LC:4129
    // -----------------------------------------------------------------------//LC:4130
    /**//LC:4131
     * <p>Splits the provided text into an array, using whitespace as the//LC:4132
     * separator, preserving all tokens, including empty tokens created by//LC:4133
     * adjacent separators. This is an alternative to using StringTokenizer.//LC:4134
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>//LC:4135
     *//LC:4136
     * <p>The separator is not included in the returned String array.//LC:4137
     * Adjacent separators are treated as separators for empty tokens.//LC:4138
     * For more control over the split use the StrTokenizer class.</p>//LC:4139
     *//LC:4140
     * <p>A {@code null} input String returns {@code null}.</p>//LC:4141
     *//LC:4142
     * <pre>//LC:4143
     * StringUtils.splitPreserveAllTokens(null)       = null//LC:4144
     * StringUtils.splitPreserveAllTokens("")         = []//LC:4145
     * StringUtils.splitPreserveAllTokens("abc def")  = ["abc", "def"]//LC:4146
     * StringUtils.splitPreserveAllTokens("abc  def") = ["abc", "", "def"]//LC:4147
     * StringUtils.splitPreserveAllTokens(" abc ")    = ["", "abc", ""]//LC:4148
     * </pre>//LC:4149
     *//LC:4150
     * @param str  the String to parse, may be {@code null}//LC:4151
     * @return an array of parsed Strings, {@code null} if null String input//LC:4152
     * @since 2.1//LC:4153
     *///LC:4154
    public static String[] splitPreserveAllTokens(final String str) {//LC:4155
        return splitWorker(str, null, -1, true);//LC:4156
    }//LC:4157
//LC:4158
    /**//LC:4159
     * <p>Splits the provided text into an array, separator specified,//LC:4160
     * preserving all tokens, including empty tokens created by adjacent//LC:4161
     * separators. This is an alternative to using StringTokenizer.</p>//LC:4162
     *//LC:4163
     * <p>The separator is not included in the returned String array.//LC:4164
     * Adjacent separators are treated as separators for empty tokens.//LC:4165
     * For more control over the split use the StrTokenizer class.</p>//LC:4166
     *//LC:4167
     * <p>A {@code null} input String returns {@code null}.</p>//LC:4168
     *//LC:4169
     * <pre>//LC:4170
     * StringUtils.splitPreserveAllTokens(null, *)         = null//LC:4171
     * StringUtils.splitPreserveAllTokens("", *)           = []//LC:4172
     * StringUtils.splitPreserveAllTokens("a.b.c", '.')    = ["a", "b", "c"]//LC:4173
     * StringUtils.splitPreserveAllTokens("a..b.c", '.')   = ["a", "", "b", "c"]//LC:4174
     * StringUtils.splitPreserveAllTokens("a:b:c", '.')    = ["a:b:c"]//LC:4175
     * StringUtils.splitPreserveAllTokens("a\tb\nc", null) = ["a", "b", "c"]//LC:4176
     * StringUtils.splitPreserveAllTokens("a b c", ' ')    = ["a", "b", "c"]//LC:4177
     * StringUtils.splitPreserveAllTokens("a b c ", ' ')   = ["a", "b", "c", ""]//LC:4178
     * StringUtils.splitPreserveAllTokens("a b c  ", ' ')   = ["a", "b", "c", "", ""]//LC:4179
     * StringUtils.splitPreserveAllTokens(" a b c", ' ')   = ["", a", "b", "c"]//LC:4180
     * StringUtils.splitPreserveAllTokens("  a b c", ' ')  = ["", "", a", "b", "c"]//LC:4181
     * StringUtils.splitPreserveAllTokens(" a b c ", ' ')  = ["", a", "b", "c", ""]//LC:4182
     * </pre>//LC:4183
     *//LC:4184
     * @param str  the String to parse, may be {@code null}//LC:4185
     * @param separatorChar  the character used as the delimiter,//LC:4186
     *  {@code null} splits on whitespace//LC:4187
     * @return an array of parsed Strings, {@code null} if null String input//LC:4188
     * @since 2.1//LC:4189
     *///LC:4190
    public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {//LC:4191
        return splitWorker(str, separatorChar, true);//LC:4192
    }//LC:4193
//LC:4194
    /**//LC:4195
     * Performs the logic for the {@code split} and//LC:4196
     * {@code splitPreserveAllTokens} methods that do not return a//LC:4197
     * maximum array length.//LC:4198
     *//LC:4199
     * @param str  the String to parse, may be {@code null}//LC:4200
     * @param separatorChar the separate character//LC:4201
     * @param preserveAllTokens if {@code true}, adjacent separators are//LC:4202
     * treated as empty token separators; if {@code false}, adjacent//LC:4203
     * separators are treated as one separator.//LC:4204
     * @return an array of parsed Strings, {@code null} if null String input//LC:4205
     *///LC:4206
    private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {//LC:4207
        // Performance tuned for 2.0 (JDK1.4)//LC:4208
//LC:4209
        if (str == null) {//LC:4210
            return null;//LC:4211
        }//LC:4212
        final int len = str.length();//LC:4213
        if (len == 0) {//LC:4214
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:4215
        }//LC:4216
        final List<String> list = new ArrayList<String>();//LC:4217
        int i = 0, start = 0;//LC:4218
        boolean match = false;//LC:4219
        boolean lastMatch = false;//LC:4220
        while (i < len) {//LC:4221
            if (str.charAt(i) == separatorChar) {//LC:4222
                if (match || preserveAllTokens) {//LC:4223
                    list.add(str.substring(start, i));//LC:4224
                    match = false;//LC:4225
                    lastMatch = true;//LC:4226
                }//LC:4227
                start = ++i;//LC:4228
                continue;//LC:4229
            }//LC:4230
            lastMatch = false;//LC:4231
            match = true;//LC:4232
            i++;//LC:4233
        }//LC:4234
        if (match || preserveAllTokens && lastMatch) {//LC:4235
            list.add(str.substring(start, i));//LC:4236
        }//LC:4237
        return list.toArray(new String[list.size()]);//LC:4238
    }//LC:4239
//LC:4240
    /**//LC:4241
     * <p>Splits the provided text into an array, separators specified,//LC:4242
     * preserving all tokens, including empty tokens created by adjacent//LC:4243
     * separators. This is an alternative to using StringTokenizer.</p>//LC:4244
     *//LC:4245
     * <p>The separator is not included in the returned String array.//LC:4246
     * Adjacent separators are treated as separators for empty tokens.//LC:4247
     * For more control over the split use the StrTokenizer class.</p>//LC:4248
     *//LC:4249
     * <p>A {@code null} input String returns {@code null}.//LC:4250
     * A {@code null} separatorChars splits on whitespace.</p>//LC:4251
     *//LC:4252
     * <pre>//LC:4253
     * StringUtils.splitPreserveAllTokens(null, *)           = null//LC:4254
     * StringUtils.splitPreserveAllTokens("", *)             = []//LC:4255
     * StringUtils.splitPreserveAllTokens("abc def", null)   = ["abc", "def"]//LC:4256
     * StringUtils.splitPreserveAllTokens("abc def", " ")    = ["abc", "def"]//LC:4257
     * StringUtils.splitPreserveAllTokens("abc  def", " ")   = ["abc", "", def"]//LC:4258
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":")   = ["ab", "cd", "ef"]//LC:4259
     * StringUtils.splitPreserveAllTokens("ab:cd:ef:", ":")  = ["ab", "cd", "ef", ""]//LC:4260
     * StringUtils.splitPreserveAllTokens("ab:cd:ef::", ":") = ["ab", "cd", "ef", "", ""]//LC:4261
     * StringUtils.splitPreserveAllTokens("ab::cd:ef", ":")  = ["ab", "", cd", "ef"]//LC:4262
     * StringUtils.splitPreserveAllTokens(":cd:ef", ":")     = ["", cd", "ef"]//LC:4263
     * StringUtils.splitPreserveAllTokens("::cd:ef", ":")    = ["", "", cd", "ef"]//LC:4264
     * StringUtils.splitPreserveAllTokens(":cd:ef:", ":")    = ["", cd", "ef", ""]//LC:4265
     * </pre>//LC:4266
     *//LC:4267
     * @param str  the String to parse, may be {@code null}//LC:4268
     * @param separatorChars  the characters used as the delimiters,//LC:4269
     *  {@code null} splits on whitespace//LC:4270
     * @return an array of parsed Strings, {@code null} if null String input//LC:4271
     * @since 2.1//LC:4272
     *///LC:4273
    public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {//LC:4274
        return splitWorker(str, separatorChars, -1, true);//LC:4275
    }//LC:4276
//LC:4277
    /**//LC:4278
     * <p>Splits the provided text into an array with a maximum length,//LC:4279
     * separators specified, preserving all tokens, including empty tokens//LC:4280
     * created by adjacent separators.</p>//LC:4281
     *//LC:4282
     * <p>The separator is not included in the returned String array.//LC:4283
     * Adjacent separators are treated as separators for empty tokens.//LC:4284
     * Adjacent separators are treated as one separator.</p>//LC:4285
     *//LC:4286
     * <p>A {@code null} input String returns {@code null}.//LC:4287
     * A {@code null} separatorChars splits on whitespace.</p>//LC:4288
     *//LC:4289
     * <p>If more than {@code max} delimited substrings are found, the last//LC:4290
     * returned string includes all characters after the first {@code max - 1}//LC:4291
     * returned strings (including separator characters).</p>//LC:4292
     *//LC:4293
     * <pre>//LC:4294
     * StringUtils.splitPreserveAllTokens(null, *, *)            = null//LC:4295
     * StringUtils.splitPreserveAllTokens("", *, *)              = []//LC:4296
     * StringUtils.splitPreserveAllTokens("ab de fg", null, 0)   = ["ab", "cd", "ef"]//LC:4297
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 0) = ["ab", "cd", "ef"]//LC:4298
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]//LC:4299
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]//LC:4300
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 2) = ["ab", "  de fg"]//LC:4301
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 3) = ["ab", "", " de fg"]//LC:4302
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 4) = ["ab", "", "", "de fg"]//LC:4303
     * </pre>//LC:4304
     *//LC:4305
     * @param str  the String to parse, may be {@code null}//LC:4306
     * @param separatorChars  the characters used as the delimiters,//LC:4307
     *  {@code null} splits on whitespace//LC:4308
     * @param max  the maximum number of elements to include in the//LC:4309
     *  array. A zero or negative value implies no limit//LC:4310
     * @return an array of parsed Strings, {@code null} if null String input//LC:4311
     * @since 2.1//LC:4312
     *///LC:4313
    public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {//LC:4314
        return splitWorker(str, separatorChars, max, true);//LC:4315
    }//LC:4316
//LC:4317
    /**//LC:4318
     * Performs the logic for the {@code split} and//LC:4319
     * {@code splitPreserveAllTokens} methods that return a maximum array//LC:4320
     * length.//LC:4321
     *//LC:4322
     * @param str  the String to parse, may be {@code null}//LC:4323
     * @param separatorChars the separate character//LC:4324
     * @param max  the maximum number of elements to include in the//LC:4325
     *  array. A zero or negative value implies no limit.//LC:4326
     * @param preserveAllTokens if {@code true}, adjacent separators are//LC:4327
     * treated as empty token separators; if {@code false}, adjacent//LC:4328
     * separators are treated as one separator.//LC:4329
     * @return an array of parsed Strings, {@code null} if null String input//LC:4330
     *///LC:4331
    private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {//LC:4332
        // Performance tuned for 2.0 (JDK1.4)//LC:4333
        // Direct code is quicker than StringTokenizer.//LC:4334
        // Also, StringTokenizer uses isSpace() not isWhitespace()//LC:4335
//LC:4336
        if (str == null) {//LC:4337
            return null;//LC:4338
        }//LC:4339
        final int len = str.length();//LC:4340
        if (len == 0) {//LC:4341
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:4342
        }//LC:4343
        final List<String> list = new ArrayList<String>();//LC:4344
        int sizePlus1 = 1;//LC:4345
        int i = 0, start = 0;//LC:4346
        boolean match = false;//LC:4347
        boolean lastMatch = false;//LC:4348
        if (separatorChars == null) {//LC:4349
            // Null separator means use whitespace//LC:4350
            while (i < len) {//LC:4351
                if (Character.isWhitespace(str.charAt(i))) {//LC:4352
                    if (match || preserveAllTokens) {//LC:4353
                        lastMatch = true;//LC:4354
                        if (sizePlus1++ == max) {//LC:4355
                            i = len;//LC:4356
                            lastMatch = false;//LC:4357
                        }//LC:4358
                        list.add(str.substring(start, i));//LC:4359
                        match = false;//LC:4360
                    }//LC:4361
                    start = ++i;//LC:4362
                    continue;//LC:4363
                }//LC:4364
                lastMatch = false;//LC:4365
                match = true;//LC:4366
                i++;//LC:4367
            }//LC:4368
        } else if (separatorChars.length() == 1) {//LC:4369
            // Optimise 1 character case//LC:4370
            final char sep = separatorChars.charAt(0);//LC:4371
            while (i < len) {//LC:4372
                if (str.charAt(i) == sep) {//LC:4373
                    if (match || preserveAllTokens) {//LC:4374
                        lastMatch = true;//LC:4375
                        if (sizePlus1++ == max) {//LC:4376
                            i = len;//LC:4377
                            lastMatch = false;//LC:4378
                        }//LC:4379
                        list.add(str.substring(start, i));//LC:4380
                        match = false;//LC:4381
                    }//LC:4382
                    start = ++i;//LC:4383
                    continue;//LC:4384
                }//LC:4385
                lastMatch = false;//LC:4386
                match = true;//LC:4387
                i++;//LC:4388
            }//LC:4389
        } else {//LC:4390
            // standard case//LC:4391
            while (i < len) {//LC:4392
                if (separatorChars.indexOf(str.charAt(i)) >= 0) {//LC:4393
                    if (match || preserveAllTokens) {//LC:4394
                        lastMatch = true;//LC:4395
                        if (sizePlus1++ == max) {//LC:4396
                            i = len;//LC:4397
                            lastMatch = false;//LC:4398
                        }//LC:4399
                        list.add(str.substring(start, i));//LC:4400
                        match = false;//LC:4401
                    }//LC:4402
                    start = ++i;//LC:4403
                    continue;//LC:4404
                }//LC:4405
                lastMatch = false;//LC:4406
                match = true;//LC:4407
                i++;//LC:4408
            }//LC:4409
        }//LC:4410
        if (match || preserveAllTokens && lastMatch) {//LC:4411
            list.add(str.substring(start, i));//LC:4412
        }//LC:4413
        return list.toArray(new String[list.size()]);//LC:4414
    }//LC:4415
//LC:4416
    /**//LC:4417
     * <p>Splits a String by Character type as returned by//LC:4418
     * {@code java.lang.Character.getType(char)}. Groups of contiguous//LC:4419
     * characters of the same type are returned as complete tokens.//LC:4420
     * <pre>//LC:4421
     * StringUtils.splitByCharacterType(null)         = null//LC:4422
     * StringUtils.splitByCharacterType("")           = []//LC:4423
     * StringUtils.splitByCharacterType("ab de fg")   = ["ab", " ", "de", " ", "fg"]//LC:4424
     * StringUtils.splitByCharacterType("ab   de fg") = ["ab", "   ", "de", " ", "fg"]//LC:4425
     * StringUtils.splitByCharacterType("ab:cd:ef")   = ["ab", ":", "cd", ":", "ef"]//LC:4426
     * StringUtils.splitByCharacterType("number5")    = ["number", "5"]//LC:4427
     * StringUtils.splitByCharacterType("fooBar")     = ["foo", "B", "ar"]//LC:4428
     * StringUtils.splitByCharacterType("foo200Bar")  = ["foo", "200", "B", "ar"]//LC:4429
     * StringUtils.splitByCharacterType("ASFRules")   = ["ASFR", "ules"]//LC:4430
     * </pre>//LC:4431
     * @param str the String to split, may be {@code null}//LC:4432
     * @return an array of parsed Strings, {@code null} if null String input//LC:4433
     * @since 2.4//LC:4434
     *///LC:4435
    public static String[] splitByCharacterType(final String str) {//LC:4436
        return splitByCharacterType(str, false);//LC:4437
    }//LC:4438
//LC:4439
    /**//LC:4440
     * <p>Splits a String by Character type as returned by//LC:4441
     * {@code java.lang.Character.getType(char)}. Groups of contiguous//LC:4442
     * characters of the same type are returned as complete tokens, with the//LC:4443
     * following exception: the character of type//LC:4444
     * {@code Character.UPPERCASE_LETTER}, if any, immediately//LC:4445
     * preceding a token of type {@code Character.LOWERCASE_LETTER}//LC:4446
     * will belong to the following token rather than to the preceding, if any,//LC:4447
     * {@code Character.UPPERCASE_LETTER} token.//LC:4448
     * <pre>//LC:4449
     * StringUtils.splitByCharacterTypeCamelCase(null)         = null//LC:4450
     * StringUtils.splitByCharacterTypeCamelCase("")           = []//LC:4451
     * StringUtils.splitByCharacterTypeCamelCase("ab de fg")   = ["ab", " ", "de", " ", "fg"]//LC:4452
     * StringUtils.splitByCharacterTypeCamelCase("ab   de fg") = ["ab", "   ", "de", " ", "fg"]//LC:4453
     * StringUtils.splitByCharacterTypeCamelCase("ab:cd:ef")   = ["ab", ":", "cd", ":", "ef"]//LC:4454
     * StringUtils.splitByCharacterTypeCamelCase("number5")    = ["number", "5"]//LC:4455
     * StringUtils.splitByCharacterTypeCamelCase("fooBar")     = ["foo", "Bar"]//LC:4456
     * StringUtils.splitByCharacterTypeCamelCase("foo200Bar")  = ["foo", "200", "Bar"]//LC:4457
     * StringUtils.splitByCharacterTypeCamelCase("ASFRules")   = ["ASF", "Rules"]//LC:4458
     * </pre>//LC:4459
     * @param str the String to split, may be {@code null}//LC:4460
     * @return an array of parsed Strings, {@code null} if null String input//LC:4461
     * @since 2.4//LC:4462
     *///LC:4463
    public static String[] splitByCharacterTypeCamelCase(final String str) {//LC:4464
        return splitByCharacterType(str, true);//LC:4465
    }//LC:4466
//LC:4467
    /**//LC:4468
     * <p>Splits a String by Character type as returned by//LC:4469
     * {@code java.lang.Character.getType(char)}. Groups of contiguous//LC:4470
     * characters of the same type are returned as complete tokens, with the//LC:4471
     * following exception: if {@code camelCase} is {@code true},//LC:4472
     * the character of type {@code Character.UPPERCASE_LETTER}, if any,//LC:4473
     * immediately preceding a token of type {@code Character.LOWERCASE_LETTER}//LC:4474
     * will belong to the following token rather than to the preceding, if any,//LC:4475
     * {@code Character.UPPERCASE_LETTER} token.//LC:4476
     * @param str the String to split, may be {@code null}//LC:4477
     * @param camelCase whether to use so-called "camel-case" for letter types//LC:4478
     * @return an array of parsed Strings, {@code null} if null String input//LC:4479
     * @since 2.4//LC:4480
     *///LC:4481
    private static String[] splitByCharacterType(final String str, final boolean camelCase) {//LC:4482
        if (str == null) {//LC:4483
            return null;//LC:4484
        }//LC:4485
        if (str.isEmpty()) {//LC:4486
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:4487
        }//LC:4488
        final char[] c = str.toCharArray();//LC:4489
        final List<String> list = new ArrayList<String>();//LC:4490
        int tokenStart = 0;//LC:4491
        int currentType = Character.getType(c[tokenStart]);//LC:4492
        for (int pos = tokenStart + 1; pos < c.length; pos++) {//LC:4493
            final int type = Character.getType(c[pos]);//LC:4494
            if (type == currentType) {//LC:4495
                continue;//LC:4496
            }//LC:4497
            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {//LC:4498
                final int newTokenStart = pos - 1;//LC:4499
                if (newTokenStart != tokenStart) {//LC:4500
                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));//LC:4501
                    tokenStart = newTokenStart;//LC:4502
                }//LC:4503
            } else {//LC:4504
                list.add(new String(c, tokenStart, pos - tokenStart));//LC:4505
                tokenStart = pos;//LC:4506
            }//LC:4507
            currentType = type;//LC:4508
        }//LC:4509
        list.add(new String(c, tokenStart, c.length - tokenStart));//LC:4510
        return list.toArray(new String[list.size()]);//LC:4511
    }//LC:4512
//LC:4513
    // Joining//LC:4514
    //-----------------------------------------------------------------------//LC:4515
    /**//LC:4516
     * <p>Joins the elements of the provided array into a single String//LC:4517
     * containing the provided list of elements.</p>//LC:4518
     *//LC:4519
     * <p>No separator is added to the joined String.//LC:4520
     * Null objects or empty strings within the array are represented by//LC:4521
     * empty strings.</p>//LC:4522
     *//LC:4523
     * <pre>//LC:4524
     * StringUtils.join(null)            = null//LC:4525
     * StringUtils.join([])              = ""//LC:4526
     * StringUtils.join([null])          = ""//LC:4527
     * StringUtils.join(["a", "b", "c"]) = "abc"//LC:4528
     * StringUtils.join([null, "", "a"]) = "a"//LC:4529
     * </pre>//LC:4530
     *//LC:4531
     * @param <T> the specific type of values to join together//LC:4532
     * @param elements  the values to join together, may be null//LC:4533
     * @return the joined String, {@code null} if null array input//LC:4534
     * @since 2.0//LC:4535
     * @since 3.0 Changed signature to use varargs//LC:4536
     *///LC:4537
    public static <T> String join(final T... elements) {//LC:4538
        return join(elements, null);//LC:4539
    }//LC:4540
//LC:4541
    /**//LC:4542
     * <p>Joins the elements of the provided array into a single String//LC:4543
     * containing the provided list of elements.</p>//LC:4544
     *//LC:4545
     * <p>No delimiter is added before or after the list.//LC:4546
     * Null objects or empty strings within the array are represented by//LC:4547
     * empty strings.</p>//LC:4548
     *//LC:4549
     * <pre>//LC:4550
     * StringUtils.join(null, *)               = null//LC:4551
     * StringUtils.join([], *)                 = ""//LC:4552
     * StringUtils.join([null], *)             = ""//LC:4553
     * StringUtils.join(["a", "b", "c"], ';')  = "a;b;c"//LC:4554
     * StringUtils.join(["a", "b", "c"], null) = "abc"//LC:4555
     * StringUtils.join([null, "", "a"], ';')  = ";;a"//LC:4556
     * </pre>//LC:4557
     *//LC:4558
     * @param array  the array of values to join together, may be null//LC:4559
     * @param separator  the separator character to use//LC:4560
     * @return the joined String, {@code null} if null array input//LC:4561
     * @since 2.0//LC:4562
     *///LC:4563
    public static String join(final Object[] array, final char separator) {//LC:4564
        if (array == null) {//LC:4565
            return null;//LC:4566
        }//LC:4567
        return join(array, separator, 0, array.length);//LC:4568
    }//LC:4569
//LC:4570
    /**//LC:4571
     * <p>//LC:4572
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4573
     * </p>//LC:4574
     *//LC:4575
     * <p>//LC:4576
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4577
     * by empty strings.//LC:4578
     * </p>//LC:4579
     *//LC:4580
     * <pre>//LC:4581
     * StringUtils.join(null, *)               = null//LC:4582
     * StringUtils.join([], *)                 = ""//LC:4583
     * StringUtils.join([null], *)             = ""//LC:4584
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4585
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4586
     * </pre>//LC:4587
     *//LC:4588
     * @param array//LC:4589
     *            the array of values to join together, may be null//LC:4590
     * @param separator//LC:4591
     *            the separator character to use//LC:4592
     * @return the joined String, {@code null} if null array input//LC:4593
     * @since 3.2//LC:4594
     *///LC:4595
    public static String join(final long[] array, final char separator) {//LC:4596
        if (array == null) {//LC:4597
            return null;//LC:4598
        }//LC:4599
        return join(array, separator, 0, array.length);//LC:4600
    }//LC:4601
//LC:4602
    /**//LC:4603
     * <p>//LC:4604
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4605
     * </p>//LC:4606
     *//LC:4607
     * <p>//LC:4608
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4609
     * by empty strings.//LC:4610
     * </p>//LC:4611
     *//LC:4612
     * <pre>//LC:4613
     * StringUtils.join(null, *)               = null//LC:4614
     * StringUtils.join([], *)                 = ""//LC:4615
     * StringUtils.join([null], *)             = ""//LC:4616
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4617
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4618
     * </pre>//LC:4619
     *//LC:4620
     * @param array//LC:4621
     *            the array of values to join together, may be null//LC:4622
     * @param separator//LC:4623
     *            the separator character to use//LC:4624
     * @return the joined String, {@code null} if null array input//LC:4625
     * @since 3.2//LC:4626
     *///LC:4627
    public static String join(final int[] array, final char separator) {//LC:4628
        if (array == null) {//LC:4629
            return null;//LC:4630
        }//LC:4631
        return join(array, separator, 0, array.length);//LC:4632
    }//LC:4633
//LC:4634
    /**//LC:4635
     * <p>//LC:4636
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4637
     * </p>//LC:4638
     *//LC:4639
     * <p>//LC:4640
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4641
     * by empty strings.//LC:4642
     * </p>//LC:4643
     *//LC:4644
     * <pre>//LC:4645
     * StringUtils.join(null, *)               = null//LC:4646
     * StringUtils.join([], *)                 = ""//LC:4647
     * StringUtils.join([null], *)             = ""//LC:4648
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4649
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4650
     * </pre>//LC:4651
     *//LC:4652
     * @param array//LC:4653
     *            the array of values to join together, may be null//LC:4654
     * @param separator//LC:4655
     *            the separator character to use//LC:4656
     * @return the joined String, {@code null} if null array input//LC:4657
     * @since 3.2//LC:4658
     *///LC:4659
    public static String join(final short[] array, final char separator) {//LC:4660
        if (array == null) {//LC:4661
            return null;//LC:4662
        }//LC:4663
        return join(array, separator, 0, array.length);//LC:4664
    }//LC:4665
//LC:4666
    /**//LC:4667
     * <p>//LC:4668
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4669
     * </p>//LC:4670
     *//LC:4671
     * <p>//LC:4672
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4673
     * by empty strings.//LC:4674
     * </p>//LC:4675
     *//LC:4676
     * <pre>//LC:4677
     * StringUtils.join(null, *)               = null//LC:4678
     * StringUtils.join([], *)                 = ""//LC:4679
     * StringUtils.join([null], *)             = ""//LC:4680
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4681
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4682
     * </pre>//LC:4683
     *//LC:4684
     * @param array//LC:4685
     *            the array of values to join together, may be null//LC:4686
     * @param separator//LC:4687
     *            the separator character to use//LC:4688
     * @return the joined String, {@code null} if null array input//LC:4689
     * @since 3.2//LC:4690
     *///LC:4691
    public static String join(final byte[] array, final char separator) {//LC:4692
        if (array == null) {//LC:4693
            return null;//LC:4694
        }//LC:4695
        return join(array, separator, 0, array.length);//LC:4696
    }//LC:4697
//LC:4698
    /**//LC:4699
     * <p>//LC:4700
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4701
     * </p>//LC:4702
     *//LC:4703
     * <p>//LC:4704
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4705
     * by empty strings.//LC:4706
     * </p>//LC:4707
     *//LC:4708
     * <pre>//LC:4709
     * StringUtils.join(null, *)               = null//LC:4710
     * StringUtils.join([], *)                 = ""//LC:4711
     * StringUtils.join([null], *)             = ""//LC:4712
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4713
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4714
     * </pre>//LC:4715
     *//LC:4716
     * @param array//LC:4717
     *            the array of values to join together, may be null//LC:4718
     * @param separator//LC:4719
     *            the separator character to use//LC:4720
     * @return the joined String, {@code null} if null array input//LC:4721
     * @since 3.2//LC:4722
     *///LC:4723
    public static String join(final char[] array, final char separator) {//LC:4724
        if (array == null) {//LC:4725
            return null;//LC:4726
        }//LC:4727
        return join(array, separator, 0, array.length);//LC:4728
    }//LC:4729
//LC:4730
    /**//LC:4731
     * <p>//LC:4732
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4733
     * </p>//LC:4734
     *//LC:4735
     * <p>//LC:4736
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4737
     * by empty strings.//LC:4738
     * </p>//LC:4739
     *//LC:4740
     * <pre>//LC:4741
     * StringUtils.join(null, *)               = null//LC:4742
     * StringUtils.join([], *)                 = ""//LC:4743
     * StringUtils.join([null], *)             = ""//LC:4744
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4745
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4746
     * </pre>//LC:4747
     *//LC:4748
     * @param array//LC:4749
     *            the array of values to join together, may be null//LC:4750
     * @param separator//LC:4751
     *            the separator character to use//LC:4752
     * @return the joined String, {@code null} if null array input//LC:4753
     * @since 3.2//LC:4754
     *///LC:4755
    public static String join(final float[] array, final char separator) {//LC:4756
        if (array == null) {//LC:4757
            return null;//LC:4758
        }//LC:4759
        return join(array, separator, 0, array.length);//LC:4760
    }//LC:4761
//LC:4762
    /**//LC:4763
     * <p>//LC:4764
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4765
     * </p>//LC:4766
     *//LC:4767
     * <p>//LC:4768
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4769
     * by empty strings.//LC:4770
     * </p>//LC:4771
     *//LC:4772
     * <pre>//LC:4773
     * StringUtils.join(null, *)               = null//LC:4774
     * StringUtils.join([], *)                 = ""//LC:4775
     * StringUtils.join([null], *)             = ""//LC:4776
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4777
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4778
     * </pre>//LC:4779
     *//LC:4780
     * @param array//LC:4781
     *            the array of values to join together, may be null//LC:4782
     * @param separator//LC:4783
     *            the separator character to use//LC:4784
     * @return the joined String, {@code null} if null array input//LC:4785
     * @since 3.2//LC:4786
     *///LC:4787
    public static String join(final double[] array, final char separator) {//LC:4788
        if (array == null) {//LC:4789
            return null;//LC:4790
        }//LC:4791
        return join(array, separator, 0, array.length);//LC:4792
    }//LC:4793
//LC:4794
//LC:4795
    /**//LC:4796
     * <p>Joins the elements of the provided array into a single String//LC:4797
     * containing the provided list of elements.</p>//LC:4798
     *//LC:4799
     * <p>No delimiter is added before or after the list.//LC:4800
     * Null objects or empty strings within the array are represented by//LC:4801
     * empty strings.</p>//LC:4802
     *//LC:4803
     * <pre>//LC:4804
     * StringUtils.join(null, *)               = null//LC:4805
     * StringUtils.join([], *)                 = ""//LC:4806
     * StringUtils.join([null], *)             = ""//LC:4807
     * StringUtils.join(["a", "b", "c"], ';')  = "a;b;c"//LC:4808
     * StringUtils.join(["a", "b", "c"], null) = "abc"//LC:4809
     * StringUtils.join([null, "", "a"], ';')  = ";;a"//LC:4810
     * </pre>//LC:4811
     *//LC:4812
     * @param array  the array of values to join together, may be null//LC:4813
     * @param separator  the separator character to use//LC:4814
     * @param startIndex the first index to start joining from.  It is//LC:4815
     * an error to pass in an end index past the end of the array//LC:4816
     * @param endIndex the index to stop joining from (exclusive). It is//LC:4817
     * an error to pass in an end index past the end of the array//LC:4818
     * @return the joined String, {@code null} if null array input//LC:4819
     * @since 2.0//LC:4820
     *///LC:4821
    public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {//LC:4822
        if (array == null) {//LC:4823
            return null;//LC:4824
        }//LC:4825
        final int noOfItems = endIndex - startIndex;//LC:4826
        if (noOfItems <= 0) {//LC:4827
            return EMPTY;//LC:4828
        }//LC:4829
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:4830
        for (int i = startIndex; i < endIndex; i++) {//LC:4831
            if (i > startIndex) {//LC:4832
                buf.append(separator);//LC:4833
            }//LC:4834
            if (array[i] != null) {//LC:4835
                buf.append(array[i]);//LC:4836
            }//LC:4837
        }//LC:4838
        return buf.toString();//LC:4839
    }//LC:4840
//LC:4841
    /**//LC:4842
     * <p>//LC:4843
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4844
     * </p>//LC:4845
     *//LC:4846
     * <p>//LC:4847
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4848
     * by empty strings.//LC:4849
     * </p>//LC:4850
     *//LC:4851
     * <pre>//LC:4852
     * StringUtils.join(null, *)               = null//LC:4853
     * StringUtils.join([], *)                 = ""//LC:4854
     * StringUtils.join([null], *)             = ""//LC:4855
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4856
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4857
     * </pre>//LC:4858
     *//LC:4859
     * @param array//LC:4860
     *            the array of values to join together, may be null//LC:4861
     * @param separator//LC:4862
     *            the separator character to use//LC:4863
     * @param startIndex//LC:4864
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:4865
     *            array//LC:4866
     * @param endIndex//LC:4867
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:4868
     *            the array//LC:4869
     * @return the joined String, {@code null} if null array input//LC:4870
     * @since 3.2//LC:4871
     *///LC:4872
    public static String join(final long[] array, final char separator, final int startIndex, final int endIndex) {//LC:4873
        if (array == null) {//LC:4874
            return null;//LC:4875
        }//LC:4876
        final int noOfItems = endIndex - startIndex;//LC:4877
        if (noOfItems <= 0) {//LC:4878
            return EMPTY;//LC:4879
        }//LC:4880
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:4881
        for (int i = startIndex; i < endIndex; i++) {//LC:4882
            if (i > startIndex) {//LC:4883
                buf.append(separator);//LC:4884
            }//LC:4885
            buf.append(array[i]);//LC:4886
        }//LC:4887
        return buf.toString();//LC:4888
    }//LC:4889
//LC:4890
    /**//LC:4891
     * <p>//LC:4892
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4893
     * </p>//LC:4894
     *//LC:4895
     * <p>//LC:4896
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4897
     * by empty strings.//LC:4898
     * </p>//LC:4899
     *//LC:4900
     * <pre>//LC:4901
     * StringUtils.join(null, *)               = null//LC:4902
     * StringUtils.join([], *)                 = ""//LC:4903
     * StringUtils.join([null], *)             = ""//LC:4904
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4905
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4906
     * </pre>//LC:4907
     *//LC:4908
     * @param array//LC:4909
     *            the array of values to join together, may be null//LC:4910
     * @param separator//LC:4911
     *            the separator character to use//LC:4912
     * @param startIndex//LC:4913
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:4914
     *            array//LC:4915
     * @param endIndex//LC:4916
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:4917
     *            the array//LC:4918
     * @return the joined String, {@code null} if null array input//LC:4919
     * @since 3.2//LC:4920
     *///LC:4921
    public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) {//LC:4922
        if (array == null) {//LC:4923
            return null;//LC:4924
        }//LC:4925
        final int noOfItems = endIndex - startIndex;//LC:4926
        if (noOfItems <= 0) {//LC:4927
            return EMPTY;//LC:4928
        }//LC:4929
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:4930
        for (int i = startIndex; i < endIndex; i++) {//LC:4931
            if (i > startIndex) {//LC:4932
                buf.append(separator);//LC:4933
            }//LC:4934
            buf.append(array[i]);//LC:4935
        }//LC:4936
        return buf.toString();//LC:4937
    }//LC:4938
//LC:4939
    /**//LC:4940
     * <p>//LC:4941
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4942
     * </p>//LC:4943
     *//LC:4944
     * <p>//LC:4945
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4946
     * by empty strings.//LC:4947
     * </p>//LC:4948
     *//LC:4949
     * <pre>//LC:4950
     * StringUtils.join(null, *)               = null//LC:4951
     * StringUtils.join([], *)                 = ""//LC:4952
     * StringUtils.join([null], *)             = ""//LC:4953
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:4954
     * StringUtils.join([1, 2, 3], null) = "123"//LC:4955
     * </pre>//LC:4956
     *//LC:4957
     * @param array//LC:4958
     *            the array of values to join together, may be null//LC:4959
     * @param separator//LC:4960
     *            the separator character to use//LC:4961
     * @param startIndex//LC:4962
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:4963
     *            array//LC:4964
     * @param endIndex//LC:4965
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:4966
     *            the array//LC:4967
     * @return the joined String, {@code null} if null array input//LC:4968
     * @since 3.2//LC:4969
     *///LC:4970
    public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) {//LC:4971
        if (array == null) {//LC:4972
            return null;//LC:4973
        }//LC:4974
        final int noOfItems = endIndex - startIndex;//LC:4975
        if (noOfItems <= 0) {//LC:4976
            return EMPTY;//LC:4977
        }//LC:4978
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:4979
        for (int i = startIndex; i < endIndex; i++) {//LC:4980
            if (i > startIndex) {//LC:4981
                buf.append(separator);//LC:4982
            }//LC:4983
            buf.append(array[i]);//LC:4984
        }//LC:4985
        return buf.toString();//LC:4986
    }//LC:4987
//LC:4988
    /**//LC:4989
     * <p>//LC:4990
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:4991
     * </p>//LC:4992
     *//LC:4993
     * <p>//LC:4994
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:4995
     * by empty strings.//LC:4996
     * </p>//LC:4997
     *//LC:4998
     * <pre>//LC:4999
     * StringUtils.join(null, *)               = null//LC:5000
     * StringUtils.join([], *)                 = ""//LC:5001
     * StringUtils.join([null], *)             = ""//LC:5002
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:5003
     * StringUtils.join([1, 2, 3], null) = "123"//LC:5004
     * </pre>//LC:5005
     *//LC:5006
     * @param array//LC:5007
     *            the array of values to join together, may be null//LC:5008
     * @param separator//LC:5009
     *            the separator character to use//LC:5010
     * @param startIndex//LC:5011
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:5012
     *            array//LC:5013
     * @param endIndex//LC:5014
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:5015
     *            the array//LC:5016
     * @return the joined String, {@code null} if null array input//LC:5017
     * @since 3.2//LC:5018
     *///LC:5019
    public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) {//LC:5020
        if (array == null) {//LC:5021
            return null;//LC:5022
        }//LC:5023
        final int noOfItems = endIndex - startIndex;//LC:5024
        if (noOfItems <= 0) {//LC:5025
            return EMPTY;//LC:5026
        }//LC:5027
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:5028
        for (int i = startIndex; i < endIndex; i++) {//LC:5029
            if (i > startIndex) {//LC:5030
                buf.append(separator);//LC:5031
            }//LC:5032
            buf.append(array[i]);//LC:5033
        }//LC:5034
        return buf.toString();//LC:5035
    }//LC:5036
//LC:5037
    /**//LC:5038
     * <p>//LC:5039
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:5040
     * </p>//LC:5041
     *//LC:5042
     * <p>//LC:5043
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:5044
     * by empty strings.//LC:5045
     * </p>//LC:5046
     *//LC:5047
     * <pre>//LC:5048
     * StringUtils.join(null, *)               = null//LC:5049
     * StringUtils.join([], *)                 = ""//LC:5050
     * StringUtils.join([null], *)             = ""//LC:5051
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:5052
     * StringUtils.join([1, 2, 3], null) = "123"//LC:5053
     * </pre>//LC:5054
     *//LC:5055
     * @param array//LC:5056
     *            the array of values to join together, may be null//LC:5057
     * @param separator//LC:5058
     *            the separator character to use//LC:5059
     * @param startIndex//LC:5060
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:5061
     *            array//LC:5062
     * @param endIndex//LC:5063
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:5064
     *            the array//LC:5065
     * @return the joined String, {@code null} if null array input//LC:5066
     * @since 3.2//LC:5067
     *///LC:5068
    public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) {//LC:5069
        if (array == null) {//LC:5070
            return null;//LC:5071
        }//LC:5072
        final int noOfItems = endIndex - startIndex;//LC:5073
        if (noOfItems <= 0) {//LC:5074
            return EMPTY;//LC:5075
        }//LC:5076
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:5077
        for (int i = startIndex; i < endIndex; i++) {//LC:5078
            if (i > startIndex) {//LC:5079
                buf.append(separator);//LC:5080
            }//LC:5081
            buf.append(array[i]);//LC:5082
        }//LC:5083
        return buf.toString();//LC:5084
    }//LC:5085
//LC:5086
    /**//LC:5087
     * <p>//LC:5088
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:5089
     * </p>//LC:5090
     *//LC:5091
     * <p>//LC:5092
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:5093
     * by empty strings.//LC:5094
     * </p>//LC:5095
     *//LC:5096
     * <pre>//LC:5097
     * StringUtils.join(null, *)               = null//LC:5098
     * StringUtils.join([], *)                 = ""//LC:5099
     * StringUtils.join([null], *)             = ""//LC:5100
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:5101
     * StringUtils.join([1, 2, 3], null) = "123"//LC:5102
     * </pre>//LC:5103
     *//LC:5104
     * @param array//LC:5105
     *            the array of values to join together, may be null//LC:5106
     * @param separator//LC:5107
     *            the separator character to use//LC:5108
     * @param startIndex//LC:5109
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:5110
     *            array//LC:5111
     * @param endIndex//LC:5112
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:5113
     *            the array//LC:5114
     * @return the joined String, {@code null} if null array input//LC:5115
     * @since 3.2//LC:5116
     *///LC:5117
    public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) {//LC:5118
        if (array == null) {//LC:5119
            return null;//LC:5120
        }//LC:5121
        final int noOfItems = endIndex - startIndex;//LC:5122
        if (noOfItems <= 0) {//LC:5123
            return EMPTY;//LC:5124
        }//LC:5125
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:5126
        for (int i = startIndex; i < endIndex; i++) {//LC:5127
            if (i > startIndex) {//LC:5128
                buf.append(separator);//LC:5129
            }//LC:5130
            buf.append(array[i]);//LC:5131
        }//LC:5132
        return buf.toString();//LC:5133
    }//LC:5134
//LC:5135
    /**//LC:5136
     * <p>//LC:5137
     * Joins the elements of the provided array into a single String containing the provided list of elements.//LC:5138
     * </p>//LC:5139
     *//LC:5140
     * <p>//LC:5141
     * No delimiter is added before or after the list. Null objects or empty strings within the array are represented//LC:5142
     * by empty strings.//LC:5143
     * </p>//LC:5144
     *//LC:5145
     * <pre>//LC:5146
     * StringUtils.join(null, *)               = null//LC:5147
     * StringUtils.join([], *)                 = ""//LC:5148
     * StringUtils.join([null], *)             = ""//LC:5149
     * StringUtils.join([1, 2, 3], ';')  = "1;2;3"//LC:5150
     * StringUtils.join([1, 2, 3], null) = "123"//LC:5151
     * </pre>//LC:5152
     *//LC:5153
     * @param array//LC:5154
     *            the array of values to join together, may be null//LC:5155
     * @param separator//LC:5156
     *            the separator character to use//LC:5157
     * @param startIndex//LC:5158
     *            the first index to start joining from. It is an error to pass in an end index past the end of the//LC:5159
     *            array//LC:5160
     * @param endIndex//LC:5161
     *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of//LC:5162
     *            the array//LC:5163
     * @return the joined String, {@code null} if null array input//LC:5164
     * @since 3.2//LC:5165
     *///LC:5166
    public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) {//LC:5167
        if (array == null) {//LC:5168
            return null;//LC:5169
        }//LC:5170
        final int noOfItems = endIndex - startIndex;//LC:5171
        if (noOfItems <= 0) {//LC:5172
            return EMPTY;//LC:5173
        }//LC:5174
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:5175
        for (int i = startIndex; i < endIndex; i++) {//LC:5176
            if (i > startIndex) {//LC:5177
                buf.append(separator);//LC:5178
            }//LC:5179
            buf.append(array[i]);//LC:5180
        }//LC:5181
        return buf.toString();//LC:5182
    }//LC:5183
//LC:5184
//LC:5185
    /**//LC:5186
     * <p>Joins the elements of the provided array into a single String//LC:5187
     * containing the provided list of elements.</p>//LC:5188
     *//LC:5189
     * <p>No delimiter is added before or after the list.//LC:5190
     * A {@code null} separator is the same as an empty String ("").//LC:5191
     * Null objects or empty strings within the array are represented by//LC:5192
     * empty strings.</p>//LC:5193
     *//LC:5194
     * <pre>//LC:5195
     * StringUtils.join(null, *)                = null//LC:5196
     * StringUtils.join([], *)                  = ""//LC:5197
     * StringUtils.join([null], *)              = ""//LC:5198
     * StringUtils.join(["a", "b", "c"], "--")  = "a--b--c"//LC:5199
     * StringUtils.join(["a", "b", "c"], null)  = "abc"//LC:5200
     * StringUtils.join(["a", "b", "c"], "")    = "abc"//LC:5201
     * StringUtils.join([null, "", "a"], ',')   = ",,a"//LC:5202
     * </pre>//LC:5203
     *//LC:5204
     * @param array  the array of values to join together, may be null//LC:5205
     * @param separator  the separator character to use, null treated as ""//LC:5206
     * @return the joined String, {@code null} if null array input//LC:5207
     *///LC:5208
    public static String join(final Object[] array, final String separator) {//LC:5209
        if (array == null) {//LC:5210
            return null;//LC:5211
        }//LC:5212
        return join(array, separator, 0, array.length);//LC:5213
    }//LC:5214
//LC:5215
    /**//LC:5216
     * <p>Joins the elements of the provided array into a single String//LC:5217
     * containing the provided list of elements.</p>//LC:5218
     *//LC:5219
     * <p>No delimiter is added before or after the list.//LC:5220
     * A {@code null} separator is the same as an empty String ("").//LC:5221
     * Null objects or empty strings within the array are represented by//LC:5222
     * empty strings.</p>//LC:5223
     *//LC:5224
     * <pre>//LC:5225
     * StringUtils.join(null, *, *, *)                = null//LC:5226
     * StringUtils.join([], *, *, *)                  = ""//LC:5227
     * StringUtils.join([null], *, *, *)              = ""//LC:5228
     * StringUtils.join(["a", "b", "c"], "--", 0, 3)  = "a--b--c"//LC:5229
     * StringUtils.join(["a", "b", "c"], "--", 1, 3)  = "b--c"//LC:5230
     * StringUtils.join(["a", "b", "c"], "--", 2, 3)  = "c"//LC:5231
     * StringUtils.join(["a", "b", "c"], "--", 2, 2)  = ""//LC:5232
     * StringUtils.join(["a", "b", "c"], null, 0, 3)  = "abc"//LC:5233
     * StringUtils.join(["a", "b", "c"], "", 0, 3)    = "abc"//LC:5234
     * StringUtils.join([null, "", "a"], ',', 0, 3)   = ",,a"//LC:5235
     * </pre>//LC:5236
     *//LC:5237
     * @param array  the array of values to join together, may be null//LC:5238
     * @param separator  the separator character to use, null treated as ""//LC:5239
     * @param startIndex the first index to start joining from.//LC:5240
     * @param endIndex the index to stop joining from (exclusive).//LC:5241
     * @return the joined String, {@code null} if null array input; or the empty string//LC:5242
     * if {@code endIndex - startIndex <= 0}. The number of joined entries is given by//LC:5243
     * {@code endIndex - startIndex}//LC:5244
     * @throws ArrayIndexOutOfBoundsException ife<br/>//LC:5245
     * {@code startIndex < 0} or <br/>//LC:5246
     * {@code startIndex >= array.length()} or <br/>//LC:5247
     * {@code endIndex < 0} or <br/>//LC:5248
     * {@code endIndex > array.length()}//LC:5249
     *///LC:5250
    public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {//LC:5251
        if (array == null) {//LC:5252
            return null;//LC:5253
        }//LC:5254
        if (separator == null) {//LC:5255
            separator = EMPTY;//LC:5256
        }//LC:5257
//LC:5258
        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))//LC:5259
        //           (Assuming that all Strings are roughly equally long)//LC:5260
        final int noOfItems = endIndex - startIndex;//LC:5261
        if (noOfItems <= 0) {//LC:5262
            return EMPTY;//LC:5263
        }//LC:5264
//LC:5265
        final StringBuilder buf = new StringBuilder(noOfItems * 16);//LC:5266
//LC:5267
        for (int i = startIndex; i < endIndex; i++) {//LC:5268
            if (i > startIndex) {//LC:5269
                buf.append(separator);//LC:5270
            }//LC:5271
            if (array[i] != null) {//LC:5272
                buf.append(array[i]);//LC:5273
            }//LC:5274
        }//LC:5275
        return buf.toString();//LC:5276
    }//LC:5277
//LC:5278
    /**//LC:5279
     * <p>Joins the elements of the provided {@code Iterator} into//LC:5280
     * a single String containing the provided elements.</p>//LC:5281
     *//LC:5282
     * <p>No delimiter is added before or after the list. Null objects or empty//LC:5283
     * strings within the iteration are represented by empty strings.</p>//LC:5284
     *//LC:5285
     * <p>See the examples here: {@link #join(Object[],char)}. </p>//LC:5286
     *//LC:5287
     * @param iterator  the {@code Iterator} of values to join together, may be null//LC:5288
     * @param separator  the separator character to use//LC:5289
     * @return the joined String, {@code null} if null iterator input//LC:5290
     * @since 2.0//LC:5291
     *///LC:5292
    public static String join(final Iterator<?> iterator, final char separator) {//LC:5293
//LC:5294
        // handle null, zero and one elements before building a buffer//LC:5295
        if (iterator == null) {//LC:5296
            return null;//LC:5297
        }//LC:5298
        if (!iterator.hasNext()) {//LC:5299
            return EMPTY;//LC:5300
        }//LC:5301
        final Object first = iterator.next();//LC:5302
        if (!iterator.hasNext()) {//LC:5303
            return ObjectUtils.toString(first);//LC:5304
        }//LC:5305
//LC:5306
        // two or more elements//LC:5307
        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small//LC:5308
        if (first != null) {//LC:5309
            buf.append(first);//LC:5310
        }//LC:5311
//LC:5312
        while (iterator.hasNext()) {//LC:5313
            buf.append(separator);//LC:5314
            final Object obj = iterator.next();//LC:5315
            if (obj != null) {//LC:5316
                buf.append(obj);//LC:5317
            }//LC:5318
        }//LC:5319
//LC:5320
        return buf.toString();//LC:5321
    }//LC:5322
//LC:5323
    /**//LC:5324
     * <p>Joins the elements of the provided {@code Iterator} into//LC:5325
     * a single String containing the provided elements.</p>//LC:5326
     *//LC:5327
     * <p>No delimiter is added before or after the list.//LC:5328
     * A {@code null} separator is the same as an empty String ("").</p>//LC:5329
     *//LC:5330
     * <p>See the examples here: {@link #join(Object[],String)}. </p>//LC:5331
     *//LC:5332
     * @param iterator  the {@code Iterator} of values to join together, may be null//LC:5333
     * @param separator  the separator character to use, null treated as ""//LC:5334
     * @return the joined String, {@code null} if null iterator input//LC:5335
     *///LC:5336
    public static String join(final Iterator<?> iterator, final String separator) {//LC:5337
//LC:5338
        // handle null, zero and one elements before building a buffer//LC:5339
        if (iterator == null) {//LC:5340
            return null;//LC:5341
        }//LC:5342
        if (!iterator.hasNext()) {//LC:5343
            return EMPTY;//LC:5344
        }//LC:5345
        final Object first = iterator.next();//LC:5346
        if (!iterator.hasNext()) {//LC:5347
            return ObjectUtils.toString(first);//LC:5348
        }//LC:5349
//LC:5350
        // two or more elements//LC:5351
        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small//LC:5352
        if (first != null) {//LC:5353
            buf.append(first);//LC:5354
        }//LC:5355
//LC:5356
        while (iterator.hasNext()) {//LC:5357
            if (separator != null) {//LC:5358
                buf.append(separator);//LC:5359
            }//LC:5360
            final Object obj = iterator.next();//LC:5361
            if (obj != null) {//LC:5362
                buf.append(obj);//LC:5363
            }//LC:5364
        }//LC:5365
        return buf.toString();//LC:5366
    }//LC:5367
//LC:5368
    /**//LC:5369
     * <p>Joins the elements of the provided {@code Iterable} into//LC:5370
     * a single String containing the provided elements.</p>//LC:5371
     *//LC:5372
     * <p>No delimiter is added before or after the list. Null objects or empty//LC:5373
     * strings within the iteration are represented by empty strings.</p>//LC:5374
     *//LC:5375
     * <p>See the examples here: {@link #join(Object[],char)}. </p>//LC:5376
     *//LC:5377
     * @param iterable  the {@code Iterable} providing the values to join together, may be null//LC:5378
     * @param separator  the separator character to use//LC:5379
     * @return the joined String, {@code null} if null iterator input//LC:5380
     * @since 2.3//LC:5381
     *///LC:5382
    public static String join(final Iterable<?> iterable, final char separator) {//LC:5383
        if (iterable == null) {//LC:5384
            return null;//LC:5385
        }//LC:5386
        return join(iterable.iterator(), separator);//LC:5387
    }//LC:5388
//LC:5389
    /**//LC:5390
     * <p>Joins the elements of the provided {@code Iterable} into//LC:5391
     * a single String containing the provided elements.</p>//LC:5392
     *//LC:5393
     * <p>No delimiter is added before or after the list.//LC:5394
     * A {@code null} separator is the same as an empty String ("").</p>//LC:5395
     *//LC:5396
     * <p>See the examples here: {@link #join(Object[],String)}. </p>//LC:5397
     *//LC:5398
     * @param iterable  the {@code Iterable} providing the values to join together, may be null//LC:5399
     * @param separator  the separator character to use, null treated as ""//LC:5400
     * @return the joined String, {@code null} if null iterator input//LC:5401
     * @since 2.3//LC:5402
     *///LC:5403
    public static String join(final Iterable<?> iterable, final String separator) {//LC:5404
        if (iterable == null) {//LC:5405
            return null;//LC:5406
        }//LC:5407
        return join(iterable.iterator(), separator);//LC:5408
    }//LC:5409
//LC:5410
    // Delete//LC:5411
    //-----------------------------------------------------------------------//LC:5412
    /**//LC:5413
     * <p>Deletes all whitespaces from a String as defined by//LC:5414
     * {@link Character#isWhitespace(char)}.</p>//LC:5415
     *//LC:5416
     * <pre>//LC:5417
     * StringUtils.deleteWhitespace(null)         = null//LC:5418
     * StringUtils.deleteWhitespace("")           = ""//LC:5419
     * StringUtils.deleteWhitespace("abc")        = "abc"//LC:5420
     * StringUtils.deleteWhitespace("   ab  c  ") = "abc"//LC:5421
     * </pre>//LC:5422
     *//LC:5423
     * @param str  the String to delete whitespace from, may be null//LC:5424
     * @return the String without whitespaces, {@code null} if null String input//LC:5425
     *///LC:5426
    public static String deleteWhitespace(final String str) {//LC:5427
        if (isEmpty(str)) {//LC:5428
            return str;//LC:5429
        }//LC:5430
        final int sz = str.length();//LC:5431
        final char[] chs = new char[sz];//LC:5432
        int count = 0;//LC:5433
        for (int i = 0; i < sz; i++) {//LC:5434
            if (!Character.isWhitespace(str.charAt(i))) {//LC:5435
                chs[count++] = str.charAt(i);//LC:5436
            }//LC:5437
        }//LC:5438
        if (count == sz) {//LC:5439
            return str;//LC:5440
        }//LC:5441
        return new String(chs, 0, count);//LC:5442
    }//LC:5443
//LC:5444
    // Remove//LC:5445
    //-----------------------------------------------------------------------//LC:5446
    /**//LC:5447
     * <p>Removes a substring only if it is at the beginning of a source string,//LC:5448
     * otherwise returns the source string.</p>//LC:5449
     *//LC:5450
     * <p>A {@code null} source string will return {@code null}.//LC:5451
     * An empty ("") source string will return the empty string.//LC:5452
     * A {@code null} search string will return the source string.</p>//LC:5453
     *//LC:5454
     * <pre>//LC:5455
     * StringUtils.removeStart(null, *)      = null//LC:5456
     * StringUtils.removeStart("", *)        = ""//LC:5457
     * StringUtils.removeStart(*, null)      = *//LC:5458
     * StringUtils.removeStart("www.domain.com", "www.")   = "domain.com"//LC:5459
     * StringUtils.removeStart("domain.com", "www.")       = "domain.com"//LC:5460
     * StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com"//LC:5461
     * StringUtils.removeStart("abc", "")    = "abc"//LC:5462
     * </pre>//LC:5463
     *//LC:5464
     * @param str  the source String to search, may be null//LC:5465
     * @param remove  the String to search for and remove, may be null//LC:5466
     * @return the substring with the string removed if found,//LC:5467
     *  {@code null} if null String input//LC:5468
     * @since 2.1//LC:5469
     *///LC:5470
    public static String removeStart(final String str, final String remove) {//LC:5471
        if (isEmpty(str) || isEmpty(remove)) {//LC:5472
            return str;//LC:5473
        }//LC:5474
        if (str.startsWith(remove)){//LC:5475
            return str.substring(remove.length());//LC:5476
        }//LC:5477
        return str;//LC:5478
    }//LC:5479
//LC:5480
    /**//LC:5481
     * <p>Case insensitive removal of a substring if it is at the beginning of a source string,//LC:5482
     * otherwise returns the source string.</p>//LC:5483
     *//LC:5484
     * <p>A {@code null} source string will return {@code null}.//LC:5485
     * An empty ("") source string will return the empty string.//LC:5486
     * A {@code null} search string will return the source string.</p>//LC:5487
     *//LC:5488
     * <pre>//LC:5489
     * StringUtils.removeStartIgnoreCase(null, *)      = null//LC:5490
     * StringUtils.removeStartIgnoreCase("", *)        = ""//LC:5491
     * StringUtils.removeStartIgnoreCase(*, null)      = *//LC:5492
     * StringUtils.removeStartIgnoreCase("www.domain.com", "www.")   = "domain.com"//LC:5493
     * StringUtils.removeStartIgnoreCase("www.domain.com", "WWW.")   = "domain.com"//LC:5494
     * StringUtils.removeStartIgnoreCase("domain.com", "www.")       = "domain.com"//LC:5495
     * StringUtils.removeStartIgnoreCase("www.domain.com", "domain") = "www.domain.com"//LC:5496
     * StringUtils.removeStartIgnoreCase("abc", "")    = "abc"//LC:5497
     * </pre>//LC:5498
     *//LC:5499
     * @param str  the source String to search, may be null//LC:5500
     * @param remove  the String to search for (case insensitive) and remove, may be null//LC:5501
     * @return the substring with the string removed if found,//LC:5502
     *  {@code null} if null String input//LC:5503
     * @since 2.4//LC:5504
     *///LC:5505
    public static String removeStartIgnoreCase(final String str, final String remove) {//LC:5506
        if (isEmpty(str) || isEmpty(remove)) {//LC:5507
            return str;//LC:5508
        }//LC:5509
        if (startsWithIgnoreCase(str, remove)) {//LC:5510
            return str.substring(remove.length());//LC:5511
        }//LC:5512
        return str;//LC:5513
    }//LC:5514
//LC:5515
    /**//LC:5516
     * <p>Removes a substring only if it is at the end of a source string,//LC:5517
     * otherwise returns the source string.</p>//LC:5518
     *//LC:5519
     * <p>A {@code null} source string will return {@code null}.//LC:5520
     * An empty ("") source string will return the empty string.//LC:5521
     * A {@code null} search string will return the source string.</p>//LC:5522
     *//LC:5523
     * <pre>//LC:5524
     * StringUtils.removeEnd(null, *)      = null//LC:5525
     * StringUtils.removeEnd("", *)        = ""//LC:5526
     * StringUtils.removeEnd(*, null)      = *//LC:5527
     * StringUtils.removeEnd("www.domain.com", ".com.")  = "www.domain.com"//LC:5528
     * StringUtils.removeEnd("www.domain.com", ".com")   = "www.domain"//LC:5529
     * StringUtils.removeEnd("www.domain.com", "domain") = "www.domain.com"//LC:5530
     * StringUtils.removeEnd("abc", "")    = "abc"//LC:5531
     * </pre>//LC:5532
     *//LC:5533
     * @param str  the source String to search, may be null//LC:5534
     * @param remove  the String to search for and remove, may be null//LC:5535
     * @return the substring with the string removed if found,//LC:5536
     *  {@code null} if null String input//LC:5537
     * @since 2.1//LC:5538
     *///LC:5539
    public static String removeEnd(final String str, final String remove) {//LC:5540
        if (isEmpty(str) || isEmpty(remove)) {//LC:5541
            return str;//LC:5542
        }//LC:5543
        if (str.endsWith(remove)) {//LC:5544
            return str.substring(0, str.length() - remove.length());//LC:5545
        }//LC:5546
        return str;//LC:5547
    }//LC:5548
//LC:5549
    /**//LC:5550
     * <p>Case insensitive removal of a substring if it is at the end of a source string,//LC:5551
     * otherwise returns the source string.</p>//LC:5552
     *//LC:5553
     * <p>A {@code null} source string will return {@code null}.//LC:5554
     * An empty ("") source string will return the empty string.//LC:5555
     * A {@code null} search string will return the source string.</p>//LC:5556
     *//LC:5557
     * <pre>//LC:5558
     * StringUtils.removeEndIgnoreCase(null, *)      = null//LC:5559
     * StringUtils.removeEndIgnoreCase("", *)        = ""//LC:5560
     * StringUtils.removeEndIgnoreCase(*, null)      = *//LC:5561
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".com.")  = "www.domain.com"//LC:5562
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".com")   = "www.domain"//LC:5563
     * StringUtils.removeEndIgnoreCase("www.domain.com", "domain") = "www.domain.com"//LC:5564
     * StringUtils.removeEndIgnoreCase("abc", "")    = "abc"//LC:5565
     * StringUtils.removeEndIgnoreCase("www.domain.com", ".COM") = "www.domain")//LC:5566
     * StringUtils.removeEndIgnoreCase("www.domain.COM", ".com") = "www.domain")//LC:5567
     * </pre>//LC:5568
     *//LC:5569
     * @param str  the source String to search, may be null//LC:5570
     * @param remove  the String to search for (case insensitive) and remove, may be null//LC:5571
     * @return the substring with the string removed if found,//LC:5572
     *  {@code null} if null String input//LC:5573
     * @since 2.4//LC:5574
     *///LC:5575
    public static String removeEndIgnoreCase(final String str, final String remove) {//LC:5576
        if (isEmpty(str) || isEmpty(remove)) {//LC:5577
            return str;//LC:5578
        }//LC:5579
        if (endsWithIgnoreCase(str, remove)) {//LC:5580
            return str.substring(0, str.length() - remove.length());//LC:5581
        }//LC:5582
        return str;//LC:5583
    }//LC:5584
//LC:5585
    /**//LC:5586
     * <p>Removes all occurrences of a substring from within the source string.</p>//LC:5587
     *//LC:5588
     * <p>A {@code null} source string will return {@code null}.//LC:5589
     * An empty ("") source string will return the empty string.//LC:5590
     * A {@code null} remove string will return the source string.//LC:5591
     * An empty ("") remove string will return the source string.</p>//LC:5592
     *//LC:5593
     * <pre>//LC:5594
     * StringUtils.remove(null, *)        = null//LC:5595
     * StringUtils.remove("", *)          = ""//LC:5596
     * StringUtils.remove(*, null)        = *//LC:5597
     * StringUtils.remove(*, "")          = *//LC:5598
     * StringUtils.remove("queued", "ue") = "qd"//LC:5599
     * StringUtils.remove("queued", "zz") = "queued"//LC:5600
     * </pre>//LC:5601
     *//LC:5602
     * @param str  the source String to search, may be null//LC:5603
     * @param remove  the String to search for and remove, may be null//LC:5604
     * @return the substring with the string removed if found,//LC:5605
     *  {@code null} if null String input//LC:5606
     * @since 2.1//LC:5607
     *///LC:5608
    public static String remove(final String str, final String remove) {//LC:5609
        if (isEmpty(str) || isEmpty(remove)) {//LC:5610
            return str;//LC:5611
        }//LC:5612
        return replace(str, remove, EMPTY, -1);//LC:5613
    }//LC:5614
//LC:5615
    /**//LC:5616
     * <p>Removes all occurrences of a character from within the source string.</p>//LC:5617
     *//LC:5618
     * <p>A {@code null} source string will return {@code null}.//LC:5619
     * An empty ("") source string will return the empty string.</p>//LC:5620
     *//LC:5621
     * <pre>//LC:5622
     * StringUtils.remove(null, *)       = null//LC:5623
     * StringUtils.remove("", *)         = ""//LC:5624
     * StringUtils.remove("queued", 'u') = "qeed"//LC:5625
     * StringUtils.remove("queued", 'z') = "queued"//LC:5626
     * </pre>//LC:5627
     *//LC:5628
     * @param str  the source String to search, may be null//LC:5629
     * @param remove  the char to search for and remove, may be null//LC:5630
     * @return the substring with the char removed if found,//LC:5631
     *  {@code null} if null String input//LC:5632
     * @since 2.1//LC:5633
     *///LC:5634
    public static String remove(final String str, final char remove) {//LC:5635
        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {//LC:5636
            return str;//LC:5637
        }//LC:5638
        final char[] chars = str.toCharArray();//LC:5639
        int pos = 0;//LC:5640
        for (int i = 0; i < chars.length; i++) {//LC:5641
            if (chars[i] != remove) {//LC:5642
                chars[pos++] = chars[i];//LC:5643
            }//LC:5644
        }//LC:5645
        return new String(chars, 0, pos);//LC:5646
    }//LC:5647
//LC:5648
    // Replacing//LC:5649
    //-----------------------------------------------------------------------//LC:5650
    /**//LC:5651
     * <p>Replaces a String with another String inside a larger String, once.</p>//LC:5652
     *//LC:5653
     * <p>A {@code null} reference passed to this method is a no-op.</p>//LC:5654
     *//LC:5655
     * <pre>//LC:5656
     * StringUtils.replaceOnce(null, *, *)        = null//LC:5657
     * StringUtils.replaceOnce("", *, *)          = ""//LC:5658
     * StringUtils.replaceOnce("any", null, *)    = "any"//LC:5659
     * StringUtils.replaceOnce("any", *, null)    = "any"//LC:5660
     * StringUtils.replaceOnce("any", "", *)      = "any"//LC:5661
     * StringUtils.replaceOnce("aba", "a", null)  = "aba"//LC:5662
     * StringUtils.replaceOnce("aba", "a", "")    = "ba"//LC:5663
     * StringUtils.replaceOnce("aba", "a", "z")   = "zba"//LC:5664
     * </pre>//LC:5665
     *//LC:5666
     * @see #replace(String text, String searchString, String replacement, int max)//LC:5667
     * @param text  text to search and replace in, may be null//LC:5668
     * @param searchString  the String to search for, may be null//LC:5669
     * @param replacement  the String to replace with, may be null//LC:5670
     * @return the text with any replacements processed,//LC:5671
     *  {@code null} if null String input//LC:5672
     *///LC:5673
    public static String replaceOnce(final String text, final String searchString, final String replacement) {//LC:5674
        return replace(text, searchString, replacement, 1);//LC:5675
    }//LC:5676
//LC:5677
    /**//LC:5678
     * Replaces each substring of the source String that matches the given regular expression with the given//LC:5679
     * replacement using the {@link Pattern#DOTALL} option. DOTALL is also know as single-line mode in Perl. This call//LC:5680
     * is also equivalent to://LC:5681
     * <ul>//LC:5682
     * <li>{@code source.replaceAll(&quot;(?s)&quot; + regex, replacement)}</li>//LC:5683
     * <li>{@code Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement)}</li>//LC:5684
     * </ul>//LC:5685
     *//LC:5686
     * @param source//LC:5687
     *            the source string//LC:5688
     * @param regex//LC:5689
     *            the regular expression to which this string is to be matched//LC:5690
     * @param replacement//LC:5691
     *            the string to be substituted for each match//LC:5692
     * @return The resulting {@code String}//LC:5693
     * @see String#replaceAll(String, String)//LC:5694
     * @see Pattern#DOTALL//LC:5695
     * @since 3.2//LC:5696
     *///LC:5697
    public static String replacePattern(final String source, final String regex, final String replacement) {//LC:5698
        return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);//LC:5699
    }//LC:5700
//LC:5701
    /**//LC:5702
     * Removes each substring of the source String that matches the given regular expression using the DOTALL option.//LC:5703
     *//LC:5704
     * @param source//LC:5705
     *            the source string//LC:5706
     * @param regex//LC:5707
     *            the regular expression to which this string is to be matched//LC:5708
     * @return The resulting {@code String}//LC:5709
     * @see String#replaceAll(String, String)//LC:5710
     * @see Pattern#DOTALL//LC:5711
     * @since 3.2//LC:5712
     *///LC:5713
    public static String removePattern(final String source, final String regex) {//LC:5714
        return replacePattern(source, regex, StringUtils.EMPTY);//LC:5715
    }//LC:5716
//LC:5717
    /**//LC:5718
     * <p>Replaces all occurrences of a String within another String.</p>//LC:5719
     *//LC:5720
     * <p>A {@code null} reference passed to this method is a no-op.</p>//LC:5721
     *//LC:5722
     * <pre>//LC:5723
     * StringUtils.replace(null, *, *)        = null//LC:5724
     * StringUtils.replace("", *, *)          = ""//LC:5725
     * StringUtils.replace("any", null, *)    = "any"//LC:5726
     * StringUtils.replace("any", *, null)    = "any"//LC:5727
     * StringUtils.replace("any", "", *)      = "any"//LC:5728
     * StringUtils.replace("aba", "a", null)  = "aba"//LC:5729
     * StringUtils.replace("aba", "a", "")    = "b"//LC:5730
     * StringUtils.replace("aba", "a", "z")   = "zbz"//LC:5731
     * </pre>//LC:5732
     *//LC:5733
     * @see #replace(String text, String searchString, String replacement, int max)//LC:5734
     * @param text  text to search and replace in, may be null//LC:5735
     * @param searchString  the String to search for, may be null//LC:5736
     * @param replacement  the String to replace it with, may be null//LC:5737
     * @return the text with any replacements processed,//LC:5738
     *  {@code null} if null String input//LC:5739
     *///LC:5740
    public static String replace(final String text, final String searchString, final String replacement) {//LC:5741
        return replace(text, searchString, replacement, -1);//LC:5742
    }//LC:5743
//LC:5744
    /**//LC:5745
     * <p>Replaces a String with another String inside a larger String,//LC:5746
     * for the first {@code max} values of the search String.</p>//LC:5747
     *//LC:5748
     * <p>A {@code null} reference passed to this method is a no-op.</p>//LC:5749
     *//LC:5750
     * <pre>//LC:5751
     * StringUtils.replace(null, *, *, *)         = null//LC:5752
     * StringUtils.replace("", *, *, *)           = ""//LC:5753
     * StringUtils.replace("any", null, *, *)     = "any"//LC:5754
     * StringUtils.replace("any", *, null, *)     = "any"//LC:5755
     * StringUtils.replace("any", "", *, *)       = "any"//LC:5756
     * StringUtils.replace("any", *, *, 0)        = "any"//LC:5757
     * StringUtils.replace("abaa", "a", null, -1) = "abaa"//LC:5758
     * StringUtils.replace("abaa", "a", "", -1)   = "b"//LC:5759
     * StringUtils.replace("abaa", "a", "z", 0)   = "abaa"//LC:5760
     * StringUtils.replace("abaa", "a", "z", 1)   = "zbaa"//LC:5761
     * StringUtils.replace("abaa", "a", "z", 2)   = "zbza"//LC:5762
     * StringUtils.replace("abaa", "a", "z", -1)  = "zbzz"//LC:5763
     * </pre>//LC:5764
     *//LC:5765
     * @param text  text to search and replace in, may be null//LC:5766
     * @param searchString  the String to search for, may be null//LC:5767
     * @param replacement  the String to replace it with, may be null//LC:5768
     * @param max  maximum number of values to replace, or {@code -1} if no maximum//LC:5769
     * @return the text with any replacements processed,//LC:5770
     *  {@code null} if null String input//LC:5771
     *///LC:5772
    public static String replace(final String text, final String searchString, final String replacement, int max) {//LC:5773
        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {//LC:5774
            return text;//LC:5775
        }//LC:5776
        int start = 0;//LC:5777
        int end = text.indexOf(searchString, start);//LC:5778
        if (end == INDEX_NOT_FOUND) {//LC:5779
            return text;//LC:5780
        }//LC:5781
        final int replLength = searchString.length();//LC:5782
        int increase = replacement.length() - replLength;//LC:5783
        increase = increase < 0 ? 0 : increase;//LC:5784
        increase *= max < 0 ? 16 : max > 64 ? 64 : max;//LC:5785
        final StringBuilder buf = new StringBuilder(text.length() + increase);//LC:5786
        while (end != INDEX_NOT_FOUND) {//LC:5787
            buf.append(text.substring(start, end)).append(replacement);//LC:5788
            start = end + replLength;//LC:5789
            if (--max == 0) {//LC:5790
                break;//LC:5791
            }//LC:5792
            end = text.indexOf(searchString, start);//LC:5793
        }//LC:5794
        buf.append(text.substring(start));//LC:5795
        return buf.toString();//LC:5796
    }//LC:5797
//LC:5798
    /**//LC:5799
     * <p>//LC:5800
     * Replaces all occurrences of Strings within another String.//LC:5801
     * </p>//LC:5802
     *//LC:5803
     * <p>//LC:5804
     * A {@code null} reference passed to this method is a no-op, or if//LC:5805
     * any "search string" or "string to replace" is null, that replace will be//LC:5806
     * ignored. This will not repeat. For repeating replaces, call the//LC:5807
     * overloaded method.//LC:5808
     * </p>//LC:5809
     *//LC:5810
     * <pre>//LC:5811
     *  StringUtils.replaceEach(null, *, *)        = null//LC:5812
     *  StringUtils.replaceEach("", *, *)          = ""//LC:5813
     *  StringUtils.replaceEach("aba", null, null) = "aba"//LC:5814
     *  StringUtils.replaceEach("aba", new String[0], null) = "aba"//LC:5815
     *  StringUtils.replaceEach("aba", null, new String[0]) = "aba"//LC:5816
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null)  = "aba"//LC:5817
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""})  = "b"//LC:5818
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"})  = "aba"//LC:5819
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"})  = "wcte"//LC:5820
     *  (example of how it does not repeat)//LC:5821
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"})  = "dcte"//LC:5822
     * </pre>//LC:5823
     *//LC:5824
     * @param text//LC:5825
     *            text to search and replace in, no-op if null//LC:5826
     * @param searchList//LC:5827
     *            the Strings to search for, no-op if null//LC:5828
     * @param replacementList//LC:5829
     *            the Strings to replace them with, no-op if null//LC:5830
     * @return the text with any replacements processed, {@code null} if//LC:5831
     *         null String input//LC:5832
     * @throws IllegalArgumentException//LC:5833
     *             if the lengths of the arrays are not the same (null is ok,//LC:5834
     *             and/or size 0)//LC:5835
     * @since 2.4//LC:5836
     *///LC:5837
    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {//LC:5838
        return replaceEach(text, searchList, replacementList, false, 0);//LC:5839
    }//LC:5840
//LC:5841
    /**//LC:5842
     * <p>//LC:5843
     * Replaces all occurrences of Strings within another String.//LC:5844
     * </p>//LC:5845
     *//LC:5846
     * <p>//LC:5847
     * A {@code null} reference passed to this method is a no-op, or if//LC:5848
     * any "search string" or "string to replace" is null, that replace will be//LC:5849
     * ignored.//LC:5850
     * </p>//LC:5851
     *//LC:5852
     * <pre>//LC:5853
     *  StringUtils.replaceEach(null, *, *, *) = null//LC:5854
     *  StringUtils.replaceEach("", *, *, *) = ""//LC:5855
     *  StringUtils.replaceEach("aba", null, null, *) = "aba"//LC:5856
     *  StringUtils.replaceEach("aba", new String[0], null, *) = "aba"//LC:5857
     *  StringUtils.replaceEach("aba", null, new String[0], *) = "aba"//LC:5858
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *) = "aba"//LC:5859
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *) = "b"//LC:5860
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *) = "aba"//LC:5861
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *) = "wcte"//LC:5862
     *  (example of how it repeats)//LC:5863
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false) = "dcte"//LC:5864
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true) = "tcte"//LC:5865
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, true) = IllegalStateException//LC:5866
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, false) = "dcabe"//LC:5867
     * </pre>//LC:5868
     *//LC:5869
     * @param text//LC:5870
     *            text to search and replace in, no-op if null//LC:5871
     * @param searchList//LC:5872
     *            the Strings to search for, no-op if null//LC:5873
     * @param replacementList//LC:5874
     *            the Strings to replace them with, no-op if null//LC:5875
     * @return the text with any replacements processed, {@code null} if//LC:5876
     *         null String input//LC:5877
     * @throws IllegalStateException//LC:5878
     *             if the search is repeating and there is an endless loop due//LC:5879
     *             to outputs of one being inputs to another//LC:5880
     * @throws IllegalArgumentException//LC:5881
     *             if the lengths of the arrays are not the same (null is ok,//LC:5882
     *             and/or size 0)//LC:5883
     * @since 2.4//LC:5884
     *///LC:5885
    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {//LC:5886
        // timeToLive should be 0 if not used or nothing to replace, else it's//LC:5887
        // the length of the replace array//LC:5888
        final int timeToLive = searchList == null ? 0 : searchList.length;//LC:5889
        return replaceEach(text, searchList, replacementList, true, timeToLive);//LC:5890
    }//LC:5891
//LC:5892
    /**//LC:5893
     * <p>//LC:5894
     * Replaces all occurrences of Strings within another String.//LC:5895
     * </p>//LC:5896
     *//LC:5897
     * <p>//LC:5898
     * A {@code null} reference passed to this method is a no-op, or if//LC:5899
     * any "search string" or "string to replace" is null, that replace will be//LC:5900
     * ignored.//LC:5901
     * </p>//LC:5902
     *//LC:5903
     * <pre>//LC:5904
     *  StringUtils.replaceEach(null, *, *, *) = null//LC:5905
     *  StringUtils.replaceEach("", *, *, *) = ""//LC:5906
     *  StringUtils.replaceEach("aba", null, null, *) = "aba"//LC:5907
     *  StringUtils.replaceEach("aba", new String[0], null, *) = "aba"//LC:5908
     *  StringUtils.replaceEach("aba", null, new String[0], *) = "aba"//LC:5909
     *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *) = "aba"//LC:5910
     *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *) = "b"//LC:5911
     *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *) = "aba"//LC:5912
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *) = "wcte"//LC:5913
     *  (example of how it repeats)//LC:5914
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false) = "dcte"//LC:5915
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true) = "tcte"//LC:5916
     *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *) = IllegalStateException//LC:5917
     * </pre>//LC:5918
     *//LC:5919
     * @param text//LC:5920
     *            text to search and replace in, no-op if null//LC:5921
     * @param searchList//LC:5922
     *            the Strings to search for, no-op if null//LC:5923
     * @param replacementList//LC:5924
     *            the Strings to replace them with, no-op if null//LC:5925
     * @param repeat if true, then replace repeatedly//LC:5926
     *       until there are no more possible replacements or timeToLive < 0//LC:5927
     * @param timeToLive//LC:5928
     *            if less than 0 then there is a circular reference and endless//LC:5929
     *            loop//LC:5930
     * @return the text with any replacements processed, {@code null} if//LC:5931
     *         null String input//LC:5932
     * @throws IllegalStateException//LC:5933
     *             if the search is repeating and there is an endless loop due//LC:5934
     *             to outputs of one being inputs to another//LC:5935
     * @throws IllegalArgumentException//LC:5936
     *             if the lengths of the arrays are not the same (null is ok,//LC:5937
     *             and/or size 0)//LC:5938
     * @since 2.4//LC:5939
     *///LC:5940
    private static String replaceEach(//LC:5941
            final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {//LC:5942
//LC:5943
        // mchyzer Performance note: This creates very few new objects (one major goal)//LC:5944
        // let me know if there are performance requests, we can create a harness to measure//LC:5945
//LC:5946
        if (text == null || text.isEmpty() || searchList == null ||//LC:5947
                searchList.length == 0 || replacementList == null || replacementList.length == 0) {//LC:5948
            return text;//LC:5949
        }//LC:5950
//LC:5951
        // if recursing, this shouldn't be less than 0//LC:5952
        if (timeToLive < 0) {//LC:5953
            throw new IllegalStateException("Aborting to protect against StackOverflowError - " +//LC:5954
                    "output of one loop is the input of another");//LC:5955
        }//LC:5956
//LC:5957
        final int searchLength = searchList.length;//LC:5958
        final int replacementLength = replacementList.length;//LC:5959
//LC:5960
        // make sure lengths are ok, these need to be equal//LC:5961
        if (searchLength != replacementLength) {//LC:5962
            throw new IllegalArgumentException("Search and Replace array lengths don't match: "//LC:5963
                    + searchLength//LC:5964
                    + " vs "//LC:5965
                    + replacementLength);//LC:5966
        }//LC:5967
//LC:5968
        // keep track of which still have matches//LC:5969
        final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];//LC:5970
//LC:5971
        // index on index that the match was found//LC:5972
        int textIndex = -1;//LC:5973
        int replaceIndex = -1;//LC:5974
        int tempIndex = -1;//LC:5975
//LC:5976
        // index of replace array that will replace the search string found//LC:5977
        // NOTE: logic duplicated below START//LC:5978
        for (int i = 0; i < searchLength; i++) {//LC:5979
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||//LC:5980
                    searchList[i].isEmpty() || replacementList[i] == null) {//LC:5981
                continue;//LC:5982
            }//LC:5983
            tempIndex = text.indexOf(searchList[i]);//LC:5984
//LC:5985
            // see if we need to keep searching for this//LC:5986
            if (tempIndex == -1) {//LC:5987
                noMoreMatchesForReplIndex[i] = true;//LC:5988
            } else {//LC:5989
                if (textIndex == -1 || tempIndex < textIndex) {//LC:5990
                    textIndex = tempIndex;//LC:5991
                    replaceIndex = i;//LC:5992
                }//LC:5993
            }//LC:5994
        }//LC:5995
        // NOTE: logic mostly below END//LC:5996
//LC:5997
        // no search strings found, we are done//LC:5998
        if (textIndex == -1) {//LC:5999
            return text;//LC:6000
        }//LC:6001
//LC:6002
        int start = 0;//LC:6003
//LC:6004
        // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit//LC:6005
        int increase = 0;//LC:6006
//LC:6007
        // count the replacement text elements that are larger than their corresponding text being replaced//LC:6008
        for (int i = 0; i < searchList.length; i++) {//LC:6009
            if (searchList[i] == null || replacementList[i] == null) {//LC:6010
                continue;//LC:6011
            }//LC:6012
            final int greater = replacementList[i].length() - searchList[i].length();//LC:6013
            if (greater > 0) {//LC:6014
                increase += 3 * greater; // assume 3 matches//LC:6015
            }//LC:6016
        }//LC:6017
        // have upper-bound at 20% increase, then let Java take over//LC:6018
        increase = Math.min(increase, text.length() / 5);//LC:6019
//LC:6020
        final StringBuilder buf = new StringBuilder(text.length() + increase);//LC:6021
//LC:6022
        while (textIndex != -1) {//LC:6023
//LC:6024
            for (int i = start; i < textIndex; i++) {//LC:6025
                buf.append(text.charAt(i));//LC:6026
            }//LC:6027
            buf.append(replacementList[replaceIndex]);//LC:6028
//LC:6029
            start = textIndex + searchList[replaceIndex].length();//LC:6030
//LC:6031
            textIndex = -1;//LC:6032
            replaceIndex = -1;//LC:6033
            tempIndex = -1;//LC:6034
            // find the next earliest match//LC:6035
            // NOTE: logic mostly duplicated above START//LC:6036
            for (int i = 0; i < searchLength; i++) {//LC:6037
                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||//LC:6038
                        searchList[i].isEmpty() || replacementList[i] == null) {//LC:6039
                    continue;//LC:6040
                }//LC:6041
                tempIndex = text.indexOf(searchList[i], start);//LC:6042
//LC:6043
                // see if we need to keep searching for this//LC:6044
                if (tempIndex == -1) {//LC:6045
                    noMoreMatchesForReplIndex[i] = true;//LC:6046
                } else {//LC:6047
                    if (textIndex == -1 || tempIndex < textIndex) {//LC:6048
                        textIndex = tempIndex;//LC:6049
                        replaceIndex = i;//LC:6050
                    }//LC:6051
                }//LC:6052
            }//LC:6053
            // NOTE: logic duplicated above END//LC:6054
//LC:6055
        }//LC:6056
        final int textLength = text.length();//LC:6057
        for (int i = start; i < textLength; i++) {//LC:6058
            buf.append(text.charAt(i));//LC:6059
        }//LC:6060
        final String result = buf.toString();//LC:6061
        if (!repeat) {//LC:6062
            return result;//LC:6063
        }//LC:6064
//LC:6065
        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);//LC:6066
    }//LC:6067
//LC:6068
    // Replace, character based//LC:6069
    //-----------------------------------------------------------------------//LC:6070
    /**//LC:6071
     * <p>Replaces all occurrences of a character in a String with another.//LC:6072
     * This is a null-safe version of {@link String#replace(char, char)}.</p>//LC:6073
     *//LC:6074
     * <p>A {@code null} string input returns {@code null}.//LC:6075
     * An empty ("") string input returns an empty string.</p>//LC:6076
     *//LC:6077
     * <pre>//LC:6078
     * StringUtils.replaceChars(null, *, *)        = null//LC:6079
     * StringUtils.replaceChars("", *, *)          = ""//LC:6080
     * StringUtils.replaceChars("abcba", 'b', 'y') = "aycya"//LC:6081
     * StringUtils.replaceChars("abcba", 'z', 'y') = "abcba"//LC:6082
     * </pre>//LC:6083
     *//LC:6084
     * @param str  String to replace characters in, may be null//LC:6085
     * @param searchChar  the character to search for, may be null//LC:6086
     * @param replaceChar  the character to replace, may be null//LC:6087
     * @return modified String, {@code null} if null string input//LC:6088
     * @since 2.0//LC:6089
     *///LC:6090
    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {//LC:6091
        if (str == null) {//LC:6092
            return null;//LC:6093
        }//LC:6094
        return str.replace(searchChar, replaceChar);//LC:6095
    }//LC:6096
//LC:6097
    /**//LC:6098
     * <p>Replaces multiple characters in a String in one go.//LC:6099
     * This method can also be used to delete characters.</p>//LC:6100
     *//LC:6101
     * <p>For example:<br />//LC:6102
     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>//LC:6103
     *//LC:6104
     * <p>A {@code null} string input returns {@code null}.//LC:6105
     * An empty ("") string input returns an empty string.//LC:6106
     * A null or empty set of search characters returns the input string.</p>//LC:6107
     *//LC:6108
     * <p>The length of the search characters should normally equal the length//LC:6109
     * of the replace characters.//LC:6110
     * If the search characters is longer, then the extra search characters//LC:6111
     * are deleted.//LC:6112
     * If the search characters is shorter, then the extra replace characters//LC:6113
     * are ignored.</p>//LC:6114
     *//LC:6115
     * <pre>//LC:6116
     * StringUtils.replaceChars(null, *, *)           = null//LC:6117
     * StringUtils.replaceChars("", *, *)             = ""//LC:6118
     * StringUtils.replaceChars("abc", null, *)       = "abc"//LC:6119
     * StringUtils.replaceChars("abc", "", *)         = "abc"//LC:6120
     * StringUtils.replaceChars("abc", "b", null)     = "ac"//LC:6121
     * StringUtils.replaceChars("abc", "b", "")       = "ac"//LC:6122
     * StringUtils.replaceChars("abcba", "bc", "yz")  = "ayzya"//LC:6123
     * StringUtils.replaceChars("abcba", "bc", "y")   = "ayya"//LC:6124
     * StringUtils.replaceChars("abcba", "bc", "yzx") = "ayzya"//LC:6125
     * </pre>//LC:6126
     *//LC:6127
     * @param str  String to replace characters in, may be null//LC:6128
     * @param searchChars  a set of characters to search for, may be null//LC:6129
     * @param replaceChars  a set of characters to replace, may be null//LC:6130
     * @return modified String, {@code null} if null string input//LC:6131
     * @since 2.0//LC:6132
     *///LC:6133
    public static String replaceChars(final String str, final String searchChars, String replaceChars) {//LC:6134
        if (isEmpty(str) || isEmpty(searchChars)) {//LC:6135
            return str;//LC:6136
        }//LC:6137
        if (replaceChars == null) {//LC:6138
            replaceChars = EMPTY;//LC:6139
        }//LC:6140
        boolean modified = false;//LC:6141
        final int replaceCharsLength = replaceChars.length();//LC:6142
        final int strLength = str.length();//LC:6143
        final StringBuilder buf = new StringBuilder(strLength);//LC:6144
        for (int i = 0; i < strLength; i++) {//LC:6145
            final char ch = str.charAt(i);//LC:6146
            final int index = searchChars.indexOf(ch);//LC:6147
            if (index >= 0) {//LC:6148
                modified = true;//LC:6149
                if (index < replaceCharsLength) {//LC:6150
                    buf.append(replaceChars.charAt(index));//LC:6151
                }//LC:6152
            } else {//LC:6153
                buf.append(ch);//LC:6154
            }//LC:6155
        }//LC:6156
        if (modified) {//LC:6157
            return buf.toString();//LC:6158
        }//LC:6159
        return str;//LC:6160
    }//LC:6161
//LC:6162
    // Overlay//LC:6163
    //-----------------------------------------------------------------------//LC:6164
    /**//LC:6165
     * <p>Overlays part of a String with another String.</p>//LC:6166
     *//LC:6167
     * <p>A {@code null} string input returns {@code null}.//LC:6168
     * A negative index is treated as zero.//LC:6169
     * An index greater than the string length is treated as the string length.//LC:6170
     * The start index is always the smaller of the two indices.</p>//LC:6171
     *//LC:6172
     * <pre>//LC:6173
     * StringUtils.overlay(null, *, *, *)            = null//LC:6174
     * StringUtils.overlay("", "abc", 0, 0)          = "abc"//LC:6175
     * StringUtils.overlay("abcdef", null, 2, 4)     = "abef"//LC:6176
     * StringUtils.overlay("abcdef", "", 2, 4)       = "abef"//LC:6177
     * StringUtils.overlay("abcdef", "", 4, 2)       = "abef"//LC:6178
     * StringUtils.overlay("abcdef", "zzzz", 2, 4)   = "abzzzzef"//LC:6179
     * StringUtils.overlay("abcdef", "zzzz", 4, 2)   = "abzzzzef"//LC:6180
     * StringUtils.overlay("abcdef", "zzzz", -1, 4)  = "zzzzef"//LC:6181
     * StringUtils.overlay("abcdef", "zzzz", 2, 8)   = "abzzzz"//LC:6182
     * StringUtils.overlay("abcdef", "zzzz", -2, -3) = "zzzzabcdef"//LC:6183
     * StringUtils.overlay("abcdef", "zzzz", 8, 10)  = "abcdefzzzz"//LC:6184
     * </pre>//LC:6185
     *//LC:6186
     * @param str  the String to do overlaying in, may be null//LC:6187
     * @param overlay  the String to overlay, may be null//LC:6188
     * @param start  the position to start overlaying at//LC:6189
     * @param end  the position to stop overlaying before//LC:6190
     * @return overlayed String, {@code null} if null String input//LC:6191
     * @since 2.0//LC:6192
     *///LC:6193
    public static String overlay(final String str, String overlay, int start, int end) {//LC:6194
        if (str == null) {//LC:6195
            return null;//LC:6196
        }//LC:6197
        if (overlay == null) {//LC:6198
            overlay = EMPTY;//LC:6199
        }//LC:6200
        final int len = str.length();//LC:6201
        if (start < 0) {//LC:6202
            start = 0;//LC:6203
        }//LC:6204
        if (start > len) {//LC:6205
            start = len;//LC:6206
        }//LC:6207
        if (end < 0) {//LC:6208
            end = 0;//LC:6209
        }//LC:6210
        if (end > len) {//LC:6211
            end = len;//LC:6212
        }//LC:6213
        if (start > end) {//LC:6214
            final int temp = start;//LC:6215
            start = end;//LC:6216
            end = temp;//LC:6217
        }//LC:6218
        return new StringBuilder(len + start - end + overlay.length() + 1)//LC:6219
                .append(str.substring(0, start))//LC:6220
                .append(overlay)//LC:6221
                .append(str.substring(end))//LC:6222
                .toString();//LC:6223
    }//LC:6224
//LC:6225
    // Chomping//LC:6226
    //-----------------------------------------------------------------------//LC:6227
    /**//LC:6228
     * <p>Removes one newline from end of a String if it's there,//LC:6229
     * otherwise leave it alone.  A newline is &quot;{@code \n}&quot;,//LC:6230
     * &quot;{@code \r}&quot;, or &quot;{@code \r\n}&quot;.</p>//LC:6231
     *//LC:6232
     * <p>NOTE: This method changed in 2.0.//LC:6233
     * It now more closely matches Perl chomp.</p>//LC:6234
     *//LC:6235
     * <pre>//LC:6236
     * StringUtils.chomp(null)          = null//LC:6237
     * StringUtils.chomp("")            = ""//LC:6238
     * StringUtils.chomp("abc \r")      = "abc "//LC:6239
     * StringUtils.chomp("abc\n")       = "abc"//LC:6240
     * StringUtils.chomp("abc\r\n")     = "abc"//LC:6241
     * StringUtils.chomp("abc\r\n\r\n") = "abc\r\n"//LC:6242
     * StringUtils.chomp("abc\n\r")     = "abc\n"//LC:6243
     * StringUtils.chomp("abc\n\rabc")  = "abc\n\rabc"//LC:6244
     * StringUtils.chomp("\r")          = ""//LC:6245
     * StringUtils.chomp("\n")          = ""//LC:6246
     * StringUtils.chomp("\r\n")        = ""//LC:6247
     * </pre>//LC:6248
     *//LC:6249
     * @param str  the String to chomp a newline from, may be null//LC:6250
     * @return String without newline, {@code null} if null String input//LC:6251
     *///LC:6252
    public static String chomp(final String str) {//LC:6253
        if (isEmpty(str)) {//LC:6254
            return str;//LC:6255
        }//LC:6256
//LC:6257
        if (str.length() == 1) {//LC:6258
            final char ch = str.charAt(0);//LC:6259
            if (ch == CharUtils.CR || ch == CharUtils.LF) {//LC:6260
                return EMPTY;//LC:6261
            }//LC:6262
            return str;//LC:6263
        }//LC:6264
//LC:6265
        int lastIdx = str.length() - 1;//LC:6266
        final char last = str.charAt(lastIdx);//LC:6267
//LC:6268
        if (last == CharUtils.LF) {//LC:6269
            if (str.charAt(lastIdx - 1) == CharUtils.CR) {//LC:6270
                lastIdx--;//LC:6271
            }//LC:6272
        } else if (last != CharUtils.CR) {//LC:6273
            lastIdx++;//LC:6274
        }//LC:6275
        return str.substring(0, lastIdx);//LC:6276
    }//LC:6277
//LC:6278
    /**//LC:6279
     * <p>Removes {@code separator} from the end of//LC:6280
     * {@code str} if it's there, otherwise leave it alone.</p>//LC:6281
     *//LC:6282
     * <p>NOTE: This method changed in version 2.0.//LC:6283
     * It now more closely matches Perl chomp.//LC:6284
     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.//LC:6285
     * This method uses {@link String#endsWith(String)}.</p>//LC:6286
     *//LC:6287
     * <pre>//LC:6288
     * StringUtils.chomp(null, *)         = null//LC:6289
     * StringUtils.chomp("", *)           = ""//LC:6290
     * StringUtils.chomp("foobar", "bar") = "foo"//LC:6291
     * StringUtils.chomp("foobar", "baz") = "foobar"//LC:6292
     * StringUtils.chomp("foo", "foo")    = ""//LC:6293
     * StringUtils.chomp("foo ", "foo")   = "foo "//LC:6294
     * StringUtils.chomp(" foo", "foo")   = " "//LC:6295
     * StringUtils.chomp("foo", "foooo")  = "foo"//LC:6296
     * StringUtils.chomp("foo", "")       = "foo"//LC:6297
     * StringUtils.chomp("foo", null)     = "foo"//LC:6298
     * </pre>//LC:6299
     *//LC:6300
     * @param str  the String to chomp from, may be null//LC:6301
     * @param separator  separator String, may be null//LC:6302
     * @return String without trailing separator, {@code null} if null String input//LC:6303
     * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String, String)} instead//LC:6304
     *///LC:6305
    @Deprecated//LC:6306
    public static String chomp(final String str, final String separator) {//LC:6307
        return removeEnd(str,separator);//LC:6308
    }//LC:6309
//LC:6310
    // Chopping//LC:6311
    //-----------------------------------------------------------------------//LC:6312
    /**//LC:6313
     * <p>Remove the last character from a String.</p>//LC:6314
     *//LC:6315
     * <p>If the String ends in {@code \r\n}, then remove both//LC:6316
     * of them.</p>//LC:6317
     *//LC:6318
     * <pre>//LC:6319
     * StringUtils.chop(null)          = null//LC:6320
     * StringUtils.chop("")            = ""//LC:6321
     * StringUtils.chop("abc \r")      = "abc "//LC:6322
     * StringUtils.chop("abc\n")       = "abc"//LC:6323
     * StringUtils.chop("abc\r\n")     = "abc"//LC:6324
     * StringUtils.chop("abc")         = "ab"//LC:6325
     * StringUtils.chop("abc\nabc")    = "abc\nab"//LC:6326
     * StringUtils.chop("a")           = ""//LC:6327
     * StringUtils.chop("\r")          = ""//LC:6328
     * StringUtils.chop("\n")          = ""//LC:6329
     * StringUtils.chop("\r\n")        = ""//LC:6330
     * </pre>//LC:6331
     *//LC:6332
     * @param str  the String to chop last character from, may be null//LC:6333
     * @return String without last character, {@code null} if null String input//LC:6334
     *///LC:6335
    public static String chop(final String str) {//LC:6336
        if (str == null) {//LC:6337
            return null;//LC:6338
        }//LC:6339
        final int strLen = str.length();//LC:6340
        if (strLen < 2) {//LC:6341
            return EMPTY;//LC:6342
        }//LC:6343
        final int lastIdx = strLen - 1;//LC:6344
        final String ret = str.substring(0, lastIdx);//LC:6345
        final char last = str.charAt(lastIdx);//LC:6346
        if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {//LC:6347
            return ret.substring(0, lastIdx - 1);//LC:6348
        }//LC:6349
        return ret;//LC:6350
    }//LC:6351
//LC:6352
    // Conversion//LC:6353
    //-----------------------------------------------------------------------//LC:6354
//LC:6355
    // Padding//LC:6356
    //-----------------------------------------------------------------------//LC:6357
    /**//LC:6358
     * <p>Repeat a String {@code repeat} times to form a//LC:6359
     * new String.</p>//LC:6360
     *//LC:6361
     * <pre>//LC:6362
     * StringUtils.repeat(null, 2) = null//LC:6363
     * StringUtils.repeat("", 0)   = ""//LC:6364
     * StringUtils.repeat("", 2)   = ""//LC:6365
     * StringUtils.repeat("a", 3)  = "aaa"//LC:6366
     * StringUtils.repeat("ab", 2) = "abab"//LC:6367
     * StringUtils.repeat("a", -2) = ""//LC:6368
     * </pre>//LC:6369
     *//LC:6370
     * @param str  the String to repeat, may be null//LC:6371
     * @param repeat  number of times to repeat str, negative treated as zero//LC:6372
     * @return a new String consisting of the original String repeated,//LC:6373
     *  {@code null} if null String input//LC:6374
     *///LC:6375
    public static String repeat(final String str, final int repeat) {//LC:6376
        // Performance tuned for 2.0 (JDK1.4)//LC:6377
//LC:6378
        if (str == null) {//LC:6379
            return null;//LC:6380
        }//LC:6381
        if (repeat <= 0) {//LC:6382
            return EMPTY;//LC:6383
        }//LC:6384
        final int inputLength = str.length();//LC:6385
        if (repeat == 1 || inputLength == 0) {//LC:6386
            return str;//LC:6387
        }//LC:6388
        if (inputLength == 1 && repeat <= PAD_LIMIT) {//LC:6389
            return repeat(str.charAt(0), repeat);//LC:6390
        }//LC:6391
//LC:6392
        final int outputLength = inputLength * repeat;//LC:6393
        switch (inputLength) {//LC:6394
            case 1 ://LC:6395
                return repeat(str.charAt(0), repeat);//LC:6396
            case 2 ://LC:6397
                final char ch0 = str.charAt(0);//LC:6398
                final char ch1 = str.charAt(1);//LC:6399
                final char[] output2 = new char[outputLength];//LC:6400
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {//LC:6401
                    output2[i] = ch0;//LC:6402
                    output2[i + 1] = ch1;//LC:6403
                }//LC:6404
                return new String(output2);//LC:6405
            default ://LC:6406
                final StringBuilder buf = new StringBuilder(outputLength);//LC:6407
                for (int i = 0; i < repeat; i++) {//LC:6408
                    buf.append(str);//LC:6409
                }//LC:6410
                return buf.toString();//LC:6411
        }//LC:6412
    }//LC:6413
//LC:6414
    /**//LC:6415
     * <p>Repeat a String {@code repeat} times to form a//LC:6416
     * new String, with a String separator injected each time. </p>//LC:6417
     *//LC:6418
     * <pre>//LC:6419
     * StringUtils.repeat(null, null, 2) = null//LC:6420
     * StringUtils.repeat(null, "x", 2)  = null//LC:6421
     * StringUtils.repeat("", null, 0)   = ""//LC:6422
     * StringUtils.repeat("", "", 2)     = ""//LC:6423
     * StringUtils.repeat("", "x", 3)    = "xxx"//LC:6424
     * StringUtils.repeat("?", ", ", 3)  = "?, ?, ?"//LC:6425
     * </pre>//LC:6426
     *//LC:6427
     * @param str        the String to repeat, may be null//LC:6428
     * @param separator  the String to inject, may be null//LC:6429
     * @param repeat     number of times to repeat str, negative treated as zero//LC:6430
     * @return a new String consisting of the original String repeated,//LC:6431
     *  {@code null} if null String input//LC:6432
     * @since 2.5//LC:6433
     *///LC:6434
    public static String repeat(final String str, final String separator, final int repeat) {//LC:6435
        if(str == null || separator == null) {//LC:6436
            return repeat(str, repeat);//LC:6437
        }//LC:6438
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it//LC:6439
        final String result = repeat(str + separator, repeat);//LC:6440
        return removeEnd(result, separator);//LC:6441
    }//LC:6442
//LC:6443
    /**//LC:6444
     * <p>Returns padding using the specified delimiter repeated//LC:6445
     * to a given length.</p>//LC:6446
     *//LC:6447
     * <pre>//LC:6448
     * StringUtils.repeat('e', 0)  = ""//LC:6449
     * StringUtils.repeat('e', 3)  = "eee"//LC:6450
     * StringUtils.repeat('e', -2) = ""//LC:6451
     * </pre>//LC:6452
     *//LC:6453
     * <p>Note: this method doesn't not support padding with//LC:6454
     * <a href="http://www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a>//LC:6455
     * as they require a pair of {@code char}s to be represented.//LC:6456
     * If you are needing to support full I18N of your applications//LC:6457
     * consider using {@link #repeat(String, int)} instead.//LC:6458
     * </p>//LC:6459
     *//LC:6460
     * @param ch  character to repeat//LC:6461
     * @param repeat  number of times to repeat char, negative treated as zero//LC:6462
     * @return String with repeated character//LC:6463
     * @see #repeat(String, int)//LC:6464
     *///LC:6465
    public static String repeat(final char ch, final int repeat) {//LC:6466
        final char[] buf = new char[repeat];//LC:6467
        for (int i = repeat - 1; i >= 0; i--) {//LC:6468
            buf[i] = ch;//LC:6469
        }//LC:6470
        return new String(buf);//LC:6471
    }//LC:6472
//LC:6473
    /**//LC:6474
     * <p>Right pad a String with spaces (' ').</p>//LC:6475
     *//LC:6476
     * <p>The String is padded to the size of {@code size}.</p>//LC:6477
     *//LC:6478
     * <pre>//LC:6479
     * StringUtils.rightPad(null, *)   = null//LC:6480
     * StringUtils.rightPad("", 3)     = "   "//LC:6481
     * StringUtils.rightPad("bat", 3)  = "bat"//LC:6482
     * StringUtils.rightPad("bat", 5)  = "bat  "//LC:6483
     * StringUtils.rightPad("bat", 1)  = "bat"//LC:6484
     * StringUtils.rightPad("bat", -1) = "bat"//LC:6485
     * </pre>//LC:6486
     *//LC:6487
     * @param str  the String to pad out, may be null//LC:6488
     * @param size  the size to pad to//LC:6489
     * @return right padded String or original String if no padding is necessary,//LC:6490
     *  {@code null} if null String input//LC:6491
     *///LC:6492
    public static String rightPad(final String str, final int size) {//LC:6493
        return rightPad(str, size, ' ');//LC:6494
    }//LC:6495
//LC:6496
    /**//LC:6497
     * <p>Right pad a String with a specified character.</p>//LC:6498
     *//LC:6499
     * <p>The String is padded to the size of {@code size}.</p>//LC:6500
     *//LC:6501
     * <pre>//LC:6502
     * StringUtils.rightPad(null, *, *)     = null//LC:6503
     * StringUtils.rightPad("", 3, 'z')     = "zzz"//LC:6504
     * StringUtils.rightPad("bat", 3, 'z')  = "bat"//LC:6505
     * StringUtils.rightPad("bat", 5, 'z')  = "batzz"//LC:6506
     * StringUtils.rightPad("bat", 1, 'z')  = "bat"//LC:6507
     * StringUtils.rightPad("bat", -1, 'z') = "bat"//LC:6508
     * </pre>//LC:6509
     *//LC:6510
     * @param str  the String to pad out, may be null//LC:6511
     * @param size  the size to pad to//LC:6512
     * @param padChar  the character to pad with//LC:6513
     * @return right padded String or original String if no padding is necessary,//LC:6514
     *  {@code null} if null String input//LC:6515
     * @since 2.0//LC:6516
     *///LC:6517
    public static String rightPad(final String str, final int size, final char padChar) {//LC:6518
        if (str == null) {//LC:6519
            return null;//LC:6520
        }//LC:6521
        final int pads = size - str.length();//LC:6522
        if (pads <= 0) {//LC:6523
            return str; // returns original String when possible//LC:6524
        }//LC:6525
        if (pads > PAD_LIMIT) {//LC:6526
            return rightPad(str, size, String.valueOf(padChar));//LC:6527
        }//LC:6528
        return str.concat(repeat(padChar, pads));//LC:6529
    }//LC:6530
//LC:6531
    /**//LC:6532
     * <p>Right pad a String with a specified String.</p>//LC:6533
     *//LC:6534
     * <p>The String is padded to the size of {@code size}.</p>//LC:6535
     *//LC:6536
     * <pre>//LC:6537
     * StringUtils.rightPad(null, *, *)      = null//LC:6538
     * StringUtils.rightPad("", 3, "z")      = "zzz"//LC:6539
     * StringUtils.rightPad("bat", 3, "yz")  = "bat"//LC:6540
     * StringUtils.rightPad("bat", 5, "yz")  = "batyz"//LC:6541
     * StringUtils.rightPad("bat", 8, "yz")  = "batyzyzy"//LC:6542
     * StringUtils.rightPad("bat", 1, "yz")  = "bat"//LC:6543
     * StringUtils.rightPad("bat", -1, "yz") = "bat"//LC:6544
     * StringUtils.rightPad("bat", 5, null)  = "bat  "//LC:6545
     * StringUtils.rightPad("bat", 5, "")    = "bat  "//LC:6546
     * </pre>//LC:6547
     *//LC:6548
     * @param str  the String to pad out, may be null//LC:6549
     * @param size  the size to pad to//LC:6550
     * @param padStr  the String to pad with, null or empty treated as single space//LC:6551
     * @return right padded String or original String if no padding is necessary,//LC:6552
     *  {@code null} if null String input//LC:6553
     *///LC:6554
    public static String rightPad(final String str, final int size, String padStr) {//LC:6555
        if (str == null) {//LC:6556
            return null;//LC:6557
        }//LC:6558
        if (isEmpty(padStr)) {//LC:6559
            padStr = SPACE;//LC:6560
        }//LC:6561
        final int padLen = padStr.length();//LC:6562
        final int strLen = str.length();//LC:6563
        final int pads = size - strLen;//LC:6564
        if (pads <= 0) {//LC:6565
            return str; // returns original String when possible//LC:6566
        }//LC:6567
        if (padLen == 1 && pads <= PAD_LIMIT) {//LC:6568
            return rightPad(str, size, padStr.charAt(0));//LC:6569
        }//LC:6570
//LC:6571
        if (pads == padLen) {//LC:6572
            return str.concat(padStr);//LC:6573
        } else if (pads < padLen) {//LC:6574
            return str.concat(padStr.substring(0, pads));//LC:6575
        } else {//LC:6576
            final char[] padding = new char[pads];//LC:6577
            final char[] padChars = padStr.toCharArray();//LC:6578
            for (int i = 0; i < pads; i++) {//LC:6579
                padding[i] = padChars[i % padLen];//LC:6580
            }//LC:6581
            return str.concat(new String(padding));//LC:6582
        }//LC:6583
    }//LC:6584
//LC:6585
    /**//LC:6586
     * <p>Left pad a String with spaces (' ').</p>//LC:6587
     *//LC:6588
     * <p>The String is padded to the size of {@code size}.</p>//LC:6589
     *//LC:6590
     * <pre>//LC:6591
     * StringUtils.leftPad(null, *)   = null//LC:6592
     * StringUtils.leftPad("", 3)     = "   "//LC:6593
     * StringUtils.leftPad("bat", 3)  = "bat"//LC:6594
     * StringUtils.leftPad("bat", 5)  = "  bat"//LC:6595
     * StringUtils.leftPad("bat", 1)  = "bat"//LC:6596
     * StringUtils.leftPad("bat", -1) = "bat"//LC:6597
     * </pre>//LC:6598
     *//LC:6599
     * @param str  the String to pad out, may be null//LC:6600
     * @param size  the size to pad to//LC:6601
     * @return left padded String or original String if no padding is necessary,//LC:6602
     *  {@code null} if null String input//LC:6603
     *///LC:6604
    public static String leftPad(final String str, final int size) {//LC:6605
        return leftPad(str, size, ' ');//LC:6606
    }//LC:6607
//LC:6608
    /**//LC:6609
     * <p>Left pad a String with a specified character.</p>//LC:6610
     *//LC:6611
     * <p>Pad to a size of {@code size}.</p>//LC:6612
     *//LC:6613
     * <pre>//LC:6614
     * StringUtils.leftPad(null, *, *)     = null//LC:6615
     * StringUtils.leftPad("", 3, 'z')     = "zzz"//LC:6616
     * StringUtils.leftPad("bat", 3, 'z')  = "bat"//LC:6617
     * StringUtils.leftPad("bat", 5, 'z')  = "zzbat"//LC:6618
     * StringUtils.leftPad("bat", 1, 'z')  = "bat"//LC:6619
     * StringUtils.leftPad("bat", -1, 'z') = "bat"//LC:6620
     * </pre>//LC:6621
     *//LC:6622
     * @param str  the String to pad out, may be null//LC:6623
     * @param size  the size to pad to//LC:6624
     * @param padChar  the character to pad with//LC:6625
     * @return left padded String or original String if no padding is necessary,//LC:6626
     *  {@code null} if null String input//LC:6627
     * @since 2.0//LC:6628
     *///LC:6629
    public static String leftPad(final String str, final int size, final char padChar) {//LC:6630
        if (str == null) {//LC:6631
            return null;//LC:6632
        }//LC:6633
        final int pads = size - str.length();//LC:6634
        if (pads <= 0) {//LC:6635
            return str; // returns original String when possible//LC:6636
        }//LC:6637
        if (pads > PAD_LIMIT) {//LC:6638
            return leftPad(str, size, String.valueOf(padChar));//LC:6639
        }//LC:6640
        return repeat(padChar, pads).concat(str);//LC:6641
    }//LC:6642
//LC:6643
    /**//LC:6644
     * <p>Left pad a String with a specified String.</p>//LC:6645
     *//LC:6646
     * <p>Pad to a size of {@code size}.</p>//LC:6647
     *//LC:6648
     * <pre>//LC:6649
     * StringUtils.leftPad(null, *, *)      = null//LC:6650
     * StringUtils.leftPad("", 3, "z")      = "zzz"//LC:6651
     * StringUtils.leftPad("bat", 3, "yz")  = "bat"//LC:6652
     * StringUtils.leftPad("bat", 5, "yz")  = "yzbat"//LC:6653
     * StringUtils.leftPad("bat", 8, "yz")  = "yzyzybat"//LC:6654
     * StringUtils.leftPad("bat", 1, "yz")  = "bat"//LC:6655
     * StringUtils.leftPad("bat", -1, "yz") = "bat"//LC:6656
     * StringUtils.leftPad("bat", 5, null)  = "  bat"//LC:6657
     * StringUtils.leftPad("bat", 5, "")    = "  bat"//LC:6658
     * </pre>//LC:6659
     *//LC:6660
     * @param str  the String to pad out, may be null//LC:6661
     * @param size  the size to pad to//LC:6662
     * @param padStr  the String to pad with, null or empty treated as single space//LC:6663
     * @return left padded String or original String if no padding is necessary,//LC:6664
     *  {@code null} if null String input//LC:6665
     *///LC:6666
    public static String leftPad(final String str, final int size, String padStr) {//LC:6667
        if (str == null) {//LC:6668
            return null;//LC:6669
        }//LC:6670
        if (isEmpty(padStr)) {//LC:6671
            padStr = SPACE;//LC:6672
        }//LC:6673
        final int padLen = padStr.length();//LC:6674
        final int strLen = str.length();//LC:6675
        final int pads = size - strLen;//LC:6676
        if (pads <= 0) {//LC:6677
            return str; // returns original String when possible//LC:6678
        }//LC:6679
        if (padLen == 1 && pads <= PAD_LIMIT) {//LC:6680
            return leftPad(str, size, padStr.charAt(0));//LC:6681
        }//LC:6682
//LC:6683
        if (pads == padLen) {//LC:6684
            return padStr.concat(str);//LC:6685
        } else if (pads < padLen) {//LC:6686
            return padStr.substring(0, pads).concat(str);//LC:6687
        } else {//LC:6688
            final char[] padding = new char[pads];//LC:6689
            final char[] padChars = padStr.toCharArray();//LC:6690
            for (int i = 0; i < pads; i++) {//LC:6691
                padding[i] = padChars[i % padLen];//LC:6692
            }//LC:6693
            return new String(padding).concat(str);//LC:6694
        }//LC:6695
    }//LC:6696
//LC:6697
    /**//LC:6698
     * Gets a CharSequence length or {@code 0} if the CharSequence is//LC:6699
     * {@code null}.//LC:6700
     *//LC:6701
     * @param cs//LC:6702
     *            a CharSequence or {@code null}//LC:6703
     * @return CharSequence length or {@code 0} if the CharSequence is//LC:6704
     *         {@code null}.//LC:6705
     * @since 2.4//LC:6706
     * @since 3.0 Changed signature from length(String) to length(CharSequence)//LC:6707
     *///LC:6708
    public static int length(final CharSequence cs) {//LC:6709
        return cs == null ? 0 : cs.length();//LC:6710
    }//LC:6711
//LC:6712
    // Centering//LC:6713
    //-----------------------------------------------------------------------//LC:6714
    /**//LC:6715
     * <p>Centers a String in a larger String of size {@code size}//LC:6716
     * using the space character (' ').<p>//LC:6717
     *//LC:6718
     * <p>If the size is less than the String length, the String is returned.//LC:6719
     * A {@code null} String returns {@code null}.//LC:6720
     * A negative size is treated as zero.</p>//LC:6721
     *//LC:6722
     * <p>Equivalent to {@code center(str, size, " ")}.</p>//LC:6723
     *//LC:6724
     * <pre>//LC:6725
     * StringUtils.center(null, *)   = null//LC:6726
     * StringUtils.center("", 4)     = "    "//LC:6727
     * StringUtils.center("ab", -1)  = "ab"//LC:6728
     * StringUtils.center("ab", 4)   = " ab "//LC:6729
     * StringUtils.center("abcd", 2) = "abcd"//LC:6730
     * StringUtils.center("a", 4)    = " a  "//LC:6731
     * </pre>//LC:6732
     *//LC:6733
     * @param str  the String to center, may be null//LC:6734
     * @param size  the int size of new String, negative treated as zero//LC:6735
     * @return centered String, {@code null} if null String input//LC:6736
     *///LC:6737
    public static String center(final String str, final int size) {//LC:6738
        return center(str, size, ' ');//LC:6739
    }//LC:6740
//LC:6741
    /**//LC:6742
     * <p>Centers a String in a larger String of size {@code size}.//LC:6743
     * Uses a supplied character as the value to pad the String with.</p>//LC:6744
     *//LC:6745
     * <p>If the size is less than the String length, the String is returned.//LC:6746
     * A {@code null} String returns {@code null}.//LC:6747
     * A negative size is treated as zero.</p>//LC:6748
     *//LC:6749
     * <pre>//LC:6750
     * StringUtils.center(null, *, *)     = null//LC:6751
     * StringUtils.center("", 4, ' ')     = "    "//LC:6752
     * StringUtils.center("ab", -1, ' ')  = "ab"//LC:6753
     * StringUtils.center("ab", 4, ' ')   = " ab "//LC:6754
     * StringUtils.center("abcd", 2, ' ') = "abcd"//LC:6755
     * StringUtils.center("a", 4, ' ')    = " a  "//LC:6756
     * StringUtils.center("a", 4, 'y')    = "yayy"//LC:6757
     * </pre>//LC:6758
     *//LC:6759
     * @param str  the String to center, may be null//LC:6760
     * @param size  the int size of new String, negative treated as zero//LC:6761
     * @param padChar  the character to pad the new String with//LC:6762
     * @return centered String, {@code null} if null String input//LC:6763
     * @since 2.0//LC:6764
     *///LC:6765
    public static String center(String str, final int size, final char padChar) {//LC:6766
        if (str == null || size <= 0) {//LC:6767
            return str;//LC:6768
        }//LC:6769
        final int strLen = str.length();//LC:6770
        final int pads = size - strLen;//LC:6771
        if (pads <= 0) {//LC:6772
            return str;//LC:6773
        }//LC:6774
        str = leftPad(str, strLen + pads / 2, padChar);//LC:6775
        str = rightPad(str, size, padChar);//LC:6776
        return str;//LC:6777
    }//LC:6778
//LC:6779
    /**//LC:6780
     * <p>Centers a String in a larger String of size {@code size}.//LC:6781
     * Uses a supplied String as the value to pad the String with.</p>//LC:6782
     *//LC:6783
     * <p>If the size is less than the String length, the String is returned.//LC:6784
     * A {@code null} String returns {@code null}.//LC:6785
     * A negative size is treated as zero.</p>//LC:6786
     *//LC:6787
     * <pre>//LC:6788
     * StringUtils.center(null, *, *)     = null//LC:6789
     * StringUtils.center("", 4, " ")     = "    "//LC:6790
     * StringUtils.center("ab", -1, " ")  = "ab"//LC:6791
     * StringUtils.center("ab", 4, " ")   = " ab "//LC:6792
     * StringUtils.center("abcd", 2, " ") = "abcd"//LC:6793
     * StringUtils.center("a", 4, " ")    = " a  "//LC:6794
     * StringUtils.center("a", 4, "yz")   = "yayz"//LC:6795
     * StringUtils.center("abc", 7, null) = "  abc  "//LC:6796
     * StringUtils.center("abc", 7, "")   = "  abc  "//LC:6797
     * </pre>//LC:6798
     *//LC:6799
     * @param str  the String to center, may be null//LC:6800
     * @param size  the int size of new String, negative treated as zero//LC:6801
     * @param padStr  the String to pad the new String with, must not be null or empty//LC:6802
     * @return centered String, {@code null} if null String input//LC:6803
     * @throws IllegalArgumentException if padStr is {@code null} or empty//LC:6804
     *///LC:6805
    public static String center(String str, final int size, String padStr) {//LC:6806
        if (str == null || size <= 0) {//LC:6807
            return str;//LC:6808
        }//LC:6809
        if (isEmpty(padStr)) {//LC:6810
            padStr = SPACE;//LC:6811
        }//LC:6812
        final int strLen = str.length();//LC:6813
        final int pads = size - strLen;//LC:6814
        if (pads <= 0) {//LC:6815
            return str;//LC:6816
        }//LC:6817
        str = leftPad(str, strLen + pads / 2, padStr);//LC:6818
        str = rightPad(str, size, padStr);//LC:6819
        return str;//LC:6820
    }//LC:6821
//LC:6822
    // Case conversion//LC:6823
    //-----------------------------------------------------------------------//LC:6824
    /**//LC:6825
     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>//LC:6826
     *//LC:6827
     * <p>A {@code null} input String returns {@code null}.</p>//LC:6828
     *//LC:6829
     * <pre>//LC:6830
     * StringUtils.upperCase(null)  = null//LC:6831
     * StringUtils.upperCase("")    = ""//LC:6832
     * StringUtils.upperCase("aBc") = "ABC"//LC:6833
     * </pre>//LC:6834
     *//LC:6835
     * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},//LC:6836
     * the result of this method is affected by the current locale.//LC:6837
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}//LC:6838
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>//LC:6839
     *//LC:6840
     * @param str  the String to upper case, may be null//LC:6841
     * @return the upper cased String, {@code null} if null String input//LC:6842
     *///LC:6843
    public static String upperCase(final String str) {//LC:6844
        if (str == null) {//LC:6845
            return null;//LC:6846
        }//LC:6847
        return str.toUpperCase();//LC:6848
    }//LC:6849
//LC:6850
    /**//LC:6851
     * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>//LC:6852
     *//LC:6853
     * <p>A {@code null} input String returns {@code null}.</p>//LC:6854
     *//LC:6855
     * <pre>//LC:6856
     * StringUtils.upperCase(null, Locale.ENGLISH)  = null//LC:6857
     * StringUtils.upperCase("", Locale.ENGLISH)    = ""//LC:6858
     * StringUtils.upperCase("aBc", Locale.ENGLISH) = "ABC"//LC:6859
     * </pre>//LC:6860
     *//LC:6861
     * @param str  the String to upper case, may be null//LC:6862
     * @param locale  the locale that defines the case transformation rules, must not be null//LC:6863
     * @return the upper cased String, {@code null} if null String input//LC:6864
     * @since 2.5//LC:6865
     *///LC:6866
    public static String upperCase(final String str, final Locale locale) {//LC:6867
        if (str == null) {//LC:6868
            return null;//LC:6869
        }//LC:6870
        return str.toUpperCase(locale);//LC:6871
    }//LC:6872
//LC:6873
    /**//LC:6874
     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>//LC:6875
     *//LC:6876
     * <p>A {@code null} input String returns {@code null}.</p>//LC:6877
     *//LC:6878
     * <pre>//LC:6879
     * StringUtils.lowerCase(null)  = null//LC:6880
     * StringUtils.lowerCase("")    = ""//LC:6881
     * StringUtils.lowerCase("aBc") = "abc"//LC:6882
     * </pre>//LC:6883
     *//LC:6884
     * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},//LC:6885
     * the result of this method is affected by the current locale.//LC:6886
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}//LC:6887
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>//LC:6888
     *//LC:6889
     * @param str  the String to lower case, may be null//LC:6890
     * @return the lower cased String, {@code null} if null String input//LC:6891
     *///LC:6892
    public static String lowerCase(final String str) {//LC:6893
        if (str == null) {//LC:6894
            return null;//LC:6895
        }//LC:6896
        return str.toLowerCase();//LC:6897
    }//LC:6898
//LC:6899
    /**//LC:6900
     * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>//LC:6901
     *//LC:6902
     * <p>A {@code null} input String returns {@code null}.</p>//LC:6903
     *//LC:6904
     * <pre>//LC:6905
     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null//LC:6906
     * StringUtils.lowerCase("", Locale.ENGLISH)    = ""//LC:6907
     * StringUtils.lowerCase("aBc", Locale.ENGLISH) = "abc"//LC:6908
     * </pre>//LC:6909
     *//LC:6910
     * @param str  the String to lower case, may be null//LC:6911
     * @param locale  the locale that defines the case transformation rules, must not be null//LC:6912
     * @return the lower cased String, {@code null} if null String input//LC:6913
     * @since 2.5//LC:6914
     *///LC:6915
    public static String lowerCase(final String str, final Locale locale) {//LC:6916
        if (str == null) {//LC:6917
            return null;//LC:6918
        }//LC:6919
        return str.toLowerCase(locale);//LC:6920
    }//LC:6921
//LC:6922
    /**//LC:6923
     * <p>Capitalizes a String changing the first letter to title case as//LC:6924
     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>//LC:6925
     *//LC:6926
     * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#capitalize(String)}.//LC:6927
     * A {@code null} input String returns {@code null}.</p>//LC:6928
     *//LC:6929
     * <pre>//LC:6930
     * StringUtils.capitalize(null)  = null//LC:6931
     * StringUtils.capitalize("")    = ""//LC:6932
     * StringUtils.capitalize("cat") = "Cat"//LC:6933
     * StringUtils.capitalize("cAt") = "CAt"//LC:6934
     * </pre>//LC:6935
     *//LC:6936
     * @param str the String to capitalize, may be null//LC:6937
     * @return the capitalized String, {@code null} if null String input//LC:6938
     * @see org.apache.commons.lang3.text.WordUtils#capitalize(String)//LC:6939
     * @see #uncapitalize(String)//LC:6940
     * @since 2.0//LC:6941
     *///LC:6942
    public static String capitalize(final String str) {//LC:6943
        int strLen;//LC:6944
        if (str == null || (strLen = str.length()) == 0) {//LC:6945
            return str;//LC:6946
        }//LC:6947
//LC:6948
        char firstChar = str.charAt(0);//LC:6949
        if (Character.isTitleCase(firstChar)) {//LC:6950
            // already capitalized//LC:6951
            return str;//LC:6952
        }//LC:6953
//LC:6954
        return new StringBuilder(strLen)//LC:6955
                .append(Character.toTitleCase(firstChar))//LC:6956
                .append(str.substring(1))//LC:6957
                .toString();//LC:6958
    }//LC:6959
//LC:6960
    /**//LC:6961
     * <p>Uncapitalizes a String changing the first letter to title case as//LC:6962
     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>//LC:6963
     *//LC:6964
     * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.//LC:6965
     * A {@code null} input String returns {@code null}.</p>//LC:6966
     *//LC:6967
     * <pre>//LC:6968
     * StringUtils.uncapitalize(null)  = null//LC:6969
     * StringUtils.uncapitalize("")    = ""//LC:6970
     * StringUtils.uncapitalize("Cat") = "cat"//LC:6971
     * StringUtils.uncapitalize("CAT") = "cAT"//LC:6972
     * </pre>//LC:6973
     *//LC:6974
     * @param str the String to uncapitalize, may be null//LC:6975
     * @return the uncapitalized String, {@code null} if null String input//LC:6976
     * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)//LC:6977
     * @see #capitalize(String)//LC:6978
     * @since 2.0//LC:6979
     *///LC:6980
    public static String uncapitalize(final String str) {//LC:6981
        int strLen;//LC:6982
        if (str == null || (strLen = str.length()) == 0) {//LC:6983
            return str;//LC:6984
        }//LC:6985
//LC:6986
        char firstChar = str.charAt(0);//LC:6987
        if (Character.isLowerCase(firstChar)) {//LC:6988
            // already uncapitalized//LC:6989
            return str;//LC:6990
        }//LC:6991
//LC:6992
        return new StringBuilder(strLen)//LC:6993
                .append(Character.toLowerCase(firstChar))//LC:6994
                .append(str.substring(1))//LC:6995
                .toString();//LC:6996
    }//LC:6997
//LC:6998
    /**//LC:6999
     * <p>Swaps the case of a String changing upper and title case to//LC:7000
     * lower case, and lower case to upper case.</p>//LC:7001
     *//LC:7002
     * <ul>//LC:7003
     *  <li>Upper case character converts to Lower case</li>//LC:7004
     *  <li>Title case character converts to Lower case</li>//LC:7005
     *  <li>Lower case character converts to Upper case</li>//LC:7006
     * </ul>//LC:7007
     *//LC:7008
     * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.//LC:7009
     * A {@code null} input String returns {@code null}.</p>//LC:7010
     *//LC:7011
     * <pre>//LC:7012
     * StringUtils.swapCase(null)                 = null//LC:7013
     * StringUtils.swapCase("")                   = ""//LC:7014
     * StringUtils.swapCase("The dog has a BONE") = "tHE DOG HAS A bone"//LC:7015
     * </pre>//LC:7016
     *//LC:7017
     * <p>NOTE: This method changed in Lang version 2.0.//LC:7018
     * It no longer performs a word based algorithm.//LC:7019
     * If you only use ASCII, you will notice no change.//LC:7020
     * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>//LC:7021
     *//LC:7022
     * @param str  the String to swap case, may be null//LC:7023
     * @return the changed String, {@code null} if null String input//LC:7024
     *///LC:7025
    public static String swapCase(final String str) {//LC:7026
        if (StringUtils.isEmpty(str)) {//LC:7027
            return str;//LC:7028
        }//LC:7029
//LC:7030
        final char[] buffer = str.toCharArray();//LC:7031
//LC:7032
        for (int i = 0; i < buffer.length; i++) {//LC:7033
            final char ch = buffer[i];//LC:7034
            if (Character.isUpperCase(ch)) {//LC:7035
                buffer[i] = Character.toLowerCase(ch);//LC:7036
            } else if (Character.isTitleCase(ch)) {//LC:7037
                buffer[i] = Character.toLowerCase(ch);//LC:7038
            } else if (Character.isLowerCase(ch)) {//LC:7039
                buffer[i] = Character.toUpperCase(ch);//LC:7040
            }//LC:7041
        }//LC:7042
        return new String(buffer);//LC:7043
    }//LC:7044
//LC:7045
    // Count matches//LC:7046
    //-----------------------------------------------------------------------//LC:7047
    /**//LC:7048
     * <p>Counts how many times the substring appears in the larger string.</p>//LC:7049
     *//LC:7050
     * <p>A {@code null} or empty ("") String input returns {@code 0}.</p>//LC:7051
     *//LC:7052
     * <pre>//LC:7053
     * StringUtils.countMatches(null, *)       = 0//LC:7054
     * StringUtils.countMatches("", *)         = 0//LC:7055
     * StringUtils.countMatches("abba", null)  = 0//LC:7056
     * StringUtils.countMatches("abba", "")    = 0//LC:7057
     * StringUtils.countMatches("abba", "a")   = 2//LC:7058
     * StringUtils.countMatches("abba", "ab")  = 1//LC:7059
     * StringUtils.countMatches("abba", "xxx") = 0//LC:7060
     * </pre>//LC:7061
     *//LC:7062
     * @param str  the CharSequence to check, may be null//LC:7063
     * @param sub  the substring to count, may be null//LC:7064
     * @return the number of occurrences, 0 if either CharSequence is {@code null}//LC:7065
     * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)//LC:7066
     *///LC:7067
    public static int countMatches(final CharSequence str, final CharSequence sub) {//LC:7068
        if (isEmpty(str) || isEmpty(sub)) {//LC:7069
            return 0;//LC:7070
        }//LC:7071
        int count = 0;//LC:7072
        int idx = 0;//LC:7073
        while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {//LC:7074
            count++;//LC:7075
            idx += sub.length();//LC:7076
        }//LC:7077
        return count;//LC:7078
    }//LC:7079
//LC:7080
    // Character Tests//LC:7081
    //-----------------------------------------------------------------------//LC:7082
    /**//LC:7083
     * <p>Checks if the CharSequence contains only Unicode letters.</p>//LC:7084
     *//LC:7085
     * <p>{@code null} will return {@code false}.//LC:7086
     * An empty CharSequence (length()=0) will return {@code false}.</p>//LC:7087
     *//LC:7088
     * <pre>//LC:7089
     * StringUtils.isAlpha(null)   = false//LC:7090
     * StringUtils.isAlpha("")     = false//LC:7091
     * StringUtils.isAlpha("  ")   = false//LC:7092
     * StringUtils.isAlpha("abc")  = true//LC:7093
     * StringUtils.isAlpha("ab2c") = false//LC:7094
     * StringUtils.isAlpha("ab-c") = false//LC:7095
     * </pre>//LC:7096
     *//LC:7097
     * @param cs  the CharSequence to check, may be null//LC:7098
     * @return {@code true} if only contains letters, and is non-null//LC:7099
     * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)//LC:7100
     * @since 3.0 Changed "" to return false and not true//LC:7101
     *///LC:7102
    public static boolean isAlpha(final CharSequence cs) {//LC:7103
        if (cs == null || cs.length() == 0) {//LC:7104
            return false;//LC:7105
        }//LC:7106
        final int sz = cs.length();//LC:7107
        for (int i = 0; i < sz; i++) {//LC:7108
            if (Character.isLetter(cs.charAt(i)) == false) {//LC:7109
                return false;//LC:7110
            }//LC:7111
        }//LC:7112
        return true;//LC:7113
    }//LC:7114
//LC:7115
    /**//LC:7116
     * <p>Checks if the CharSequence contains only Unicode letters and//LC:7117
     * space (' ').</p>//LC:7118
     *//LC:7119
     * <p>{@code null} will return {@code false}//LC:7120
     * An empty CharSequence (length()=0) will return {@code true}.</p>//LC:7121
     *//LC:7122
     * <pre>//LC:7123
     * StringUtils.isAlphaSpace(null)   = false//LC:7124
     * StringUtils.isAlphaSpace("")     = true//LC:7125
     * StringUtils.isAlphaSpace("  ")   = true//LC:7126
     * StringUtils.isAlphaSpace("abc")  = true//LC:7127
     * StringUtils.isAlphaSpace("ab c") = true//LC:7128
     * StringUtils.isAlphaSpace("ab2c") = false//LC:7129
     * StringUtils.isAlphaSpace("ab-c") = false//LC:7130
     * </pre>//LC:7131
     *//LC:7132
     * @param cs  the CharSequence to check, may be null//LC:7133
     * @return {@code true} if only contains letters and space,//LC:7134
     *  and is non-null//LC:7135
     * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)//LC:7136
     *///LC:7137
    public static boolean isAlphaSpace(final CharSequence cs) {//LC:7138
        if (cs == null) {//LC:7139
            return false;//LC:7140
        }//LC:7141
        final int sz = cs.length();//LC:7142
        for (int i = 0; i < sz; i++) {//LC:7143
            if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {//LC:7144
                return false;//LC:7145
            }//LC:7146
        }//LC:7147
        return true;//LC:7148
    }//LC:7149
//LC:7150
    /**//LC:7151
     * <p>Checks if the CharSequence contains only Unicode letters or digits.</p>//LC:7152
     *//LC:7153
     * <p>{@code null} will return {@code false}.//LC:7154
     * An empty CharSequence (length()=0) will return {@code false}.</p>//LC:7155
     *//LC:7156
     * <pre>//LC:7157
     * StringUtils.isAlphanumeric(null)   = false//LC:7158
     * StringUtils.isAlphanumeric("")     = false//LC:7159
     * StringUtils.isAlphanumeric("  ")   = false//LC:7160
     * StringUtils.isAlphanumeric("abc")  = true//LC:7161
     * StringUtils.isAlphanumeric("ab c") = false//LC:7162
     * StringUtils.isAlphanumeric("ab2c") = true//LC:7163
     * StringUtils.isAlphanumeric("ab-c") = false//LC:7164
     * </pre>//LC:7165
     *//LC:7166
     * @param cs  the CharSequence to check, may be null//LC:7167
     * @return {@code true} if only contains letters or digits,//LC:7168
     *  and is non-null//LC:7169
     * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)//LC:7170
     * @since 3.0 Changed "" to return false and not true//LC:7171
     *///LC:7172
    public static boolean isAlphanumeric(final CharSequence cs) {//LC:7173
        if (cs == null || cs.length() == 0) {//LC:7174
            return false;//LC:7175
        }//LC:7176
        final int sz = cs.length();//LC:7177
        for (int i = 0; i < sz; i++) {//LC:7178
            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {//LC:7179
                return false;//LC:7180
            }//LC:7181
        }//LC:7182
        return true;//LC:7183
    }//LC:7184
//LC:7185
    /**//LC:7186
     * <p>Checks if the CharSequence contains only Unicode letters, digits//LC:7187
     * or space ({@code ' '}).</p>//LC:7188
     *//LC:7189
     * <p>{@code null} will return {@code false}.//LC:7190
     * An empty CharSequence (length()=0) will return {@code true}.</p>//LC:7191
     *//LC:7192
     * <pre>//LC:7193
     * StringUtils.isAlphanumericSpace(null)   = false//LC:7194
     * StringUtils.isAlphanumericSpace("")     = true//LC:7195
     * StringUtils.isAlphanumericSpace("  ")   = true//LC:7196
     * StringUtils.isAlphanumericSpace("abc")  = true//LC:7197
     * StringUtils.isAlphanumericSpace("ab c") = true//LC:7198
     * StringUtils.isAlphanumericSpace("ab2c") = true//LC:7199
     * StringUtils.isAlphanumericSpace("ab-c") = false//LC:7200
     * </pre>//LC:7201
     *//LC:7202
     * @param cs  the CharSequence to check, may be null//LC:7203
     * @return {@code true} if only contains letters, digits or space,//LC:7204
     *  and is non-null//LC:7205
     * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)//LC:7206
     *///LC:7207
    public static boolean isAlphanumericSpace(final CharSequence cs) {//LC:7208
        if (cs == null) {//LC:7209
            return false;//LC:7210
        }//LC:7211
        final int sz = cs.length();//LC:7212
        for (int i = 0; i < sz; i++) {//LC:7213
            if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {//LC:7214
                return false;//LC:7215
            }//LC:7216
        }//LC:7217
        return true;//LC:7218
    }//LC:7219
//LC:7220
    /**//LC:7221
     * <p>Checks if the CharSequence contains only ASCII printable characters.</p>//LC:7222
     *//LC:7223
     * <p>{@code null} will return {@code false}.//LC:7224
     * An empty CharSequence (length()=0) will return {@code true}.</p>//LC:7225
     *//LC:7226
     * <pre>//LC:7227
     * StringUtils.isAsciiPrintable(null)     = false//LC:7228
     * StringUtils.isAsciiPrintable("")       = true//LC:7229
     * StringUtils.isAsciiPrintable(" ")      = true//LC:7230
     * StringUtils.isAsciiPrintable("Ceki")   = true//LC:7231
     * StringUtils.isAsciiPrintable("ab2c")   = true//LC:7232
     * StringUtils.isAsciiPrintable("!ab-c~") = true//LC:7233
     * StringUtils.isAsciiPrintable("\u0020") = true//LC:7234
     * StringUtils.isAsciiPrintable("\u0021") = true//LC:7235
     * StringUtils.isAsciiPrintable("\u007e") = true//LC:7236
     * StringUtils.isAsciiPrintable("\u007f") = false//LC:7237
     * StringUtils.isAsciiPrintable("Ceki G\u00fclc\u00fc") = false//LC:7238
     * </pre>//LC:7239
     *//LC:7240
     * @param cs the CharSequence to check, may be null//LC:7241
     * @return {@code true} if every character is in the range//LC:7242
     *  32 thru 126//LC:7243
     * @since 2.1//LC:7244
     * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)//LC:7245
     *///LC:7246
    public static boolean isAsciiPrintable(final CharSequence cs) {//LC:7247
        if (cs == null) {//LC:7248
            return false;//LC:7249
        }//LC:7250
        final int sz = cs.length();//LC:7251
        for (int i = 0; i < sz; i++) {//LC:7252
            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {//LC:7253
                return false;//LC:7254
            }//LC:7255
        }//LC:7256
        return true;//LC:7257
    }//LC:7258
//LC:7259
    /**//LC:7260
     * <p>Checks if the CharSequence contains only Unicode digits.//LC:7261
     * A decimal point is not a Unicode digit and returns false.</p>//LC:7262
     *//LC:7263
     * <p>{@code null} will return {@code false}.//LC:7264
     * An empty CharSequence (length()=0) will return {@code false}.</p>//LC:7265
     *//LC:7266
     * <p>Note that the method does not allow for a leading sign, either positive or negative.//LC:7267
     * Also, if a String passes the numeric test, it may still generate a NumberFormatException//LC:7268
     * when parsed by Integer.parseInt or Long.parseLong, e.g. if the value is outside the range//LC:7269
     * for int or long respectively.</p>//LC:7270
     *//LC:7271
     * <pre>//LC:7272
     * StringUtils.isNumeric(null)   = false//LC:7273
     * StringUtils.isNumeric("")     = false//LC:7274
     * StringUtils.isNumeric("  ")   = false//LC:7275
     * StringUtils.isNumeric("123")  = true//LC:7276
     * StringUtils.isNumeric("12 3") = false//LC:7277
     * StringUtils.isNumeric("ab2c") = false//LC:7278
     * StringUtils.isNumeric("12-3") = false//LC:7279
     * StringUtils.isNumeric("12.3") = false//LC:7280
     * StringUtils.isNumeric("-123") = false//LC:7281
     * StringUtils.isNumeric("+123") = false//LC:7282
     * </pre>//LC:7283
     *//LC:7284
     * @param cs  the CharSequence to check, may be null//LC:7285
     * @return {@code true} if only contains digits, and is non-null//LC:7286
     * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)//LC:7287
     * @since 3.0 Changed "" to return false and not true//LC:7288
     *///LC:7289
    public static boolean isNumeric(final CharSequence cs) {//LC:7290
        if (cs == null || cs.length() == 0) {//LC:7291
            return false;//LC:7292
        }//LC:7293
        final int sz = cs.length();//LC:7294
        for (int i = 0; i < sz; i++) {//LC:7295
            if (Character.isDigit(cs.charAt(i)) == false) {//LC:7296
                return false;//LC:7297
            }//LC:7298
        }//LC:7299
        return true;//LC:7300
    }//LC:7301
//LC:7302
    /**//LC:7303
     * <p>Checks if the CharSequence contains only Unicode digits or space//LC:7304
     * ({@code ' '}).//LC:7305
     * A decimal point is not a Unicode digit and returns false.</p>//LC:7306
     *//LC:7307
     * <p>{@code null} will return {@code false}.//LC:7308
     * An empty CharSequence (length()=0) will return {@code true}.</p>//LC:7309
     *//LC:7310
     * <pre>//LC:7311
     * StringUtils.isNumericSpace(null)   = false//LC:7312
     * StringUtils.isNumericSpace("")     = true//LC:7313
     * StringUtils.isNumericSpace("  ")   = true//LC:7314
     * StringUtils.isNumericSpace("123")  = true//LC:7315
     * StringUtils.isNumericSpace("12 3") = true//LC:7316
     * StringUtils.isNumericSpace("ab2c") = false//LC:7317
     * StringUtils.isNumericSpace("12-3") = false//LC:7318
     * StringUtils.isNumericSpace("12.3") = false//LC:7319
     * </pre>//LC:7320
     *//LC:7321
     * @param cs  the CharSequence to check, may be null//LC:7322
     * @return {@code true} if only contains digits or space,//LC:7323
     *  and is non-null//LC:7324
     * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)//LC:7325
     *///LC:7326
    public static boolean isNumericSpace(final CharSequence cs) {//LC:7327
        if (cs == null) {//LC:7328
            return false;//LC:7329
        }//LC:7330
        final int sz = cs.length();//LC:7331
        for (int i = 0; i < sz; i++) {//LC:7332
            if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {//LC:7333
                return false;//LC:7334
            }//LC:7335
        }//LC:7336
        return true;//LC:7337
    }//LC:7338
//LC:7339
    /**//LC:7340
     * <p>Checks if the CharSequence contains only whitespace.</p>//LC:7341
     *//LC:7342
     * <p>{@code null} will return {@code false}.//LC:7343
     * An empty CharSequence (length()=0) will return {@code true}.</p>//LC:7344
     *//LC:7345
     * <pre>//LC:7346
     * StringUtils.isWhitespace(null)   = false//LC:7347
     * StringUtils.isWhitespace("")     = true//LC:7348
     * StringUtils.isWhitespace("  ")   = true//LC:7349
     * StringUtils.isWhitespace("abc")  = false//LC:7350
     * StringUtils.isWhitespace("ab2c") = false//LC:7351
     * StringUtils.isWhitespace("ab-c") = false//LC:7352
     * </pre>//LC:7353
     *//LC:7354
     * @param cs  the CharSequence to check, may be null//LC:7355
     * @return {@code true} if only contains whitespace, and is non-null//LC:7356
     * @since 2.0//LC:7357
     * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)//LC:7358
     *///LC:7359
    public static boolean isWhitespace(final CharSequence cs) {//LC:7360
        if (cs == null) {//LC:7361
            return false;//LC:7362
        }//LC:7363
        final int sz = cs.length();//LC:7364
        for (int i = 0; i < sz; i++) {//LC:7365
            if (Character.isWhitespace(cs.charAt(i)) == false) {//LC:7366
                return false;//LC:7367
            }//LC:7368
        }//LC:7369
        return true;//LC:7370
    }//LC:7371
//LC:7372
    /**//LC:7373
     * <p>Checks if the CharSequence contains only lowercase characters.</p>//LC:7374
     *//LC:7375
     * <p>{@code null} will return {@code false}.//LC:7376
     * An empty CharSequence (length()=0) will return {@code false}.</p>//LC:7377
     *//LC:7378
     * <pre>//LC:7379
     * StringUtils.isAllLowerCase(null)   = false//LC:7380
     * StringUtils.isAllLowerCase("")     = false//LC:7381
     * StringUtils.isAllLowerCase("  ")   = false//LC:7382
     * StringUtils.isAllLowerCase("abc")  = true//LC:7383
     * StringUtils.isAllLowerCase("abC") = false//LC:7384
     * </pre>//LC:7385
     *//LC:7386
     * @param cs  the CharSequence to check, may be null//LC:7387
     * @return {@code true} if only contains lowercase characters, and is non-null//LC:7388
     * @since 2.5//LC:7389
     * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)//LC:7390
     *///LC:7391
    public static boolean isAllLowerCase(final CharSequence cs) {//LC:7392
        if (cs == null || isEmpty(cs)) {//LC:7393
            return false;//LC:7394
        }//LC:7395
        final int sz = cs.length();//LC:7396
        for (int i = 0; i < sz; i++) {//LC:7397
            if (Character.isLowerCase(cs.charAt(i)) == false) {//LC:7398
                return false;//LC:7399
            }//LC:7400
        }//LC:7401
        return true;//LC:7402
    }//LC:7403
//LC:7404
    /**//LC:7405
     * <p>Checks if the CharSequence contains only uppercase characters.</p>//LC:7406
     *//LC:7407
     * <p>{@code null} will return {@code false}.//LC:7408
     * An empty String (length()=0) will return {@code false}.</p>//LC:7409
     *//LC:7410
     * <pre>//LC:7411
     * StringUtils.isAllUpperCase(null)   = false//LC:7412
     * StringUtils.isAllUpperCase("")     = false//LC:7413
     * StringUtils.isAllUpperCase("  ")   = false//LC:7414
     * StringUtils.isAllUpperCase("ABC")  = true//LC:7415
     * StringUtils.isAllUpperCase("aBC") = false//LC:7416
     * </pre>//LC:7417
     *//LC:7418
     * @param cs the CharSequence to check, may be null//LC:7419
     * @return {@code true} if only contains uppercase characters, and is non-null//LC:7420
     * @since 2.5//LC:7421
     * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)//LC:7422
     *///LC:7423
    public static boolean isAllUpperCase(final CharSequence cs) {//LC:7424
        if (cs == null || isEmpty(cs)) {//LC:7425
            return false;//LC:7426
        }//LC:7427
        final int sz = cs.length();//LC:7428
        for (int i = 0; i < sz; i++) {//LC:7429
            if (Character.isUpperCase(cs.charAt(i)) == false) {//LC:7430
                return false;//LC:7431
            }//LC:7432
        }//LC:7433
        return true;//LC:7434
    }//LC:7435
//LC:7436
    // Defaults//LC:7437
    //-----------------------------------------------------------------------//LC:7438
    /**//LC:7439
     * <p>Returns either the passed in String,//LC:7440
     * or if the String is {@code null}, an empty String ("").</p>//LC:7441
     *//LC:7442
     * <pre>//LC:7443
     * StringUtils.defaultString(null)  = ""//LC:7444
     * StringUtils.defaultString("")    = ""//LC:7445
     * StringUtils.defaultString("bat") = "bat"//LC:7446
     * </pre>//LC:7447
     *//LC:7448
     * @see ObjectUtils#toString(Object)//LC:7449
     * @see String#valueOf(Object)//LC:7450
     * @param str  the String to check, may be null//LC:7451
     * @return the passed in String, or the empty String if it//LC:7452
     *  was {@code null}//LC:7453
     *///LC:7454
    public static String defaultString(final String str) {//LC:7455
        return str == null ? EMPTY : str;//LC:7456
    }//LC:7457
//LC:7458
    /**//LC:7459
     * <p>Returns either the passed in String, or if the String is//LC:7460
     * {@code null}, the value of {@code defaultStr}.</p>//LC:7461
     *//LC:7462
     * <pre>//LC:7463
     * StringUtils.defaultString(null, "NULL")  = "NULL"//LC:7464
     * StringUtils.defaultString("", "NULL")    = ""//LC:7465
     * StringUtils.defaultString("bat", "NULL") = "bat"//LC:7466
     * </pre>//LC:7467
     *//LC:7468
     * @see ObjectUtils#toString(Object,String)//LC:7469
     * @see String#valueOf(Object)//LC:7470
     * @param str  the String to check, may be null//LC:7471
     * @param defaultStr  the default String to return//LC:7472
     *  if the input is {@code null}, may be null//LC:7473
     * @return the passed in String, or the default if it was {@code null}//LC:7474
     *///LC:7475
    public static String defaultString(final String str, final String defaultStr) {//LC:7476
        return str == null ? defaultStr : str;//LC:7477
    }//LC:7478
//LC:7479
    /**//LC:7480
     * <p>Returns either the passed in CharSequence, or if the CharSequence is//LC:7481
     * whitespace, empty ("") or {@code null}, the value of {@code defaultStr}.</p>//LC:7482
     *//LC:7483
     * <pre>//LC:7484
     * StringUtils.defaultIfBlank(null, "NULL")  = "NULL"//LC:7485
     * StringUtils.defaultIfBlank("", "NULL")    = "NULL"//LC:7486
     * StringUtils.defaultIfBlank(" ", "NULL")   = "NULL"//LC:7487
     * StringUtils.defaultIfBlank("bat", "NULL") = "bat"//LC:7488
     * StringUtils.defaultIfBlank("", null)      = null//LC:7489
     * </pre>//LC:7490
     * @param <T> the specific kind of CharSequence//LC:7491
     * @param str the CharSequence to check, may be null//LC:7492
     * @param defaultStr  the default CharSequence to return//LC:7493
     *  if the input is whitespace, empty ("") or {@code null}, may be null//LC:7494
     * @return the passed in CharSequence, or the default//LC:7495
     * @see StringUtils#defaultString(String, String)//LC:7496
     *///LC:7497
    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {//LC:7498
        return StringUtils.isBlank(str) ? defaultStr : str;//LC:7499
    }//LC:7500
//LC:7501
    /**//LC:7502
     * <p>Returns either the passed in CharSequence, or if the CharSequence is//LC:7503
     * empty or {@code null}, the value of {@code defaultStr}.</p>//LC:7504
     *//LC:7505
     * <pre>//LC:7506
     * StringUtils.defaultIfEmpty(null, "NULL")  = "NULL"//LC:7507
     * StringUtils.defaultIfEmpty("", "NULL")    = "NULL"//LC:7508
     * StringUtils.defaultIfEmpty(" ", "NULL")   = " "//LC:7509
     * StringUtils.defaultIfEmpty("bat", "NULL") = "bat"//LC:7510
     * StringUtils.defaultIfEmpty("", null)      = null//LC:7511
     * </pre>//LC:7512
     * @param <T> the specific kind of CharSequence//LC:7513
     * @param str  the CharSequence to check, may be null//LC:7514
     * @param defaultStr  the default CharSequence to return//LC:7515
     *  if the input is empty ("") or {@code null}, may be null//LC:7516
     * @return the passed in CharSequence, or the default//LC:7517
     * @see StringUtils#defaultString(String, String)//LC:7518
     *///LC:7519
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {//LC:7520
        return StringUtils.isEmpty(str) ? defaultStr : str;//LC:7521
    }//LC:7522
//LC:7523
    // Reversing//LC:7524
    //-----------------------------------------------------------------------//LC:7525
    /**//LC:7526
     * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>//LC:7527
     *//LC:7528
     * <p>A {@code null} String returns {@code null}.</p>//LC:7529
     *//LC:7530
     * <pre>//LC:7531
     * StringUtils.reverse(null)  = null//LC:7532
     * StringUtils.reverse("")    = ""//LC:7533
     * StringUtils.reverse("bat") = "tab"//LC:7534
     * </pre>//LC:7535
     *//LC:7536
     * @param str  the String to reverse, may be null//LC:7537
     * @return the reversed String, {@code null} if null String input//LC:7538
     *///LC:7539
    public static String reverse(final String str) {//LC:7540
        if (str == null) {//LC:7541
            return null;//LC:7542
        }//LC:7543
        return new StringBuilder(str).reverse().toString();//LC:7544
    }//LC:7545
//LC:7546
    /**//LC:7547
     * <p>Reverses a String that is delimited by a specific character.</p>//LC:7548
     *//LC:7549
     * <p>The Strings between the delimiters are not reversed.//LC:7550
     * Thus java.lang.String becomes String.lang.java (if the delimiter//LC:7551
     * is {@code '.'}).</p>//LC:7552
     *//LC:7553
     * <pre>//LC:7554
     * StringUtils.reverseDelimited(null, *)      = null//LC:7555
     * StringUtils.reverseDelimited("", *)        = ""//LC:7556
     * StringUtils.reverseDelimited("a.b.c", 'x') = "a.b.c"//LC:7557
     * StringUtils.reverseDelimited("a.b.c", ".") = "c.b.a"//LC:7558
     * </pre>//LC:7559
     *//LC:7560
     * @param str  the String to reverse, may be null//LC:7561
     * @param separatorChar  the separator character to use//LC:7562
     * @return the reversed String, {@code null} if null String input//LC:7563
     * @since 2.0//LC:7564
     *///LC:7565
    public static String reverseDelimited(final String str, final char separatorChar) {//LC:7566
        if (str == null) {//LC:7567
            return null;//LC:7568
        }//LC:7569
        // could implement manually, but simple way is to reuse other,//LC:7570
        // probably slower, methods.//LC:7571
        final String[] strs = split(str, separatorChar);//LC:7572
        ArrayUtils.reverse(strs);//LC:7573
        return join(strs, separatorChar);//LC:7574
    }//LC:7575
//LC:7576
    // Abbreviating//LC:7577
    //-----------------------------------------------------------------------//LC:7578
    /**//LC:7579
     * <p>Abbreviates a String using ellipses. This will turn//LC:7580
     * "Now is the time for all good men" into "Now is the time for..."</p>//LC:7581
     *//LC:7582
     * <p>Specifically://LC:7583
     * <ul>//LC:7584
     *   <li>If {@code str} is less than {@code maxWidth} characters//LC:7585
     *       long, return it.</li>//LC:7586
     *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + "...")}.</li>//LC:7587
     *   <li>If {@code maxWidth} is less than {@code 4}, throw an//LC:7588
     *       {@code IllegalArgumentException}.</li>//LC:7589
     *   <li>In no case will it return a String of length greater than//LC:7590
     *       {@code maxWidth}.</li>//LC:7591
     * </ul>//LC:7592
     * </p>//LC:7593
     *//LC:7594
     * <pre>//LC:7595
     * StringUtils.abbreviate(null, *)      = null//LC:7596
     * StringUtils.abbreviate("", 4)        = ""//LC:7597
     * StringUtils.abbreviate("abcdefg", 6) = "abc..."//LC:7598
     * StringUtils.abbreviate("abcdefg", 7) = "abcdefg"//LC:7599
     * StringUtils.abbreviate("abcdefg", 8) = "abcdefg"//LC:7600
     * StringUtils.abbreviate("abcdefg", 4) = "a..."//LC:7601
     * StringUtils.abbreviate("abcdefg", 3) = IllegalArgumentException//LC:7602
     * </pre>//LC:7603
     *//LC:7604
     * @param str  the String to check, may be null//LC:7605
     * @param maxWidth  maximum length of result String, must be at least 4//LC:7606
     * @return abbreviated String, {@code null} if null String input//LC:7607
     * @throws IllegalArgumentException if the width is too small//LC:7608
     * @since 2.0//LC:7609
     *///LC:7610
    public static String abbreviate(final String str, final int maxWidth) {//LC:7611
        return abbreviate(str, 0, maxWidth);//LC:7612
    }//LC:7613
//LC:7614
    /**//LC:7615
     * <p>Abbreviates a String using ellipses. This will turn//LC:7616
     * "Now is the time for all good men" into "...is the time for..."</p>//LC:7617
     *//LC:7618
     * <p>Works like {@code abbreviate(String, int)}, but allows you to specify//LC:7619
     * a "left edge" offset.  Note that this left edge is not necessarily going to//LC:7620
     * be the leftmost character in the result, or the first character following the//LC:7621
     * ellipses, but it will appear somewhere in the result.//LC:7622
     *//LC:7623
     * <p>In no case will it return a String of length greater than//LC:7624
     * {@code maxWidth}.</p>//LC:7625
     *//LC:7626
     * <pre>//LC:7627
     * StringUtils.abbreviate(null, *, *)                = null//LC:7628
     * StringUtils.abbreviate("", 0, 4)                  = ""//LC:7629
     * StringUtils.abbreviate("abcdefghijklmno", -1, 10) = "abcdefg..."//LC:7630
     * StringUtils.abbreviate("abcdefghijklmno", 0, 10)  = "abcdefg..."//LC:7631
     * StringUtils.abbreviate("abcdefghijklmno", 1, 10)  = "abcdefg..."//LC:7632
     * StringUtils.abbreviate("abcdefghijklmno", 4, 10)  = "abcdefg..."//LC:7633
     * StringUtils.abbreviate("abcdefghijklmno", 5, 10)  = "...fghi..."//LC:7634
     * StringUtils.abbreviate("abcdefghijklmno", 6, 10)  = "...ghij..."//LC:7635
     * StringUtils.abbreviate("abcdefghijklmno", 8, 10)  = "...ijklmno"//LC:7636
     * StringUtils.abbreviate("abcdefghijklmno", 10, 10) = "...ijklmno"//LC:7637
     * StringUtils.abbreviate("abcdefghijklmno", 12, 10) = "...ijklmno"//LC:7638
     * StringUtils.abbreviate("abcdefghij", 0, 3)        = IllegalArgumentException//LC:7639
     * StringUtils.abbreviate("abcdefghij", 5, 6)        = IllegalArgumentException//LC:7640
     * </pre>//LC:7641
     *//LC:7642
     * @param str  the String to check, may be null//LC:7643
     * @param offset  left edge of source String//LC:7644
     * @param maxWidth  maximum length of result String, must be at least 4//LC:7645
     * @return abbreviated String, {@code null} if null String input//LC:7646
     * @throws IllegalArgumentException if the width is too small//LC:7647
     * @since 2.0//LC:7648
     *///LC:7649
    public static String abbreviate(final String str, int offset, final int maxWidth) {//LC:7650
        if (str == null) {//LC:7651
            return null;//LC:7652
        }//LC:7653
        if (maxWidth < 4) {//LC:7654
            throw new IllegalArgumentException("Minimum abbreviation width is 4");//LC:7655
        }//LC:7656
        if (str.length() <= maxWidth) {//LC:7657
            return str;//LC:7658
        }//LC:7659
        if (offset > str.length()) {//LC:7660
            offset = str.length();//LC:7661
        }//LC:7662
        if (str.length() - offset < maxWidth - 3) {//LC:7663
            offset = str.length() - (maxWidth - 3);//LC:7664
        }//LC:7665
        final String abrevMarker = "...";//LC:7666
        if (offset <= 4) {//LC:7667
            return str.substring(0, maxWidth - 3) + abrevMarker;//LC:7668
        }//LC:7669
        if (maxWidth < 7) {//LC:7670
            throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");//LC:7671
        }//LC:7672
        if (offset + maxWidth - 3 < str.length()) {//LC:7673
            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);//LC:7674
        }//LC:7675
        return abrevMarker + str.substring(str.length() - (maxWidth - 3));//LC:7676
    }//LC:7677
//LC:7678
    /**//LC:7679
     * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied//LC:7680
     * replacement String.</p>//LC:7681
     *//LC:7682
     * <p>This abbreviation only occurs if the following criteria is met://LC:7683
     * <ul>//LC:7684
     * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>//LC:7685
     * <li>The length to truncate to is less than the length of the supplied String</li>//LC:7686
     * <li>The length to truncate to is greater than 0</li>//LC:7687
     * <li>The abbreviated String will have enough room for the length supplied replacement String//LC:7688
     * and the first and last characters of the supplied String for abbreviation</li>//LC:7689
     * </ul>//LC:7690
     * Otherwise, the returned String will be the same as the supplied String for abbreviation.//LC:7691
     * </p>//LC:7692
     *//LC:7693
     * <pre>//LC:7694
     * StringUtils.abbreviateMiddle(null, null, 0)      = null//LC:7695
     * StringUtils.abbreviateMiddle("abc", null, 0)      = "abc"//LC:7696
     * StringUtils.abbreviateMiddle("abc", ".", 0)      = "abc"//LC:7697
     * StringUtils.abbreviateMiddle("abc", ".", 3)      = "abc"//LC:7698
     * StringUtils.abbreviateMiddle("abcdef", ".", 4)     = "ab.f"//LC:7699
     * </pre>//LC:7700
     *//LC:7701
     * @param str  the String to abbreviate, may be null//LC:7702
     * @param middle the String to replace the middle characters with, may be null//LC:7703
     * @param length the length to abbreviate {@code str} to.//LC:7704
     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.//LC:7705
     * @since 2.5//LC:7706
     *///LC:7707
    public static String abbreviateMiddle(final String str, final String middle, final int length) {//LC:7708
        if (isEmpty(str) || isEmpty(middle)) {//LC:7709
            return str;//LC:7710
        }//LC:7711
//LC:7712
        if (length >= str.length() || length < middle.length()+2) {//LC:7713
            return str;//LC:7714
        }//LC:7715
//LC:7716
        final int targetSting = length-middle.length();//LC:7717
        final int startOffset = targetSting/2+targetSting%2;//LC:7718
        final int endOffset = str.length()-targetSting/2;//LC:7719
//LC:7720
        final StringBuilder builder = new StringBuilder(length);//LC:7721
        builder.append(str.substring(0,startOffset));//LC:7722
        builder.append(middle);//LC:7723
        builder.append(str.substring(endOffset));//LC:7724
//LC:7725
        return builder.toString();//LC:7726
    }//LC:7727
//LC:7728
    // Difference//LC:7729
    //-----------------------------------------------------------------------//LC:7730
    /**//LC:7731
     * <p>Compares two Strings, and returns the portion where they differ.//LC:7732
     * More precisely, return the remainder of the second String,//LC:7733
     * starting from where it's different from the first. This means that//LC:7734
     * the difference between "abc" and "ab" is the empty String and not "c". </p>//LC:7735
     *//LC:7736
     * <p>For example,//LC:7737
     * {@code difference("i am a machine", "i am a robot") -> "robot"}.</p>//LC:7738
     *//LC:7739
     * <pre>//LC:7740
     * StringUtils.difference(null, null) = null//LC:7741
     * StringUtils.difference("", "") = ""//LC:7742
     * StringUtils.difference("", "abc") = "abc"//LC:7743
     * StringUtils.difference("abc", "") = ""//LC:7744
     * StringUtils.difference("abc", "abc") = ""//LC:7745
     * StringUtils.difference("abc", "ab") = ""//LC:7746
     * StringUtils.difference("ab", "abxyz") = "xyz"//LC:7747
     * StringUtils.difference("abcde", "abxyz") = "xyz"//LC:7748
     * StringUtils.difference("abcde", "xyz") = "xyz"//LC:7749
     * </pre>//LC:7750
     *//LC:7751
     * @param str1  the first String, may be null//LC:7752
     * @param str2  the second String, may be null//LC:7753
     * @return the portion of str2 where it differs from str1; returns the//LC:7754
     * empty String if they are equal//LC:7755
     * @see #indexOfDifference(CharSequence,CharSequence)//LC:7756
     * @since 2.0//LC:7757
     *///LC:7758
    public static String difference(final String str1, final String str2) {//LC:7759
        if (str1 == null) {//LC:7760
            return str2;//LC:7761
        }//LC:7762
        if (str2 == null) {//LC:7763
            return str1;//LC:7764
        }//LC:7765
        final int at = indexOfDifference(str1, str2);//LC:7766
        if (at == INDEX_NOT_FOUND) {//LC:7767
            return EMPTY;//LC:7768
        }//LC:7769
        return str2.substring(at);//LC:7770
    }//LC:7771
//LC:7772
    /**//LC:7773
     * <p>Compares two CharSequences, and returns the index at which the//LC:7774
     * CharSequences begin to differ.</p>//LC:7775
     *//LC:7776
     * <p>For example,//LC:7777
     * {@code indexOfDifference("i am a machine", "i am a robot") -> 7}</p>//LC:7778
     *//LC:7779
     * <pre>//LC:7780
     * StringUtils.indexOfDifference(null, null) = -1//LC:7781
     * StringUtils.indexOfDifference("", "") = -1//LC:7782
     * StringUtils.indexOfDifference("", "abc") = 0//LC:7783
     * StringUtils.indexOfDifference("abc", "") = 0//LC:7784
     * StringUtils.indexOfDifference("abc", "abc") = -1//LC:7785
     * StringUtils.indexOfDifference("ab", "abxyz") = 2//LC:7786
     * StringUtils.indexOfDifference("abcde", "abxyz") = 2//LC:7787
     * StringUtils.indexOfDifference("abcde", "xyz") = 0//LC:7788
     * </pre>//LC:7789
     *//LC:7790
     * @param cs1  the first CharSequence, may be null//LC:7791
     * @param cs2  the second CharSequence, may be null//LC:7792
     * @return the index where cs1 and cs2 begin to differ; -1 if they are equal//LC:7793
     * @since 2.0//LC:7794
     * @since 3.0 Changed signature from indexOfDifference(String, String) to//LC:7795
     * indexOfDifference(CharSequence, CharSequence)//LC:7796
     *///LC:7797
    public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) {//LC:7798
        if (cs1 == cs2) {//LC:7799
            return INDEX_NOT_FOUND;//LC:7800
        }//LC:7801
        if (cs1 == null || cs2 == null) {//LC:7802
            return 0;//LC:7803
        }//LC:7804
        int i;//LC:7805
        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {//LC:7806
            if (cs1.charAt(i) != cs2.charAt(i)) {//LC:7807
                break;//LC:7808
            }//LC:7809
        }//LC:7810
        if (i < cs2.length() || i < cs1.length()) {//LC:7811
            return i;//LC:7812
        }//LC:7813
        return INDEX_NOT_FOUND;//LC:7814
    }//LC:7815
//LC:7816
    /**//LC:7817
     * <p>Compares all CharSequences in an array and returns the index at which the//LC:7818
     * CharSequences begin to differ.</p>//LC:7819
     *//LC:7820
     * <p>For example,//LC:7821
     * <code>indexOfDifference(new String[] {"i am a machine", "i am a robot"}) -> 7</code></p>//LC:7822
     *//LC:7823
     * <pre>//LC:7824
     * StringUtils.indexOfDifference(null) = -1//LC:7825
     * StringUtils.indexOfDifference(new String[] {}) = -1//LC:7826
     * StringUtils.indexOfDifference(new String[] {"abc"}) = -1//LC:7827
     * StringUtils.indexOfDifference(new String[] {null, null}) = -1//LC:7828
     * StringUtils.indexOfDifference(new String[] {"", ""}) = -1//LC:7829
     * StringUtils.indexOfDifference(new String[] {"", null}) = 0//LC:7830
     * StringUtils.indexOfDifference(new String[] {"abc", null, null}) = 0//LC:7831
     * StringUtils.indexOfDifference(new String[] {null, null, "abc"}) = 0//LC:7832
     * StringUtils.indexOfDifference(new String[] {"", "abc"}) = 0//LC:7833
     * StringUtils.indexOfDifference(new String[] {"abc", ""}) = 0//LC:7834
     * StringUtils.indexOfDifference(new String[] {"abc", "abc"}) = -1//LC:7835
     * StringUtils.indexOfDifference(new String[] {"abc", "a"}) = 1//LC:7836
     * StringUtils.indexOfDifference(new String[] {"ab", "abxyz"}) = 2//LC:7837
     * StringUtils.indexOfDifference(new String[] {"abcde", "abxyz"}) = 2//LC:7838
     * StringUtils.indexOfDifference(new String[] {"abcde", "xyz"}) = 0//LC:7839
     * StringUtils.indexOfDifference(new String[] {"xyz", "abcde"}) = 0//LC:7840
     * StringUtils.indexOfDifference(new String[] {"i am a machine", "i am a robot"}) = 7//LC:7841
     * </pre>//LC:7842
     *//LC:7843
     * @param css  array of CharSequences, entries may be null//LC:7844
     * @return the index where the strings begin to differ; -1 if they are all equal//LC:7845
     * @since 2.4//LC:7846
     * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)//LC:7847
     *///LC:7848
    public static int indexOfDifference(final CharSequence... css) {//LC:7849
        if (css == null || css.length <= 1) {//LC:7850
            return INDEX_NOT_FOUND;//LC:7851
        }//LC:7852
        boolean anyStringNull = false;//LC:7853
        boolean allStringsNull = true;//LC:7854
        final int arrayLen = css.length;//LC:7855
        int shortestStrLen = Integer.MAX_VALUE;//LC:7856
        int longestStrLen = 0;//LC:7857
//LC:7858
        // find the min and max string lengths; this avoids checking to make//LC:7859
        // sure we are not exceeding the length of the string each time through//LC:7860
        // the bottom loop.//LC:7861
        for (int i = 0; i < arrayLen; i++) {//LC:7862
            if (css[i] == null) {//LC:7863
                anyStringNull = true;//LC:7864
                shortestStrLen = 0;//LC:7865
            } else {//LC:7866
                allStringsNull = false;//LC:7867
                shortestStrLen = Math.min(css[i].length(), shortestStrLen);//LC:7868
                longestStrLen = Math.max(css[i].length(), longestStrLen);//LC:7869
            }//LC:7870
        }//LC:7871
//LC:7872
        // handle lists containing all nulls or all empty strings//LC:7873
        if (allStringsNull || longestStrLen == 0 && !anyStringNull) {//LC:7874
            return INDEX_NOT_FOUND;//LC:7875
        }//LC:7876
//LC:7877
        // handle lists containing some nulls or some empty strings//LC:7878
        if (shortestStrLen == 0) {//LC:7879
            return 0;//LC:7880
        }//LC:7881
//LC:7882
        // find the position with the first difference across all strings//LC:7883
        int firstDiff = -1;//LC:7884
        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {//LC:7885
            final char comparisonChar = css[0].charAt(stringPos);//LC:7886
            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {//LC:7887
                if (css[arrayPos].charAt(stringPos) != comparisonChar) {//LC:7888
                    firstDiff = stringPos;//LC:7889
                    break;//LC:7890
                }//LC:7891
            }//LC:7892
            if (firstDiff != -1) {//LC:7893
                break;//LC:7894
            }//LC:7895
        }//LC:7896
//LC:7897
        if (firstDiff == -1 && shortestStrLen != longestStrLen) {//LC:7898
            // we compared all of the characters up to the length of the//LC:7899
            // shortest string and didn't find a match, but the string lengths//LC:7900
            // vary, so return the length of the shortest string.//LC:7901
            return shortestStrLen;//LC:7902
        }//LC:7903
        return firstDiff;//LC:7904
    }//LC:7905
//LC:7906
    /**//LC:7907
     * <p>Compares all Strings in an array and returns the initial sequence of//LC:7908
     * characters that is common to all of them.</p>//LC:7909
     *//LC:7910
     * <p>For example,//LC:7911
     * <code>getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -> "i am a "</code></p>//LC:7912
     *//LC:7913
     * <pre>//LC:7914
     * StringUtils.getCommonPrefix(null) = ""//LC:7915
     * StringUtils.getCommonPrefix(new String[] {}) = ""//LC:7916
     * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"//LC:7917
     * StringUtils.getCommonPrefix(new String[] {null, null}) = ""//LC:7918
     * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""//LC:7919
     * StringUtils.getCommonPrefix(new String[] {"", null}) = ""//LC:7920
     * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""//LC:7921
     * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""//LC:7922
     * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""//LC:7923
     * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""//LC:7924
     * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"//LC:7925
     * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"//LC:7926
     * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"//LC:7927
     * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"//LC:7928
     * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""//LC:7929
     * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""//LC:7930
     * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "//LC:7931
     * </pre>//LC:7932
     *//LC:7933
     * @param strs  array of String objects, entries may be null//LC:7934
     * @return the initial sequence of characters that are common to all Strings//LC:7935
     * in the array; empty String if the array is null, the elements are all null//LC:7936
     * or if there is no common prefix.//LC:7937
     * @since 2.4//LC:7938
     *///LC:7939
    public static String getCommonPrefix(final String... strs) {//LC:7940
        if (strs == null || strs.length == 0) {//LC:7941
            return EMPTY;//LC:7942
        }//LC:7943
        final int smallestIndexOfDiff = indexOfDifference(strs);//LC:7944
        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {//LC:7945
            // all strings were identical//LC:7946
            if (strs[0] == null) {//LC:7947
                return EMPTY;//LC:7948
            }//LC:7949
            return strs[0];//LC:7950
        } else if (smallestIndexOfDiff == 0) {//LC:7951
            // there were no common initial characters//LC:7952
            return EMPTY;//LC:7953
        } else {//LC:7954
            // we found a common initial character sequence//LC:7955
            return strs[0].substring(0, smallestIndexOfDiff);//LC:7956
        }//LC:7957
    }//LC:7958
//LC:7959
    // Misc//LC:7960
    //-----------------------------------------------------------------------//LC:7961
    /**//LC:7962
     * <p>Find the Levenshtein distance between two Strings.</p>//LC:7963
     *//LC:7964
     * <p>This is the number of changes needed to change one String into//LC:7965
     * another, where each change is a single character modification (deletion,//LC:7966
     * insertion or substitution).</p>//LC:7967
     *//LC:7968
     * <p>The previous implementation of the Levenshtein distance algorithm//LC:7969
     * was from <a href="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>//LC:7970
     *//LC:7971
     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError//LC:7972
     * which can occur when my Java implementation is used with very large strings.<br>//LC:7973
     * This implementation of the Levenshtein distance algorithm//LC:7974
     * is from <a href="http://www.merriampark.com/ldjava.htm">http://www.merriampark.com/ldjava.htm</a></p>//LC:7975
     *//LC:7976
     * <pre>//LC:7977
     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException//LC:7978
     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException//LC:7979
     * StringUtils.getLevenshteinDistance("","")               = 0//LC:7980
     * StringUtils.getLevenshteinDistance("","a")              = 1//LC:7981
     * StringUtils.getLevenshteinDistance("aaapppp", "")       = 7//LC:7982
     * StringUtils.getLevenshteinDistance("frog", "fog")       = 1//LC:7983
     * StringUtils.getLevenshteinDistance("fly", "ant")        = 3//LC:7984
     * StringUtils.getLevenshteinDistance("elephant", "hippo") = 7//LC:7985
     * StringUtils.getLevenshteinDistance("hippo", "elephant") = 7//LC:7986
     * StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") = 8//LC:7987
     * StringUtils.getLevenshteinDistance("hello", "hallo")    = 1//LC:7988
     * </pre>//LC:7989
     *//LC:7990
     * @param s  the first String, must not be null//LC:7991
     * @param t  the second String, must not be null//LC:7992
     * @return result distance//LC:7993
     * @throws IllegalArgumentException if either String input {@code null}//LC:7994
     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to//LC:7995
     * getLevenshteinDistance(CharSequence, CharSequence)//LC:7996
     *///LC:7997
    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {//LC:7998
        if (s == null || t == null) {//LC:7999
            throw new IllegalArgumentException("Strings must not be null");//LC:8000
        }//LC:8001
//LC:8002
        /*//LC:8003
           The difference between this impl. and the previous is that, rather//LC:8004
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,//LC:8005
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,//LC:8006
           is the 'current working' distance array that maintains the newest distance cost//LC:8007
           counts as we iterate through the characters of String s.  Each time we increment//LC:8008
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so//LC:8009
           allows us to retain the previous cost counts as required by the algorithm (taking//LC:8010
           the minimum of the cost count to the left, up one, and diagonally up and to the left//LC:8011
           of the current cost count being calculated).  (Note that the arrays aren't really//LC:8012
           copied anymore, just switched...this is clearly much better than cloning an array//LC:8013
           or doing a System.arraycopy() each time  through the outer loop.)//LC:8014
//LC:8015
           Effectively, the difference between the two implementations is this one does not//LC:8016
           cause an out of memory condition when calculating the LD over two very large strings.//LC:8017
         *///LC:8018
//LC:8019
        int n = s.length(); // length of s//LC:8020
        int m = t.length(); // length of t//LC:8021
//LC:8022
        if (n == 0) {//LC:8023
            return m;//LC:8024
        } else if (m == 0) {//LC:8025
            return n;//LC:8026
        }//LC:8027
//LC:8028
        if (n > m) {//LC:8029
            // swap the input strings to consume less memory//LC:8030
            final CharSequence tmp = s;//LC:8031
            s = t;//LC:8032
            t = tmp;//LC:8033
            n = m;//LC:8034
            m = t.length();//LC:8035
        }//LC:8036
//LC:8037
        int p[] = new int[n + 1]; //'previous' cost array, horizontally//LC:8038
        int d[] = new int[n + 1]; // cost array, horizontally//LC:8039
        int _d[]; //placeholder to assist in swapping p and d//LC:8040
//LC:8041
        // indexes into strings s and t//LC:8042
        int i; // iterates through s//LC:8043
        int j; // iterates through t//LC:8044
//LC:8045
        char t_j; // jth character of t//LC:8046
//LC:8047
        int cost; // cost//LC:8048
//LC:8049
        for (i = 0; i <= n; i++) {//LC:8050
            p[i] = i;//LC:8051
        }//LC:8052
//LC:8053
        for (j = 1; j <= m; j++) {//LC:8054
            t_j = t.charAt(j - 1);//LC:8055
            d[0] = j;//LC:8056
//LC:8057
            for (i = 1; i <= n; i++) {//LC:8058
                cost = s.charAt(i - 1) == t_j ? 0 : 1;//LC:8059
                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost//LC:8060
                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);//LC:8061
            }//LC:8062
//LC:8063
            // copy current distance counts to 'previous row' distance counts//LC:8064
            _d = p;//LC:8065
            p = d;//LC:8066
            d = _d;//LC:8067
        }//LC:8068
//LC:8069
        // our last action in the above loop was to switch d and p, so p now//LC:8070
        // actually has the most recent cost counts//LC:8071
        return p[n];//LC:8072
    }//LC:8073
//LC:8074
    /**//LC:8075
     * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given//LC:8076
     * threshold.</p>//LC:8077
     *//LC:8078
     * <p>This is the number of changes needed to change one String into//LC:8079
     * another, where each change is a single character modification (deletion,//LC:8080
     * insertion or substitution).</p>//LC:8081
     *//LC:8082
     * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield//LC:8083
     * and Chas Emerick's implementation of the Levenshtein distance algorithm from//LC:8084
     * <a href="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>//LC:8085
     *//LC:8086
     * <pre>//LC:8087
     * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException//LC:8088
     * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException//LC:8089
     * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException//LC:8090
     * StringUtils.getLevenshteinDistance("","", 0)               = 0//LC:8091
     * StringUtils.getLevenshteinDistance("aaapppp", "", 8)       = 7//LC:8092
     * StringUtils.getLevenshteinDistance("aaapppp", "", 7)       = 7//LC:8093
     * StringUtils.getLevenshteinDistance("aaapppp", "", 6))      = -1//LC:8094
     * StringUtils.getLevenshteinDistance("elephant", "hippo", 7) = 7//LC:8095
     * StringUtils.getLevenshteinDistance("elephant", "hippo", 6) = -1//LC:8096
     * StringUtils.getLevenshteinDistance("hippo", "elephant", 7) = 7//LC:8097
     * StringUtils.getLevenshteinDistance("hippo", "elephant", 6) = -1//LC:8098
     * </pre>//LC:8099
     *//LC:8100
     * @param s  the first String, must not be null//LC:8101
     * @param t  the second String, must not be null//LC:8102
     * @param threshold the target threshold, must not be negative//LC:8103
     * @return result distance, or {@code -1} if the distance would be greater than the threshold//LC:8104
     * @throws IllegalArgumentException if either String input {@code null} or negative threshold//LC:8105
     *///LC:8106
    public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {//LC:8107
        if (s == null || t == null) {//LC:8108
            throw new IllegalArgumentException("Strings must not be null");//LC:8109
        }//LC:8110
        if (threshold < 0) {//LC:8111
            throw new IllegalArgumentException("Threshold must not be negative");//LC:8112
        }//LC:8113
//LC:8114
        /*//LC:8115
        This implementation only computes the distance if it's less than or equal to the//LC:8116
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded//LC:8117
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only//LC:8118
        computing a diagonal stripe of width 2k + 1 of the cost table.//LC:8119
        It is also possible to use this to compute the unbounded Levenshtein distance by starting//LC:8120
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where//LC:8121
        d is the distance.//LC:8122
//LC:8123
        One subtlety comes from needing to ignore entries on the border of our stripe//LC:8124
        eg.//LC:8125
        p[] = |#|#|#|*//LC:8126
        d[] =  *|#|#|#|//LC:8127
        We must ignore the entry to the left of the leftmost member//LC:8128
        We must ignore the entry above the rightmost member//LC:8129
//LC:8130
        Another subtlety comes from our stripe running off the matrix if the strings aren't//LC:8131
        of the same size.  Since string s is always swapped to be the shorter of the two,//LC:8132
        the stripe will always run off to the upper right instead of the lower left of the matrix.//LC:8133
//LC:8134
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.//LC:8135
        In this case we're going to walk a stripe of length 3.  The matrix would look like so://LC:8136
//LC:8137
           1 2 3 4 5//LC:8138
        1 |#|#| | | |//LC:8139
        2 |#|#|#| | |//LC:8140
        3 | |#|#|#| |//LC:8141
        4 | | |#|#|#|//LC:8142
        5 | | | |#|#|//LC:8143
        6 | | | | |#|//LC:8144
        7 | | | | | |//LC:8145
//LC:8146
        Note how the stripe leads off the table as there is no possible way to turn a string of length 5//LC:8147
        into one of length 7 in edit distance of 1.//LC:8148
//LC:8149
        Additionally, this implementation decreases memory usage by using two//LC:8150
        single-dimensional arrays and swapping them back and forth instead of allocating//LC:8151
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning//LC:8152
        when it's detected that the stripe has run off the matrix and initially filling the arrays with//LC:8153
        large values so that entries we don't compute are ignored.//LC:8154
//LC:8155
        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.//LC:8156
         *///LC:8157
//LC:8158
        int n = s.length(); // length of s//LC:8159
        int m = t.length(); // length of t//LC:8160
//LC:8161
        // if one string is empty, the edit distance is necessarily the length of the other//LC:8162
        if (n == 0) {//LC:8163
            return m <= threshold ? m : -1;//LC:8164
        } else if (m == 0) {//LC:8165
            return n <= threshold ? n : -1;//LC:8166
        }//LC:8167
//LC:8168
        if (n > m) {//LC:8169
            // swap the two strings to consume less memory//LC:8170
            final CharSequence tmp = s;//LC:8171
            s = t;//LC:8172
            t = tmp;//LC:8173
            n = m;//LC:8174
            m = t.length();//LC:8175
        }//LC:8176
//LC:8177
        int p[] = new int[n + 1]; // 'previous' cost array, horizontally//LC:8178
        int d[] = new int[n + 1]; // cost array, horizontally//LC:8179
        int _d[]; // placeholder to assist in swapping p and d//LC:8180
//LC:8181
        // fill in starting table values//LC:8182
        final int boundary = Math.min(n, threshold) + 1;//LC:8183
        for (int i = 0; i < boundary; i++) {//LC:8184
            p[i] = i;//LC:8185
        }//LC:8186
        // these fills ensure that the value above the rightmost entry of our//LC:8187
        // stripe will be ignored in following loop iterations//LC:8188
        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);//LC:8189
        Arrays.fill(d, Integer.MAX_VALUE);//LC:8190
//LC:8191
        // iterates through t//LC:8192
        for (int j = 1; j <= m; j++) {//LC:8193
            final char t_j = t.charAt(j - 1); // jth character of t//LC:8194
            d[0] = j;//LC:8195
//LC:8196
            // compute stripe indices, constrain to array size//LC:8197
            final int min = Math.max(1, j - threshold);//LC:8198
            final int max = Math.min(n, j + threshold);//LC:8199
//LC:8200
            // the stripe may lead off of the table if s and t are of different sizes//LC:8201
            if (min > max) {//LC:8202
                return -1;//LC:8203
            }//LC:8204
//LC:8205
            // ignore entry left of leftmost//LC:8206
            if (min > 1) {//LC:8207
                d[min - 1] = Integer.MAX_VALUE;//LC:8208
            }//LC:8209
//LC:8210
            // iterates through [min, max] in s//LC:8211
            for (int i = min; i <= max; i++) {//LC:8212
                if (s.charAt(i - 1) == t_j) {//LC:8213
                    // diagonally left and up//LC:8214
                    d[i] = p[i - 1];//LC:8215
                } else {//LC:8216
                    // 1 + minimum of cell to the left, to the top, diagonally left and up//LC:8217
                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);//LC:8218
                }//LC:8219
            }//LC:8220
//LC:8221
            // copy current distance counts to 'previous row' distance counts//LC:8222
            _d = p;//LC:8223
            p = d;//LC:8224
            d = _d;//LC:8225
        }//LC:8226
//LC:8227
        // if p[n] is greater than the threshold, there's no guarantee on it being the correct//LC:8228
        // distance//LC:8229
        if (p[n] <= threshold) {//LC:8230
            return p[n];//LC:8231
        }//LC:8232
        return -1;//LC:8233
    }//LC:8234
//LC:8235
    // startsWith//LC:8236
    //-----------------------------------------------------------------------//LC:8237
//LC:8238
    /**//LC:8239
     * <p>Check if a CharSequence starts with a specified prefix.</p>//LC:8240
     *//LC:8241
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:8242
     * references are considered to be equal. The comparison is case sensitive.</p>//LC:8243
     *//LC:8244
     * <pre>//LC:8245
     * StringUtils.startsWith(null, null)      = true//LC:8246
     * StringUtils.startsWith(null, "abc")     = false//LC:8247
     * StringUtils.startsWith("abcdef", null)  = false//LC:8248
     * StringUtils.startsWith("abcdef", "abc") = true//LC:8249
     * StringUtils.startsWith("ABCDEF", "abc") = false//LC:8250
     * </pre>//LC:8251
     *//LC:8252
     * @see String#startsWith(String)//LC:8253
     * @param str  the CharSequence to check, may be null//LC:8254
     * @param prefix the prefix to find, may be null//LC:8255
     * @return {@code true} if the CharSequence starts with the prefix, case sensitive, or//LC:8256
     *  both {@code null}//LC:8257
     * @since 2.4//LC:8258
     * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)//LC:8259
     *///LC:8260
    public static boolean startsWith(final CharSequence str, final CharSequence prefix) {//LC:8261
        return startsWith(str, prefix, false);//LC:8262
    }//LC:8263
//LC:8264
    /**//LC:8265
     * <p>Case insensitive check if a CharSequence starts with a specified prefix.</p>//LC:8266
     *//LC:8267
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:8268
     * references are considered to be equal. The comparison is case insensitive.</p>//LC:8269
     *//LC:8270
     * <pre>//LC:8271
     * StringUtils.startsWithIgnoreCase(null, null)      = true//LC:8272
     * StringUtils.startsWithIgnoreCase(null, "abc")     = false//LC:8273
     * StringUtils.startsWithIgnoreCase("abcdef", null)  = false//LC:8274
     * StringUtils.startsWithIgnoreCase("abcdef", "abc") = true//LC:8275
     * StringUtils.startsWithIgnoreCase("ABCDEF", "abc") = true//LC:8276
     * </pre>//LC:8277
     *//LC:8278
     * @see String#startsWith(String)//LC:8279
     * @param str  the CharSequence to check, may be null//LC:8280
     * @param prefix the prefix to find, may be null//LC:8281
     * @return {@code true} if the CharSequence starts with the prefix, case insensitive, or//LC:8282
     *  both {@code null}//LC:8283
     * @since 2.4//LC:8284
     * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)//LC:8285
     *///LC:8286
    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {//LC:8287
        return startsWith(str, prefix, true);//LC:8288
    }//LC:8289
//LC:8290
    /**//LC:8291
     * <p>Check if a CharSequence starts with a specified prefix (optionally case insensitive).</p>//LC:8292
     *//LC:8293
     * @see String#startsWith(String)//LC:8294
     * @param str  the CharSequence to check, may be null//LC:8295
     * @param prefix the prefix to find, may be null//LC:8296
     * @param ignoreCase indicates whether the compare should ignore case//LC:8297
     *  (case insensitive) or not.//LC:8298
     * @return {@code true} if the CharSequence starts with the prefix or//LC:8299
     *  both {@code null}//LC:8300
     *///LC:8301
    private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {//LC:8302
        if (str == null || prefix == null) {//LC:8303
            return str == null && prefix == null;//LC:8304
        }//LC:8305
        if (prefix.length() > str.length()) {//LC:8306
            return false;//LC:8307
        }//LC:8308
        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());//LC:8309
    }//LC:8310
//LC:8311
    /**//LC:8312
     * <p>Check if a CharSequence starts with any of an array of specified strings.</p>//LC:8313
     *//LC:8314
     * <pre>//LC:8315
     * StringUtils.startsWithAny(null, null)      = false//LC:8316
     * StringUtils.startsWithAny(null, new String[] {"abc"})  = false//LC:8317
     * StringUtils.startsWithAny("abcxyz", null)     = false//LC:8318
     * StringUtils.startsWithAny("abcxyz", new String[] {""}) = false//LC:8319
     * StringUtils.startsWithAny("abcxyz", new String[] {"abc"}) = true//LC:8320
     * StringUtils.startsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true//LC:8321
     * </pre>//LC:8322
     *//LC:8323
     * @param string  the CharSequence to check, may be null//LC:8324
     * @param searchStrings the CharSequences to find, may be null or empty//LC:8325
     * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or//LC:8326
     *  both {@code null}//LC:8327
     * @since 2.5//LC:8328
     * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)//LC:8329
     *///LC:8330
    public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {//LC:8331
        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {//LC:8332
            return false;//LC:8333
        }//LC:8334
        for (final CharSequence searchString : searchStrings) {//LC:8335
            if (StringUtils.startsWith(string, searchString)) {//LC:8336
                return true;//LC:8337
            }//LC:8338
        }//LC:8339
        return false;//LC:8340
    }//LC:8341
//LC:8342
    // endsWith//LC:8343
    //-----------------------------------------------------------------------//LC:8344
//LC:8345
    /**//LC:8346
     * <p>Check if a CharSequence ends with a specified suffix.</p>//LC:8347
     *//LC:8348
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:8349
     * references are considered to be equal. The comparison is case sensitive.</p>//LC:8350
     *//LC:8351
     * <pre>//LC:8352
     * StringUtils.endsWith(null, null)      = true//LC:8353
     * StringUtils.endsWith(null, "def")     = false//LC:8354
     * StringUtils.endsWith("abcdef", null)  = false//LC:8355
     * StringUtils.endsWith("abcdef", "def") = true//LC:8356
     * StringUtils.endsWith("ABCDEF", "def") = false//LC:8357
     * StringUtils.endsWith("ABCDEF", "cde") = false//LC:8358
     * </pre>//LC:8359
     *//LC:8360
     * @see String#endsWith(String)//LC:8361
     * @param str  the CharSequence to check, may be null//LC:8362
     * @param suffix the suffix to find, may be null//LC:8363
     * @return {@code true} if the CharSequence ends with the suffix, case sensitive, or//LC:8364
     *  both {@code null}//LC:8365
     * @since 2.4//LC:8366
     * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)//LC:8367
     *///LC:8368
    public static boolean endsWith(final CharSequence str, final CharSequence suffix) {//LC:8369
        return endsWith(str, suffix, false);//LC:8370
    }//LC:8371
//LC:8372
    /**//LC:8373
     * <p>Case insensitive check if a CharSequence ends with a specified suffix.</p>//LC:8374
     *//LC:8375
     * <p>{@code null}s are handled without exceptions. Two {@code null}//LC:8376
     * references are considered to be equal. The comparison is case insensitive.</p>//LC:8377
     *//LC:8378
     * <pre>//LC:8379
     * StringUtils.endsWithIgnoreCase(null, null)      = true//LC:8380
     * StringUtils.endsWithIgnoreCase(null, "def")     = false//LC:8381
     * StringUtils.endsWithIgnoreCase("abcdef", null)  = false//LC:8382
     * StringUtils.endsWithIgnoreCase("abcdef", "def") = true//LC:8383
     * StringUtils.endsWithIgnoreCase("ABCDEF", "def") = true//LC:8384
     * StringUtils.endsWithIgnoreCase("ABCDEF", "cde") = false//LC:8385
     * </pre>//LC:8386
     *//LC:8387
     * @see String#endsWith(String)//LC:8388
     * @param str  the CharSequence to check, may be null//LC:8389
     * @param suffix the suffix to find, may be null//LC:8390
     * @return {@code true} if the CharSequence ends with the suffix, case insensitive, or//LC:8391
     *  both {@code null}//LC:8392
     * @since 2.4//LC:8393
     * @since 3.0 Changed signature from endsWithIgnoreCase(String, String) to endsWithIgnoreCase(CharSequence, CharSequence)//LC:8394
     *///LC:8395
    public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {//LC:8396
        return endsWith(str, suffix, true);//LC:8397
    }//LC:8398
//LC:8399
    /**//LC:8400
     * <p>Check if a CharSequence ends with a specified suffix (optionally case insensitive).</p>//LC:8401
     *//LC:8402
     * @see String#endsWith(String)//LC:8403
     * @param str  the CharSequence to check, may be null//LC:8404
     * @param suffix the suffix to find, may be null//LC:8405
     * @param ignoreCase indicates whether the compare should ignore case//LC:8406
     *  (case insensitive) or not.//LC:8407
     * @return {@code true} if the CharSequence starts with the prefix or//LC:8408
     *  both {@code null}//LC:8409
     *///LC:8410
    private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {//LC:8411
        if (str == null || suffix == null) {//LC:8412
            return str == null && suffix == null;//LC:8413
        }//LC:8414
        if (suffix.length() > str.length()) {//LC:8415
            return false;//LC:8416
        }//LC:8417
        final int strOffset = str.length() - suffix.length();//LC:8418
        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());//LC:8419
    }//LC:8420
//LC:8421
    /**//LC:8422
     * <p>//LC:8423
     * Similar to <a//LC:8424
     * href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize//LC:8425
     * -space</a>//LC:8426
     * </p>//LC:8427
     * <p>//LC:8428
     * The function returns the argument string with whitespace normalized by using//LC:8429
     * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace//LC:8430
     * and then replacing sequences of whitespace characters by a single space.//LC:8431
     * </p>//LC:8432
     * In XML Whitespace characters are the same as those allowed by the <a//LC:8433
     * href="http://www.w3.org/TR/REC-xml/#NT-S">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+//LC:8434
     * <p>//LC:8435
     * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]//LC:8436
     * <p>//LC:8437
     * For reference://LC:8438
     * <ul>//LC:8439
     * <li>\x0B = vertical tab</li>//LC:8440
     * <li>\f = #xC = form feed</li>//LC:8441
     * <li>#x20 = space</li>//LC:8442
     * <li>#x9 = \t</li>//LC:8443
     * <li>#xA = \n</li>//LC:8444
     * <li>#xD = \r</li>//LC:8445
     * </ul>//LC:8446
     * </p>//LC:8447
     * <p>//LC:8448
     * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also//LC:8449
     * normalize. Additionally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both//LC:8450
     * ends of this String.//LC:8451
     * </p>//LC:8452
     *//LC:8453
     * @see Pattern//LC:8454
     * @see #trim(String)//LC:8455
     * @see <a//LC:8456
     *      href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize-space</a>//LC:8457
     * @param str the source String to normalize whitespaces from, may be null//LC:8458
     * @return the modified string with whitespace normalized, {@code null} if null String input//LC:8459
     *//LC:8460
     * @since 3.0//LC:8461
     *///LC:8462
    public static String normalizeSpace(final String str) {//LC:8463
        if (str == null) {//LC:8464
            return null;//LC:8465
        }//LC:8466
        return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);//LC:8467
    }//LC:8468
//LC:8469
    /**//LC:8470
     * <p>Check if a CharSequence ends with any of an array of specified strings.</p>//LC:8471
     *//LC:8472
     * <pre>//LC:8473
     * StringUtils.endsWithAny(null, null)      = false//LC:8474
     * StringUtils.endsWithAny(null, new String[] {"abc"})  = false//LC:8475
     * StringUtils.endsWithAny("abcxyz", null)     = false//LC:8476
     * StringUtils.endsWithAny("abcxyz", new String[] {""}) = true//LC:8477
     * StringUtils.endsWithAny("abcxyz", new String[] {"xyz"}) = true//LC:8478
     * StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true//LC:8479
     * </pre>//LC:8480
     *//LC:8481
     * @param string  the CharSequence to check, may be null//LC:8482
     * @param searchStrings the CharSequences to find, may be null or empty//LC:8483
     * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or//LC:8484
     *  both {@code null}//LC:8485
     * @since 3.0//LC:8486
     *///LC:8487
    public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {//LC:8488
        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {//LC:8489
            return false;//LC:8490
        }//LC:8491
        for (final CharSequence searchString : searchStrings) {//LC:8492
            if (StringUtils.endsWith(string, searchString)) {//LC:8493
                return true;//LC:8494
            }//LC:8495
        }//LC:8496
        return false;//LC:8497
    }//LC:8498
//LC:8499
    /**//LC:8500
     * Appends the suffix to the end of the string if the string does not//LC:8501
     * already end in the suffix.//LC:8502
     *//LC:8503
     * @param str The string.//LC:8504
     * @param suffix The suffix to append to the end of the string.//LC:8505
     * @param ignoreCase Indicates whether the compare should ignore case.//LC:8506
     * @param suffixes Additional suffixes that are valid terminators (optional).//LC:8507
     *//LC:8508
     * @return A new String if suffix was appened, the same string otherwise.//LC:8509
     *///LC:8510
    private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {//LC:8511
        if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {//LC:8512
            return str;//LC:8513
        }//LC:8514
        if (suffixes != null && suffixes.length > 0) {//LC:8515
            for (final CharSequence s : suffixes) {//LC:8516
                if (endsWith(str, s, ignoreCase)) {//LC:8517
                    return str;//LC:8518
                }//LC:8519
            }//LC:8520
        }//LC:8521
        return str + suffix.toString();//LC:8522
    }//LC:8523
//LC:8524
    /**//LC:8525
     * Appends the suffix to the end of the string if the string does not//LC:8526
     * already end with any the suffixes.//LC:8527
     *//LC:8528
     * <pre>//LC:8529
     * StringUtils.appendIfMissing(null, null) = null//LC:8530
     * StringUtils.appendIfMissing("abc", null) = "abc"//LC:8531
     * StringUtils.appendIfMissing("", "xyz") = "xyz"//LC:8532
     * StringUtils.appendIfMissing("abc", "xyz") = "abcxyz"//LC:8533
     * StringUtils.appendIfMissing("abcxyz", "xyz") = "abcxyz"//LC:8534
     * StringUtils.appendIfMissing("abcXYZ", "xyz") = "abcXYZxyz"//LC:8535
     * </pre>//LC:8536
     * <p>With additional suffixes,</p>//LC:8537
     * <pre>//LC:8538
     * StringUtils.appendIfMissing(null, null, null) = null//LC:8539
     * StringUtils.appendIfMissing("abc", null, null) = "abc"//LC:8540
     * StringUtils.appendIfMissing("", "xyz", null) = "xyz"//LC:8541
     * StringUtils.appendIfMissing("abc", "xyz", new CharSequence[]{null}) = "abcxyz"//LC:8542
     * StringUtils.appendIfMissing("abc", "xyz", "") = "abc"//LC:8543
     * StringUtils.appendIfMissing("abc", "xyz", "mno") = "abcxyz"//LC:8544
     * StringUtils.appendIfMissing("abcxyz", "xyz", "mno") = "abcxyz"//LC:8545
     * StringUtils.appendIfMissing("abcmno", "xyz", "mno") = "abcmno"//LC:8546
     * StringUtils.appendIfMissing("abcXYZ", "xyz", "mno") = "abcXYZxyz"//LC:8547
     * StringUtils.appendIfMissing("abcMNO", "xyz", "mno") = "abcMNOxyz"//LC:8548
     * </pre>//LC:8549
     *//LC:8550
     * @param str The string.//LC:8551
     * @param suffix The suffix to append to the end of the string.//LC:8552
     * @param suffixes Additional suffixes that are valid terminators.//LC:8553
     *//LC:8554
     * @return A new String if suffix was appened, the same string otherwise.//LC:8555
     *//LC:8556
     * @since 3.2//LC:8557
     *///LC:8558
    public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {//LC:8559
        return appendIfMissing(str, suffix, false, suffixes);//LC:8560
    }//LC:8561
//LC:8562
    /**//LC:8563
     * Appends the suffix to the end of the string if the string does not//LC:8564
     * already end, case insensitive, with any of the suffixes.//LC:8565
     *//LC:8566
     * <pre>//LC:8567
     * StringUtils.appendIfMissingIgnoreCase(null, null) = null//LC:8568
     * StringUtils.appendIfMissingIgnoreCase("abc", null) = "abc"//LC:8569
     * StringUtils.appendIfMissingIgnoreCase("", "xyz") = "xyz"//LC:8570
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz") = "abcxyz"//LC:8571
     * StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz") = "abcxyz"//LC:8572
     * StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz") = "abcXYZ"//LC:8573
     * </pre>//LC:8574
     * <p>With additional suffixes,</p>//LC:8575
     * <pre>//LC:8576
     * StringUtils.appendIfMissingIgnoreCase(null, null, null) = null//LC:8577
     * StringUtils.appendIfMissingIgnoreCase("abc", null, null) = "abc"//LC:8578
     * StringUtils.appendIfMissingIgnoreCase("", "xyz", null) = "xyz"//LC:8579
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", new CharSequence[]{null}) = "abcxyz"//LC:8580
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", "") = "abc"//LC:8581
     * StringUtils.appendIfMissingIgnoreCase("abc", "xyz", "mno") = "axyz"//LC:8582
     * StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz", "mno") = "abcxyz"//LC:8583
     * StringUtils.appendIfMissingIgnoreCase("abcmno", "xyz", "mno") = "abcmno"//LC:8584
     * StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz", "mno") = "abcXYZ"//LC:8585
     * StringUtils.appendIfMissingIgnoreCase("abcMNO", "xyz", "mno") = "abcMNO"//LC:8586
     * </pre>//LC:8587
     *//LC:8588
     * @param str The string.//LC:8589
     * @param suffix The suffix to append to the end of the string.//LC:8590
     * @param suffixes Additional suffixes that are valid terminators.//LC:8591
     *//LC:8592
     * @return A new String if suffix was appened, the same string otherwise.//LC:8593
     *//LC:8594
     * @since 3.2//LC:8595
     *///LC:8596
    public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {//LC:8597
        return appendIfMissing(str, suffix, true, suffixes);//LC:8598
    }//LC:8599
//LC:8600
    /**//LC:8601
     * Prepends the prefix to the start of the string if the string does not//LC:8602
     * already start with any of the prefixes.//LC:8603
     *//LC:8604
     * @param str The string.//LC:8605
     * @param prefix The prefix to prepend to the start of the string.//LC:8606
     * @param ignoreCase Indicates whether the compare should ignore case.//LC:8607
     * @param prefixes Additional prefixes that are valid (optional).//LC:8608
     *//LC:8609
     * @return A new String if prefix was prepended, the same string otherwise.//LC:8610
     *///LC:8611
    private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {//LC:8612
        if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {//LC:8613
            return str;//LC:8614
        }//LC:8615
        if (prefixes != null && prefixes.length > 0) {//LC:8616
            for (final CharSequence p : prefixes) {//LC:8617
                if (startsWith(str, p, ignoreCase)) {//LC:8618
                    return str;//LC:8619
                }//LC:8620
            }//LC:8621
        }//LC:8622
        return prefix.toString() + str;//LC:8623
    }//LC:8624
//LC:8625
    /**//LC:8626
     * Prepends the prefix to the start of the string if the string does not//LC:8627
     * already start with any of the prefixes.//LC:8628
     *//LC:8629
     * <pre>//LC:8630
     * StringUtils.prependIfMissing(null, null) = null//LC:8631
     * StringUtils.prependIfMissing("abc", null) = "abc"//LC:8632
     * StringUtils.prependIfMissing("", "xyz") = "xyz"//LC:8633
     * StringUtils.prependIfMissing("abc", "xyz") = "xyzabc"//LC:8634
     * StringUtils.prependIfMissing("xyzabc", "xyz") = "xyzabc"//LC:8635
     * StringUtils.prependIfMissing("XYZabc", "xyz") = "xyzXYZabc"//LC:8636
     * </pre>//LC:8637
     * <p>With additional prefixes,</p>//LC:8638
     * <pre>//LC:8639
     * StringUtils.prependIfMissing(null, null, null) = null//LC:8640
     * StringUtils.prependIfMissing("abc", null, null) = "abc"//LC:8641
     * StringUtils.prependIfMissing("", "xyz", null) = "xyz"//LC:8642
     * StringUtils.prependIfMissing("abc", "xyz", new CharSequence[]{null}) = "xyzabc"//LC:8643
     * StringUtils.prependIfMissing("abc", "xyz", "") = "abc"//LC:8644
     * StringUtils.prependIfMissing("abc", "xyz", "mno") = "xyzabc"//LC:8645
     * StringUtils.prependIfMissing("xyzabc", "xyz", "mno") = "xyzabc"//LC:8646
     * StringUtils.prependIfMissing("mnoabc", "xyz", "mno") = "mnoabc"//LC:8647
     * StringUtils.prependIfMissing("XYZabc", "xyz", "mno") = "xyzXYZabc"//LC:8648
     * StringUtils.prependIfMissing("MNOabc", "xyz", "mno") = "xyzMNOabc"//LC:8649
     * </pre>//LC:8650
     *//LC:8651
     * @param str The string.//LC:8652
     * @param prefix The prefix to prepend to the start of the string.//LC:8653
     * @param prefixes Additional prefixes that are valid.//LC:8654
     *//LC:8655
     * @return A new String if prefix was prepended, the same string otherwise.//LC:8656
     *//LC:8657
     * @since 3.2//LC:8658
     *///LC:8659
    public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {//LC:8660
        return prependIfMissing(str, prefix, false, prefixes);//LC:8661
    }//LC:8662
//LC:8663
    /**//LC:8664
     * Prepends the prefix to the start of the string if the string does not//LC:8665
     * already start, case insensitive, with any of the prefixes.//LC:8666
     *//LC:8667
     * <pre>//LC:8668
     * StringUtils.prependIfMissingIgnoreCase(null, null) = null//LC:8669
     * StringUtils.prependIfMissingIgnoreCase("abc", null) = "abc"//LC:8670
     * StringUtils.prependIfMissingIgnoreCase("", "xyz") = "xyz"//LC:8671
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz") = "xyzabc"//LC:8672
     * StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz") = "xyzabc"//LC:8673
     * StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz") = "XYZabc"//LC:8674
     * </pre>//LC:8675
     * <p>With additional prefixes,</p>//LC:8676
     * <pre>//LC:8677
     * StringUtils.prependIfMissingIgnoreCase(null, null, null) = null//LC:8678
     * StringUtils.prependIfMissingIgnoreCase("abc", null, null) = "abc"//LC:8679
     * StringUtils.prependIfMissingIgnoreCase("", "xyz", null) = "xyz"//LC:8680
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", new CharSequence[]{null}) = "xyzabc"//LC:8681
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", "") = "abc"//LC:8682
     * StringUtils.prependIfMissingIgnoreCase("abc", "xyz", "mno") = "xyzabc"//LC:8683
     * StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz", "mno") = "xyzabc"//LC:8684
     * StringUtils.prependIfMissingIgnoreCase("mnoabc", "xyz", "mno") = "mnoabc"//LC:8685
     * StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz", "mno") = "XYZabc"//LC:8686
     * StringUtils.prependIfMissingIgnoreCase("MNOabc", "xyz", "mno") = "MNOabc"//LC:8687
     * </pre>//LC:8688
     *//LC:8689
     * @param str The string.//LC:8690
     * @param prefix The prefix to prepend to the start of the string.//LC:8691
     * @param prefixes Additional prefixes that are valid (optional).//LC:8692
     *//LC:8693
     * @return A new String if prefix was prepended, the same string otherwise.//LC:8694
     *//LC:8695
     * @since 3.2//LC:8696
     *///LC:8697
    public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {//LC:8698
        return prependIfMissing(str, prefix, true, prefixes);//LC:8699
    }//LC:8700
//LC:8701
    /**//LC:8702
     * Converts a <code>byte[]</code> to a String using the specified character encoding.//LC:8703
     *//LC:8704
     * @param bytes//LC:8705
     *            the byte array to read from//LC:8706
     * @param charsetName//LC:8707
     *            the encoding to use, if null then use the platform default//LC:8708
     * @return a new String//LC:8709
     * @throws UnsupportedEncodingException//LC:8710
     *             If the named charset is not supported//LC:8711
     * @throws NullPointerException//LC:8712
     *             if the input is null//LC:8713
     * @since 3.1//LC:8714
     *///LC:8715
    public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {//LC:8716
        return charsetName == null ? new String(bytes) : new String(bytes, charsetName);//LC:8717
    }//LC:8718
//LC:8719
}//LC:8720
//LC:8721
//LC:8722
//LC:8723
/**//LC:8724
 * <p>Operations on {@link java.lang.CharSequence} that are//LC:8725
 * {@code null} safe.</p>//LC:8726
 *//LC:8727
 * @see java.lang.CharSequence//LC:8728
 * @since 3.0//LC:8729
 * @version $Id$//LC:8730
 *///LC:8731
class CharSequenceUtils {//LC:8732
//LC:8733
    /**//LC:8734
     * <p>{@code CharSequenceUtils} instances should NOT be constructed in//LC:8735
     * standard programming. </p>//LC:8736
     *//LC:8737
     * <p>This constructor is public to permit tools that require a JavaBean//LC:8738
     * instance to operate.</p>//LC:8739
     *///LC:8740
    public CharSequenceUtils() {//LC:8741
        super();//LC:8742
    }//LC:8743
//LC:8744
    //-----------------------------------------------------------------------//LC:8745
    /**//LC:8746
     * <p>Returns a new {@code CharSequence} that is a subsequence of this//LC:8747
     * sequence starting with the {@code char} value at the specified index.</p>//LC:8748
     *//LC:8749
     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.//LC:8750
     * The length (in {@code char}) of the returned sequence is {@code length() - start},//LC:8751
     * so if {@code start == end} then an empty sequence is returned.</p>//LC:8752
     *//LC:8753
     * @param cs  the specified subsequence, null returns null//LC:8754
     * @param start  the start index, inclusive, valid//LC:8755
     * @return a new subsequence, may be null//LC:8756
     * @throws IndexOutOfBoundsException if {@code start} is negative or if//LC:8757
     *  {@code start} is greater than {@code length()}//LC:8758
     *///LC:8759
    public static CharSequence subSequence(final CharSequence cs, final int start) {//LC:8760
        return cs == null ? null : cs.subSequence(start, cs.length());//LC:8761
    }//LC:8762
//LC:8763
    //-----------------------------------------------------------------------//LC:8764
    /**//LC:8765
     * <p>Finds the first index in the {@code CharSequence} that matches the//LC:8766
     * specified character.</p>//LC:8767
     *//LC:8768
     * @param cs  the {@code CharSequence} to be processed, not null//LC:8769
     * @param searchChar  the char to be searched for//LC:8770
     * @param start  the start index, negative starts at the string start//LC:8771
     * @return the index where the search char was found, -1 if not found//LC:8772
     *///LC:8773
    static int indexOf(final CharSequence cs, final int searchChar, int start) {//LC:8774
        if (cs instanceof String) {//LC:8775
            return ((String) cs).indexOf(searchChar, start);//LC:8776
        } else {//LC:8777
            final int sz = cs.length();//LC:8778
            if (start < 0) {//LC:8779
                start = 0;//LC:8780
            }//LC:8781
            for (int i = start; i < sz; i++) {//LC:8782
                if (cs.charAt(i) == searchChar) {//LC:8783
                    return i;//LC:8784
                }//LC:8785
            }//LC:8786
            return -1;//LC:8787
        }//LC:8788
    }//LC:8789
//LC:8790
    /**//LC:8791
     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.//LC:8792
     *//LC:8793
     * @param cs the {@code CharSequence} to be processed//LC:8794
     * @param searchChar the {@code CharSequence} to be searched for//LC:8795
     * @param start the start index//LC:8796
     * @return the index where the search sequence was found//LC:8797
     *///LC:8798
    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {//LC:8799
        return cs.toString().indexOf(searchChar.toString(), start);//LC:8800
//        if (cs instanceof String && searchChar instanceof String) {//LC:8801
//            // TODO: Do we assume searchChar is usually relatively small;//LC:8802
//            //       If so then calling toString() on it is better than reverting to//LC:8803
//            //       the green implementation in the else block//LC:8804
//            return ((String) cs).indexOf((String) searchChar, start);//LC:8805
//        } else {//LC:8806
//            // TODO: Implement rather than convert to String//LC:8807
//            return cs.toString().indexOf(searchChar.toString(), start);//LC:8808
//        }//LC:8809
    }//LC:8810
//LC:8811
    /**//LC:8812
     * <p>Finds the last index in the {@code CharSequence} that matches the//LC:8813
     * specified character.</p>//LC:8814
     *//LC:8815
     * @param cs  the {@code CharSequence} to be processed//LC:8816
     * @param searchChar  the char to be searched for//LC:8817
     * @param start  the start index, negative returns -1, beyond length starts at end//LC:8818
     * @return the index where the search char was found, -1 if not found//LC:8819
     *///LC:8820
    static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {//LC:8821
        if (cs instanceof String) {//LC:8822
            return ((String) cs).lastIndexOf(searchChar, start);//LC:8823
        } else {//LC:8824
            final int sz = cs.length();//LC:8825
            if (start < 0) {//LC:8826
                return -1;//LC:8827
            }//LC:8828
            if (start >= sz) {//LC:8829
                start = sz - 1;//LC:8830
            }//LC:8831
            for (int i = start; i >= 0; --i) {//LC:8832
                if (cs.charAt(i) == searchChar) {//LC:8833
                    return i;//LC:8834
                }//LC:8835
            }//LC:8836
            return -1;//LC:8837
        }//LC:8838
    }//LC:8839
//LC:8840
    /**//LC:8841
     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf//LC:8842
     *//LC:8843
     * @param cs the {@code CharSequence} to be processed//LC:8844
     * @param searchChar the {@code CharSequence} to be searched for//LC:8845
     * @param start the start index//LC:8846
     * @return the index where the search sequence was found//LC:8847
     *///LC:8848
    static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {//LC:8849
        return cs.toString().lastIndexOf(searchChar.toString(), start);//LC:8850
//        if (cs instanceof String && searchChar instanceof String) {//LC:8851
//            // TODO: Do we assume searchChar is usually relatively small;//LC:8852
//            //       If so then calling toString() on it is better than reverting to//LC:8853
//            //       the green implementation in the else block//LC:8854
//            return ((String) cs).lastIndexOf((String) searchChar, start);//LC:8855
//        } else {//LC:8856
//            // TODO: Implement rather than convert to String//LC:8857
//            return cs.toString().lastIndexOf(searchChar.toString(), start);//LC:8858
//        }//LC:8859
    }//LC:8860
//LC:8861
    /**//LC:8862
     * Green implementation of toCharArray.//LC:8863
     *//LC:8864
     * @param cs the {@code CharSequence} to be processed//LC:8865
     * @return the resulting char array//LC:8866
     *///LC:8867
    static char[] toCharArray(final CharSequence cs) {//LC:8868
        if (cs instanceof String) {//LC:8869
            return ((String) cs).toCharArray();//LC:8870
        } else {//LC:8871
            final int sz = cs.length();//LC:8872
            final char[] array = new char[cs.length()];//LC:8873
            for (int i = 0; i < sz; i++) {//LC:8874
                array[i] = cs.charAt(i);//LC:8875
            }//LC:8876
            return array;//LC:8877
        }//LC:8878
    }//LC:8879
//LC:8880
    /**//LC:8881
     * Green implementation of regionMatches.//LC:8882
     *//LC:8883
     * @param cs the {@code CharSequence} to be processed//LC:8884
     * @param ignoreCase whether or not to be case insensitive//LC:8885
     * @param thisStart the index to start on the {@code cs} CharSequence//LC:8886
     * @param substring the {@code CharSequence} to be looked for//LC:8887
     * @param start the index to start on the {@code substring} CharSequence//LC:8888
     * @param length character length of the region//LC:8889
     * @return whether the region matched//LC:8890
     *///LC:8891
    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,//LC:8892
                                 final CharSequence substring, final int start, final int length)    {//LC:8893
        if (cs instanceof String && substring instanceof String) {//LC:8894
            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);//LC:8895
        } else {//LC:8896
            int index1 = thisStart;//LC:8897
            int index2 = start;//LC:8898
            int tmpLen = length;//LC:8899
//LC:8900
            while (tmpLen-- > 0) {//LC:8901
                char c1 = cs.charAt(index1++);//LC:8902
                char c2 = substring.charAt(index2++);//LC:8903
//LC:8904
                if (c1 == c2) {//LC:8905
                    continue;//LC:8906
                }//LC:8907
//LC:8908
                if (!ignoreCase) {//LC:8909
                    return false;//LC:8910
                }//LC:8911
//LC:8912
                // The same check as in String.regionMatches()://LC:8913
                if (Character.toUpperCase(c1) != Character.toUpperCase(c2)//LC:8914
                        && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {//LC:8915
                    return false;//LC:8916
                }//LC:8917
            }//LC:8918
//LC:8919
            return true;//LC:8920
        }//LC:8921
    }//LC:8922
}//LC:8923
//LC:8924
//LC:8925
/**//LC:8926
 * <p>Operations on arrays, primitive arrays (like {@code int[]}) and//LC:8927
 * primitive wrapper arrays (like {@code Integer[]}).</p>//LC:8928
 *//LC:8929
 * <p>This class tries to handle {@code null} input gracefully.//LC:8930
 * An exception will not be thrown for a {@code null}//LC:8931
 * array input. However, an Object array that contains a {@code null}//LC:8932
 * element may throw an exception. Each method documents its behaviour.</p>//LC:8933
 *//LC:8934
 * <p>#ThreadSafe#</p>//LC:8935
 * @since 2.0//LC:8936
 * @version $Id$//LC:8937
 *///LC:8938
class ArrayUtils {//LC:8939
//LC:8940
    /**//LC:8941
     * An empty immutable {@code Object} array.//LC:8942
     *///LC:8943
    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];//LC:8944
    /**//LC:8945
     * An empty immutable {@code Class} array.//LC:8946
     *///LC:8947
    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];//LC:8948
    /**//LC:8949
     * An empty immutable {@code String} array.//LC:8950
     *///LC:8951
    public static final String[] EMPTY_STRING_ARRAY = new String[0];//LC:8952
    /**//LC:8953
     * An empty immutable {@code long} array.//LC:8954
     *///LC:8955
    public static final long[] EMPTY_LONG_ARRAY = new long[0];//LC:8956
    /**//LC:8957
     * An empty immutable {@code Long} array.//LC:8958
     *///LC:8959
    public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];//LC:8960
    /**//LC:8961
     * An empty immutable {@code int} array.//LC:8962
     *///LC:8963
    public static final int[] EMPTY_INT_ARRAY = new int[0];//LC:8964
    /**//LC:8965
     * An empty immutable {@code Integer} array.//LC:8966
     *///LC:8967
    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];//LC:8968
    /**//LC:8969
     * An empty immutable {@code short} array.//LC:8970
     *///LC:8971
    public static final short[] EMPTY_SHORT_ARRAY = new short[0];//LC:8972
    /**//LC:8973
     * An empty immutable {@code Short} array.//LC:8974
     *///LC:8975
    public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];//LC:8976
    /**//LC:8977
     * An empty immutable {@code byte} array.//LC:8978
     *///LC:8979
    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];//LC:8980
    /**//LC:8981
     * An empty immutable {@code Byte} array.//LC:8982
     *///LC:8983
    public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];//LC:8984
    /**//LC:8985
     * An empty immutable {@code double} array.//LC:8986
     *///LC:8987
    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];//LC:8988
    /**//LC:8989
     * An empty immutable {@code Double} array.//LC:8990
     *///LC:8991
    public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];//LC:8992
    /**//LC:8993
     * An empty immutable {@code float} array.//LC:8994
     *///LC:8995
    public static final float[] EMPTY_FLOAT_ARRAY = new float[0];//LC:8996
    /**//LC:8997
     * An empty immutable {@code Float} array.//LC:8998
     *///LC:8999
    public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];//LC:9000
    /**//LC:9001
     * An empty immutable {@code boolean} array.//LC:9002
     *///LC:9003
    public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];//LC:9004
    /**//LC:9005
     * An empty immutable {@code Boolean} array.//LC:9006
     *///LC:9007
    public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];//LC:9008
    /**//LC:9009
     * An empty immutable {@code char} array.//LC:9010
     *///LC:9011
    public static final char[] EMPTY_CHAR_ARRAY = new char[0];//LC:9012
    /**//LC:9013
     * An empty immutable {@code Character} array.//LC:9014
     *///LC:9015
    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];//LC:9016
//LC:9017
    /**//LC:9018
     * The index value when an element is not found in a list or array: {@code -1}.//LC:9019
     * This value is returned by methods in this class and can also be used in comparisons with values returned by//LC:9020
     * various method from {@link java.util.List}.//LC:9021
     *///LC:9022
    public static final int INDEX_NOT_FOUND = -1;//LC:9023
//LC:9024
    /**//LC:9025
     * <p>ArrayUtils instances should NOT be constructed in standard programming.//LC:9026
     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>//LC:9027
     *//LC:9028
     * <p>This constructor is public to permit tools that require a JavaBean instance//LC:9029
     * to operate.</p>//LC:9030
     *///LC:9031
    public ArrayUtils() {//LC:9032
        super();//LC:9033
    }//LC:9034
//LC:9035
//LC:9036
    // NOTE: Cannot use {@code} to enclose text which includes {}, but <code></code> is OK//LC:9037
//LC:9038
//LC:9039
    // Basic methods handling multi-dimensional arrays//LC:9040
    //-----------------------------------------------------------------------//LC:9041
    /**//LC:9042
     * <p>Outputs an array as a String, treating {@code null} as an empty array.</p>//LC:9043
     *//LC:9044
     * <p>Multi-dimensional arrays are handled correctly, including//LC:9045
     * multi-dimensional primitive arrays.</p>//LC:9046
     *//LC:9047
     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>//LC:9048
     *//LC:9049
     * @param array  the array to get a toString for, may be {@code null}//LC:9050
     * @return a String representation of the array, '{}' if null array input//LC:9051
     *///LC:9052
    public static String toString(final Object array) {//LC:9053
        return toString(array, "{}");//LC:9054
    }//LC:9055
//LC:9056
    /**//LC:9057
     * <p>Outputs an array as a String handling {@code null}s.</p>//LC:9058
     *//LC:9059
     * <p>Multi-dimensional arrays are handled correctly, including//LC:9060
     * multi-dimensional primitive arrays.</p>//LC:9061
     *//LC:9062
     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>//LC:9063
     *//LC:9064
     * @param array  the array to get a toString for, may be {@code null}//LC:9065
     * @param stringIfNull  the String to return if the array is {@code null}//LC:9066
     * @return a String representation of the array//LC:9067
     *///LC:9068
    public static String toString(final Object array, final String stringIfNull) {//LC:9069
        if (array == null) {//LC:9070
            return stringIfNull;//LC:9071
        }//LC:9072
        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();//LC:9073
    }//LC:9074
//LC:9075
    /**//LC:9076
     * <p>Get a hash code for an array handling multi-dimensional arrays correctly.</p>//LC:9077
     *//LC:9078
     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>//LC:9079
     *//LC:9080
     * @param array  the array to get a hash code for, {@code null} returns zero//LC:9081
     * @return a hash code for the array//LC:9082
     *///LC:9083
    public static int hashCode(final Object array) {//LC:9084
        return new HashCodeBuilder().append(array).toHashCode();//LC:9085
    }//LC:9086
//LC:9087
    /**//LC:9088
     * <p>Compares two arrays, using equals(), handling multi-dimensional arrays//LC:9089
     * correctly.</p>//LC:9090
     *//LC:9091
     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>//LC:9092
     *//LC:9093
     * @param array1  the left hand array to compare, may be {@code null}//LC:9094
     * @param array2  the right hand array to compare, may be {@code null}//LC:9095
     * @return {@code true} if the arrays are equal//LC:9096
     *///LC:9097
    public static boolean isEquals(final Object array1, final Object array2) {//LC:9098
        return new EqualsBuilder().append(array1, array2).isEquals();//LC:9099
    }//LC:9100
//LC:9101
    // To map//LC:9102
    //-----------------------------------------------------------------------//LC:9103
    /**//LC:9104
     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array//LC:9105
     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two//LC:9106
     * elements, where the first element is used as key and the second as//LC:9107
     * value.</p>//LC:9108
     *//LC:9109
     * <p>This method can be used to initialize:</p>//LC:9110
     * <pre>//LC:9111
     * // Create a Map mapping colors.//LC:9112
     * Map colorMap = MapUtils.toMap(new String[][] {{//LC:9113
     *     {"RED", "#FF0000"},//LC:9114
     *     {"GREEN", "#00FF00"},//LC:9115
     *     {"BLUE", "#0000FF"}});//LC:9116
     * </pre>//LC:9117
     *//LC:9118
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9119
     *//LC:9120
     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or//LC:9121
     *  an Array containing at least two elements, may be {@code null}//LC:9122
     * @return a {@code Map} that was created from the array//LC:9123
     * @throws IllegalArgumentException  if one element of this Array is//LC:9124
     *  itself an Array containing less then two elements//LC:9125
     * @throws IllegalArgumentException  if the array contains elements other//LC:9126
     *  than {@link java.util.Map.Entry} and an Array//LC:9127
     *///LC:9128
    public static Map<Object, Object> toMap(final Object[] array) {//LC:9129
        if (array == null) {//LC:9130
            return null;//LC:9131
        }//LC:9132
        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));//LC:9133
        for (int i = 0; i < array.length; i++) {//LC:9134
            final Object object = array[i];//LC:9135
            if (object instanceof Map.Entry<?, ?>) {//LC:9136
                final Map.Entry<?,?> entry = (Map.Entry<?,?>) object;//LC:9137
                map.put(entry.getKey(), entry.getValue());//LC:9138
            } else if (object instanceof Object[]) {//LC:9139
                final Object[] entry = (Object[]) object;//LC:9140
                if (entry.length < 2) {//LC:9141
                    throw new IllegalArgumentException("Array element " + i + ", '"//LC:9142
                            + object//LC:9143
                            + "', has a length less than 2");//LC:9144
                }//LC:9145
                map.put(entry[0], entry[1]);//LC:9146
            } else {//LC:9147
                throw new IllegalArgumentException("Array element " + i + ", '"//LC:9148
                        + object//LC:9149
                        + "', is neither of type Map.Entry nor an Array");//LC:9150
            }//LC:9151
        }//LC:9152
        return map;//LC:9153
    }//LC:9154
//LC:9155
    // Generic array//LC:9156
    //-----------------------------------------------------------------------//LC:9157
    /**//LC:9158
     * <p>Create a type-safe generic array.</p>//LC:9159
     *//LC:9160
     * <p>The Java language does not allow an array to be created from a generic type:</p>//LC:9161
     *//LC:9162
     * <pre>//LC:9163
     public static &lt;T&gt; T[] createAnArray(int size) {//LC:9164
     return new T[size]; // compiler error here//LC:9165
     }//LC:9166
     public static &lt;T&gt; T[] createAnArray(int size) {//LC:9167
     return (T[])new Object[size]; // ClassCastException at runtime//LC:9168
     }//LC:9169
     * </pre>//LC:9170
     *//LC:9171
     * <p>Therefore new arrays of generic types can be created with this method.//LC:9172
     * For example, an array of Strings can be created:</p>//LC:9173
     *//LC:9174
     * <pre>//LC:9175
     String[] array = ArrayUtils.toArray("1", "2");//LC:9176
     String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();//LC:9177
     * </pre>//LC:9178
     *//LC:9179
     * <p>The method is typically used in scenarios, where the caller itself uses generic types//LC:9180
     * that have to be combined into an array.</p>//LC:9181
     *//LC:9182
     * <p>Note, this method makes only sense to provide arguments of the same type so that the//LC:9183
     * compiler can deduce the type of the array itself. While it is possible to select the//LC:9184
     * type explicitly like in//LC:9185
     * <code>Number[] array = ArrayUtils.&lt;Number&gt;toArray(Integer.valueOf(42), Double.valueOf(Math.PI))</code>,//LC:9186
     * there is no real advantage when compared to//LC:9187
     * <code>new Number[] {Integer.valueOf(42), Double.valueOf(Math.PI)}</code>.</p>//LC:9188
     *//LC:9189
     * @param  <T>   the array's element type//LC:9190
     * @param  items  the varargs array items, null allowed//LC:9191
     * @return the array, not null unless a null array is passed in//LC:9192
     * @since  3.0//LC:9193
     *///LC:9194
    public static <T> T[] toArray(final T... items) {//LC:9195
        return items;//LC:9196
    }//LC:9197
//LC:9198
    // Clone//LC:9199
    //-----------------------------------------------------------------------//LC:9200
    /**//LC:9201
     * <p>Shallow clones an array returning a typecast result and handling//LC:9202
     * {@code null}.</p>//LC:9203
     *//LC:9204
     * <p>The objects in the array are not cloned, thus there is no special//LC:9205
     * handling for multi-dimensional arrays.</p>//LC:9206
     *//LC:9207
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9208
     *//LC:9209
     * @param <T> the component type of the array//LC:9210
     * @param array  the array to shallow clone, may be {@code null}//LC:9211
     * @return the cloned array, {@code null} if {@code null} input//LC:9212
     *///LC:9213
    public static <T> T[] clone(final T[] array) {//LC:9214
        if (array == null) {//LC:9215
            return null;//LC:9216
        }//LC:9217
        return array.clone();//LC:9218
    }//LC:9219
//LC:9220
    /**//LC:9221
     * <p>Clones an array returning a typecast result and handling//LC:9222
     * {@code null}.</p>//LC:9223
     *//LC:9224
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9225
     *//LC:9226
     * @param array  the array to clone, may be {@code null}//LC:9227
     * @return the cloned array, {@code null} if {@code null} input//LC:9228
     *///LC:9229
    public static long[] clone(final long[] array) {//LC:9230
        if (array == null) {//LC:9231
            return null;//LC:9232
        }//LC:9233
        return array.clone();//LC:9234
    }//LC:9235
//LC:9236
    /**//LC:9237
     * <p>Clones an array returning a typecast result and handling//LC:9238
     * {@code null}.</p>//LC:9239
     *//LC:9240
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9241
     *//LC:9242
     * @param array  the array to clone, may be {@code null}//LC:9243
     * @return the cloned array, {@code null} if {@code null} input//LC:9244
     *///LC:9245
    public static int[] clone(final int[] array) {//LC:9246
        if (array == null) {//LC:9247
            return null;//LC:9248
        }//LC:9249
        return array.clone();//LC:9250
    }//LC:9251
//LC:9252
    /**//LC:9253
     * <p>Clones an array returning a typecast result and handling//LC:9254
     * {@code null}.</p>//LC:9255
     *//LC:9256
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9257
     *//LC:9258
     * @param array  the array to clone, may be {@code null}//LC:9259
     * @return the cloned array, {@code null} if {@code null} input//LC:9260
     *///LC:9261
    public static short[] clone(final short[] array) {//LC:9262
        if (array == null) {//LC:9263
            return null;//LC:9264
        }//LC:9265
        return array.clone();//LC:9266
    }//LC:9267
//LC:9268
    /**//LC:9269
     * <p>Clones an array returning a typecast result and handling//LC:9270
     * {@code null}.</p>//LC:9271
     *//LC:9272
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9273
     *//LC:9274
     * @param array  the array to clone, may be {@code null}//LC:9275
     * @return the cloned array, {@code null} if {@code null} input//LC:9276
     *///LC:9277
    public static char[] clone(final char[] array) {//LC:9278
        if (array == null) {//LC:9279
            return null;//LC:9280
        }//LC:9281
        return array.clone();//LC:9282
    }//LC:9283
//LC:9284
    /**//LC:9285
     * <p>Clones an array returning a typecast result and handling//LC:9286
     * {@code null}.</p>//LC:9287
     *//LC:9288
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9289
     *//LC:9290
     * @param array  the array to clone, may be {@code null}//LC:9291
     * @return the cloned array, {@code null} if {@code null} input//LC:9292
     *///LC:9293
    public static byte[] clone(final byte[] array) {//LC:9294
        if (array == null) {//LC:9295
            return null;//LC:9296
        }//LC:9297
        return array.clone();//LC:9298
    }//LC:9299
//LC:9300
    /**//LC:9301
     * <p>Clones an array returning a typecast result and handling//LC:9302
     * {@code null}.</p>//LC:9303
     *//LC:9304
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9305
     *//LC:9306
     * @param array  the array to clone, may be {@code null}//LC:9307
     * @return the cloned array, {@code null} if {@code null} input//LC:9308
     *///LC:9309
    public static double[] clone(final double[] array) {//LC:9310
        if (array == null) {//LC:9311
            return null;//LC:9312
        }//LC:9313
        return array.clone();//LC:9314
    }//LC:9315
//LC:9316
    /**//LC:9317
     * <p>Clones an array returning a typecast result and handling//LC:9318
     * {@code null}.</p>//LC:9319
     *//LC:9320
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9321
     *//LC:9322
     * @param array  the array to clone, may be {@code null}//LC:9323
     * @return the cloned array, {@code null} if {@code null} input//LC:9324
     *///LC:9325
    public static float[] clone(final float[] array) {//LC:9326
        if (array == null) {//LC:9327
            return null;//LC:9328
        }//LC:9329
        return array.clone();//LC:9330
    }//LC:9331
//LC:9332
    /**//LC:9333
     * <p>Clones an array returning a typecast result and handling//LC:9334
     * {@code null}.</p>//LC:9335
     *//LC:9336
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:9337
     *//LC:9338
     * @param array  the array to clone, may be {@code null}//LC:9339
     * @return the cloned array, {@code null} if {@code null} input//LC:9340
     *///LC:9341
    public static boolean[] clone(final boolean[] array) {//LC:9342
        if (array == null) {//LC:9343
            return null;//LC:9344
        }//LC:9345
        return array.clone();//LC:9346
    }//LC:9347
//LC:9348
    // nullToEmpty//LC:9349
    //-----------------------------------------------------------------------//LC:9350
    /**//LC:9351
     * <p>Defensive programming technique to change a {@code null}//LC:9352
     * reference to an empty one.</p>//LC:9353
     *//LC:9354
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9355
     *//LC:9356
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9357
     * the empty {@code public static} references in this class.</p>//LC:9358
     *//LC:9359
     * @param array  the array to check for {@code null} or empty//LC:9360
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9361
     * @since 2.5//LC:9362
     *///LC:9363
    public static Object[] nullToEmpty(final Object[] array) {//LC:9364
        if (array == null || array.length == 0) {//LC:9365
            return EMPTY_OBJECT_ARRAY;//LC:9366
        }//LC:9367
        return array;//LC:9368
    }//LC:9369
//LC:9370
    /**//LC:9371
     * <p>Defensive programming technique to change a {@code null}//LC:9372
     * reference to an empty one.</p>//LC:9373
     *//LC:9374
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9375
     *//LC:9376
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9377
     * the empty {@code public static} references in this class.</p>//LC:9378
     *//LC:9379
     * @param array  the array to check for {@code null} or empty//LC:9380
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9381
     * @since 2.5//LC:9382
     *///LC:9383
    public static String[] nullToEmpty(final String[] array) {//LC:9384
        if (array == null || array.length == 0) {//LC:9385
            return EMPTY_STRING_ARRAY;//LC:9386
        }//LC:9387
        return array;//LC:9388
    }//LC:9389
//LC:9390
    /**//LC:9391
     * <p>Defensive programming technique to change a {@code null}//LC:9392
     * reference to an empty one.</p>//LC:9393
     *//LC:9394
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9395
     *//LC:9396
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9397
     * the empty {@code public static} references in this class.</p>//LC:9398
     *//LC:9399
     * @param array  the array to check for {@code null} or empty//LC:9400
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9401
     * @since 2.5//LC:9402
     *///LC:9403
    public static long[] nullToEmpty(final long[] array) {//LC:9404
        if (array == null || array.length == 0) {//LC:9405
            return EMPTY_LONG_ARRAY;//LC:9406
        }//LC:9407
        return array;//LC:9408
    }//LC:9409
//LC:9410
    /**//LC:9411
     * <p>Defensive programming technique to change a {@code null}//LC:9412
     * reference to an empty one.</p>//LC:9413
     *//LC:9414
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9415
     *//LC:9416
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9417
     * the empty {@code public static} references in this class.</p>//LC:9418
     *//LC:9419
     * @param array  the array to check for {@code null} or empty//LC:9420
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9421
     * @since 2.5//LC:9422
     *///LC:9423
    public static int[] nullToEmpty(final int[] array) {//LC:9424
        if (array == null || array.length == 0) {//LC:9425
            return EMPTY_INT_ARRAY;//LC:9426
        }//LC:9427
        return array;//LC:9428
    }//LC:9429
//LC:9430
    /**//LC:9431
     * <p>Defensive programming technique to change a {@code null}//LC:9432
     * reference to an empty one.</p>//LC:9433
     *//LC:9434
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9435
     *//LC:9436
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9437
     * the empty {@code public static} references in this class.</p>//LC:9438
     *//LC:9439
     * @param array  the array to check for {@code null} or empty//LC:9440
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9441
     * @since 2.5//LC:9442
     *///LC:9443
    public static short[] nullToEmpty(final short[] array) {//LC:9444
        if (array == null || array.length == 0) {//LC:9445
            return EMPTY_SHORT_ARRAY;//LC:9446
        }//LC:9447
        return array;//LC:9448
    }//LC:9449
//LC:9450
    /**//LC:9451
     * <p>Defensive programming technique to change a {@code null}//LC:9452
     * reference to an empty one.</p>//LC:9453
     *//LC:9454
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9455
     *//LC:9456
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9457
     * the empty {@code public static} references in this class.</p>//LC:9458
     *//LC:9459
     * @param array  the array to check for {@code null} or empty//LC:9460
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9461
     * @since 2.5//LC:9462
     *///LC:9463
    public static char[] nullToEmpty(final char[] array) {//LC:9464
        if (array == null || array.length == 0) {//LC:9465
            return EMPTY_CHAR_ARRAY;//LC:9466
        }//LC:9467
        return array;//LC:9468
    }//LC:9469
//LC:9470
    /**//LC:9471
     * <p>Defensive programming technique to change a {@code null}//LC:9472
     * reference to an empty one.</p>//LC:9473
     *//LC:9474
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9475
     *//LC:9476
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9477
     * the empty {@code public static} references in this class.</p>//LC:9478
     *//LC:9479
     * @param array  the array to check for {@code null} or empty//LC:9480
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9481
     * @since 2.5//LC:9482
     *///LC:9483
    public static byte[] nullToEmpty(final byte[] array) {//LC:9484
        if (array == null || array.length == 0) {//LC:9485
            return EMPTY_BYTE_ARRAY;//LC:9486
        }//LC:9487
        return array;//LC:9488
    }//LC:9489
//LC:9490
    /**//LC:9491
     * <p>Defensive programming technique to change a {@code null}//LC:9492
     * reference to an empty one.</p>//LC:9493
     *//LC:9494
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9495
     *//LC:9496
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9497
     * the empty {@code public static} references in this class.</p>//LC:9498
     *//LC:9499
     * @param array  the array to check for {@code null} or empty//LC:9500
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9501
     * @since 2.5//LC:9502
     *///LC:9503
    public static double[] nullToEmpty(final double[] array) {//LC:9504
        if (array == null || array.length == 0) {//LC:9505
            return EMPTY_DOUBLE_ARRAY;//LC:9506
        }//LC:9507
        return array;//LC:9508
    }//LC:9509
//LC:9510
    /**//LC:9511
     * <p>Defensive programming technique to change a {@code null}//LC:9512
     * reference to an empty one.</p>//LC:9513
     *//LC:9514
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9515
     *//LC:9516
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9517
     * the empty {@code public static} references in this class.</p>//LC:9518
     *//LC:9519
     * @param array  the array to check for {@code null} or empty//LC:9520
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9521
     * @since 2.5//LC:9522
     *///LC:9523
    public static float[] nullToEmpty(final float[] array) {//LC:9524
        if (array == null || array.length == 0) {//LC:9525
            return EMPTY_FLOAT_ARRAY;//LC:9526
        }//LC:9527
        return array;//LC:9528
    }//LC:9529
//LC:9530
    /**//LC:9531
     * <p>Defensive programming technique to change a {@code null}//LC:9532
     * reference to an empty one.</p>//LC:9533
     *//LC:9534
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9535
     *//LC:9536
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9537
     * the empty {@code public static} references in this class.</p>//LC:9538
     *//LC:9539
     * @param array  the array to check for {@code null} or empty//LC:9540
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9541
     * @since 2.5//LC:9542
     *///LC:9543
    public static boolean[] nullToEmpty(final boolean[] array) {//LC:9544
        if (array == null || array.length == 0) {//LC:9545
            return EMPTY_BOOLEAN_ARRAY;//LC:9546
        }//LC:9547
        return array;//LC:9548
    }//LC:9549
//LC:9550
    /**//LC:9551
     * <p>Defensive programming technique to change a {@code null}//LC:9552
     * reference to an empty one.</p>//LC:9553
     *//LC:9554
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9555
     *//LC:9556
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9557
     * the empty {@code public static} references in this class.</p>//LC:9558
     *//LC:9559
     * @param array  the array to check for {@code null} or empty//LC:9560
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9561
     * @since 2.5//LC:9562
     *///LC:9563
    public static Long[] nullToEmpty(final Long[] array) {//LC:9564
        if (array == null || array.length == 0) {//LC:9565
            return EMPTY_LONG_OBJECT_ARRAY;//LC:9566
        }//LC:9567
        return array;//LC:9568
    }//LC:9569
//LC:9570
    /**//LC:9571
     * <p>Defensive programming technique to change a {@code null}//LC:9572
     * reference to an empty one.</p>//LC:9573
     *//LC:9574
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9575
     *//LC:9576
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9577
     * the empty {@code public static} references in this class.</p>//LC:9578
     *//LC:9579
     * @param array  the array to check for {@code null} or empty//LC:9580
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9581
     * @since 2.5//LC:9582
     *///LC:9583
    public static Integer[] nullToEmpty(final Integer[] array) {//LC:9584
        if (array == null || array.length == 0) {//LC:9585
            return EMPTY_INTEGER_OBJECT_ARRAY;//LC:9586
        }//LC:9587
        return array;//LC:9588
    }//LC:9589
//LC:9590
    /**//LC:9591
     * <p>Defensive programming technique to change a {@code null}//LC:9592
     * reference to an empty one.</p>//LC:9593
     *//LC:9594
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9595
     *//LC:9596
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9597
     * the empty {@code public static} references in this class.</p>//LC:9598
     *//LC:9599
     * @param array  the array to check for {@code null} or empty//LC:9600
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9601
     * @since 2.5//LC:9602
     *///LC:9603
    public static Short[] nullToEmpty(final Short[] array) {//LC:9604
        if (array == null || array.length == 0) {//LC:9605
            return EMPTY_SHORT_OBJECT_ARRAY;//LC:9606
        }//LC:9607
        return array;//LC:9608
    }//LC:9609
//LC:9610
    /**//LC:9611
     * <p>Defensive programming technique to change a {@code null}//LC:9612
     * reference to an empty one.</p>//LC:9613
     *//LC:9614
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9615
     *//LC:9616
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9617
     * the empty {@code public static} references in this class.</p>//LC:9618
     *//LC:9619
     * @param array  the array to check for {@code null} or empty//LC:9620
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9621
     * @since 2.5//LC:9622
     *///LC:9623
    public static Character[] nullToEmpty(final Character[] array) {//LC:9624
        if (array == null || array.length == 0) {//LC:9625
            return EMPTY_CHARACTER_OBJECT_ARRAY;//LC:9626
        }//LC:9627
        return array;//LC:9628
    }//LC:9629
//LC:9630
    /**//LC:9631
     * <p>Defensive programming technique to change a {@code null}//LC:9632
     * reference to an empty one.</p>//LC:9633
     *//LC:9634
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9635
     *//LC:9636
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9637
     * the empty {@code public static} references in this class.</p>//LC:9638
     *//LC:9639
     * @param array  the array to check for {@code null} or empty//LC:9640
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9641
     * @since 2.5//LC:9642
     *///LC:9643
    public static Byte[] nullToEmpty(final Byte[] array) {//LC:9644
        if (array == null || array.length == 0) {//LC:9645
            return EMPTY_BYTE_OBJECT_ARRAY;//LC:9646
        }//LC:9647
        return array;//LC:9648
    }//LC:9649
//LC:9650
    /**//LC:9651
     * <p>Defensive programming technique to change a {@code null}//LC:9652
     * reference to an empty one.</p>//LC:9653
     *//LC:9654
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9655
     *//LC:9656
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9657
     * the empty {@code public static} references in this class.</p>//LC:9658
     *//LC:9659
     * @param array  the array to check for {@code null} or empty//LC:9660
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9661
     * @since 2.5//LC:9662
     *///LC:9663
    public static Double[] nullToEmpty(final Double[] array) {//LC:9664
        if (array == null || array.length == 0) {//LC:9665
            return EMPTY_DOUBLE_OBJECT_ARRAY;//LC:9666
        }//LC:9667
        return array;//LC:9668
    }//LC:9669
//LC:9670
    /**//LC:9671
     * <p>Defensive programming technique to change a {@code null}//LC:9672
     * reference to an empty one.</p>//LC:9673
     *//LC:9674
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9675
     *//LC:9676
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9677
     * the empty {@code public static} references in this class.</p>//LC:9678
     *//LC:9679
     * @param array  the array to check for {@code null} or empty//LC:9680
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9681
     * @since 2.5//LC:9682
     *///LC:9683
    public static Float[] nullToEmpty(final Float[] array) {//LC:9684
        if (array == null || array.length == 0) {//LC:9685
            return EMPTY_FLOAT_OBJECT_ARRAY;//LC:9686
        }//LC:9687
        return array;//LC:9688
    }//LC:9689
//LC:9690
    /**//LC:9691
     * <p>Defensive programming technique to change a {@code null}//LC:9692
     * reference to an empty one.</p>//LC:9693
     *//LC:9694
     * <p>This method returns an empty array for a {@code null} input array.</p>//LC:9695
     *//LC:9696
     * <p>As a memory optimizing technique an empty array passed in will be overridden with//LC:9697
     * the empty {@code public static} references in this class.</p>//LC:9698
     *//LC:9699
     * @param array  the array to check for {@code null} or empty//LC:9700
     * @return the same array, {@code public static} empty array if {@code null} or empty input//LC:9701
     * @since 2.5//LC:9702
     *///LC:9703
    public static Boolean[] nullToEmpty(final Boolean[] array) {//LC:9704
        if (array == null || array.length == 0) {//LC:9705
            return EMPTY_BOOLEAN_OBJECT_ARRAY;//LC:9706
        }//LC:9707
        return array;//LC:9708
    }//LC:9709
//LC:9710
    // Subarrays//LC:9711
    //-----------------------------------------------------------------------//LC:9712
    /**//LC:9713
     * <p>Produces a new array containing the elements between//LC:9714
     * the start and end indices.</p>//LC:9715
     *//LC:9716
     * <p>The start index is inclusive, the end index exclusive.//LC:9717
     * Null array input produces null output.</p>//LC:9718
     *//LC:9719
     * <p>The component type of the subarray is always the same as//LC:9720
     * that of the input array. Thus, if the input is an array of type//LC:9721
     * {@code Date}, the following usage is envisaged:</p>//LC:9722
     *//LC:9723
     * <pre>//LC:9724
     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);//LC:9725
     * </pre>//LC:9726
     *//LC:9727
     * @param <T> the component type of the array//LC:9728
     * @param array  the array//LC:9729
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9730
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9731
     *      in an empty array.//LC:9732
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9733
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9734
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9735
     *      array length.//LC:9736
     * @return a new array containing the elements between//LC:9737
     *      the start and end indices.//LC:9738
     * @since 2.1//LC:9739
     *///LC:9740
    public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9741
        if (array == null) {//LC:9742
            return null;//LC:9743
        }//LC:9744
        if (startIndexInclusive < 0) {//LC:9745
            startIndexInclusive = 0;//LC:9746
        }//LC:9747
        if (endIndexExclusive > array.length) {//LC:9748
            endIndexExclusive = array.length;//LC:9749
        }//LC:9750
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9751
        final Class<?> type = array.getClass().getComponentType();//LC:9752
        if (newSize <= 0) {//LC:9753
            @SuppressWarnings("unchecked") // OK, because array is of type T//LC:9754
            final T[] emptyArray = (T[]) Array.newInstance(type, 0);//LC:9755
            return emptyArray;//LC:9756
        }//LC:9757
        @SuppressWarnings("unchecked") // OK, because array is of type T//LC:9758
        final//LC:9759
        T[] subarray = (T[]) Array.newInstance(type, newSize);//LC:9760
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9761
        return subarray;//LC:9762
    }//LC:9763
//LC:9764
    /**//LC:9765
     * <p>Produces a new {@code long} array containing the elements//LC:9766
     * between the start and end indices.</p>//LC:9767
     *//LC:9768
     * <p>The start index is inclusive, the end index exclusive.//LC:9769
     * Null array input produces null output.</p>//LC:9770
     *//LC:9771
     * @param array  the array//LC:9772
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9773
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9774
     *      in an empty array.//LC:9775
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9776
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9777
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9778
     *      array length.//LC:9779
     * @return a new array containing the elements between//LC:9780
     *      the start and end indices.//LC:9781
     * @since 2.1//LC:9782
     *///LC:9783
    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9784
        if (array == null) {//LC:9785
            return null;//LC:9786
        }//LC:9787
        if (startIndexInclusive < 0) {//LC:9788
            startIndexInclusive = 0;//LC:9789
        }//LC:9790
        if (endIndexExclusive > array.length) {//LC:9791
            endIndexExclusive = array.length;//LC:9792
        }//LC:9793
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9794
        if (newSize <= 0) {//LC:9795
            return EMPTY_LONG_ARRAY;//LC:9796
        }//LC:9797
//LC:9798
        final long[] subarray = new long[newSize];//LC:9799
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9800
        return subarray;//LC:9801
    }//LC:9802
//LC:9803
    /**//LC:9804
     * <p>Produces a new {@code int} array containing the elements//LC:9805
     * between the start and end indices.</p>//LC:9806
     *//LC:9807
     * <p>The start index is inclusive, the end index exclusive.//LC:9808
     * Null array input produces null output.</p>//LC:9809
     *//LC:9810
     * @param array  the array//LC:9811
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9812
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9813
     *      in an empty array.//LC:9814
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9815
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9816
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9817
     *      array length.//LC:9818
     * @return a new array containing the elements between//LC:9819
     *      the start and end indices.//LC:9820
     * @since 2.1//LC:9821
     *///LC:9822
    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9823
        if (array == null) {//LC:9824
            return null;//LC:9825
        }//LC:9826
        if (startIndexInclusive < 0) {//LC:9827
            startIndexInclusive = 0;//LC:9828
        }//LC:9829
        if (endIndexExclusive > array.length) {//LC:9830
            endIndexExclusive = array.length;//LC:9831
        }//LC:9832
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9833
        if (newSize <= 0) {//LC:9834
            return EMPTY_INT_ARRAY;//LC:9835
        }//LC:9836
//LC:9837
        final int[] subarray = new int[newSize];//LC:9838
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9839
        return subarray;//LC:9840
    }//LC:9841
//LC:9842
    /**//LC:9843
     * <p>Produces a new {@code short} array containing the elements//LC:9844
     * between the start and end indices.</p>//LC:9845
     *//LC:9846
     * <p>The start index is inclusive, the end index exclusive.//LC:9847
     * Null array input produces null output.</p>//LC:9848
     *//LC:9849
     * @param array  the array//LC:9850
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9851
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9852
     *      in an empty array.//LC:9853
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9854
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9855
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9856
     *      array length.//LC:9857
     * @return a new array containing the elements between//LC:9858
     *      the start and end indices.//LC:9859
     * @since 2.1//LC:9860
     *///LC:9861
    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9862
        if (array == null) {//LC:9863
            return null;//LC:9864
        }//LC:9865
        if (startIndexInclusive < 0) {//LC:9866
            startIndexInclusive = 0;//LC:9867
        }//LC:9868
        if (endIndexExclusive > array.length) {//LC:9869
            endIndexExclusive = array.length;//LC:9870
        }//LC:9871
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9872
        if (newSize <= 0) {//LC:9873
            return EMPTY_SHORT_ARRAY;//LC:9874
        }//LC:9875
//LC:9876
        final short[] subarray = new short[newSize];//LC:9877
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9878
        return subarray;//LC:9879
    }//LC:9880
//LC:9881
    /**//LC:9882
     * <p>Produces a new {@code char} array containing the elements//LC:9883
     * between the start and end indices.</p>//LC:9884
     *//LC:9885
     * <p>The start index is inclusive, the end index exclusive.//LC:9886
     * Null array input produces null output.</p>//LC:9887
     *//LC:9888
     * @param array  the array//LC:9889
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9890
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9891
     *      in an empty array.//LC:9892
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9893
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9894
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9895
     *      array length.//LC:9896
     * @return a new array containing the elements between//LC:9897
     *      the start and end indices.//LC:9898
     * @since 2.1//LC:9899
     *///LC:9900
    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9901
        if (array == null) {//LC:9902
            return null;//LC:9903
        }//LC:9904
        if (startIndexInclusive < 0) {//LC:9905
            startIndexInclusive = 0;//LC:9906
        }//LC:9907
        if (endIndexExclusive > array.length) {//LC:9908
            endIndexExclusive = array.length;//LC:9909
        }//LC:9910
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9911
        if (newSize <= 0) {//LC:9912
            return EMPTY_CHAR_ARRAY;//LC:9913
        }//LC:9914
//LC:9915
        final char[] subarray = new char[newSize];//LC:9916
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9917
        return subarray;//LC:9918
    }//LC:9919
//LC:9920
    /**//LC:9921
     * <p>Produces a new {@code byte} array containing the elements//LC:9922
     * between the start and end indices.</p>//LC:9923
     *//LC:9924
     * <p>The start index is inclusive, the end index exclusive.//LC:9925
     * Null array input produces null output.</p>//LC:9926
     *//LC:9927
     * @param array  the array//LC:9928
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9929
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9930
     *      in an empty array.//LC:9931
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9932
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9933
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9934
     *      array length.//LC:9935
     * @return a new array containing the elements between//LC:9936
     *      the start and end indices.//LC:9937
     * @since 2.1//LC:9938
     *///LC:9939
    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9940
        if (array == null) {//LC:9941
            return null;//LC:9942
        }//LC:9943
        if (startIndexInclusive < 0) {//LC:9944
            startIndexInclusive = 0;//LC:9945
        }//LC:9946
        if (endIndexExclusive > array.length) {//LC:9947
            endIndexExclusive = array.length;//LC:9948
        }//LC:9949
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9950
        if (newSize <= 0) {//LC:9951
            return EMPTY_BYTE_ARRAY;//LC:9952
        }//LC:9953
//LC:9954
        final byte[] subarray = new byte[newSize];//LC:9955
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9956
        return subarray;//LC:9957
    }//LC:9958
//LC:9959
    /**//LC:9960
     * <p>Produces a new {@code double} array containing the elements//LC:9961
     * between the start and end indices.</p>//LC:9962
     *//LC:9963
     * <p>The start index is inclusive, the end index exclusive.//LC:9964
     * Null array input produces null output.</p>//LC:9965
     *//LC:9966
     * @param array  the array//LC:9967
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:9968
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:9969
     *      in an empty array.//LC:9970
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:9971
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:9972
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:9973
     *      array length.//LC:9974
     * @return a new array containing the elements between//LC:9975
     *      the start and end indices.//LC:9976
     * @since 2.1//LC:9977
     *///LC:9978
    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {//LC:9979
        if (array == null) {//LC:9980
            return null;//LC:9981
        }//LC:9982
        if (startIndexInclusive < 0) {//LC:9983
            startIndexInclusive = 0;//LC:9984
        }//LC:9985
        if (endIndexExclusive > array.length) {//LC:9986
            endIndexExclusive = array.length;//LC:9987
        }//LC:9988
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:9989
        if (newSize <= 0) {//LC:9990
            return EMPTY_DOUBLE_ARRAY;//LC:9991
        }//LC:9992
//LC:9993
        final double[] subarray = new double[newSize];//LC:9994
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:9995
        return subarray;//LC:9996
    }//LC:9997
//LC:9998
    /**//LC:9999
     * <p>Produces a new {@code float} array containing the elements//LC:10000
     * between the start and end indices.</p>//LC:10001
     *//LC:10002
     * <p>The start index is inclusive, the end index exclusive.//LC:10003
     * Null array input produces null output.</p>//LC:10004
     *//LC:10005
     * @param array  the array//LC:10006
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:10007
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:10008
     *      in an empty array.//LC:10009
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:10010
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:10011
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:10012
     *      array length.//LC:10013
     * @return a new array containing the elements between//LC:10014
     *      the start and end indices.//LC:10015
     * @since 2.1//LC:10016
     *///LC:10017
    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {//LC:10018
        if (array == null) {//LC:10019
            return null;//LC:10020
        }//LC:10021
        if (startIndexInclusive < 0) {//LC:10022
            startIndexInclusive = 0;//LC:10023
        }//LC:10024
        if (endIndexExclusive > array.length) {//LC:10025
            endIndexExclusive = array.length;//LC:10026
        }//LC:10027
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:10028
        if (newSize <= 0) {//LC:10029
            return EMPTY_FLOAT_ARRAY;//LC:10030
        }//LC:10031
//LC:10032
        final float[] subarray = new float[newSize];//LC:10033
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:10034
        return subarray;//LC:10035
    }//LC:10036
//LC:10037
    /**//LC:10038
     * <p>Produces a new {@code boolean} array containing the elements//LC:10039
     * between the start and end indices.</p>//LC:10040
     *//LC:10041
     * <p>The start index is inclusive, the end index exclusive.//LC:10042
     * Null array input produces null output.</p>//LC:10043
     *//LC:10044
     * @param array  the array//LC:10045
     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)//LC:10046
     *      is promoted to 0, overvalue (&gt;array.length) results//LC:10047
     *      in an empty array.//LC:10048
     * @param endIndexExclusive  elements up to endIndex-1 are present in the//LC:10049
     *      returned subarray. Undervalue (&lt; startIndex) produces//LC:10050
     *      empty array, overvalue (&gt;array.length) is demoted to//LC:10051
     *      array length.//LC:10052
     * @return a new array containing the elements between//LC:10053
     *      the start and end indices.//LC:10054
     * @since 2.1//LC:10055
     *///LC:10056
    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {//LC:10057
        if (array == null) {//LC:10058
            return null;//LC:10059
        }//LC:10060
        if (startIndexInclusive < 0) {//LC:10061
            startIndexInclusive = 0;//LC:10062
        }//LC:10063
        if (endIndexExclusive > array.length) {//LC:10064
            endIndexExclusive = array.length;//LC:10065
        }//LC:10066
        final int newSize = endIndexExclusive - startIndexInclusive;//LC:10067
        if (newSize <= 0) {//LC:10068
            return EMPTY_BOOLEAN_ARRAY;//LC:10069
        }//LC:10070
//LC:10071
        final boolean[] subarray = new boolean[newSize];//LC:10072
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);//LC:10073
        return subarray;//LC:10074
    }//LC:10075
//LC:10076
    // Is same length//LC:10077
    //-----------------------------------------------------------------------//LC:10078
    /**//LC:10079
     * <p>Checks whether two arrays are the same length, treating//LC:10080
     * {@code null} arrays as length {@code 0}.//LC:10081
     *//LC:10082
     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>//LC:10083
     *//LC:10084
     * @param array1 the first array, may be {@code null}//LC:10085
     * @param array2 the second array, may be {@code null}//LC:10086
     * @return {@code true} if length of arrays matches, treating//LC:10087
     *  {@code null} as an empty array//LC:10088
     *///LC:10089
    public static boolean isSameLength(final Object[] array1, final Object[] array2) {//LC:10090
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10091
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10092
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10093
            return false;//LC:10094
        }//LC:10095
        return true;//LC:10096
    }//LC:10097
//LC:10098
    /**//LC:10099
     * <p>Checks whether two arrays are the same length, treating//LC:10100
     * {@code null} arrays as length {@code 0}.</p>//LC:10101
     *//LC:10102
     * @param array1 the first array, may be {@code null}//LC:10103
     * @param array2 the second array, may be {@code null}//LC:10104
     * @return {@code true} if length of arrays matches, treating//LC:10105
     *  {@code null} as an empty array//LC:10106
     *///LC:10107
    public static boolean isSameLength(final long[] array1, final long[] array2) {//LC:10108
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10109
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10110
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10111
            return false;//LC:10112
        }//LC:10113
        return true;//LC:10114
    }//LC:10115
//LC:10116
    /**//LC:10117
     * <p>Checks whether two arrays are the same length, treating//LC:10118
     * {@code null} arrays as length {@code 0}.</p>//LC:10119
     *//LC:10120
     * @param array1 the first array, may be {@code null}//LC:10121
     * @param array2 the second array, may be {@code null}//LC:10122
     * @return {@code true} if length of arrays matches, treating//LC:10123
     *  {@code null} as an empty array//LC:10124
     *///LC:10125
    public static boolean isSameLength(final int[] array1, final int[] array2) {//LC:10126
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10127
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10128
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10129
            return false;//LC:10130
        }//LC:10131
        return true;//LC:10132
    }//LC:10133
//LC:10134
    /**//LC:10135
     * <p>Checks whether two arrays are the same length, treating//LC:10136
     * {@code null} arrays as length {@code 0}.</p>//LC:10137
     *//LC:10138
     * @param array1 the first array, may be {@code null}//LC:10139
     * @param array2 the second array, may be {@code null}//LC:10140
     * @return {@code true} if length of arrays matches, treating//LC:10141
     *  {@code null} as an empty array//LC:10142
     *///LC:10143
    public static boolean isSameLength(final short[] array1, final short[] array2) {//LC:10144
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10145
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10146
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10147
            return false;//LC:10148
        }//LC:10149
        return true;//LC:10150
    }//LC:10151
//LC:10152
    /**//LC:10153
     * <p>Checks whether two arrays are the same length, treating//LC:10154
     * {@code null} arrays as length {@code 0}.</p>//LC:10155
     *//LC:10156
     * @param array1 the first array, may be {@code null}//LC:10157
     * @param array2 the second array, may be {@code null}//LC:10158
     * @return {@code true} if length of arrays matches, treating//LC:10159
     *  {@code null} as an empty array//LC:10160
     *///LC:10161
    public static boolean isSameLength(final char[] array1, final char[] array2) {//LC:10162
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10163
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10164
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10165
            return false;//LC:10166
        }//LC:10167
        return true;//LC:10168
    }//LC:10169
//LC:10170
    /**//LC:10171
     * <p>Checks whether two arrays are the same length, treating//LC:10172
     * {@code null} arrays as length {@code 0}.</p>//LC:10173
     *//LC:10174
     * @param array1 the first array, may be {@code null}//LC:10175
     * @param array2 the second array, may be {@code null}//LC:10176
     * @return {@code true} if length of arrays matches, treating//LC:10177
     *  {@code null} as an empty array//LC:10178
     *///LC:10179
    public static boolean isSameLength(final byte[] array1, final byte[] array2) {//LC:10180
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10181
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10182
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10183
            return false;//LC:10184
        }//LC:10185
        return true;//LC:10186
    }//LC:10187
//LC:10188
    /**//LC:10189
     * <p>Checks whether two arrays are the same length, treating//LC:10190
     * {@code null} arrays as length {@code 0}.</p>//LC:10191
     *//LC:10192
     * @param array1 the first array, may be {@code null}//LC:10193
     * @param array2 the second array, may be {@code null}//LC:10194
     * @return {@code true} if length of arrays matches, treating//LC:10195
     *  {@code null} as an empty array//LC:10196
     *///LC:10197
    public static boolean isSameLength(final double[] array1, final double[] array2) {//LC:10198
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10199
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10200
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10201
            return false;//LC:10202
        }//LC:10203
        return true;//LC:10204
    }//LC:10205
//LC:10206
    /**//LC:10207
     * <p>Checks whether two arrays are the same length, treating//LC:10208
     * {@code null} arrays as length {@code 0}.</p>//LC:10209
     *//LC:10210
     * @param array1 the first array, may be {@code null}//LC:10211
     * @param array2 the second array, may be {@code null}//LC:10212
     * @return {@code true} if length of arrays matches, treating//LC:10213
     *  {@code null} as an empty array//LC:10214
     *///LC:10215
    public static boolean isSameLength(final float[] array1, final float[] array2) {//LC:10216
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10217
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10218
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10219
            return false;//LC:10220
        }//LC:10221
        return true;//LC:10222
    }//LC:10223
//LC:10224
    /**//LC:10225
     * <p>Checks whether two arrays are the same length, treating//LC:10226
     * {@code null} arrays as length {@code 0}.</p>//LC:10227
     *//LC:10228
     * @param array1 the first array, may be {@code null}//LC:10229
     * @param array2 the second array, may be {@code null}//LC:10230
     * @return {@code true} if length of arrays matches, treating//LC:10231
     *  {@code null} as an empty array//LC:10232
     *///LC:10233
    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {//LC:10234
        if ((array1 == null && array2 != null && array2.length > 0) ||//LC:10235
                (array2 == null && array1 != null && array1.length > 0) ||//LC:10236
                (array1 != null && array2 != null && array1.length != array2.length)) {//LC:10237
            return false;//LC:10238
        }//LC:10239
        return true;//LC:10240
    }//LC:10241
//LC:10242
    //-----------------------------------------------------------------------//LC:10243
    /**//LC:10244
     * <p>Returns the length of the specified array.//LC:10245
     * This method can deal with {@code Object} arrays and with primitive arrays.</p>//LC:10246
     *//LC:10247
     * <p>If the input array is {@code null}, {@code 0} is returned.</p>//LC:10248
     *//LC:10249
     * <pre>//LC:10250
     * ArrayUtils.getLength(null)            = 0//LC:10251
     * ArrayUtils.getLength([])              = 0//LC:10252
     * ArrayUtils.getLength([null])          = 1//LC:10253
     * ArrayUtils.getLength([true, false])   = 2//LC:10254
     * ArrayUtils.getLength([1, 2, 3])       = 3//LC:10255
     * ArrayUtils.getLength(["a", "b", "c"]) = 3//LC:10256
     * </pre>//LC:10257
     *//LC:10258
     * @param array  the array to retrieve the length from, may be null//LC:10259
     * @return The length of the array, or {@code 0} if the array is {@code null}//LC:10260
     * @throws IllegalArgumentException if the object argument is not an array.//LC:10261
     * @since 2.1//LC:10262
     *///LC:10263
    public static int getLength(final Object array) {//LC:10264
        if (array == null) {//LC:10265
            return 0;//LC:10266
        }//LC:10267
        return Array.getLength(array);//LC:10268
    }//LC:10269
//LC:10270
    /**//LC:10271
     * <p>Checks whether two arrays are the same type taking into account//LC:10272
     * multi-dimensional arrays.</p>//LC:10273
     *//LC:10274
     * @param array1 the first array, must not be {@code null}//LC:10275
     * @param array2 the second array, must not be {@code null}//LC:10276
     * @return {@code true} if type of arrays matches//LC:10277
     * @throws IllegalArgumentException if either array is {@code null}//LC:10278
     *///LC:10279
    public static boolean isSameType(final Object array1, final Object array2) {//LC:10280
        if (array1 == null || array2 == null) {//LC:10281
            throw new IllegalArgumentException("The Array must not be null");//LC:10282
        }//LC:10283
        return array1.getClass().getName().equals(array2.getClass().getName());//LC:10284
    }//LC:10285
//LC:10286
    // Reverse//LC:10287
    //-----------------------------------------------------------------------//LC:10288
    /**//LC:10289
     * <p>Reverses the order of the given array.</p>//LC:10290
     *//LC:10291
     * <p>There is no special handling for multi-dimensional arrays.</p>//LC:10292
     *//LC:10293
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10294
     *//LC:10295
     * @param array  the array to reverse, may be {@code null}//LC:10296
     *///LC:10297
    public static void reverse(final Object[] array) {//LC:10298
        if (array == null) {//LC:10299
            return;//LC:10300
        }//LC:10301
        int i = 0;//LC:10302
        int j = array.length - 1;//LC:10303
        Object tmp;//LC:10304
        while (j > i) {//LC:10305
            tmp = array[j];//LC:10306
            array[j] = array[i];//LC:10307
            array[i] = tmp;//LC:10308
            j--;//LC:10309
            i++;//LC:10310
        }//LC:10311
    }//LC:10312
//LC:10313
    /**//LC:10314
     * <p>Reverses the order of the given array.</p>//LC:10315
     *//LC:10316
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10317
     *//LC:10318
     * @param array  the array to reverse, may be {@code null}//LC:10319
     *///LC:10320
    public static void reverse(final long[] array) {//LC:10321
        if (array == null) {//LC:10322
            return;//LC:10323
        }//LC:10324
        int i = 0;//LC:10325
        int j = array.length - 1;//LC:10326
        long tmp;//LC:10327
        while (j > i) {//LC:10328
            tmp = array[j];//LC:10329
            array[j] = array[i];//LC:10330
            array[i] = tmp;//LC:10331
            j--;//LC:10332
            i++;//LC:10333
        }//LC:10334
    }//LC:10335
//LC:10336
    /**//LC:10337
     * <p>Reverses the order of the given array.</p>//LC:10338
     *//LC:10339
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10340
     *//LC:10341
     * @param array  the array to reverse, may be {@code null}//LC:10342
     *///LC:10343
    public static void reverse(final int[] array) {//LC:10344
        if (array == null) {//LC:10345
            return;//LC:10346
        }//LC:10347
        int i = 0;//LC:10348
        int j = array.length - 1;//LC:10349
        int tmp;//LC:10350
        while (j > i) {//LC:10351
            tmp = array[j];//LC:10352
            array[j] = array[i];//LC:10353
            array[i] = tmp;//LC:10354
            j--;//LC:10355
            i++;//LC:10356
        }//LC:10357
    }//LC:10358
//LC:10359
    /**//LC:10360
     * <p>Reverses the order of the given array.</p>//LC:10361
     *//LC:10362
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10363
     *//LC:10364
     * @param array  the array to reverse, may be {@code null}//LC:10365
     *///LC:10366
    public static void reverse(final short[] array) {//LC:10367
        if (array == null) {//LC:10368
            return;//LC:10369
        }//LC:10370
        int i = 0;//LC:10371
        int j = array.length - 1;//LC:10372
        short tmp;//LC:10373
        while (j > i) {//LC:10374
            tmp = array[j];//LC:10375
            array[j] = array[i];//LC:10376
            array[i] = tmp;//LC:10377
            j--;//LC:10378
            i++;//LC:10379
        }//LC:10380
    }//LC:10381
//LC:10382
    /**//LC:10383
     * <p>Reverses the order of the given array.</p>//LC:10384
     *//LC:10385
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10386
     *//LC:10387
     * @param array  the array to reverse, may be {@code null}//LC:10388
     *///LC:10389
    public static void reverse(final char[] array) {//LC:10390
        if (array == null) {//LC:10391
            return;//LC:10392
        }//LC:10393
        int i = 0;//LC:10394
        int j = array.length - 1;//LC:10395
        char tmp;//LC:10396
        while (j > i) {//LC:10397
            tmp = array[j];//LC:10398
            array[j] = array[i];//LC:10399
            array[i] = tmp;//LC:10400
            j--;//LC:10401
            i++;//LC:10402
        }//LC:10403
    }//LC:10404
//LC:10405
    /**//LC:10406
     * <p>Reverses the order of the given array.</p>//LC:10407
     *//LC:10408
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10409
     *//LC:10410
     * @param array  the array to reverse, may be {@code null}//LC:10411
     *///LC:10412
    public static void reverse(final byte[] array) {//LC:10413
        if (array == null) {//LC:10414
            return;//LC:10415
        }//LC:10416
        int i = 0;//LC:10417
        int j = array.length - 1;//LC:10418
        byte tmp;//LC:10419
        while (j > i) {//LC:10420
            tmp = array[j];//LC:10421
            array[j] = array[i];//LC:10422
            array[i] = tmp;//LC:10423
            j--;//LC:10424
            i++;//LC:10425
        }//LC:10426
    }//LC:10427
//LC:10428
    /**//LC:10429
     * <p>Reverses the order of the given array.</p>//LC:10430
     *//LC:10431
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10432
     *//LC:10433
     * @param array  the array to reverse, may be {@code null}//LC:10434
     *///LC:10435
    public static void reverse(final double[] array) {//LC:10436
        if (array == null) {//LC:10437
            return;//LC:10438
        }//LC:10439
        int i = 0;//LC:10440
        int j = array.length - 1;//LC:10441
        double tmp;//LC:10442
        while (j > i) {//LC:10443
            tmp = array[j];//LC:10444
            array[j] = array[i];//LC:10445
            array[i] = tmp;//LC:10446
            j--;//LC:10447
            i++;//LC:10448
        }//LC:10449
    }//LC:10450
//LC:10451
    /**//LC:10452
     * <p>Reverses the order of the given array.</p>//LC:10453
     *//LC:10454
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10455
     *//LC:10456
     * @param array  the array to reverse, may be {@code null}//LC:10457
     *///LC:10458
    public static void reverse(final float[] array) {//LC:10459
        if (array == null) {//LC:10460
            return;//LC:10461
        }//LC:10462
        int i = 0;//LC:10463
        int j = array.length - 1;//LC:10464
        float tmp;//LC:10465
        while (j > i) {//LC:10466
            tmp = array[j];//LC:10467
            array[j] = array[i];//LC:10468
            array[i] = tmp;//LC:10469
            j--;//LC:10470
            i++;//LC:10471
        }//LC:10472
    }//LC:10473
//LC:10474
    /**//LC:10475
     * <p>Reverses the order of the given array.</p>//LC:10476
     *//LC:10477
     * <p>This method does nothing for a {@code null} input array.</p>//LC:10478
     *//LC:10479
     * @param array  the array to reverse, may be {@code null}//LC:10480
     *///LC:10481
    public static void reverse(final boolean[] array) {//LC:10482
        if (array == null) {//LC:10483
            return;//LC:10484
        }//LC:10485
        int i = 0;//LC:10486
        int j = array.length - 1;//LC:10487
        boolean tmp;//LC:10488
        while (j > i) {//LC:10489
            tmp = array[j];//LC:10490
            array[j] = array[i];//LC:10491
            array[i] = tmp;//LC:10492
            j--;//LC:10493
            i++;//LC:10494
        }//LC:10495
    }//LC:10496
//LC:10497
    // IndexOf search//LC:10498
    // ----------------------------------------------------------------------//LC:10499
//LC:10500
    // Object IndexOf//LC:10501
    //-----------------------------------------------------------------------//LC:10502
    /**//LC:10503
     * <p>Finds the index of the given object in the array.</p>//LC:10504
     *//LC:10505
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10506
     *//LC:10507
     * @param array  the array to search through for the object, may be {@code null}//LC:10508
     * @param objectToFind  the object to find, may be {@code null}//LC:10509
     * @return the index of the object within the array,//LC:10510
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10511
     *///LC:10512
    public static int indexOf(final Object[] array, final Object objectToFind) {//LC:10513
        return indexOf(array, objectToFind, 0);//LC:10514
    }//LC:10515
//LC:10516
    /**//LC:10517
     * <p>Finds the index of the given object in the array starting at the given index.</p>//LC:10518
     *//LC:10519
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10520
     *//LC:10521
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:10522
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:10523
     *//LC:10524
     * @param array  the array to search through for the object, may be {@code null}//LC:10525
     * @param objectToFind  the object to find, may be {@code null}//LC:10526
     * @param startIndex  the index to start searching at//LC:10527
     * @return the index of the object within the array starting at the index,//LC:10528
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10529
     *///LC:10530
    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {//LC:10531
        if (array == null) {//LC:10532
            return INDEX_NOT_FOUND;//LC:10533
        }//LC:10534
        if (startIndex < 0) {//LC:10535
            startIndex = 0;//LC:10536
        }//LC:10537
        if (objectToFind == null) {//LC:10538
            for (int i = startIndex; i < array.length; i++) {//LC:10539
                if (array[i] == null) {//LC:10540
                    return i;//LC:10541
                }//LC:10542
            }//LC:10543
        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {//LC:10544
            for (int i = startIndex; i < array.length; i++) {//LC:10545
                if (objectToFind.equals(array[i])) {//LC:10546
                    return i;//LC:10547
                }//LC:10548
            }//LC:10549
        }//LC:10550
        return INDEX_NOT_FOUND;//LC:10551
    }//LC:10552
//LC:10553
    /**//LC:10554
     * <p>Finds the last index of the given object within the array.</p>//LC:10555
     *//LC:10556
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10557
     *//LC:10558
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:10559
     * @param objectToFind  the object to find, may be {@code null}//LC:10560
     * @return the last index of the object within the array,//LC:10561
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10562
     *///LC:10563
    public static int lastIndexOf(final Object[] array, final Object objectToFind) {//LC:10564
        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);//LC:10565
    }//LC:10566
//LC:10567
    /**//LC:10568
     * <p>Finds the last index of the given object in the array starting at the given index.</p>//LC:10569
     *//LC:10570
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10571
     *//LC:10572
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than//LC:10573
     * the array length will search from the end of the array.</p>//LC:10574
     *//LC:10575
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:10576
     * @param objectToFind  the object to find, may be {@code null}//LC:10577
     * @param startIndex  the start index to travers backwards from//LC:10578
     * @return the last index of the object within the array,//LC:10579
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10580
     *///LC:10581
    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {//LC:10582
        if (array == null) {//LC:10583
            return INDEX_NOT_FOUND;//LC:10584
        }//LC:10585
        if (startIndex < 0) {//LC:10586
            return INDEX_NOT_FOUND;//LC:10587
        } else if (startIndex >= array.length) {//LC:10588
            startIndex = array.length - 1;//LC:10589
        }//LC:10590
        if (objectToFind == null) {//LC:10591
            for (int i = startIndex; i >= 0; i--) {//LC:10592
                if (array[i] == null) {//LC:10593
                    return i;//LC:10594
                }//LC:10595
            }//LC:10596
        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {//LC:10597
            for (int i = startIndex; i >= 0; i--) {//LC:10598
                if (objectToFind.equals(array[i])) {//LC:10599
                    return i;//LC:10600
                }//LC:10601
            }//LC:10602
        }//LC:10603
        return INDEX_NOT_FOUND;//LC:10604
    }//LC:10605
//LC:10606
    /**//LC:10607
     * <p>Checks if the object is in the given array.</p>//LC:10608
     *//LC:10609
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:10610
     *//LC:10611
     * @param array  the array to search through//LC:10612
     * @param objectToFind  the object to find//LC:10613
     * @return {@code true} if the array contains the object//LC:10614
     *///LC:10615
    public static boolean contains(final Object[] array, final Object objectToFind) {//LC:10616
        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;//LC:10617
    }//LC:10618
//LC:10619
    // long IndexOf//LC:10620
    //-----------------------------------------------------------------------//LC:10621
    /**//LC:10622
     * <p>Finds the index of the given value in the array.</p>//LC:10623
     *//LC:10624
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10625
     *//LC:10626
     * @param array  the array to search through for the object, may be {@code null}//LC:10627
     * @param valueToFind  the value to find//LC:10628
     * @return the index of the value within the array,//LC:10629
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10630
     *///LC:10631
    public static int indexOf(final long[] array, final long valueToFind) {//LC:10632
        return indexOf(array, valueToFind, 0);//LC:10633
    }//LC:10634
//LC:10635
    /**//LC:10636
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:10637
     *//LC:10638
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10639
     *//LC:10640
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:10641
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:10642
     *//LC:10643
     * @param array  the array to search through for the object, may be {@code null}//LC:10644
     * @param valueToFind  the value to find//LC:10645
     * @param startIndex  the index to start searching at//LC:10646
     * @return the index of the value within the array,//LC:10647
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10648
     *///LC:10649
    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {//LC:10650
        if (array == null) {//LC:10651
            return INDEX_NOT_FOUND;//LC:10652
        }//LC:10653
        if (startIndex < 0) {//LC:10654
            startIndex = 0;//LC:10655
        }//LC:10656
        for (int i = startIndex; i < array.length; i++) {//LC:10657
            if (valueToFind == array[i]) {//LC:10658
                return i;//LC:10659
            }//LC:10660
        }//LC:10661
        return INDEX_NOT_FOUND;//LC:10662
    }//LC:10663
//LC:10664
    /**//LC:10665
     * <p>Finds the last index of the given value within the array.</p>//LC:10666
     *//LC:10667
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10668
     *//LC:10669
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:10670
     * @param valueToFind  the object to find//LC:10671
     * @return the last index of the value within the array,//LC:10672
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10673
     *///LC:10674
    public static int lastIndexOf(final long[] array, final long valueToFind) {//LC:10675
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:10676
    }//LC:10677
//LC:10678
    /**//LC:10679
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:10680
     *//LC:10681
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10682
     *//LC:10683
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:10684
     * array length will search from the end of the array.</p>//LC:10685
     *//LC:10686
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:10687
     * @param valueToFind  the value to find//LC:10688
     * @param startIndex  the start index to travers backwards from//LC:10689
     * @return the last index of the value within the array,//LC:10690
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10691
     *///LC:10692
    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {//LC:10693
        if (array == null) {//LC:10694
            return INDEX_NOT_FOUND;//LC:10695
        }//LC:10696
        if (startIndex < 0) {//LC:10697
            return INDEX_NOT_FOUND;//LC:10698
        } else if (startIndex >= array.length) {//LC:10699
            startIndex = array.length - 1;//LC:10700
        }//LC:10701
        for (int i = startIndex; i >= 0; i--) {//LC:10702
            if (valueToFind == array[i]) {//LC:10703
                return i;//LC:10704
            }//LC:10705
        }//LC:10706
        return INDEX_NOT_FOUND;//LC:10707
    }//LC:10708
//LC:10709
    /**//LC:10710
     * <p>Checks if the value is in the given array.</p>//LC:10711
     *//LC:10712
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:10713
     *//LC:10714
     * @param array  the array to search through//LC:10715
     * @param valueToFind  the value to find//LC:10716
     * @return {@code true} if the array contains the object//LC:10717
     *///LC:10718
    public static boolean contains(final long[] array, final long valueToFind) {//LC:10719
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:10720
    }//LC:10721
//LC:10722
    // int IndexOf//LC:10723
    //-----------------------------------------------------------------------//LC:10724
    /**//LC:10725
     * <p>Finds the index of the given value in the array.</p>//LC:10726
     *//LC:10727
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10728
     *//LC:10729
     * @param array  the array to search through for the object, may be {@code null}//LC:10730
     * @param valueToFind  the value to find//LC:10731
     * @return the index of the value within the array,//LC:10732
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10733
     *///LC:10734
    public static int indexOf(final int[] array, final int valueToFind) {//LC:10735
        return indexOf(array, valueToFind, 0);//LC:10736
    }//LC:10737
//LC:10738
    /**//LC:10739
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:10740
     *//LC:10741
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10742
     *//LC:10743
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:10744
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:10745
     *//LC:10746
     * @param array  the array to search through for the object, may be {@code null}//LC:10747
     * @param valueToFind  the value to find//LC:10748
     * @param startIndex  the index to start searching at//LC:10749
     * @return the index of the value within the array,//LC:10750
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10751
     *///LC:10752
    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {//LC:10753
        if (array == null) {//LC:10754
            return INDEX_NOT_FOUND;//LC:10755
        }//LC:10756
        if (startIndex < 0) {//LC:10757
            startIndex = 0;//LC:10758
        }//LC:10759
        for (int i = startIndex; i < array.length; i++) {//LC:10760
            if (valueToFind == array[i]) {//LC:10761
                return i;//LC:10762
            }//LC:10763
        }//LC:10764
        return INDEX_NOT_FOUND;//LC:10765
    }//LC:10766
//LC:10767
    /**//LC:10768
     * <p>Finds the last index of the given value within the array.</p>//LC:10769
     *//LC:10770
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10771
     *//LC:10772
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:10773
     * @param valueToFind  the object to find//LC:10774
     * @return the last index of the value within the array,//LC:10775
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10776
     *///LC:10777
    public static int lastIndexOf(final int[] array, final int valueToFind) {//LC:10778
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:10779
    }//LC:10780
//LC:10781
    /**//LC:10782
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:10783
     *//LC:10784
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10785
     *//LC:10786
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:10787
     * array length will search from the end of the array.</p>//LC:10788
     *//LC:10789
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:10790
     * @param valueToFind  the value to find//LC:10791
     * @param startIndex  the start index to travers backwards from//LC:10792
     * @return the last index of the value within the array,//LC:10793
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10794
     *///LC:10795
    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {//LC:10796
        if (array == null) {//LC:10797
            return INDEX_NOT_FOUND;//LC:10798
        }//LC:10799
        if (startIndex < 0) {//LC:10800
            return INDEX_NOT_FOUND;//LC:10801
        } else if (startIndex >= array.length) {//LC:10802
            startIndex = array.length - 1;//LC:10803
        }//LC:10804
        for (int i = startIndex; i >= 0; i--) {//LC:10805
            if (valueToFind == array[i]) {//LC:10806
                return i;//LC:10807
            }//LC:10808
        }//LC:10809
        return INDEX_NOT_FOUND;//LC:10810
    }//LC:10811
//LC:10812
    /**//LC:10813
     * <p>Checks if the value is in the given array.</p>//LC:10814
     *//LC:10815
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:10816
     *//LC:10817
     * @param array  the array to search through//LC:10818
     * @param valueToFind  the value to find//LC:10819
     * @return {@code true} if the array contains the object//LC:10820
     *///LC:10821
    public static boolean contains(final int[] array, final int valueToFind) {//LC:10822
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:10823
    }//LC:10824
//LC:10825
    // short IndexOf//LC:10826
    //-----------------------------------------------------------------------//LC:10827
    /**//LC:10828
     * <p>Finds the index of the given value in the array.</p>//LC:10829
     *//LC:10830
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10831
     *//LC:10832
     * @param array  the array to search through for the object, may be {@code null}//LC:10833
     * @param valueToFind  the value to find//LC:10834
     * @return the index of the value within the array,//LC:10835
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10836
     *///LC:10837
    public static int indexOf(final short[] array, final short valueToFind) {//LC:10838
        return indexOf(array, valueToFind, 0);//LC:10839
    }//LC:10840
//LC:10841
    /**//LC:10842
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:10843
     *//LC:10844
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10845
     *//LC:10846
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:10847
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:10848
     *//LC:10849
     * @param array  the array to search through for the object, may be {@code null}//LC:10850
     * @param valueToFind  the value to find//LC:10851
     * @param startIndex  the index to start searching at//LC:10852
     * @return the index of the value within the array,//LC:10853
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10854
     *///LC:10855
    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {//LC:10856
        if (array == null) {//LC:10857
            return INDEX_NOT_FOUND;//LC:10858
        }//LC:10859
        if (startIndex < 0) {//LC:10860
            startIndex = 0;//LC:10861
        }//LC:10862
        for (int i = startIndex; i < array.length; i++) {//LC:10863
            if (valueToFind == array[i]) {//LC:10864
                return i;//LC:10865
            }//LC:10866
        }//LC:10867
        return INDEX_NOT_FOUND;//LC:10868
    }//LC:10869
//LC:10870
    /**//LC:10871
     * <p>Finds the last index of the given value within the array.</p>//LC:10872
     *//LC:10873
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10874
     *//LC:10875
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:10876
     * @param valueToFind  the object to find//LC:10877
     * @return the last index of the value within the array,//LC:10878
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10879
     *///LC:10880
    public static int lastIndexOf(final short[] array, final short valueToFind) {//LC:10881
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:10882
    }//LC:10883
//LC:10884
    /**//LC:10885
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:10886
     *//LC:10887
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10888
     *//LC:10889
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:10890
     * array length will search from the end of the array.</p>//LC:10891
     *//LC:10892
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:10893
     * @param valueToFind  the value to find//LC:10894
     * @param startIndex  the start index to travers backwards from//LC:10895
     * @return the last index of the value within the array,//LC:10896
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10897
     *///LC:10898
    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {//LC:10899
        if (array == null) {//LC:10900
            return INDEX_NOT_FOUND;//LC:10901
        }//LC:10902
        if (startIndex < 0) {//LC:10903
            return INDEX_NOT_FOUND;//LC:10904
        } else if (startIndex >= array.length) {//LC:10905
            startIndex = array.length - 1;//LC:10906
        }//LC:10907
        for (int i = startIndex; i >= 0; i--) {//LC:10908
            if (valueToFind == array[i]) {//LC:10909
                return i;//LC:10910
            }//LC:10911
        }//LC:10912
        return INDEX_NOT_FOUND;//LC:10913
    }//LC:10914
//LC:10915
    /**//LC:10916
     * <p>Checks if the value is in the given array.</p>//LC:10917
     *//LC:10918
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:10919
     *//LC:10920
     * @param array  the array to search through//LC:10921
     * @param valueToFind  the value to find//LC:10922
     * @return {@code true} if the array contains the object//LC:10923
     *///LC:10924
    public static boolean contains(final short[] array, final short valueToFind) {//LC:10925
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:10926
    }//LC:10927
//LC:10928
    // char IndexOf//LC:10929
    //-----------------------------------------------------------------------//LC:10930
    /**//LC:10931
     * <p>Finds the index of the given value in the array.</p>//LC:10932
     *//LC:10933
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10934
     *//LC:10935
     * @param array  the array to search through for the object, may be {@code null}//LC:10936
     * @param valueToFind  the value to find//LC:10937
     * @return the index of the value within the array,//LC:10938
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10939
     * @since 2.1//LC:10940
     *///LC:10941
    public static int indexOf(final char[] array, final char valueToFind) {//LC:10942
        return indexOf(array, valueToFind, 0);//LC:10943
    }//LC:10944
//LC:10945
    /**//LC:10946
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:10947
     *//LC:10948
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10949
     *//LC:10950
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:10951
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:10952
     *//LC:10953
     * @param array  the array to search through for the object, may be {@code null}//LC:10954
     * @param valueToFind  the value to find//LC:10955
     * @param startIndex  the index to start searching at//LC:10956
     * @return the index of the value within the array,//LC:10957
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10958
     * @since 2.1//LC:10959
     *///LC:10960
    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {//LC:10961
        if (array == null) {//LC:10962
            return INDEX_NOT_FOUND;//LC:10963
        }//LC:10964
        if (startIndex < 0) {//LC:10965
            startIndex = 0;//LC:10966
        }//LC:10967
        for (int i = startIndex; i < array.length; i++) {//LC:10968
            if (valueToFind == array[i]) {//LC:10969
                return i;//LC:10970
            }//LC:10971
        }//LC:10972
        return INDEX_NOT_FOUND;//LC:10973
    }//LC:10974
//LC:10975
    /**//LC:10976
     * <p>Finds the last index of the given value within the array.</p>//LC:10977
     *//LC:10978
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10979
     *//LC:10980
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:10981
     * @param valueToFind  the object to find//LC:10982
     * @return the last index of the value within the array,//LC:10983
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:10984
     * @since 2.1//LC:10985
     *///LC:10986
    public static int lastIndexOf(final char[] array, final char valueToFind) {//LC:10987
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:10988
    }//LC:10989
//LC:10990
    /**//LC:10991
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:10992
     *//LC:10993
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:10994
     *//LC:10995
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:10996
     * array length will search from the end of the array.</p>//LC:10997
     *//LC:10998
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:10999
     * @param valueToFind  the value to find//LC:11000
     * @param startIndex  the start index to travers backwards from//LC:11001
     * @return the last index of the value within the array,//LC:11002
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11003
     * @since 2.1//LC:11004
     *///LC:11005
    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {//LC:11006
        if (array == null) {//LC:11007
            return INDEX_NOT_FOUND;//LC:11008
        }//LC:11009
        if (startIndex < 0) {//LC:11010
            return INDEX_NOT_FOUND;//LC:11011
        } else if (startIndex >= array.length) {//LC:11012
            startIndex = array.length - 1;//LC:11013
        }//LC:11014
        for (int i = startIndex; i >= 0; i--) {//LC:11015
            if (valueToFind == array[i]) {//LC:11016
                return i;//LC:11017
            }//LC:11018
        }//LC:11019
        return INDEX_NOT_FOUND;//LC:11020
    }//LC:11021
//LC:11022
    /**//LC:11023
     * <p>Checks if the value is in the given array.</p>//LC:11024
     *//LC:11025
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:11026
     *//LC:11027
     * @param array  the array to search through//LC:11028
     * @param valueToFind  the value to find//LC:11029
     * @return {@code true} if the array contains the object//LC:11030
     * @since 2.1//LC:11031
     *///LC:11032
    public static boolean contains(final char[] array, final char valueToFind) {//LC:11033
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:11034
    }//LC:11035
//LC:11036
    // byte IndexOf//LC:11037
    //-----------------------------------------------------------------------//LC:11038
    /**//LC:11039
     * <p>Finds the index of the given value in the array.</p>//LC:11040
     *//LC:11041
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11042
     *//LC:11043
     * @param array  the array to search through for the object, may be {@code null}//LC:11044
     * @param valueToFind  the value to find//LC:11045
     * @return the index of the value within the array,//LC:11046
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11047
     *///LC:11048
    public static int indexOf(final byte[] array, final byte valueToFind) {//LC:11049
        return indexOf(array, valueToFind, 0);//LC:11050
    }//LC:11051
//LC:11052
    /**//LC:11053
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:11054
     *//LC:11055
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11056
     *//LC:11057
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:11058
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:11059
     *//LC:11060
     * @param array  the array to search through for the object, may be {@code null}//LC:11061
     * @param valueToFind  the value to find//LC:11062
     * @param startIndex  the index to start searching at//LC:11063
     * @return the index of the value within the array,//LC:11064
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11065
     *///LC:11066
    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {//LC:11067
        if (array == null) {//LC:11068
            return INDEX_NOT_FOUND;//LC:11069
        }//LC:11070
        if (startIndex < 0) {//LC:11071
            startIndex = 0;//LC:11072
        }//LC:11073
        for (int i = startIndex; i < array.length; i++) {//LC:11074
            if (valueToFind == array[i]) {//LC:11075
                return i;//LC:11076
            }//LC:11077
        }//LC:11078
        return INDEX_NOT_FOUND;//LC:11079
    }//LC:11080
//LC:11081
    /**//LC:11082
     * <p>Finds the last index of the given value within the array.</p>//LC:11083
     *//LC:11084
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11085
     *//LC:11086
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:11087
     * @param valueToFind  the object to find//LC:11088
     * @return the last index of the value within the array,//LC:11089
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11090
     *///LC:11091
    public static int lastIndexOf(final byte[] array, final byte valueToFind) {//LC:11092
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:11093
    }//LC:11094
//LC:11095
    /**//LC:11096
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:11097
     *//LC:11098
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11099
     *//LC:11100
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:11101
     * array length will search from the end of the array.</p>//LC:11102
     *//LC:11103
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:11104
     * @param valueToFind  the value to find//LC:11105
     * @param startIndex  the start index to travers backwards from//LC:11106
     * @return the last index of the value within the array,//LC:11107
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11108
     *///LC:11109
    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {//LC:11110
        if (array == null) {//LC:11111
            return INDEX_NOT_FOUND;//LC:11112
        }//LC:11113
        if (startIndex < 0) {//LC:11114
            return INDEX_NOT_FOUND;//LC:11115
        } else if (startIndex >= array.length) {//LC:11116
            startIndex = array.length - 1;//LC:11117
        }//LC:11118
        for (int i = startIndex; i >= 0; i--) {//LC:11119
            if (valueToFind == array[i]) {//LC:11120
                return i;//LC:11121
            }//LC:11122
        }//LC:11123
        return INDEX_NOT_FOUND;//LC:11124
    }//LC:11125
//LC:11126
    /**//LC:11127
     * <p>Checks if the value is in the given array.</p>//LC:11128
     *//LC:11129
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:11130
     *//LC:11131
     * @param array  the array to search through//LC:11132
     * @param valueToFind  the value to find//LC:11133
     * @return {@code true} if the array contains the object//LC:11134
     *///LC:11135
    public static boolean contains(final byte[] array, final byte valueToFind) {//LC:11136
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:11137
    }//LC:11138
//LC:11139
    // double IndexOf//LC:11140
    //-----------------------------------------------------------------------//LC:11141
    /**//LC:11142
     * <p>Finds the index of the given value in the array.</p>//LC:11143
     *//LC:11144
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11145
     *//LC:11146
     * @param array  the array to search through for the object, may be {@code null}//LC:11147
     * @param valueToFind  the value to find//LC:11148
     * @return the index of the value within the array,//LC:11149
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11150
     *///LC:11151
    public static int indexOf(final double[] array, final double valueToFind) {//LC:11152
        return indexOf(array, valueToFind, 0);//LC:11153
    }//LC:11154
//LC:11155
    /**//LC:11156
     * <p>Finds the index of the given value within a given tolerance in the array.//LC:11157
     * This method will return the index of the first value which falls between the region//LC:11158
     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>//LC:11159
     *//LC:11160
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11161
     *//LC:11162
     * @param array  the array to search through for the object, may be {@code null}//LC:11163
     * @param valueToFind  the value to find//LC:11164
     * @param tolerance tolerance of the search//LC:11165
     * @return the index of the value within the array,//LC:11166
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11167
     *///LC:11168
    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {//LC:11169
        return indexOf(array, valueToFind, 0, tolerance);//LC:11170
    }//LC:11171
//LC:11172
    /**//LC:11173
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:11174
     *//LC:11175
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11176
     *//LC:11177
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:11178
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:11179
     *//LC:11180
     * @param array  the array to search through for the object, may be {@code null}//LC:11181
     * @param valueToFind  the value to find//LC:11182
     * @param startIndex  the index to start searching at//LC:11183
     * @return the index of the value within the array,//LC:11184
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11185
     *///LC:11186
    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {//LC:11187
        if (ArrayUtils.isEmpty(array)) {//LC:11188
            return INDEX_NOT_FOUND;//LC:11189
        }//LC:11190
        if (startIndex < 0) {//LC:11191
            startIndex = 0;//LC:11192
        }//LC:11193
        for (int i = startIndex; i < array.length; i++) {//LC:11194
            if (valueToFind == array[i]) {//LC:11195
                return i;//LC:11196
            }//LC:11197
        }//LC:11198
        return INDEX_NOT_FOUND;//LC:11199
    }//LC:11200
//LC:11201
    /**//LC:11202
     * <p>Finds the index of the given value in the array starting at the given index.//LC:11203
     * This method will return the index of the first value which falls between the region//LC:11204
     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>//LC:11205
     *//LC:11206
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11207
     *//LC:11208
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:11209
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:11210
     *//LC:11211
     * @param array  the array to search through for the object, may be {@code null}//LC:11212
     * @param valueToFind  the value to find//LC:11213
     * @param startIndex  the index to start searching at//LC:11214
     * @param tolerance tolerance of the search//LC:11215
     * @return the index of the value within the array,//LC:11216
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11217
     *///LC:11218
    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {//LC:11219
        if (ArrayUtils.isEmpty(array)) {//LC:11220
            return INDEX_NOT_FOUND;//LC:11221
        }//LC:11222
        if (startIndex < 0) {//LC:11223
            startIndex = 0;//LC:11224
        }//LC:11225
        final double min = valueToFind - tolerance;//LC:11226
        final double max = valueToFind + tolerance;//LC:11227
        for (int i = startIndex; i < array.length; i++) {//LC:11228
            if (array[i] >= min && array[i] <= max) {//LC:11229
                return i;//LC:11230
            }//LC:11231
        }//LC:11232
        return INDEX_NOT_FOUND;//LC:11233
    }//LC:11234
//LC:11235
    /**//LC:11236
     * <p>Finds the last index of the given value within the array.</p>//LC:11237
     *//LC:11238
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11239
     *//LC:11240
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:11241
     * @param valueToFind  the object to find//LC:11242
     * @return the last index of the value within the array,//LC:11243
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11244
     *///LC:11245
    public static int lastIndexOf(final double[] array, final double valueToFind) {//LC:11246
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:11247
    }//LC:11248
//LC:11249
    /**//LC:11250
     * <p>Finds the last index of the given value within a given tolerance in the array.//LC:11251
     * This method will return the index of the last value which falls between the region//LC:11252
     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>//LC:11253
     *//LC:11254
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11255
     *//LC:11256
     * @param array  the array to search through for the object, may be {@code null}//LC:11257
     * @param valueToFind  the value to find//LC:11258
     * @param tolerance tolerance of the search//LC:11259
     * @return the index of the value within the array,//LC:11260
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11261
     *///LC:11262
    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {//LC:11263
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);//LC:11264
    }//LC:11265
//LC:11266
    /**//LC:11267
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:11268
     *//LC:11269
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11270
     *//LC:11271
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:11272
     * array length will search from the end of the array.</p>//LC:11273
     *//LC:11274
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:11275
     * @param valueToFind  the value to find//LC:11276
     * @param startIndex  the start index to travers backwards from//LC:11277
     * @return the last index of the value within the array,//LC:11278
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11279
     *///LC:11280
    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {//LC:11281
        if (ArrayUtils.isEmpty(array)) {//LC:11282
            return INDEX_NOT_FOUND;//LC:11283
        }//LC:11284
        if (startIndex < 0) {//LC:11285
            return INDEX_NOT_FOUND;//LC:11286
        } else if (startIndex >= array.length) {//LC:11287
            startIndex = array.length - 1;//LC:11288
        }//LC:11289
        for (int i = startIndex; i >= 0; i--) {//LC:11290
            if (valueToFind == array[i]) {//LC:11291
                return i;//LC:11292
            }//LC:11293
        }//LC:11294
        return INDEX_NOT_FOUND;//LC:11295
    }//LC:11296
//LC:11297
    /**//LC:11298
     * <p>Finds the last index of the given value in the array starting at the given index.//LC:11299
     * This method will return the index of the last value which falls between the region//LC:11300
     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>//LC:11301
     *//LC:11302
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11303
     *//LC:11304
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:11305
     * array length will search from the end of the array.</p>//LC:11306
     *//LC:11307
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:11308
     * @param valueToFind  the value to find//LC:11309
     * @param startIndex  the start index to travers backwards from//LC:11310
     * @param tolerance  search for value within plus/minus this amount//LC:11311
     * @return the last index of the value within the array,//LC:11312
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11313
     *///LC:11314
    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {//LC:11315
        if (ArrayUtils.isEmpty(array)) {//LC:11316
            return INDEX_NOT_FOUND;//LC:11317
        }//LC:11318
        if (startIndex < 0) {//LC:11319
            return INDEX_NOT_FOUND;//LC:11320
        } else if (startIndex >= array.length) {//LC:11321
            startIndex = array.length - 1;//LC:11322
        }//LC:11323
        final double min = valueToFind - tolerance;//LC:11324
        final double max = valueToFind + tolerance;//LC:11325
        for (int i = startIndex; i >= 0; i--) {//LC:11326
            if (array[i] >= min && array[i] <= max) {//LC:11327
                return i;//LC:11328
            }//LC:11329
        }//LC:11330
        return INDEX_NOT_FOUND;//LC:11331
    }//LC:11332
//LC:11333
    /**//LC:11334
     * <p>Checks if the value is in the given array.</p>//LC:11335
     *//LC:11336
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:11337
     *//LC:11338
     * @param array  the array to search through//LC:11339
     * @param valueToFind  the value to find//LC:11340
     * @return {@code true} if the array contains the object//LC:11341
     *///LC:11342
    public static boolean contains(final double[] array, final double valueToFind) {//LC:11343
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:11344
    }//LC:11345
//LC:11346
    /**//LC:11347
     * <p>Checks if a value falling within the given tolerance is in the//LC:11348
     * given array.  If the array contains a value within the inclusive range//LC:11349
     * defined by (value - tolerance) to (value + tolerance).</p>//LC:11350
     *//LC:11351
     * <p>The method returns {@code false} if a {@code null} array//LC:11352
     * is passed in.</p>//LC:11353
     *//LC:11354
     * @param array  the array to search//LC:11355
     * @param valueToFind  the value to find//LC:11356
     * @param tolerance  the array contains the tolerance of the search//LC:11357
     * @return true if value falling within tolerance is in array//LC:11358
     *///LC:11359
    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {//LC:11360
        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;//LC:11361
    }//LC:11362
//LC:11363
    // float IndexOf//LC:11364
    //-----------------------------------------------------------------------//LC:11365
    /**//LC:11366
     * <p>Finds the index of the given value in the array.</p>//LC:11367
     *//LC:11368
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11369
     *//LC:11370
     * @param array  the array to search through for the object, may be {@code null}//LC:11371
     * @param valueToFind  the value to find//LC:11372
     * @return the index of the value within the array,//LC:11373
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11374
     *///LC:11375
    public static int indexOf(final float[] array, final float valueToFind) {//LC:11376
        return indexOf(array, valueToFind, 0);//LC:11377
    }//LC:11378
//LC:11379
    /**//LC:11380
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:11381
     *//LC:11382
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11383
     *//LC:11384
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:11385
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:11386
     *//LC:11387
     * @param array  the array to search through for the object, may be {@code null}//LC:11388
     * @param valueToFind  the value to find//LC:11389
     * @param startIndex  the index to start searching at//LC:11390
     * @return the index of the value within the array,//LC:11391
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11392
     *///LC:11393
    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {//LC:11394
        if (ArrayUtils.isEmpty(array)) {//LC:11395
            return INDEX_NOT_FOUND;//LC:11396
        }//LC:11397
        if (startIndex < 0) {//LC:11398
            startIndex = 0;//LC:11399
        }//LC:11400
        for (int i = startIndex; i < array.length; i++) {//LC:11401
            if (valueToFind == array[i]) {//LC:11402
                return i;//LC:11403
            }//LC:11404
        }//LC:11405
        return INDEX_NOT_FOUND;//LC:11406
    }//LC:11407
//LC:11408
    /**//LC:11409
     * <p>Finds the last index of the given value within the array.</p>//LC:11410
     *//LC:11411
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11412
     *//LC:11413
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:11414
     * @param valueToFind  the object to find//LC:11415
     * @return the last index of the value within the array,//LC:11416
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11417
     *///LC:11418
    public static int lastIndexOf(final float[] array, final float valueToFind) {//LC:11419
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:11420
    }//LC:11421
//LC:11422
    /**//LC:11423
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:11424
     *//LC:11425
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11426
     *//LC:11427
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the//LC:11428
     * array length will search from the end of the array.</p>//LC:11429
     *//LC:11430
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:11431
     * @param valueToFind  the value to find//LC:11432
     * @param startIndex  the start index to travers backwards from//LC:11433
     * @return the last index of the value within the array,//LC:11434
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11435
     *///LC:11436
    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {//LC:11437
        if (ArrayUtils.isEmpty(array)) {//LC:11438
            return INDEX_NOT_FOUND;//LC:11439
        }//LC:11440
        if (startIndex < 0) {//LC:11441
            return INDEX_NOT_FOUND;//LC:11442
        } else if (startIndex >= array.length) {//LC:11443
            startIndex = array.length - 1;//LC:11444
        }//LC:11445
        for (int i = startIndex; i >= 0; i--) {//LC:11446
            if (valueToFind == array[i]) {//LC:11447
                return i;//LC:11448
            }//LC:11449
        }//LC:11450
        return INDEX_NOT_FOUND;//LC:11451
    }//LC:11452
//LC:11453
    /**//LC:11454
     * <p>Checks if the value is in the given array.</p>//LC:11455
     *//LC:11456
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:11457
     *//LC:11458
     * @param array  the array to search through//LC:11459
     * @param valueToFind  the value to find//LC:11460
     * @return {@code true} if the array contains the object//LC:11461
     *///LC:11462
    public static boolean contains(final float[] array, final float valueToFind) {//LC:11463
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:11464
    }//LC:11465
//LC:11466
    // boolean IndexOf//LC:11467
    //-----------------------------------------------------------------------//LC:11468
    /**//LC:11469
     * <p>Finds the index of the given value in the array.</p>//LC:11470
     *//LC:11471
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11472
     *//LC:11473
     * @param array  the array to search through for the object, may be {@code null}//LC:11474
     * @param valueToFind  the value to find//LC:11475
     * @return the index of the value within the array,//LC:11476
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11477
     *///LC:11478
    public static int indexOf(final boolean[] array, final boolean valueToFind) {//LC:11479
        return indexOf(array, valueToFind, 0);//LC:11480
    }//LC:11481
//LC:11482
    /**//LC:11483
     * <p>Finds the index of the given value in the array starting at the given index.</p>//LC:11484
     *//LC:11485
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11486
     *//LC:11487
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array//LC:11488
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).</p>//LC:11489
     *//LC:11490
     * @param array  the array to search through for the object, may be {@code null}//LC:11491
     * @param valueToFind  the value to find//LC:11492
     * @param startIndex  the index to start searching at//LC:11493
     * @return the index of the value within the array,//LC:11494
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null}//LC:11495
     *  array input//LC:11496
     *///LC:11497
    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {//LC:11498
        if (ArrayUtils.isEmpty(array)) {//LC:11499
            return INDEX_NOT_FOUND;//LC:11500
        }//LC:11501
        if (startIndex < 0) {//LC:11502
            startIndex = 0;//LC:11503
        }//LC:11504
        for (int i = startIndex; i < array.length; i++) {//LC:11505
            if (valueToFind == array[i]) {//LC:11506
                return i;//LC:11507
            }//LC:11508
        }//LC:11509
        return INDEX_NOT_FOUND;//LC:11510
    }//LC:11511
//LC:11512
    /**//LC:11513
     * <p>Finds the last index of the given value within the array.</p>//LC:11514
     *//LC:11515
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) if//LC:11516
     * {@code null} array input.</p>//LC:11517
     *//LC:11518
     * @param array  the array to travers backwords looking for the object, may be {@code null}//LC:11519
     * @param valueToFind  the object to find//LC:11520
     * @return the last index of the value within the array,//LC:11521
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11522
     *///LC:11523
    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {//LC:11524
        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);//LC:11525
    }//LC:11526
//LC:11527
    /**//LC:11528
     * <p>Finds the last index of the given value in the array starting at the given index.</p>//LC:11529
     *//LC:11530
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.</p>//LC:11531
     *//LC:11532
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than//LC:11533
     * the array length will search from the end of the array.</p>//LC:11534
     *//LC:11535
     * @param array  the array to traverse for looking for the object, may be {@code null}//LC:11536
     * @param valueToFind  the value to find//LC:11537
     * @param startIndex  the start index to travers backwards from//LC:11538
     * @return the last index of the value within the array,//LC:11539
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input//LC:11540
     *///LC:11541
    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {//LC:11542
        if (ArrayUtils.isEmpty(array)) {//LC:11543
            return INDEX_NOT_FOUND;//LC:11544
        }//LC:11545
        if (startIndex < 0) {//LC:11546
            return INDEX_NOT_FOUND;//LC:11547
        } else if (startIndex >= array.length) {//LC:11548
            startIndex = array.length - 1;//LC:11549
        }//LC:11550
        for (int i = startIndex; i >= 0; i--) {//LC:11551
            if (valueToFind == array[i]) {//LC:11552
                return i;//LC:11553
            }//LC:11554
        }//LC:11555
        return INDEX_NOT_FOUND;//LC:11556
    }//LC:11557
//LC:11558
    /**//LC:11559
     * <p>Checks if the value is in the given array.</p>//LC:11560
     *//LC:11561
     * <p>The method returns {@code false} if a {@code null} array is passed in.</p>//LC:11562
     *//LC:11563
     * @param array  the array to search through//LC:11564
     * @param valueToFind  the value to find//LC:11565
     * @return {@code true} if the array contains the object//LC:11566
     *///LC:11567
    public static boolean contains(final boolean[] array, final boolean valueToFind) {//LC:11568
        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;//LC:11569
    }//LC:11570
//LC:11571
    // Primitive/Object array converters//LC:11572
    // ----------------------------------------------------------------------//LC:11573
//LC:11574
    // Character array converters//LC:11575
    // ----------------------------------------------------------------------//LC:11576
    /**//LC:11577
     * <p>Converts an array of object Characters to primitives.</p>//LC:11578
     *//LC:11579
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11580
     *//LC:11581
     * @param array  a {@code Character} array, may be {@code null}//LC:11582
     * @return a {@code char} array, {@code null} if null array input//LC:11583
     * @throws NullPointerException if array content is {@code null}//LC:11584
     *///LC:11585
    public static char[] toPrimitive(final Character[] array) {//LC:11586
        if (array == null) {//LC:11587
            return null;//LC:11588
        } else if (array.length == 0) {//LC:11589
            return EMPTY_CHAR_ARRAY;//LC:11590
        }//LC:11591
        final char[] result = new char[array.length];//LC:11592
        for (int i = 0; i < array.length; i++) {//LC:11593
            result[i] = array[i].charValue();//LC:11594
        }//LC:11595
        return result;//LC:11596
    }//LC:11597
//LC:11598
    /**//LC:11599
     * <p>Converts an array of object Character to primitives handling {@code null}.</p>//LC:11600
     *//LC:11601
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11602
     *//LC:11603
     * @param array  a {@code Character} array, may be {@code null}//LC:11604
     * @param valueForNull  the value to insert if {@code null} found//LC:11605
     * @return a {@code char} array, {@code null} if null array input//LC:11606
     *///LC:11607
    public static char[] toPrimitive(final Character[] array, final char valueForNull) {//LC:11608
        if (array == null) {//LC:11609
            return null;//LC:11610
        } else if (array.length == 0) {//LC:11611
            return EMPTY_CHAR_ARRAY;//LC:11612
        }//LC:11613
        final char[] result = new char[array.length];//LC:11614
        for (int i = 0; i < array.length; i++) {//LC:11615
            final Character b = array[i];//LC:11616
            result[i] = (b == null ? valueForNull : b.charValue());//LC:11617
        }//LC:11618
        return result;//LC:11619
    }//LC:11620
//LC:11621
    /**//LC:11622
     * <p>Converts an array of primitive chars to objects.</p>//LC:11623
     *//LC:11624
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11625
     *//LC:11626
     * @param array a {@code char} array//LC:11627
     * @return a {@code Character} array, {@code null} if null array input//LC:11628
     *///LC:11629
    public static Character[] toObject(final char[] array) {//LC:11630
        if (array == null) {//LC:11631
            return null;//LC:11632
        } else if (array.length == 0) {//LC:11633
            return EMPTY_CHARACTER_OBJECT_ARRAY;//LC:11634
        }//LC:11635
        final Character[] result = new Character[array.length];//LC:11636
        for (int i = 0; i < array.length; i++) {//LC:11637
            result[i] = Character.valueOf(array[i]);//LC:11638
        }//LC:11639
        return result;//LC:11640
    }//LC:11641
//LC:11642
    // Long array converters//LC:11643
    // ----------------------------------------------------------------------//LC:11644
    /**//LC:11645
     * <p>Converts an array of object Longs to primitives.</p>//LC:11646
     *//LC:11647
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11648
     *//LC:11649
     * @param array  a {@code Long} array, may be {@code null}//LC:11650
     * @return a {@code long} array, {@code null} if null array input//LC:11651
     * @throws NullPointerException if array content is {@code null}//LC:11652
     *///LC:11653
    public static long[] toPrimitive(final Long[] array) {//LC:11654
        if (array == null) {//LC:11655
            return null;//LC:11656
        } else if (array.length == 0) {//LC:11657
            return EMPTY_LONG_ARRAY;//LC:11658
        }//LC:11659
        final long[] result = new long[array.length];//LC:11660
        for (int i = 0; i < array.length; i++) {//LC:11661
            result[i] = array[i].longValue();//LC:11662
        }//LC:11663
        return result;//LC:11664
    }//LC:11665
//LC:11666
    /**//LC:11667
     * <p>Converts an array of object Long to primitives handling {@code null}.</p>//LC:11668
     *//LC:11669
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11670
     *//LC:11671
     * @param array  a {@code Long} array, may be {@code null}//LC:11672
     * @param valueForNull  the value to insert if {@code null} found//LC:11673
     * @return a {@code long} array, {@code null} if null array input//LC:11674
     *///LC:11675
    public static long[] toPrimitive(final Long[] array, final long valueForNull) {//LC:11676
        if (array == null) {//LC:11677
            return null;//LC:11678
        } else if (array.length == 0) {//LC:11679
            return EMPTY_LONG_ARRAY;//LC:11680
        }//LC:11681
        final long[] result = new long[array.length];//LC:11682
        for (int i = 0; i < array.length; i++) {//LC:11683
            final Long b = array[i];//LC:11684
            result[i] = (b == null ? valueForNull : b.longValue());//LC:11685
        }//LC:11686
        return result;//LC:11687
    }//LC:11688
//LC:11689
    /**//LC:11690
     * <p>Converts an array of primitive longs to objects.</p>//LC:11691
     *//LC:11692
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11693
     *//LC:11694
     * @param array  a {@code long} array//LC:11695
     * @return a {@code Long} array, {@code null} if null array input//LC:11696
     *///LC:11697
    public static Long[] toObject(final long[] array) {//LC:11698
        if (array == null) {//LC:11699
            return null;//LC:11700
        } else if (array.length == 0) {//LC:11701
            return EMPTY_LONG_OBJECT_ARRAY;//LC:11702
        }//LC:11703
        final Long[] result = new Long[array.length];//LC:11704
        for (int i = 0; i < array.length; i++) {//LC:11705
            result[i] = Long.valueOf(array[i]);//LC:11706
        }//LC:11707
        return result;//LC:11708
    }//LC:11709
//LC:11710
    // Int array converters//LC:11711
    // ----------------------------------------------------------------------//LC:11712
    /**//LC:11713
     * <p>Converts an array of object Integers to primitives.</p>//LC:11714
     *//LC:11715
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11716
     *//LC:11717
     * @param array  a {@code Integer} array, may be {@code null}//LC:11718
     * @return an {@code int} array, {@code null} if null array input//LC:11719
     * @throws NullPointerException if array content is {@code null}//LC:11720
     *///LC:11721
    public static int[] toPrimitive(final Integer[] array) {//LC:11722
        if (array == null) {//LC:11723
            return null;//LC:11724
        } else if (array.length == 0) {//LC:11725
            return EMPTY_INT_ARRAY;//LC:11726
        }//LC:11727
        final int[] result = new int[array.length];//LC:11728
        for (int i = 0; i < array.length; i++) {//LC:11729
            result[i] = array[i].intValue();//LC:11730
        }//LC:11731
        return result;//LC:11732
    }//LC:11733
//LC:11734
    /**//LC:11735
     * <p>Converts an array of object Integer to primitives handling {@code null}.</p>//LC:11736
     *//LC:11737
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11738
     *//LC:11739
     * @param array  a {@code Integer} array, may be {@code null}//LC:11740
     * @param valueForNull  the value to insert if {@code null} found//LC:11741
     * @return an {@code int} array, {@code null} if null array input//LC:11742
     *///LC:11743
    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {//LC:11744
        if (array == null) {//LC:11745
            return null;//LC:11746
        } else if (array.length == 0) {//LC:11747
            return EMPTY_INT_ARRAY;//LC:11748
        }//LC:11749
        final int[] result = new int[array.length];//LC:11750
        for (int i = 0; i < array.length; i++) {//LC:11751
            final Integer b = array[i];//LC:11752
            result[i] = (b == null ? valueForNull : b.intValue());//LC:11753
        }//LC:11754
        return result;//LC:11755
    }//LC:11756
//LC:11757
    /**//LC:11758
     * <p>Converts an array of primitive ints to objects.</p>//LC:11759
     *//LC:11760
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11761
     *//LC:11762
     * @param array  an {@code int} array//LC:11763
     * @return an {@code Integer} array, {@code null} if null array input//LC:11764
     *///LC:11765
    public static Integer[] toObject(final int[] array) {//LC:11766
        if (array == null) {//LC:11767
            return null;//LC:11768
        } else if (array.length == 0) {//LC:11769
            return EMPTY_INTEGER_OBJECT_ARRAY;//LC:11770
        }//LC:11771
        final Integer[] result = new Integer[array.length];//LC:11772
        for (int i = 0; i < array.length; i++) {//LC:11773
            result[i] = Integer.valueOf(array[i]);//LC:11774
        }//LC:11775
        return result;//LC:11776
    }//LC:11777
//LC:11778
    // Short array converters//LC:11779
    // ----------------------------------------------------------------------//LC:11780
    /**//LC:11781
     * <p>Converts an array of object Shorts to primitives.</p>//LC:11782
     *//LC:11783
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11784
     *//LC:11785
     * @param array  a {@code Short} array, may be {@code null}//LC:11786
     * @return a {@code byte} array, {@code null} if null array input//LC:11787
     * @throws NullPointerException if array content is {@code null}//LC:11788
     *///LC:11789
    public static short[] toPrimitive(final Short[] array) {//LC:11790
        if (array == null) {//LC:11791
            return null;//LC:11792
        } else if (array.length == 0) {//LC:11793
            return EMPTY_SHORT_ARRAY;//LC:11794
        }//LC:11795
        final short[] result = new short[array.length];//LC:11796
        for (int i = 0; i < array.length; i++) {//LC:11797
            result[i] = array[i].shortValue();//LC:11798
        }//LC:11799
        return result;//LC:11800
    }//LC:11801
//LC:11802
    /**//LC:11803
     * <p>Converts an array of object Short to primitives handling {@code null}.</p>//LC:11804
     *//LC:11805
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11806
     *//LC:11807
     * @param array  a {@code Short} array, may be {@code null}//LC:11808
     * @param valueForNull  the value to insert if {@code null} found//LC:11809
     * @return a {@code byte} array, {@code null} if null array input//LC:11810
     *///LC:11811
    public static short[] toPrimitive(final Short[] array, final short valueForNull) {//LC:11812
        if (array == null) {//LC:11813
            return null;//LC:11814
        } else if (array.length == 0) {//LC:11815
            return EMPTY_SHORT_ARRAY;//LC:11816
        }//LC:11817
        final short[] result = new short[array.length];//LC:11818
        for (int i = 0; i < array.length; i++) {//LC:11819
            final Short b = array[i];//LC:11820
            result[i] = (b == null ? valueForNull : b.shortValue());//LC:11821
        }//LC:11822
        return result;//LC:11823
    }//LC:11824
//LC:11825
    /**//LC:11826
     * <p>Converts an array of primitive shorts to objects.</p>//LC:11827
     *//LC:11828
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11829
     *//LC:11830
     * @param array  a {@code short} array//LC:11831
     * @return a {@code Short} array, {@code null} if null array input//LC:11832
     *///LC:11833
    public static Short[] toObject(final short[] array) {//LC:11834
        if (array == null) {//LC:11835
            return null;//LC:11836
        } else if (array.length == 0) {//LC:11837
            return EMPTY_SHORT_OBJECT_ARRAY;//LC:11838
        }//LC:11839
        final Short[] result = new Short[array.length];//LC:11840
        for (int i = 0; i < array.length; i++) {//LC:11841
            result[i] = Short.valueOf(array[i]);//LC:11842
        }//LC:11843
        return result;//LC:11844
    }//LC:11845
//LC:11846
    // Byte array converters//LC:11847
    // ----------------------------------------------------------------------//LC:11848
    /**//LC:11849
     * <p>Converts an array of object Bytes to primitives.</p>//LC:11850
     *//LC:11851
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11852
     *//LC:11853
     * @param array  a {@code Byte} array, may be {@code null}//LC:11854
     * @return a {@code byte} array, {@code null} if null array input//LC:11855
     * @throws NullPointerException if array content is {@code null}//LC:11856
     *///LC:11857
    public static byte[] toPrimitive(final Byte[] array) {//LC:11858
        if (array == null) {//LC:11859
            return null;//LC:11860
        } else if (array.length == 0) {//LC:11861
            return EMPTY_BYTE_ARRAY;//LC:11862
        }//LC:11863
        final byte[] result = new byte[array.length];//LC:11864
        for (int i = 0; i < array.length; i++) {//LC:11865
            result[i] = array[i].byteValue();//LC:11866
        }//LC:11867
        return result;//LC:11868
    }//LC:11869
//LC:11870
    /**//LC:11871
     * <p>Converts an array of object Bytes to primitives handling {@code null}.</p>//LC:11872
     *//LC:11873
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11874
     *//LC:11875
     * @param array  a {@code Byte} array, may be {@code null}//LC:11876
     * @param valueForNull  the value to insert if {@code null} found//LC:11877
     * @return a {@code byte} array, {@code null} if null array input//LC:11878
     *///LC:11879
    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {//LC:11880
        if (array == null) {//LC:11881
            return null;//LC:11882
        } else if (array.length == 0) {//LC:11883
            return EMPTY_BYTE_ARRAY;//LC:11884
        }//LC:11885
        final byte[] result = new byte[array.length];//LC:11886
        for (int i = 0; i < array.length; i++) {//LC:11887
            final Byte b = array[i];//LC:11888
            result[i] = (b == null ? valueForNull : b.byteValue());//LC:11889
        }//LC:11890
        return result;//LC:11891
    }//LC:11892
//LC:11893
    /**//LC:11894
     * <p>Converts an array of primitive bytes to objects.</p>//LC:11895
     *//LC:11896
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11897
     *//LC:11898
     * @param array  a {@code byte} array//LC:11899
     * @return a {@code Byte} array, {@code null} if null array input//LC:11900
     *///LC:11901
    public static Byte[] toObject(final byte[] array) {//LC:11902
        if (array == null) {//LC:11903
            return null;//LC:11904
        } else if (array.length == 0) {//LC:11905
            return EMPTY_BYTE_OBJECT_ARRAY;//LC:11906
        }//LC:11907
        final Byte[] result = new Byte[array.length];//LC:11908
        for (int i = 0; i < array.length; i++) {//LC:11909
            result[i] = Byte.valueOf(array[i]);//LC:11910
        }//LC:11911
        return result;//LC:11912
    }//LC:11913
//LC:11914
    // Double array converters//LC:11915
    // ----------------------------------------------------------------------//LC:11916
    /**//LC:11917
     * <p>Converts an array of object Doubles to primitives.</p>//LC:11918
     *//LC:11919
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11920
     *//LC:11921
     * @param array  a {@code Double} array, may be {@code null}//LC:11922
     * @return a {@code double} array, {@code null} if null array input//LC:11923
     * @throws NullPointerException if array content is {@code null}//LC:11924
     *///LC:11925
    public static double[] toPrimitive(final Double[] array) {//LC:11926
        if (array == null) {//LC:11927
            return null;//LC:11928
        } else if (array.length == 0) {//LC:11929
            return EMPTY_DOUBLE_ARRAY;//LC:11930
        }//LC:11931
        final double[] result = new double[array.length];//LC:11932
        for (int i = 0; i < array.length; i++) {//LC:11933
            result[i] = array[i].doubleValue();//LC:11934
        }//LC:11935
        return result;//LC:11936
    }//LC:11937
//LC:11938
    /**//LC:11939
     * <p>Converts an array of object Doubles to primitives handling {@code null}.</p>//LC:11940
     *//LC:11941
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11942
     *//LC:11943
     * @param array  a {@code Double} array, may be {@code null}//LC:11944
     * @param valueForNull  the value to insert if {@code null} found//LC:11945
     * @return a {@code double} array, {@code null} if null array input//LC:11946
     *///LC:11947
    public static double[] toPrimitive(final Double[] array, final double valueForNull) {//LC:11948
        if (array == null) {//LC:11949
            return null;//LC:11950
        } else if (array.length == 0) {//LC:11951
            return EMPTY_DOUBLE_ARRAY;//LC:11952
        }//LC:11953
        final double[] result = new double[array.length];//LC:11954
        for (int i = 0; i < array.length; i++) {//LC:11955
            final Double b = array[i];//LC:11956
            result[i] = (b == null ? valueForNull : b.doubleValue());//LC:11957
        }//LC:11958
        return result;//LC:11959
    }//LC:11960
//LC:11961
    /**//LC:11962
     * <p>Converts an array of primitive doubles to objects.</p>//LC:11963
     *//LC:11964
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11965
     *//LC:11966
     * @param array  a {@code double} array//LC:11967
     * @return a {@code Double} array, {@code null} if null array input//LC:11968
     *///LC:11969
    public static Double[] toObject(final double[] array) {//LC:11970
        if (array == null) {//LC:11971
            return null;//LC:11972
        } else if (array.length == 0) {//LC:11973
            return EMPTY_DOUBLE_OBJECT_ARRAY;//LC:11974
        }//LC:11975
        final Double[] result = new Double[array.length];//LC:11976
        for (int i = 0; i < array.length; i++) {//LC:11977
            result[i] = Double.valueOf(array[i]);//LC:11978
        }//LC:11979
        return result;//LC:11980
    }//LC:11981
//LC:11982
    //   Float array converters//LC:11983
    // ----------------------------------------------------------------------//LC:11984
    /**//LC:11985
     * <p>Converts an array of object Floats to primitives.</p>//LC:11986
     *//LC:11987
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:11988
     *//LC:11989
     * @param array  a {@code Float} array, may be {@code null}//LC:11990
     * @return a {@code float} array, {@code null} if null array input//LC:11991
     * @throws NullPointerException if array content is {@code null}//LC:11992
     *///LC:11993
    public static float[] toPrimitive(final Float[] array) {//LC:11994
        if (array == null) {//LC:11995
            return null;//LC:11996
        } else if (array.length == 0) {//LC:11997
            return EMPTY_FLOAT_ARRAY;//LC:11998
        }//LC:11999
        final float[] result = new float[array.length];//LC:12000
        for (int i = 0; i < array.length; i++) {//LC:12001
            result[i] = array[i].floatValue();//LC:12002
        }//LC:12003
        return result;//LC:12004
    }//LC:12005
//LC:12006
    /**//LC:12007
     * <p>Converts an array of object Floats to primitives handling {@code null}.</p>//LC:12008
     *//LC:12009
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:12010
     *//LC:12011
     * @param array  a {@code Float} array, may be {@code null}//LC:12012
     * @param valueForNull  the value to insert if {@code null} found//LC:12013
     * @return a {@code float} array, {@code null} if null array input//LC:12014
     *///LC:12015
    public static float[] toPrimitive(final Float[] array, final float valueForNull) {//LC:12016
        if (array == null) {//LC:12017
            return null;//LC:12018
        } else if (array.length == 0) {//LC:12019
            return EMPTY_FLOAT_ARRAY;//LC:12020
        }//LC:12021
        final float[] result = new float[array.length];//LC:12022
        for (int i = 0; i < array.length; i++) {//LC:12023
            final Float b = array[i];//LC:12024
            result[i] = (b == null ? valueForNull : b.floatValue());//LC:12025
        }//LC:12026
        return result;//LC:12027
    }//LC:12028
//LC:12029
    /**//LC:12030
     * <p>Converts an array of primitive floats to objects.</p>//LC:12031
     *//LC:12032
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:12033
     *//LC:12034
     * @param array  a {@code float} array//LC:12035
     * @return a {@code Float} array, {@code null} if null array input//LC:12036
     *///LC:12037
    public static Float[] toObject(final float[] array) {//LC:12038
        if (array == null) {//LC:12039
            return null;//LC:12040
        } else if (array.length == 0) {//LC:12041
            return EMPTY_FLOAT_OBJECT_ARRAY;//LC:12042
        }//LC:12043
        final Float[] result = new Float[array.length];//LC:12044
        for (int i = 0; i < array.length; i++) {//LC:12045
            result[i] = Float.valueOf(array[i]);//LC:12046
        }//LC:12047
        return result;//LC:12048
    }//LC:12049
//LC:12050
    // Boolean array converters//LC:12051
    // ----------------------------------------------------------------------//LC:12052
    /**//LC:12053
     * <p>Converts an array of object Booleans to primitives.</p>//LC:12054
     *//LC:12055
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:12056
     *//LC:12057
     * @param array  a {@code Boolean} array, may be {@code null}//LC:12058
     * @return a {@code boolean} array, {@code null} if null array input//LC:12059
     * @throws NullPointerException if array content is {@code null}//LC:12060
     *///LC:12061
    public static boolean[] toPrimitive(final Boolean[] array) {//LC:12062
        if (array == null) {//LC:12063
            return null;//LC:12064
        } else if (array.length == 0) {//LC:12065
            return EMPTY_BOOLEAN_ARRAY;//LC:12066
        }//LC:12067
        final boolean[] result = new boolean[array.length];//LC:12068
        for (int i = 0; i < array.length; i++) {//LC:12069
            result[i] = array[i].booleanValue();//LC:12070
        }//LC:12071
        return result;//LC:12072
    }//LC:12073
//LC:12074
    /**//LC:12075
     * <p>Converts an array of object Booleans to primitives handling {@code null}.</p>//LC:12076
     *//LC:12077
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:12078
     *//LC:12079
     * @param array  a {@code Boolean} array, may be {@code null}//LC:12080
     * @param valueForNull  the value to insert if {@code null} found//LC:12081
     * @return a {@code boolean} array, {@code null} if null array input//LC:12082
     *///LC:12083
    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {//LC:12084
        if (array == null) {//LC:12085
            return null;//LC:12086
        } else if (array.length == 0) {//LC:12087
            return EMPTY_BOOLEAN_ARRAY;//LC:12088
        }//LC:12089
        final boolean[] result = new boolean[array.length];//LC:12090
        for (int i = 0; i < array.length; i++) {//LC:12091
            final Boolean b = array[i];//LC:12092
            result[i] = (b == null ? valueForNull : b.booleanValue());//LC:12093
        }//LC:12094
        return result;//LC:12095
    }//LC:12096
//LC:12097
    /**//LC:12098
     * <p>Converts an array of primitive booleans to objects.</p>//LC:12099
     *//LC:12100
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:12101
     *//LC:12102
     * @param array  a {@code boolean} array//LC:12103
     * @return a {@code Boolean} array, {@code null} if null array input//LC:12104
     *///LC:12105
    public static Boolean[] toObject(final boolean[] array) {//LC:12106
        if (array == null) {//LC:12107
            return null;//LC:12108
        } else if (array.length == 0) {//LC:12109
            return EMPTY_BOOLEAN_OBJECT_ARRAY;//LC:12110
        }//LC:12111
        final Boolean[] result = new Boolean[array.length];//LC:12112
        for (int i = 0; i < array.length; i++) {//LC:12113
            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);//LC:12114
        }//LC:12115
        return result;//LC:12116
    }//LC:12117
//LC:12118
    // ----------------------------------------------------------------------//LC:12119
    /**//LC:12120
     * <p>Checks if an array of Objects is empty or {@code null}.</p>//LC:12121
     *//LC:12122
     * @param array  the array to test//LC:12123
     * @return {@code true} if the array is empty or {@code null}//LC:12124
     * @since 2.1//LC:12125
     *///LC:12126
    public static boolean isEmpty(final Object[] array) {//LC:12127
        return array == null || array.length == 0;//LC:12128
    }//LC:12129
//LC:12130
    /**//LC:12131
     * <p>Checks if an array of primitive longs is empty or {@code null}.</p>//LC:12132
     *//LC:12133
     * @param array  the array to test//LC:12134
     * @return {@code true} if the array is empty or {@code null}//LC:12135
     * @since 2.1//LC:12136
     *///LC:12137
    public static boolean isEmpty(final long[] array) {//LC:12138
        return array == null || array.length == 0;//LC:12139
    }//LC:12140
//LC:12141
    /**//LC:12142
     * <p>Checks if an array of primitive ints is empty or {@code null}.</p>//LC:12143
     *//LC:12144
     * @param array  the array to test//LC:12145
     * @return {@code true} if the array is empty or {@code null}//LC:12146
     * @since 2.1//LC:12147
     *///LC:12148
    public static boolean isEmpty(final int[] array) {//LC:12149
        return array == null || array.length == 0;//LC:12150
    }//LC:12151
//LC:12152
    /**//LC:12153
     * <p>Checks if an array of primitive shorts is empty or {@code null}.</p>//LC:12154
     *//LC:12155
     * @param array  the array to test//LC:12156
     * @return {@code true} if the array is empty or {@code null}//LC:12157
     * @since 2.1//LC:12158
     *///LC:12159
    public static boolean isEmpty(final short[] array) {//LC:12160
        return array == null || array.length == 0;//LC:12161
    }//LC:12162
//LC:12163
    /**//LC:12164
     * <p>Checks if an array of primitive chars is empty or {@code null}.</p>//LC:12165
     *//LC:12166
     * @param array  the array to test//LC:12167
     * @return {@code true} if the array is empty or {@code null}//LC:12168
     * @since 2.1//LC:12169
     *///LC:12170
    public static boolean isEmpty(final char[] array) {//LC:12171
        return array == null || array.length == 0;//LC:12172
    }//LC:12173
//LC:12174
    /**//LC:12175
     * <p>Checks if an array of primitive bytes is empty or {@code null}.</p>//LC:12176
     *//LC:12177
     * @param array  the array to test//LC:12178
     * @return {@code true} if the array is empty or {@code null}//LC:12179
     * @since 2.1//LC:12180
     *///LC:12181
    public static boolean isEmpty(final byte[] array) {//LC:12182
        return array == null || array.length == 0;//LC:12183
    }//LC:12184
//LC:12185
    /**//LC:12186
     * <p>Checks if an array of primitive doubles is empty or {@code null}.</p>//LC:12187
     *//LC:12188
     * @param array  the array to test//LC:12189
     * @return {@code true} if the array is empty or {@code null}//LC:12190
     * @since 2.1//LC:12191
     *///LC:12192
    public static boolean isEmpty(final double[] array) {//LC:12193
        return array == null || array.length == 0;//LC:12194
    }//LC:12195
//LC:12196
    /**//LC:12197
     * <p>Checks if an array of primitive floats is empty or {@code null}.</p>//LC:12198
     *//LC:12199
     * @param array  the array to test//LC:12200
     * @return {@code true} if the array is empty or {@code null}//LC:12201
     * @since 2.1//LC:12202
     *///LC:12203
    public static boolean isEmpty(final float[] array) {//LC:12204
        return array == null || array.length == 0;//LC:12205
    }//LC:12206
//LC:12207
    /**//LC:12208
     * <p>Checks if an array of primitive booleans is empty or {@code null}.</p>//LC:12209
     *//LC:12210
     * @param array  the array to test//LC:12211
     * @return {@code true} if the array is empty or {@code null}//LC:12212
     * @since 2.1//LC:12213
     *///LC:12214
    public static boolean isEmpty(final boolean[] array) {//LC:12215
        return array == null || array.length == 0;//LC:12216
    }//LC:12217
//LC:12218
    // ----------------------------------------------------------------------//LC:12219
    /**//LC:12220
     * <p>Checks if an array of Objects is not empty or not {@code null}.</p>//LC:12221
     *//LC:12222
     * @param <T> the component type of the array//LC:12223
     * @param array  the array to test//LC:12224
     * @return {@code true} if the array is not empty or not {@code null}//LC:12225
     * @since 2.5//LC:12226
     *///LC:12227
    public static <T> boolean isNotEmpty(final T[] array) {//LC:12228
        return (array != null && array.length != 0);//LC:12229
    }//LC:12230
//LC:12231
    /**//LC:12232
     * <p>Checks if an array of primitive longs is not empty or not {@code null}.</p>//LC:12233
     *//LC:12234
     * @param array  the array to test//LC:12235
     * @return {@code true} if the array is not empty or not {@code null}//LC:12236
     * @since 2.5//LC:12237
     *///LC:12238
    public static boolean isNotEmpty(final long[] array) {//LC:12239
        return (array != null && array.length != 0);//LC:12240
    }//LC:12241
//LC:12242
    /**//LC:12243
     * <p>Checks if an array of primitive ints is not empty or not {@code null}.</p>//LC:12244
     *//LC:12245
     * @param array  the array to test//LC:12246
     * @return {@code true} if the array is not empty or not {@code null}//LC:12247
     * @since 2.5//LC:12248
     *///LC:12249
    public static boolean isNotEmpty(final int[] array) {//LC:12250
        return (array != null && array.length != 0);//LC:12251
    }//LC:12252
//LC:12253
    /**//LC:12254
     * <p>Checks if an array of primitive shorts is not empty or not {@code null}.</p>//LC:12255
     *//LC:12256
     * @param array  the array to test//LC:12257
     * @return {@code true} if the array is not empty or not {@code null}//LC:12258
     * @since 2.5//LC:12259
     *///LC:12260
    public static boolean isNotEmpty(final short[] array) {//LC:12261
        return (array != null && array.length != 0);//LC:12262
    }//LC:12263
//LC:12264
    /**//LC:12265
     * <p>Checks if an array of primitive chars is not empty or not {@code null}.</p>//LC:12266
     *//LC:12267
     * @param array  the array to test//LC:12268
     * @return {@code true} if the array is not empty or not {@code null}//LC:12269
     * @since 2.5//LC:12270
     *///LC:12271
    public static boolean isNotEmpty(final char[] array) {//LC:12272
        return (array != null && array.length != 0);//LC:12273
    }//LC:12274
//LC:12275
    /**//LC:12276
     * <p>Checks if an array of primitive bytes is not empty or not {@code null}.</p>//LC:12277
     *//LC:12278
     * @param array  the array to test//LC:12279
     * @return {@code true} if the array is not empty or not {@code null}//LC:12280
     * @since 2.5//LC:12281
     *///LC:12282
    public static boolean isNotEmpty(final byte[] array) {//LC:12283
        return (array != null && array.length != 0);//LC:12284
    }//LC:12285
//LC:12286
    /**//LC:12287
     * <p>Checks if an array of primitive doubles is not empty or not {@code null}.</p>//LC:12288
     *//LC:12289
     * @param array  the array to test//LC:12290
     * @return {@code true} if the array is not empty or not {@code null}//LC:12291
     * @since 2.5//LC:12292
     *///LC:12293
    public static boolean isNotEmpty(final double[] array) {//LC:12294
        return (array != null && array.length != 0);//LC:12295
    }//LC:12296
//LC:12297
    /**//LC:12298
     * <p>Checks if an array of primitive floats is not empty or not {@code null}.</p>//LC:12299
     *//LC:12300
     * @param array  the array to test//LC:12301
     * @return {@code true} if the array is not empty or not {@code null}//LC:12302
     * @since 2.5//LC:12303
     *///LC:12304
    public static boolean isNotEmpty(final float[] array) {//LC:12305
        return (array != null && array.length != 0);//LC:12306
    }//LC:12307
//LC:12308
    /**//LC:12309
     * <p>Checks if an array of primitive booleans is not empty or not {@code null}.</p>//LC:12310
     *//LC:12311
     * @param array  the array to test//LC:12312
     * @return {@code true} if the array is not empty or not {@code null}//LC:12313
     * @since 2.5//LC:12314
     *///LC:12315
    public static boolean isNotEmpty(final boolean[] array) {//LC:12316
        return (array != null && array.length != 0);//LC:12317
    }//LC:12318
//LC:12319
    /**//LC:12320
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12321
     * <p>The new array contains all of the element of {@code array1} followed//LC:12322
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12323
     * a new array.</p>//LC:12324
     *//LC:12325
     * <pre>//LC:12326
     * ArrayUtils.addAll(null, null)     = null//LC:12327
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12328
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12329
     * ArrayUtils.addAll([], [])         = []//LC:12330
     * ArrayUtils.addAll([null], [null]) = [null, null]//LC:12331
     * ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"]//LC:12332
     * </pre>//LC:12333
     *//LC:12334
     * @param <T> the component type of the array//LC:12335
     * @param array1  the first array whose elements are added to the new array, may be {@code null}//LC:12336
     * @param array2  the second array whose elements are added to the new array, may be {@code null}//LC:12337
     * @return The new array, {@code null} if both arrays are {@code null}.//LC:12338
     *      The type of the new array is the type of the first array,//LC:12339
     *      unless the first array is null, in which case the type is the same as the second array.//LC:12340
     * @since 2.1//LC:12341
     * @throws IllegalArgumentException if the array types are incompatible//LC:12342
     *///LC:12343
    public static <T> T[] addAll(final T[] array1, final T... array2) {//LC:12344
        if (array1 == null) {//LC:12345
            return clone(array2);//LC:12346
        } else if (array2 == null) {//LC:12347
            return clone(array1);//LC:12348
        }//LC:12349
        final Class<?> type1 = array1.getClass().getComponentType();//LC:12350
        @SuppressWarnings("unchecked") // OK, because array is of type T//LC:12351
        final//LC:12352
        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);//LC:12353
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12354
        try {//LC:12355
            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12356
        } catch (final ArrayStoreException ase) {//LC:12357
            // Check if problem was due to incompatible types//LC:12358
            /*//LC:12359
             * We do this here, rather than before the copy because://LC:12360
             * - it would be a wasted check most of the time//LC:12361
             * - safer, in case check turns out to be too strict//LC:12362
             *///LC:12363
            final Class<?> type2 = array2.getClass().getComponentType();//LC:12364
            if (!type1.isAssignableFrom(type2)){//LC:12365
                throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "//LC:12366
                        +type1.getName(), ase);//LC:12367
            }//LC:12368
            throw ase; // No, so rethrow original//LC:12369
        }//LC:12370
        return joinedArray;//LC:12371
    }//LC:12372
//LC:12373
    /**//LC:12374
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12375
     * <p>The new array contains all of the element of {@code array1} followed//LC:12376
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12377
     * a new array.</p>//LC:12378
     *//LC:12379
     * <pre>//LC:12380
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12381
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12382
     * ArrayUtils.addAll([], [])         = []//LC:12383
     * </pre>//LC:12384
     *//LC:12385
     * @param array1  the first array whose elements are added to the new array.//LC:12386
     * @param array2  the second array whose elements are added to the new array.//LC:12387
     * @return The new boolean[] array.//LC:12388
     * @since 2.1//LC:12389
     *///LC:12390
    public static boolean[] addAll(final boolean[] array1, final boolean... array2) {//LC:12391
        if (array1 == null) {//LC:12392
            return clone(array2);//LC:12393
        } else if (array2 == null) {//LC:12394
            return clone(array1);//LC:12395
        }//LC:12396
        final boolean[] joinedArray = new boolean[array1.length + array2.length];//LC:12397
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12398
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12399
        return joinedArray;//LC:12400
    }//LC:12401
//LC:12402
    /**//LC:12403
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12404
     * <p>The new array contains all of the element of {@code array1} followed//LC:12405
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12406
     * a new array.</p>//LC:12407
     *//LC:12408
     * <pre>//LC:12409
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12410
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12411
     * ArrayUtils.addAll([], [])         = []//LC:12412
     * </pre>//LC:12413
     *//LC:12414
     * @param array1  the first array whose elements are added to the new array.//LC:12415
     * @param array2  the second array whose elements are added to the new array.//LC:12416
     * @return The new char[] array.//LC:12417
     * @since 2.1//LC:12418
     *///LC:12419
    public static char[] addAll(final char[] array1, final char... array2) {//LC:12420
        if (array1 == null) {//LC:12421
            return clone(array2);//LC:12422
        } else if (array2 == null) {//LC:12423
            return clone(array1);//LC:12424
        }//LC:12425
        final char[] joinedArray = new char[array1.length + array2.length];//LC:12426
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12427
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12428
        return joinedArray;//LC:12429
    }//LC:12430
//LC:12431
    /**//LC:12432
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12433
     * <p>The new array contains all of the element of {@code array1} followed//LC:12434
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12435
     * a new array.</p>//LC:12436
     *//LC:12437
     * <pre>//LC:12438
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12439
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12440
     * ArrayUtils.addAll([], [])         = []//LC:12441
     * </pre>//LC:12442
     *//LC:12443
     * @param array1  the first array whose elements are added to the new array.//LC:12444
     * @param array2  the second array whose elements are added to the new array.//LC:12445
     * @return The new byte[] array.//LC:12446
     * @since 2.1//LC:12447
     *///LC:12448
    public static byte[] addAll(final byte[] array1, final byte... array2) {//LC:12449
        if (array1 == null) {//LC:12450
            return clone(array2);//LC:12451
        } else if (array2 == null) {//LC:12452
            return clone(array1);//LC:12453
        }//LC:12454
        final byte[] joinedArray = new byte[array1.length + array2.length];//LC:12455
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12456
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12457
        return joinedArray;//LC:12458
    }//LC:12459
//LC:12460
    /**//LC:12461
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12462
     * <p>The new array contains all of the element of {@code array1} followed//LC:12463
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12464
     * a new array.</p>//LC:12465
     *//LC:12466
     * <pre>//LC:12467
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12468
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12469
     * ArrayUtils.addAll([], [])         = []//LC:12470
     * </pre>//LC:12471
     *//LC:12472
     * @param array1  the first array whose elements are added to the new array.//LC:12473
     * @param array2  the second array whose elements are added to the new array.//LC:12474
     * @return The new short[] array.//LC:12475
     * @since 2.1//LC:12476
     *///LC:12477
    public static short[] addAll(final short[] array1, final short... array2) {//LC:12478
        if (array1 == null) {//LC:12479
            return clone(array2);//LC:12480
        } else if (array2 == null) {//LC:12481
            return clone(array1);//LC:12482
        }//LC:12483
        final short[] joinedArray = new short[array1.length + array2.length];//LC:12484
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12485
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12486
        return joinedArray;//LC:12487
    }//LC:12488
//LC:12489
    /**//LC:12490
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12491
     * <p>The new array contains all of the element of {@code array1} followed//LC:12492
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12493
     * a new array.</p>//LC:12494
     *//LC:12495
     * <pre>//LC:12496
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12497
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12498
     * ArrayUtils.addAll([], [])         = []//LC:12499
     * </pre>//LC:12500
     *//LC:12501
     * @param array1  the first array whose elements are added to the new array.//LC:12502
     * @param array2  the second array whose elements are added to the new array.//LC:12503
     * @return The new int[] array.//LC:12504
     * @since 2.1//LC:12505
     *///LC:12506
    public static int[] addAll(final int[] array1, final int... array2) {//LC:12507
        if (array1 == null) {//LC:12508
            return clone(array2);//LC:12509
        } else if (array2 == null) {//LC:12510
            return clone(array1);//LC:12511
        }//LC:12512
        final int[] joinedArray = new int[array1.length + array2.length];//LC:12513
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12514
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12515
        return joinedArray;//LC:12516
    }//LC:12517
//LC:12518
    /**//LC:12519
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12520
     * <p>The new array contains all of the element of {@code array1} followed//LC:12521
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12522
     * a new array.</p>//LC:12523
     *//LC:12524
     * <pre>//LC:12525
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12526
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12527
     * ArrayUtils.addAll([], [])         = []//LC:12528
     * </pre>//LC:12529
     *//LC:12530
     * @param array1  the first array whose elements are added to the new array.//LC:12531
     * @param array2  the second array whose elements are added to the new array.//LC:12532
     * @return The new long[] array.//LC:12533
     * @since 2.1//LC:12534
     *///LC:12535
    public static long[] addAll(final long[] array1, final long... array2) {//LC:12536
        if (array1 == null) {//LC:12537
            return clone(array2);//LC:12538
        } else if (array2 == null) {//LC:12539
            return clone(array1);//LC:12540
        }//LC:12541
        final long[] joinedArray = new long[array1.length + array2.length];//LC:12542
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12543
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12544
        return joinedArray;//LC:12545
    }//LC:12546
//LC:12547
    /**//LC:12548
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12549
     * <p>The new array contains all of the element of {@code array1} followed//LC:12550
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12551
     * a new array.</p>//LC:12552
     *//LC:12553
     * <pre>//LC:12554
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12555
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12556
     * ArrayUtils.addAll([], [])         = []//LC:12557
     * </pre>//LC:12558
     *//LC:12559
     * @param array1  the first array whose elements are added to the new array.//LC:12560
     * @param array2  the second array whose elements are added to the new array.//LC:12561
     * @return The new float[] array.//LC:12562
     * @since 2.1//LC:12563
     *///LC:12564
    public static float[] addAll(final float[] array1, final float... array2) {//LC:12565
        if (array1 == null) {//LC:12566
            return clone(array2);//LC:12567
        } else if (array2 == null) {//LC:12568
            return clone(array1);//LC:12569
        }//LC:12570
        final float[] joinedArray = new float[array1.length + array2.length];//LC:12571
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12572
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12573
        return joinedArray;//LC:12574
    }//LC:12575
//LC:12576
    /**//LC:12577
     * <p>Adds all the elements of the given arrays into a new array.</p>//LC:12578
     * <p>The new array contains all of the element of {@code array1} followed//LC:12579
     * by all of the elements {@code array2}. When an array is returned, it is always//LC:12580
     * a new array.</p>//LC:12581
     *//LC:12582
     * <pre>//LC:12583
     * ArrayUtils.addAll(array1, null)   = cloned copy of array1//LC:12584
     * ArrayUtils.addAll(null, array2)   = cloned copy of array2//LC:12585
     * ArrayUtils.addAll([], [])         = []//LC:12586
     * </pre>//LC:12587
     *//LC:12588
     * @param array1  the first array whose elements are added to the new array.//LC:12589
     * @param array2  the second array whose elements are added to the new array.//LC:12590
     * @return The new double[] array.//LC:12591
     * @since 2.1//LC:12592
     *///LC:12593
    public static double[] addAll(final double[] array1, final double... array2) {//LC:12594
        if (array1 == null) {//LC:12595
            return clone(array2);//LC:12596
        } else if (array2 == null) {//LC:12597
            return clone(array1);//LC:12598
        }//LC:12599
        final double[] joinedArray = new double[array1.length + array2.length];//LC:12600
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);//LC:12601
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);//LC:12602
        return joinedArray;//LC:12603
    }//LC:12604
//LC:12605
    /**//LC:12606
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12607
     *//LC:12608
     * <p>The new array contains the same elements of the input//LC:12609
     * array plus the given element in the last position. The component type of//LC:12610
     * the new array is the same as that of the input array.</p>//LC:12611
     *//LC:12612
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12613
     *  whose component type is the same as the element, unless the element itself is null,//LC:12614
     *  in which case the return type is Object[]</p>//LC:12615
     *//LC:12616
     * <pre>//LC:12617
     * ArrayUtils.add(null, null)      = [null]//LC:12618
     * ArrayUtils.add(null, "a")       = ["a"]//LC:12619
     * ArrayUtils.add(["a"], null)     = ["a", null]//LC:12620
     * ArrayUtils.add(["a"], "b")      = ["a", "b"]//LC:12621
     * ArrayUtils.add(["a", "b"], "c") = ["a", "b", "c"]//LC:12622
     * </pre>//LC:12623
     *//LC:12624
     * @param <T> the component type of the array//LC:12625
     * @param array  the array to "add" the element to, may be {@code null}//LC:12626
     * @param element  the object to add, may be {@code null}//LC:12627
     * @return A new array containing the existing elements plus the new element//LC:12628
     * The returned array type will be that of the input array (unless null),//LC:12629
     * in which case it will have the same type as the element.//LC:12630
     * If both are null, an IllegalArgumentException is thrown//LC:12631
     * @since 2.1//LC:12632
     * @throws IllegalArgumentException if both arguments are null//LC:12633
     *///LC:12634
    public static <T> T[] add(final T[] array, final T element) {//LC:12635
        Class<?> type;//LC:12636
        if (array != null){//LC:12637
            type = array.getClass();//LC:12638
        } else if (element != null) {//LC:12639
            type = element.getClass();//LC:12640
        } else {//LC:12641
            throw new IllegalArgumentException("Arguments cannot both be null");//LC:12642
        }//LC:12643
        @SuppressWarnings("unchecked") // type must be T//LC:12644
        final//LC:12645
        T[] newArray = (T[]) copyArrayGrow1(array, type);//LC:12646
        newArray[newArray.length - 1] = element;//LC:12647
        return newArray;//LC:12648
    }//LC:12649
//LC:12650
    /**//LC:12651
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12652
     *//LC:12653
     * <p>The new array contains the same elements of the input//LC:12654
     * array plus the given element in the last position. The component type of//LC:12655
     * the new array is the same as that of the input array.</p>//LC:12656
     *//LC:12657
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12658
     *  whose component type is the same as the element.</p>//LC:12659
     *//LC:12660
     * <pre>//LC:12661
     * ArrayUtils.add(null, true)          = [true]//LC:12662
     * ArrayUtils.add([true], false)       = [true, false]//LC:12663
     * ArrayUtils.add([true, false], true) = [true, false, true]//LC:12664
     * </pre>//LC:12665
     *//LC:12666
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12667
     * @param element  the object to add at the last index of the new array//LC:12668
     * @return A new array containing the existing elements plus the new element//LC:12669
     * @since 2.1//LC:12670
     *///LC:12671
    public static boolean[] add(final boolean[] array, final boolean element) {//LC:12672
        final boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);//LC:12673
        newArray[newArray.length - 1] = element;//LC:12674
        return newArray;//LC:12675
    }//LC:12676
//LC:12677
    /**//LC:12678
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12679
     *//LC:12680
     * <p>The new array contains the same elements of the input//LC:12681
     * array plus the given element in the last position. The component type of//LC:12682
     * the new array is the same as that of the input array.</p>//LC:12683
     *//LC:12684
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12685
     *  whose component type is the same as the element.</p>//LC:12686
     *//LC:12687
     * <pre>//LC:12688
     * ArrayUtils.add(null, 0)   = [0]//LC:12689
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12690
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12691
     * </pre>//LC:12692
     *//LC:12693
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12694
     * @param element  the object to add at the last index of the new array//LC:12695
     * @return A new array containing the existing elements plus the new element//LC:12696
     * @since 2.1//LC:12697
     *///LC:12698
    public static byte[] add(final byte[] array, final byte element) {//LC:12699
        final byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);//LC:12700
        newArray[newArray.length - 1] = element;//LC:12701
        return newArray;//LC:12702
    }//LC:12703
//LC:12704
    /**//LC:12705
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12706
     *//LC:12707
     * <p>The new array contains the same elements of the input//LC:12708
     * array plus the given element in the last position. The component type of//LC:12709
     * the new array is the same as that of the input array.</p>//LC:12710
     *//LC:12711
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12712
     *  whose component type is the same as the element.</p>//LC:12713
     *//LC:12714
     * <pre>//LC:12715
     * ArrayUtils.add(null, '0')       = ['0']//LC:12716
     * ArrayUtils.add(['1'], '0')      = ['1', '0']//LC:12717
     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']//LC:12718
     * </pre>//LC:12719
     *//LC:12720
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12721
     * @param element  the object to add at the last index of the new array//LC:12722
     * @return A new array containing the existing elements plus the new element//LC:12723
     * @since 2.1//LC:12724
     *///LC:12725
    public static char[] add(final char[] array, final char element) {//LC:12726
        final char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);//LC:12727
        newArray[newArray.length - 1] = element;//LC:12728
        return newArray;//LC:12729
    }//LC:12730
//LC:12731
    /**//LC:12732
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12733
     *//LC:12734
     * <p>The new array contains the same elements of the input//LC:12735
     * array plus the given element in the last position. The component type of//LC:12736
     * the new array is the same as that of the input array.</p>//LC:12737
     *//LC:12738
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12739
     *  whose component type is the same as the element.</p>//LC:12740
     *//LC:12741
     * <pre>//LC:12742
     * ArrayUtils.add(null, 0)   = [0]//LC:12743
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12744
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12745
     * </pre>//LC:12746
     *//LC:12747
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12748
     * @param element  the object to add at the last index of the new array//LC:12749
     * @return A new array containing the existing elements plus the new element//LC:12750
     * @since 2.1//LC:12751
     *///LC:12752
    public static double[] add(final double[] array, final double element) {//LC:12753
        final double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);//LC:12754
        newArray[newArray.length - 1] = element;//LC:12755
        return newArray;//LC:12756
    }//LC:12757
//LC:12758
    /**//LC:12759
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12760
     *//LC:12761
     * <p>The new array contains the same elements of the input//LC:12762
     * array plus the given element in the last position. The component type of//LC:12763
     * the new array is the same as that of the input array.</p>//LC:12764
     *//LC:12765
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12766
     *  whose component type is the same as the element.</p>//LC:12767
     *//LC:12768
     * <pre>//LC:12769
     * ArrayUtils.add(null, 0)   = [0]//LC:12770
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12771
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12772
     * </pre>//LC:12773
     *//LC:12774
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12775
     * @param element  the object to add at the last index of the new array//LC:12776
     * @return A new array containing the existing elements plus the new element//LC:12777
     * @since 2.1//LC:12778
     *///LC:12779
    public static float[] add(final float[] array, final float element) {//LC:12780
        final float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);//LC:12781
        newArray[newArray.length - 1] = element;//LC:12782
        return newArray;//LC:12783
    }//LC:12784
//LC:12785
    /**//LC:12786
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12787
     *//LC:12788
     * <p>The new array contains the same elements of the input//LC:12789
     * array plus the given element in the last position. The component type of//LC:12790
     * the new array is the same as that of the input array.</p>//LC:12791
     *//LC:12792
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12793
     *  whose component type is the same as the element.</p>//LC:12794
     *//LC:12795
     * <pre>//LC:12796
     * ArrayUtils.add(null, 0)   = [0]//LC:12797
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12798
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12799
     * </pre>//LC:12800
     *//LC:12801
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12802
     * @param element  the object to add at the last index of the new array//LC:12803
     * @return A new array containing the existing elements plus the new element//LC:12804
     * @since 2.1//LC:12805
     *///LC:12806
    public static int[] add(final int[] array, final int element) {//LC:12807
        final int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);//LC:12808
        newArray[newArray.length - 1] = element;//LC:12809
        return newArray;//LC:12810
    }//LC:12811
//LC:12812
    /**//LC:12813
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12814
     *//LC:12815
     * <p>The new array contains the same elements of the input//LC:12816
     * array plus the given element in the last position. The component type of//LC:12817
     * the new array is the same as that of the input array.</p>//LC:12818
     *//LC:12819
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12820
     *  whose component type is the same as the element.</p>//LC:12821
     *//LC:12822
     * <pre>//LC:12823
     * ArrayUtils.add(null, 0)   = [0]//LC:12824
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12825
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12826
     * </pre>//LC:12827
     *//LC:12828
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12829
     * @param element  the object to add at the last index of the new array//LC:12830
     * @return A new array containing the existing elements plus the new element//LC:12831
     * @since 2.1//LC:12832
     *///LC:12833
    public static long[] add(final long[] array, final long element) {//LC:12834
        final long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);//LC:12835
        newArray[newArray.length - 1] = element;//LC:12836
        return newArray;//LC:12837
    }//LC:12838
//LC:12839
    /**//LC:12840
     * <p>Copies the given array and adds the given element at the end of the new array.</p>//LC:12841
     *//LC:12842
     * <p>The new array contains the same elements of the input//LC:12843
     * array plus the given element in the last position. The component type of//LC:12844
     * the new array is the same as that of the input array.</p>//LC:12845
     *//LC:12846
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12847
     *  whose component type is the same as the element.</p>//LC:12848
     *//LC:12849
     * <pre>//LC:12850
     * ArrayUtils.add(null, 0)   = [0]//LC:12851
     * ArrayUtils.add([1], 0)    = [1, 0]//LC:12852
     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]//LC:12853
     * </pre>//LC:12854
     *//LC:12855
     * @param array  the array to copy and add the element to, may be {@code null}//LC:12856
     * @param element  the object to add at the last index of the new array//LC:12857
     * @return A new array containing the existing elements plus the new element//LC:12858
     * @since 2.1//LC:12859
     *///LC:12860
    public static short[] add(final short[] array, final short element) {//LC:12861
        final short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);//LC:12862
        newArray[newArray.length - 1] = element;//LC:12863
        return newArray;//LC:12864
    }//LC:12865
//LC:12866
    /**//LC:12867
     * Returns a copy of the given array of size 1 greater than the argument.//LC:12868
     * The last value of the array is left to the default value.//LC:12869
     *//LC:12870
     * @param array The array to copy, must not be {@code null}.//LC:12871
     * @param newArrayComponentType If {@code array} is {@code null}, create a//LC:12872
     * size 1 array of this type.//LC:12873
     * @return A new copy of the array of size 1 greater than the input.//LC:12874
     *///LC:12875
    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {//LC:12876
        if (array != null) {//LC:12877
            final int arrayLength = Array.getLength(array);//LC:12878
            final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);//LC:12879
            System.arraycopy(array, 0, newArray, 0, arrayLength);//LC:12880
            return newArray;//LC:12881
        }//LC:12882
        return Array.newInstance(newArrayComponentType, 1);//LC:12883
    }//LC:12884
//LC:12885
    /**//LC:12886
     * <p>Inserts the specified element at the specified position in the array.//LC:12887
     * Shifts the element currently at that position (if any) and any subsequent//LC:12888
     * elements to the right (adds one to their indices).</p>//LC:12889
     *//LC:12890
     * <p>This method returns a new array with the same elements of the input//LC:12891
     * array plus the given element on the specified position. The component//LC:12892
     * type of the returned array is always the same as that of the input//LC:12893
     * array.</p>//LC:12894
     *//LC:12895
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12896
     *  whose component type is the same as the element.</p>//LC:12897
     *//LC:12898
     * <pre>//LC:12899
     * ArrayUtils.add(null, 0, null)      = [null]//LC:12900
     * ArrayUtils.add(null, 0, "a")       = ["a"]//LC:12901
     * ArrayUtils.add(["a"], 1, null)     = ["a", null]//LC:12902
     * ArrayUtils.add(["a"], 1, "b")      = ["a", "b"]//LC:12903
     * ArrayUtils.add(["a", "b"], 3, "c") = ["a", "b", "c"]//LC:12904
     * </pre>//LC:12905
     *//LC:12906
     * @param <T> the component type of the array//LC:12907
     * @param array  the array to add the element to, may be {@code null}//LC:12908
     * @param index  the position of the new object//LC:12909
     * @param element  the object to add//LC:12910
     * @return A new array containing the existing elements and the new element//LC:12911
     * @throws IndexOutOfBoundsException if the index is out of range//LC:12912
     * (index < 0 || index > array.length).//LC:12913
     * @throws IllegalArgumentException if both array and element are null//LC:12914
     *///LC:12915
    public static <T> T[] add(final T[] array, final int index, final T element) {//LC:12916
        Class<?> clss = null;//LC:12917
        if (array != null) {//LC:12918
            clss = array.getClass().getComponentType();//LC:12919
        } else if (element != null) {//LC:12920
            clss = element.getClass();//LC:12921
        } else {//LC:12922
            throw new IllegalArgumentException("Array and element cannot both be null");//LC:12923
        }//LC:12924
        @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T//LC:12925
        final T[] newArray = (T[]) add(array, index, element, clss);//LC:12926
        return newArray;//LC:12927
    }//LC:12928
//LC:12929
    /**//LC:12930
     * <p>Inserts the specified element at the specified position in the array.//LC:12931
     * Shifts the element currently at that position (if any) and any subsequent//LC:12932
     * elements to the right (adds one to their indices).</p>//LC:12933
     *//LC:12934
     * <p>This method returns a new array with the same elements of the input//LC:12935
     * array plus the given element on the specified position. The component//LC:12936
     * type of the returned array is always the same as that of the input//LC:12937
     * array.</p>//LC:12938
     *//LC:12939
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12940
     *  whose component type is the same as the element.</p>//LC:12941
     *//LC:12942
     * <pre>//LC:12943
     * ArrayUtils.add(null, 0, true)          = [true]//LC:12944
     * ArrayUtils.add([true], 0, false)       = [false, true]//LC:12945
     * ArrayUtils.add([false], 1, true)       = [false, true]//LC:12946
     * ArrayUtils.add([true, false], 1, true) = [true, true, false]//LC:12947
     * </pre>//LC:12948
     *//LC:12949
     * @param array  the array to add the element to, may be {@code null}//LC:12950
     * @param index  the position of the new object//LC:12951
     * @param element  the object to add//LC:12952
     * @return A new array containing the existing elements and the new element//LC:12953
     * @throws IndexOutOfBoundsException if the index is out of range//LC:12954
     * (index < 0 || index > array.length).//LC:12955
     *///LC:12956
    public static boolean[] add(final boolean[] array, final int index, final boolean element) {//LC:12957
        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);//LC:12958
    }//LC:12959
//LC:12960
    /**//LC:12961
     * <p>Inserts the specified element at the specified position in the array.//LC:12962
     * Shifts the element currently at that position (if any) and any subsequent//LC:12963
     * elements to the right (adds one to their indices).</p>//LC:12964
     *//LC:12965
     * <p>This method returns a new array with the same elements of the input//LC:12966
     * array plus the given element on the specified position. The component//LC:12967
     * type of the returned array is always the same as that of the input//LC:12968
     * array.</p>//LC:12969
     *//LC:12970
     * <p>If the input array is {@code null}, a new one element array is returned//LC:12971
     *  whose component type is the same as the element.</p>//LC:12972
     *//LC:12973
     * <pre>//LC:12974
     * ArrayUtils.add(null, 0, 'a')            = ['a']//LC:12975
     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']//LC:12976
     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']//LC:12977
     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']//LC:12978
     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']//LC:12979
     * </pre>//LC:12980
     *//LC:12981
     * @param array  the array to add the element to, may be {@code null}//LC:12982
     * @param index  the position of the new object//LC:12983
     * @param element  the object to add//LC:12984
     * @return A new array containing the existing elements and the new element//LC:12985
     * @throws IndexOutOfBoundsException if the index is out of range//LC:12986
     * (index < 0 || index > array.length).//LC:12987
     *///LC:12988
    public static char[] add(final char[] array, final int index, final char element) {//LC:12989
        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);//LC:12990
    }//LC:12991
//LC:12992
    /**//LC:12993
     * <p>Inserts the specified element at the specified position in the array.//LC:12994
     * Shifts the element currently at that position (if any) and any subsequent//LC:12995
     * elements to the right (adds one to their indices).</p>//LC:12996
     *//LC:12997
     * <p>This method returns a new array with the same elements of the input//LC:12998
     * array plus the given element on the specified position. The component//LC:12999
     * type of the returned array is always the same as that of the input//LC:13000
     * array.</p>//LC:13001
     *//LC:13002
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13003
     *  whose component type is the same as the element.</p>//LC:13004
     *//LC:13005
     * <pre>//LC:13006
     * ArrayUtils.add([1], 0, 2)         = [2, 1]//LC:13007
     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]//LC:13008
     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]//LC:13009
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]//LC:13010
     * </pre>//LC:13011
     *//LC:13012
     * @param array  the array to add the element to, may be {@code null}//LC:13013
     * @param index  the position of the new object//LC:13014
     * @param element  the object to add//LC:13015
     * @return A new array containing the existing elements and the new element//LC:13016
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13017
     * (index < 0 || index > array.length).//LC:13018
     *///LC:13019
    public static byte[] add(final byte[] array, final int index, final byte element) {//LC:13020
        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);//LC:13021
    }//LC:13022
//LC:13023
    /**//LC:13024
     * <p>Inserts the specified element at the specified position in the array.//LC:13025
     * Shifts the element currently at that position (if any) and any subsequent//LC:13026
     * elements to the right (adds one to their indices).</p>//LC:13027
     *//LC:13028
     * <p>This method returns a new array with the same elements of the input//LC:13029
     * array plus the given element on the specified position. The component//LC:13030
     * type of the returned array is always the same as that of the input//LC:13031
     * array.</p>//LC:13032
     *//LC:13033
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13034
     *  whose component type is the same as the element.</p>//LC:13035
     *//LC:13036
     * <pre>//LC:13037
     * ArrayUtils.add([1], 0, 2)         = [2, 1]//LC:13038
     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]//LC:13039
     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]//LC:13040
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]//LC:13041
     * </pre>//LC:13042
     *//LC:13043
     * @param array  the array to add the element to, may be {@code null}//LC:13044
     * @param index  the position of the new object//LC:13045
     * @param element  the object to add//LC:13046
     * @return A new array containing the existing elements and the new element//LC:13047
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13048
     * (index < 0 || index > array.length).//LC:13049
     *///LC:13050
    public static short[] add(final short[] array, final int index, final short element) {//LC:13051
        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);//LC:13052
    }//LC:13053
//LC:13054
    /**//LC:13055
     * <p>Inserts the specified element at the specified position in the array.//LC:13056
     * Shifts the element currently at that position (if any) and any subsequent//LC:13057
     * elements to the right (adds one to their indices).</p>//LC:13058
     *//LC:13059
     * <p>This method returns a new array with the same elements of the input//LC:13060
     * array plus the given element on the specified position. The component//LC:13061
     * type of the returned array is always the same as that of the input//LC:13062
     * array.</p>//LC:13063
     *//LC:13064
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13065
     *  whose component type is the same as the element.</p>//LC:13066
     *//LC:13067
     * <pre>//LC:13068
     * ArrayUtils.add([1], 0, 2)         = [2, 1]//LC:13069
     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]//LC:13070
     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]//LC:13071
     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]//LC:13072
     * </pre>//LC:13073
     *//LC:13074
     * @param array  the array to add the element to, may be {@code null}//LC:13075
     * @param index  the position of the new object//LC:13076
     * @param element  the object to add//LC:13077
     * @return A new array containing the existing elements and the new element//LC:13078
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13079
     * (index < 0 || index > array.length).//LC:13080
     *///LC:13081
    public static int[] add(final int[] array, final int index, final int element) {//LC:13082
        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);//LC:13083
    }//LC:13084
//LC:13085
    /**//LC:13086
     * <p>Inserts the specified element at the specified position in the array.//LC:13087
     * Shifts the element currently at that position (if any) and any subsequent//LC:13088
     * elements to the right (adds one to their indices).</p>//LC:13089
     *//LC:13090
     * <p>This method returns a new array with the same elements of the input//LC:13091
     * array plus the given element on the specified position. The component//LC:13092
     * type of the returned array is always the same as that of the input//LC:13093
     * array.</p>//LC:13094
     *//LC:13095
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13096
     *  whose component type is the same as the element.</p>//LC:13097
     *//LC:13098
     * <pre>//LC:13099
     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]//LC:13100
     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]//LC:13101
     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]//LC:13102
     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]//LC:13103
     * </pre>//LC:13104
     *//LC:13105
     * @param array  the array to add the element to, may be {@code null}//LC:13106
     * @param index  the position of the new object//LC:13107
     * @param element  the object to add//LC:13108
     * @return A new array containing the existing elements and the new element//LC:13109
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13110
     * (index < 0 || index > array.length).//LC:13111
     *///LC:13112
    public static long[] add(final long[] array, final int index, final long element) {//LC:13113
        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);//LC:13114
    }//LC:13115
//LC:13116
    /**//LC:13117
     * <p>Inserts the specified element at the specified position in the array.//LC:13118
     * Shifts the element currently at that position (if any) and any subsequent//LC:13119
     * elements to the right (adds one to their indices).</p>//LC:13120
     *//LC:13121
     * <p>This method returns a new array with the same elements of the input//LC:13122
     * array plus the given element on the specified position. The component//LC:13123
     * type of the returned array is always the same as that of the input//LC:13124
     * array.</p>//LC:13125
     *//LC:13126
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13127
     *  whose component type is the same as the element.</p>//LC:13128
     *//LC:13129
     * <pre>//LC:13130
     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]//LC:13131
     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]//LC:13132
     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]//LC:13133
     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]//LC:13134
     * </pre>//LC:13135
     *//LC:13136
     * @param array  the array to add the element to, may be {@code null}//LC:13137
     * @param index  the position of the new object//LC:13138
     * @param element  the object to add//LC:13139
     * @return A new array containing the existing elements and the new element//LC:13140
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13141
     * (index < 0 || index > array.length).//LC:13142
     *///LC:13143
    public static float[] add(final float[] array, final int index, final float element) {//LC:13144
        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);//LC:13145
    }//LC:13146
//LC:13147
    /**//LC:13148
     * <p>Inserts the specified element at the specified position in the array.//LC:13149
     * Shifts the element currently at that position (if any) and any subsequent//LC:13150
     * elements to the right (adds one to their indices).</p>//LC:13151
     *//LC:13152
     * <p>This method returns a new array with the same elements of the input//LC:13153
     * array plus the given element on the specified position. The component//LC:13154
     * type of the returned array is always the same as that of the input//LC:13155
     * array.</p>//LC:13156
     *//LC:13157
     * <p>If the input array is {@code null}, a new one element array is returned//LC:13158
     *  whose component type is the same as the element.</p>//LC:13159
     *//LC:13160
     * <pre>//LC:13161
     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]//LC:13162
     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]//LC:13163
     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]//LC:13164
     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]//LC:13165
     * </pre>//LC:13166
     *//LC:13167
     * @param array  the array to add the element to, may be {@code null}//LC:13168
     * @param index  the position of the new object//LC:13169
     * @param element  the object to add//LC:13170
     * @return A new array containing the existing elements and the new element//LC:13171
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13172
     * (index < 0 || index > array.length).//LC:13173
     *///LC:13174
    public static double[] add(final double[] array, final int index, final double element) {//LC:13175
        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);//LC:13176
    }//LC:13177
//LC:13178
    /**//LC:13179
     * Underlying implementation of add(array, index, element) methods.//LC:13180
     * The last parameter is the class, which may not equal element.getClass//LC:13181
     * for primitives.//LC:13182
     *//LC:13183
     * @param array  the array to add the element to, may be {@code null}//LC:13184
     * @param index  the position of the new object//LC:13185
     * @param element  the object to add//LC:13186
     * @param clss the type of the element being added//LC:13187
     * @return A new array containing the existing elements and the new element//LC:13188
     *///LC:13189
    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {//LC:13190
        if (array == null) {//LC:13191
            if (index != 0) {//LC:13192
                throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");//LC:13193
            }//LC:13194
            final Object joinedArray = Array.newInstance(clss, 1);//LC:13195
            Array.set(joinedArray, 0, element);//LC:13196
            return joinedArray;//LC:13197
        }//LC:13198
        final int length = Array.getLength(array);//LC:13199
        if (index > length || index < 0) {//LC:13200
            throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);//LC:13201
        }//LC:13202
        final Object result = Array.newInstance(clss, length + 1);//LC:13203
        System.arraycopy(array, 0, result, 0, index);//LC:13204
        Array.set(result, index, element);//LC:13205
        if (index < length) {//LC:13206
            System.arraycopy(array, index, result, index + 1, length - index);//LC:13207
        }//LC:13208
        return result;//LC:13209
    }//LC:13210
//LC:13211
    /**//LC:13212
     * <p>Removes the element at the specified position from the specified array.//LC:13213
     * All subsequent elements are shifted to the left (subtracts one from//LC:13214
     * their indices).</p>//LC:13215
     *//LC:13216
     * <p>This method returns a new array with the same elements of the input//LC:13217
     * array except the element on the specified position. The component//LC:13218
     * type of the returned array is always the same as that of the input//LC:13219
     * array.</p>//LC:13220
     *//LC:13221
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13222
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13223
     *//LC:13224
     * <pre>//LC:13225
     * ArrayUtils.remove(["a"], 0)           = []//LC:13226
     * ArrayUtils.remove(["a", "b"], 0)      = ["b"]//LC:13227
     * ArrayUtils.remove(["a", "b"], 1)      = ["a"]//LC:13228
     * ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"]//LC:13229
     * </pre>//LC:13230
     *//LC:13231
     * @param <T> the component type of the array//LC:13232
     * @param array  the array to remove the element from, may not be {@code null}//LC:13233
     * @param index  the position of the element to be removed//LC:13234
     * @return A new array containing the existing elements except the element//LC:13235
     *         at the specified position.//LC:13236
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13237
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13238
     * @since 2.1//LC:13239
     *///LC:13240
    @SuppressWarnings("unchecked") // remove() always creates an array of the same type as its input//LC:13241
    public static <T> T[] remove(final T[] array, final int index) {//LC:13242
        return (T[]) remove((Object) array, index);//LC:13243
    }//LC:13244
//LC:13245
    /**//LC:13246
     * <p>Removes the first occurrence of the specified element from the//LC:13247
     * specified array. All subsequent elements are shifted to the left//LC:13248
     * (subtracts one from their indices). If the array doesn't contains//LC:13249
     * such an element, no elements are removed from the array.</p>//LC:13250
     *//LC:13251
     * <p>This method returns a new array with the same elements of the input//LC:13252
     * array except the first occurrence of the specified element. The component//LC:13253
     * type of the returned array is always the same as that of the input//LC:13254
     * array.</p>//LC:13255
     *//LC:13256
     * <pre>//LC:13257
     * ArrayUtils.removeElement(null, "a")            = null//LC:13258
     * ArrayUtils.removeElement([], "a")              = []//LC:13259
     * ArrayUtils.removeElement(["a"], "b")           = ["a"]//LC:13260
     * ArrayUtils.removeElement(["a", "b"], "a")      = ["b"]//LC:13261
     * ArrayUtils.removeElement(["a", "b", "a"], "a") = ["b", "a"]//LC:13262
     * </pre>//LC:13263
     *//LC:13264
     * @param <T> the component type of the array//LC:13265
     * @param array  the array to remove the element from, may be {@code null}//LC:13266
     * @param element  the element to be removed//LC:13267
     * @return A new array containing the existing elements except the first//LC:13268
     *         occurrence of the specified element.//LC:13269
     * @since 2.1//LC:13270
     *///LC:13271
    public static <T> T[] removeElement(final T[] array, final Object element) {//LC:13272
        final int index = indexOf(array, element);//LC:13273
        if (index == INDEX_NOT_FOUND) {//LC:13274
            return clone(array);//LC:13275
        }//LC:13276
        return remove(array, index);//LC:13277
    }//LC:13278
//LC:13279
    /**//LC:13280
     * <p>Removes the element at the specified position from the specified array.//LC:13281
     * All subsequent elements are shifted to the left (subtracts one from//LC:13282
     * their indices).</p>//LC:13283
     *//LC:13284
     * <p>This method returns a new array with the same elements of the input//LC:13285
     * array except the element on the specified position. The component//LC:13286
     * type of the returned array is always the same as that of the input//LC:13287
     * array.</p>//LC:13288
     *//LC:13289
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13290
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13291
     *//LC:13292
     * <pre>//LC:13293
     * ArrayUtils.remove([true], 0)              = []//LC:13294
     * ArrayUtils.remove([true, false], 0)       = [false]//LC:13295
     * ArrayUtils.remove([true, false], 1)       = [true]//LC:13296
     * ArrayUtils.remove([true, true, false], 1) = [true, false]//LC:13297
     * </pre>//LC:13298
     *//LC:13299
     * @param array  the array to remove the element from, may not be {@code null}//LC:13300
     * @param index  the position of the element to be removed//LC:13301
     * @return A new array containing the existing elements except the element//LC:13302
     *         at the specified position.//LC:13303
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13304
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13305
     * @since 2.1//LC:13306
     *///LC:13307
    public static boolean[] remove(final boolean[] array, final int index) {//LC:13308
        return (boolean[]) remove((Object) array, index);//LC:13309
    }//LC:13310
//LC:13311
    /**//LC:13312
     * <p>Removes the first occurrence of the specified element from the//LC:13313
     * specified array. All subsequent elements are shifted to the left//LC:13314
     * (subtracts one from their indices). If the array doesn't contains//LC:13315
     * such an element, no elements are removed from the array.</p>//LC:13316
     *//LC:13317
     * <p>This method returns a new array with the same elements of the input//LC:13318
     * array except the first occurrence of the specified element. The component//LC:13319
     * type of the returned array is always the same as that of the input//LC:13320
     * array.</p>//LC:13321
     *//LC:13322
     * <pre>//LC:13323
     * ArrayUtils.removeElement(null, true)                = null//LC:13324
     * ArrayUtils.removeElement([], true)                  = []//LC:13325
     * ArrayUtils.removeElement([true], false)             = [true]//LC:13326
     * ArrayUtils.removeElement([true, false], false)      = [true]//LC:13327
     * ArrayUtils.removeElement([true, false, true], true) = [false, true]//LC:13328
     * </pre>//LC:13329
     *//LC:13330
     * @param array  the array to remove the element from, may be {@code null}//LC:13331
     * @param element  the element to be removed//LC:13332
     * @return A new array containing the existing elements except the first//LC:13333
     *         occurrence of the specified element.//LC:13334
     * @since 2.1//LC:13335
     *///LC:13336
    public static boolean[] removeElement(final boolean[] array, final boolean element) {//LC:13337
        final int index = indexOf(array, element);//LC:13338
        if (index == INDEX_NOT_FOUND) {//LC:13339
            return clone(array);//LC:13340
        }//LC:13341
        return remove(array, index);//LC:13342
    }//LC:13343
//LC:13344
    /**//LC:13345
     * <p>Removes the element at the specified position from the specified array.//LC:13346
     * All subsequent elements are shifted to the left (subtracts one from//LC:13347
     * their indices).</p>//LC:13348
     *//LC:13349
     * <p>This method returns a new array with the same elements of the input//LC:13350
     * array except the element on the specified position. The component//LC:13351
     * type of the returned array is always the same as that of the input//LC:13352
     * array.</p>//LC:13353
     *//LC:13354
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13355
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13356
     *//LC:13357
     * <pre>//LC:13358
     * ArrayUtils.remove([1], 0)          = []//LC:13359
     * ArrayUtils.remove([1, 0], 0)       = [0]//LC:13360
     * ArrayUtils.remove([1, 0], 1)       = [1]//LC:13361
     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]//LC:13362
     * </pre>//LC:13363
     *//LC:13364
     * @param array  the array to remove the element from, may not be {@code null}//LC:13365
     * @param index  the position of the element to be removed//LC:13366
     * @return A new array containing the existing elements except the element//LC:13367
     *         at the specified position.//LC:13368
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13369
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13370
     * @since 2.1//LC:13371
     *///LC:13372
    public static byte[] remove(final byte[] array, final int index) {//LC:13373
        return (byte[]) remove((Object) array, index);//LC:13374
    }//LC:13375
//LC:13376
    /**//LC:13377
     * <p>Removes the first occurrence of the specified element from the//LC:13378
     * specified array. All subsequent elements are shifted to the left//LC:13379
     * (subtracts one from their indices). If the array doesn't contains//LC:13380
     * such an element, no elements are removed from the array.</p>//LC:13381
     *//LC:13382
     * <p>This method returns a new array with the same elements of the input//LC:13383
     * array except the first occurrence of the specified element. The component//LC:13384
     * type of the returned array is always the same as that of the input//LC:13385
     * array.</p>//LC:13386
     *//LC:13387
     * <pre>//LC:13388
     * ArrayUtils.removeElement(null, 1)        = null//LC:13389
     * ArrayUtils.removeElement([], 1)          = []//LC:13390
     * ArrayUtils.removeElement([1], 0)         = [1]//LC:13391
     * ArrayUtils.removeElement([1, 0], 0)      = [1]//LC:13392
     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]//LC:13393
     * </pre>//LC:13394
     *//LC:13395
     * @param array  the array to remove the element from, may be {@code null}//LC:13396
     * @param element  the element to be removed//LC:13397
     * @return A new array containing the existing elements except the first//LC:13398
     *         occurrence of the specified element.//LC:13399
     * @since 2.1//LC:13400
     *///LC:13401
    public static byte[] removeElement(final byte[] array, final byte element) {//LC:13402
        final int index = indexOf(array, element);//LC:13403
        if (index == INDEX_NOT_FOUND) {//LC:13404
            return clone(array);//LC:13405
        }//LC:13406
        return remove(array, index);//LC:13407
    }//LC:13408
//LC:13409
    /**//LC:13410
     * <p>Removes the element at the specified position from the specified array.//LC:13411
     * All subsequent elements are shifted to the left (subtracts one from//LC:13412
     * their indices).</p>//LC:13413
     *//LC:13414
     * <p>This method returns a new array with the same elements of the input//LC:13415
     * array except the element on the specified position. The component//LC:13416
     * type of the returned array is always the same as that of the input//LC:13417
     * array.</p>//LC:13418
     *//LC:13419
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13420
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13421
     *//LC:13422
     * <pre>//LC:13423
     * ArrayUtils.remove(['a'], 0)           = []//LC:13424
     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']//LC:13425
     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']//LC:13426
     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']//LC:13427
     * </pre>//LC:13428
     *//LC:13429
     * @param array  the array to remove the element from, may not be {@code null}//LC:13430
     * @param index  the position of the element to be removed//LC:13431
     * @return A new array containing the existing elements except the element//LC:13432
     *         at the specified position.//LC:13433
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13434
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13435
     * @since 2.1//LC:13436
     *///LC:13437
    public static char[] remove(final char[] array, final int index) {//LC:13438
        return (char[]) remove((Object) array, index);//LC:13439
    }//LC:13440
//LC:13441
    /**//LC:13442
     * <p>Removes the first occurrence of the specified element from the//LC:13443
     * specified array. All subsequent elements are shifted to the left//LC:13444
     * (subtracts one from their indices). If the array doesn't contains//LC:13445
     * such an element, no elements are removed from the array.</p>//LC:13446
     *//LC:13447
     * <p>This method returns a new array with the same elements of the input//LC:13448
     * array except the first occurrence of the specified element. The component//LC:13449
     * type of the returned array is always the same as that of the input//LC:13450
     * array.</p>//LC:13451
     *//LC:13452
     * <pre>//LC:13453
     * ArrayUtils.removeElement(null, 'a')            = null//LC:13454
     * ArrayUtils.removeElement([], 'a')              = []//LC:13455
     * ArrayUtils.removeElement(['a'], 'b')           = ['a']//LC:13456
     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']//LC:13457
     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']//LC:13458
     * </pre>//LC:13459
     *//LC:13460
     * @param array  the array to remove the element from, may be {@code null}//LC:13461
     * @param element  the element to be removed//LC:13462
     * @return A new array containing the existing elements except the first//LC:13463
     *         occurrence of the specified element.//LC:13464
     * @since 2.1//LC:13465
     *///LC:13466
    public static char[] removeElement(final char[] array, final char element) {//LC:13467
        final int index = indexOf(array, element);//LC:13468
        if (index == INDEX_NOT_FOUND) {//LC:13469
            return clone(array);//LC:13470
        }//LC:13471
        return remove(array, index);//LC:13472
    }//LC:13473
//LC:13474
    /**//LC:13475
     * <p>Removes the element at the specified position from the specified array.//LC:13476
     * All subsequent elements are shifted to the left (subtracts one from//LC:13477
     * their indices).</p>//LC:13478
     *//LC:13479
     * <p>This method returns a new array with the same elements of the input//LC:13480
     * array except the element on the specified position. The component//LC:13481
     * type of the returned array is always the same as that of the input//LC:13482
     * array.</p>//LC:13483
     *//LC:13484
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13485
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13486
     *//LC:13487
     * <pre>//LC:13488
     * ArrayUtils.remove([1.1], 0)           = []//LC:13489
     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]//LC:13490
     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]//LC:13491
     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]//LC:13492
     * </pre>//LC:13493
     *//LC:13494
     * @param array  the array to remove the element from, may not be {@code null}//LC:13495
     * @param index  the position of the element to be removed//LC:13496
     * @return A new array containing the existing elements except the element//LC:13497
     *         at the specified position.//LC:13498
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13499
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13500
     * @since 2.1//LC:13501
     *///LC:13502
    public static double[] remove(final double[] array, final int index) {//LC:13503
        return (double[]) remove((Object) array, index);//LC:13504
    }//LC:13505
//LC:13506
    /**//LC:13507
     * <p>Removes the first occurrence of the specified element from the//LC:13508
     * specified array. All subsequent elements are shifted to the left//LC:13509
     * (subtracts one from their indices). If the array doesn't contains//LC:13510
     * such an element, no elements are removed from the array.</p>//LC:13511
     *//LC:13512
     * <p>This method returns a new array with the same elements of the input//LC:13513
     * array except the first occurrence of the specified element. The component//LC:13514
     * type of the returned array is always the same as that of the input//LC:13515
     * array.</p>//LC:13516
     *//LC:13517
     * <pre>//LC:13518
     * ArrayUtils.removeElement(null, 1.1)            = null//LC:13519
     * ArrayUtils.removeElement([], 1.1)              = []//LC:13520
     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]//LC:13521
     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]//LC:13522
     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]//LC:13523
     * </pre>//LC:13524
     *//LC:13525
     * @param array  the array to remove the element from, may be {@code null}//LC:13526
     * @param element  the element to be removed//LC:13527
     * @return A new array containing the existing elements except the first//LC:13528
     *         occurrence of the specified element.//LC:13529
     * @since 2.1//LC:13530
     *///LC:13531
    public static double[] removeElement(final double[] array, final double element) {//LC:13532
        final int index = indexOf(array, element);//LC:13533
        if (index == INDEX_NOT_FOUND) {//LC:13534
            return clone(array);//LC:13535
        }//LC:13536
        return remove(array, index);//LC:13537
    }//LC:13538
//LC:13539
    /**//LC:13540
     * <p>Removes the element at the specified position from the specified array.//LC:13541
     * All subsequent elements are shifted to the left (subtracts one from//LC:13542
     * their indices).</p>//LC:13543
     *//LC:13544
     * <p>This method returns a new array with the same elements of the input//LC:13545
     * array except the element on the specified position. The component//LC:13546
     * type of the returned array is always the same as that of the input//LC:13547
     * array.</p>//LC:13548
     *//LC:13549
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13550
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13551
     *//LC:13552
     * <pre>//LC:13553
     * ArrayUtils.remove([1.1], 0)           = []//LC:13554
     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]//LC:13555
     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]//LC:13556
     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]//LC:13557
     * </pre>//LC:13558
     *//LC:13559
     * @param array  the array to remove the element from, may not be {@code null}//LC:13560
     * @param index  the position of the element to be removed//LC:13561
     * @return A new array containing the existing elements except the element//LC:13562
     *         at the specified position.//LC:13563
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13564
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13565
     * @since 2.1//LC:13566
     *///LC:13567
    public static float[] remove(final float[] array, final int index) {//LC:13568
        return (float[]) remove((Object) array, index);//LC:13569
    }//LC:13570
//LC:13571
    /**//LC:13572
     * <p>Removes the first occurrence of the specified element from the//LC:13573
     * specified array. All subsequent elements are shifted to the left//LC:13574
     * (subtracts one from their indices). If the array doesn't contains//LC:13575
     * such an element, no elements are removed from the array.</p>//LC:13576
     *//LC:13577
     * <p>This method returns a new array with the same elements of the input//LC:13578
     * array except the first occurrence of the specified element. The component//LC:13579
     * type of the returned array is always the same as that of the input//LC:13580
     * array.</p>//LC:13581
     *//LC:13582
     * <pre>//LC:13583
     * ArrayUtils.removeElement(null, 1.1)            = null//LC:13584
     * ArrayUtils.removeElement([], 1.1)              = []//LC:13585
     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]//LC:13586
     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]//LC:13587
     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]//LC:13588
     * </pre>//LC:13589
     *//LC:13590
     * @param array  the array to remove the element from, may be {@code null}//LC:13591
     * @param element  the element to be removed//LC:13592
     * @return A new array containing the existing elements except the first//LC:13593
     *         occurrence of the specified element.//LC:13594
     * @since 2.1//LC:13595
     *///LC:13596
    public static float[] removeElement(final float[] array, final float element) {//LC:13597
        final int index = indexOf(array, element);//LC:13598
        if (index == INDEX_NOT_FOUND) {//LC:13599
            return clone(array);//LC:13600
        }//LC:13601
        return remove(array, index);//LC:13602
    }//LC:13603
//LC:13604
    /**//LC:13605
     * <p>Removes the element at the specified position from the specified array.//LC:13606
     * All subsequent elements are shifted to the left (subtracts one from//LC:13607
     * their indices).</p>//LC:13608
     *//LC:13609
     * <p>This method returns a new array with the same elements of the input//LC:13610
     * array except the element on the specified position. The component//LC:13611
     * type of the returned array is always the same as that of the input//LC:13612
     * array.</p>//LC:13613
     *//LC:13614
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13615
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13616
     *//LC:13617
     * <pre>//LC:13618
     * ArrayUtils.remove([1], 0)         = []//LC:13619
     * ArrayUtils.remove([2, 6], 0)      = [6]//LC:13620
     * ArrayUtils.remove([2, 6], 1)      = [2]//LC:13621
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]//LC:13622
     * </pre>//LC:13623
     *//LC:13624
     * @param array  the array to remove the element from, may not be {@code null}//LC:13625
     * @param index  the position of the element to be removed//LC:13626
     * @return A new array containing the existing elements except the element//LC:13627
     *         at the specified position.//LC:13628
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13629
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13630
     * @since 2.1//LC:13631
     *///LC:13632
    public static int[] remove(final int[] array, final int index) {//LC:13633
        return (int[]) remove((Object) array, index);//LC:13634
    }//LC:13635
//LC:13636
    /**//LC:13637
     * <p>Removes the first occurrence of the specified element from the//LC:13638
     * specified array. All subsequent elements are shifted to the left//LC:13639
     * (subtracts one from their indices). If the array doesn't contains//LC:13640
     * such an element, no elements are removed from the array.</p>//LC:13641
     *//LC:13642
     * <p>This method returns a new array with the same elements of the input//LC:13643
     * array except the first occurrence of the specified element. The component//LC:13644
     * type of the returned array is always the same as that of the input//LC:13645
     * array.</p>//LC:13646
     *//LC:13647
     * <pre>//LC:13648
     * ArrayUtils.removeElement(null, 1)      = null//LC:13649
     * ArrayUtils.removeElement([], 1)        = []//LC:13650
     * ArrayUtils.removeElement([1], 2)       = [1]//LC:13651
     * ArrayUtils.removeElement([1, 3], 1)    = [3]//LC:13652
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]//LC:13653
     * </pre>//LC:13654
     *//LC:13655
     * @param array  the array to remove the element from, may be {@code null}//LC:13656
     * @param element  the element to be removed//LC:13657
     * @return A new array containing the existing elements except the first//LC:13658
     *         occurrence of the specified element.//LC:13659
     * @since 2.1//LC:13660
     *///LC:13661
    public static int[] removeElement(final int[] array, final int element) {//LC:13662
        final int index = indexOf(array, element);//LC:13663
        if (index == INDEX_NOT_FOUND) {//LC:13664
            return clone(array);//LC:13665
        }//LC:13666
        return remove(array, index);//LC:13667
    }//LC:13668
//LC:13669
    /**//LC:13670
     * <p>Removes the element at the specified position from the specified array.//LC:13671
     * All subsequent elements are shifted to the left (subtracts one from//LC:13672
     * their indices).</p>//LC:13673
     *//LC:13674
     * <p>This method returns a new array with the same elements of the input//LC:13675
     * array except the element on the specified position. The component//LC:13676
     * type of the returned array is always the same as that of the input//LC:13677
     * array.</p>//LC:13678
     *//LC:13679
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13680
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13681
     *//LC:13682
     * <pre>//LC:13683
     * ArrayUtils.remove([1], 0)         = []//LC:13684
     * ArrayUtils.remove([2, 6], 0)      = [6]//LC:13685
     * ArrayUtils.remove([2, 6], 1)      = [2]//LC:13686
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]//LC:13687
     * </pre>//LC:13688
     *//LC:13689
     * @param array  the array to remove the element from, may not be {@code null}//LC:13690
     * @param index  the position of the element to be removed//LC:13691
     * @return A new array containing the existing elements except the element//LC:13692
     *         at the specified position.//LC:13693
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13694
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13695
     * @since 2.1//LC:13696
     *///LC:13697
    public static long[] remove(final long[] array, final int index) {//LC:13698
        return (long[]) remove((Object) array, index);//LC:13699
    }//LC:13700
//LC:13701
    /**//LC:13702
     * <p>Removes the first occurrence of the specified element from the//LC:13703
     * specified array. All subsequent elements are shifted to the left//LC:13704
     * (subtracts one from their indices). If the array doesn't contains//LC:13705
     * such an element, no elements are removed from the array.</p>//LC:13706
     *//LC:13707
     * <p>This method returns a new array with the same elements of the input//LC:13708
     * array except the first occurrence of the specified element. The component//LC:13709
     * type of the returned array is always the same as that of the input//LC:13710
     * array.</p>//LC:13711
     *//LC:13712
     * <pre>//LC:13713
     * ArrayUtils.removeElement(null, 1)      = null//LC:13714
     * ArrayUtils.removeElement([], 1)        = []//LC:13715
     * ArrayUtils.removeElement([1], 2)       = [1]//LC:13716
     * ArrayUtils.removeElement([1, 3], 1)    = [3]//LC:13717
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]//LC:13718
     * </pre>//LC:13719
     *//LC:13720
     * @param array  the array to remove the element from, may be {@code null}//LC:13721
     * @param element  the element to be removed//LC:13722
     * @return A new array containing the existing elements except the first//LC:13723
     *         occurrence of the specified element.//LC:13724
     * @since 2.1//LC:13725
     *///LC:13726
    public static long[] removeElement(final long[] array, final long element) {//LC:13727
        final int index = indexOf(array, element);//LC:13728
        if (index == INDEX_NOT_FOUND) {//LC:13729
            return clone(array);//LC:13730
        }//LC:13731
        return remove(array, index);//LC:13732
    }//LC:13733
//LC:13734
    /**//LC:13735
     * <p>Removes the element at the specified position from the specified array.//LC:13736
     * All subsequent elements are shifted to the left (subtracts one from//LC:13737
     * their indices).</p>//LC:13738
     *//LC:13739
     * <p>This method returns a new array with the same elements of the input//LC:13740
     * array except the element on the specified position. The component//LC:13741
     * type of the returned array is always the same as that of the input//LC:13742
     * array.</p>//LC:13743
     *//LC:13744
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13745
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13746
     *//LC:13747
     * <pre>//LC:13748
     * ArrayUtils.remove([1], 0)         = []//LC:13749
     * ArrayUtils.remove([2, 6], 0)      = [6]//LC:13750
     * ArrayUtils.remove([2, 6], 1)      = [2]//LC:13751
     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]//LC:13752
     * </pre>//LC:13753
     *//LC:13754
     * @param array  the array to remove the element from, may not be {@code null}//LC:13755
     * @param index  the position of the element to be removed//LC:13756
     * @return A new array containing the existing elements except the element//LC:13757
     *         at the specified position.//LC:13758
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13759
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13760
     * @since 2.1//LC:13761
     *///LC:13762
    public static short[] remove(final short[] array, final int index) {//LC:13763
        return (short[]) remove((Object) array, index);//LC:13764
    }//LC:13765
//LC:13766
    /**//LC:13767
     * <p>Removes the first occurrence of the specified element from the//LC:13768
     * specified array. All subsequent elements are shifted to the left//LC:13769
     * (subtracts one from their indices). If the array doesn't contains//LC:13770
     * such an element, no elements are removed from the array.</p>//LC:13771
     *//LC:13772
     * <p>This method returns a new array with the same elements of the input//LC:13773
     * array except the first occurrence of the specified element. The component//LC:13774
     * type of the returned array is always the same as that of the input//LC:13775
     * array.</p>//LC:13776
     *//LC:13777
     * <pre>//LC:13778
     * ArrayUtils.removeElement(null, 1)      = null//LC:13779
     * ArrayUtils.removeElement([], 1)        = []//LC:13780
     * ArrayUtils.removeElement([1], 2)       = [1]//LC:13781
     * ArrayUtils.removeElement([1, 3], 1)    = [3]//LC:13782
     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]//LC:13783
     * </pre>//LC:13784
     *//LC:13785
     * @param array  the array to remove the element from, may be {@code null}//LC:13786
     * @param element  the element to be removed//LC:13787
     * @return A new array containing the existing elements except the first//LC:13788
     *         occurrence of the specified element.//LC:13789
     * @since 2.1//LC:13790
     *///LC:13791
    public static short[] removeElement(final short[] array, final short element) {//LC:13792
        final int index = indexOf(array, element);//LC:13793
        if (index == INDEX_NOT_FOUND) {//LC:13794
            return clone(array);//LC:13795
        }//LC:13796
        return remove(array, index);//LC:13797
    }//LC:13798
//LC:13799
    /**//LC:13800
     * <p>Removes the element at the specified position from the specified array.//LC:13801
     * All subsequent elements are shifted to the left (subtracts one from//LC:13802
     * their indices).</p>//LC:13803
     *//LC:13804
     * <p>This method returns a new array with the same elements of the input//LC:13805
     * array except the element on the specified position. The component//LC:13806
     * type of the returned array is always the same as that of the input//LC:13807
     * array.</p>//LC:13808
     *//LC:13809
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13810
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13811
     *//LC:13812
     * @param array  the array to remove the element from, may not be {@code null}//LC:13813
     * @param index  the position of the element to be removed//LC:13814
     * @return A new array containing the existing elements except the element//LC:13815
     *         at the specified position.//LC:13816
     * @throws IndexOutOfBoundsException if the index is out of range//LC:13817
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13818
     * @since 2.1//LC:13819
     *///LC:13820
    private static Object remove(final Object array, final int index) {//LC:13821
        final int length = getLength(array);//LC:13822
        if (index < 0 || index >= length) {//LC:13823
            throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);//LC:13824
        }//LC:13825
//LC:13826
        final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);//LC:13827
        System.arraycopy(array, 0, result, 0, index);//LC:13828
        if (index < length - 1) {//LC:13829
            System.arraycopy(array, index + 1, result, index, length - index - 1);//LC:13830
        }//LC:13831
//LC:13832
        return result;//LC:13833
    }//LC:13834
//LC:13835
    /**//LC:13836
     * <p>Removes the elements at the specified positions from the specified array.//LC:13837
     * All remaining elements are shifted to the left.</p>//LC:13838
     *//LC:13839
     * <p>This method returns a new array with the same elements of the input//LC:13840
     * array except those at the specified positions. The component//LC:13841
     * type of the returned array is always the same as that of the input//LC:13842
     * array.</p>//LC:13843
     *//LC:13844
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13845
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13846
     *//LC:13847
     * <pre>//LC:13848
     * ArrayUtils.removeAll(["a", "b", "c"], 0, 2) = ["b"]//LC:13849
     * ArrayUtils.removeAll(["a", "b", "c"], 1, 2) = ["a"]//LC:13850
     * </pre>//LC:13851
     *//LC:13852
     * @param <T> the component type of the array//LC:13853
     * @param array   the array to remove the element from, may not be {@code null}//LC:13854
     * @param indices the positions of the elements to be removed//LC:13855
     * @return A new array containing the existing elements except those//LC:13856
     *         at the specified positions.//LC:13857
     * @throws IndexOutOfBoundsException if any index is out of range//LC:13858
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13859
     * @since 3.0.1//LC:13860
     *///LC:13861
    @SuppressWarnings("unchecked") // removeAll() always creates an array of the same type as its input//LC:13862
    public static <T> T[] removeAll(final T[] array, final int... indices) {//LC:13863
        return (T[]) removeAll((Object) array, clone(indices));//LC:13864
    }//LC:13865
//LC:13866
    /**//LC:13867
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:13868
     * from the specified array. All subsequent elements are shifted left.//LC:13869
     * For any element-to-be-removed specified in greater quantities than//LC:13870
     * contained in the original array, no change occurs beyond the//LC:13871
     * removal of the existing matching items.</p>//LC:13872
     *//LC:13873
     * <p>This method returns a new array with the same elements of the input//LC:13874
     * array except for the earliest-encountered occurrences of the specified//LC:13875
     * elements. The component type of the returned array is always the same//LC:13876
     * as that of the input array.</p>//LC:13877
     *//LC:13878
     * <pre>//LC:13879
     * ArrayUtils.removeElements(null, "a", "b")            = null//LC:13880
     * ArrayUtils.removeElements([], "a", "b")              = []//LC:13881
     * ArrayUtils.removeElements(["a"], "b", "c")           = ["a"]//LC:13882
     * ArrayUtils.removeElements(["a", "b"], "a", "c")      = ["b"]//LC:13883
     * ArrayUtils.removeElements(["a", "b", "a"], "a")      = ["b", "a"]//LC:13884
     * ArrayUtils.removeElements(["a", "b", "a"], "a", "a") = ["b"]//LC:13885
     * </pre>//LC:13886
     *//LC:13887
     * @param <T> the component type of the array//LC:13888
     * @param array  the array to remove the element from, may be {@code null}//LC:13889
     * @param values the elements to be removed//LC:13890
     * @return A new array containing the existing elements except the//LC:13891
     *         earliest-encountered occurrences of the specified elements.//LC:13892
     * @since 3.0.1//LC:13893
     *///LC:13894
    public static <T> T[] removeElements(final T[] array, final T... values) {//LC:13895
        if (isEmpty(array) || isEmpty(values)) {//LC:13896
            return clone(array);//LC:13897
        }//LC:13898
        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);//LC:13899
        for (final T v : values) {//LC:13900
            final MutableInt count = occurrences.get(v);//LC:13901
            if (count == null) {//LC:13902
                occurrences.put(v, new MutableInt(1));//LC:13903
            } else {//LC:13904
                count.increment();//LC:13905
            }//LC:13906
        }//LC:13907
        final BitSet toRemove = new BitSet();//LC:13908
        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {//LC:13909
            final T v = e.getKey();//LC:13910
            int found = 0;//LC:13911
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:13912
                found = indexOf(array, v, found);//LC:13913
                if (found < 0) {//LC:13914
                    break;//LC:13915
                }//LC:13916
                toRemove.set(found++);//LC:13917
            }//LC:13918
        }//LC:13919
        @SuppressWarnings("unchecked") // removeAll() always creates an array of the same type as its input//LC:13920
        final//LC:13921
        T[] result = (T[]) removeAll(array, toRemove);//LC:13922
        return result;//LC:13923
    }//LC:13924
//LC:13925
    /**//LC:13926
     * <p>Removes the elements at the specified positions from the specified array.//LC:13927
     * All remaining elements are shifted to the left.</p>//LC:13928
     *//LC:13929
     * <p>This method returns a new array with the same elements of the input//LC:13930
     * array except those at the specified positions. The component//LC:13931
     * type of the returned array is always the same as that of the input//LC:13932
     * array.</p>//LC:13933
     *//LC:13934
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:13935
     * will be thrown, because in that case no valid index can be specified.</p>//LC:13936
     *//LC:13937
     * <pre>//LC:13938
     * ArrayUtils.removeAll([1], 0)             = []//LC:13939
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:13940
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:13941
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:13942
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:13943
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:13944
     * </pre>//LC:13945
     *//LC:13946
     * @param array   the array to remove the element from, may not be {@code null}//LC:13947
     * @param indices the positions of the elements to be removed//LC:13948
     * @return A new array containing the existing elements except those//LC:13949
     *         at the specified positions.//LC:13950
     * @throws IndexOutOfBoundsException if any index is out of range//LC:13951
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:13952
     * @since 3.0.1//LC:13953
     *///LC:13954
    public static byte[] removeAll(final byte[] array, final int... indices) {//LC:13955
        return (byte[]) removeAll((Object) array, clone(indices));//LC:13956
    }//LC:13957
//LC:13958
    /**//LC:13959
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:13960
     * from the specified array. All subsequent elements are shifted left.//LC:13961
     * For any element-to-be-removed specified in greater quantities than//LC:13962
     * contained in the original array, no change occurs beyond the//LC:13963
     * removal of the existing matching items.</p>//LC:13964
     *//LC:13965
     * <p>This method returns a new array with the same elements of the input//LC:13966
     * array except for the earliest-encountered occurrences of the specified//LC:13967
     * elements. The component type of the returned array is always the same//LC:13968
     * as that of the input array.</p>//LC:13969
     *//LC:13970
     * <pre>//LC:13971
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:13972
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:13973
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:13974
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:13975
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:13976
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:13977
     * </pre>//LC:13978
     *//LC:13979
     * @param array  the array to remove the element from, may be {@code null}//LC:13980
     * @param values the elements to be removed//LC:13981
     * @return A new array containing the existing elements except the//LC:13982
     *         earliest-encountered occurrences of the specified elements.//LC:13983
     * @since 3.0.1//LC:13984
     *///LC:13985
    public static byte[] removeElements(final byte[] array, final byte... values) {//LC:13986
        if (isEmpty(array) || isEmpty(values)) {//LC:13987
            return clone(array);//LC:13988
        }//LC:13989
        final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);//LC:13990
        for (final byte v : values) {//LC:13991
            final Byte boxed = Byte.valueOf(v);//LC:13992
            final MutableInt count = occurrences.get(boxed);//LC:13993
            if (count == null) {//LC:13994
                occurrences.put(boxed, new MutableInt(1));//LC:13995
            } else {//LC:13996
                count.increment();//LC:13997
            }//LC:13998
        }//LC:13999
        final BitSet toRemove = new BitSet();//LC:14000
        for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {//LC:14001
            final Byte v = e.getKey();//LC:14002
            int found = 0;//LC:14003
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14004
                found = indexOf(array, v.byteValue(), found);//LC:14005
                if (found < 0) {//LC:14006
                    break;//LC:14007
                }//LC:14008
                toRemove.set(found++);//LC:14009
            }//LC:14010
        }//LC:14011
        return (byte[]) removeAll(array, toRemove);//LC:14012
    }//LC:14013
//LC:14014
    /**//LC:14015
     * <p>Removes the elements at the specified positions from the specified array.//LC:14016
     * All remaining elements are shifted to the left.</p>//LC:14017
     *//LC:14018
     * <p>This method returns a new array with the same elements of the input//LC:14019
     * array except those at the specified positions. The component//LC:14020
     * type of the returned array is always the same as that of the input//LC:14021
     * array.</p>//LC:14022
     *//LC:14023
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14024
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14025
     *//LC:14026
     * <pre>//LC:14027
     * ArrayUtils.removeAll([1], 0)             = []//LC:14028
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14029
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14030
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14031
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14032
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14033
     * </pre>//LC:14034
     *//LC:14035
     * @param array   the array to remove the element from, may not be {@code null}//LC:14036
     * @param indices the positions of the elements to be removed//LC:14037
     * @return A new array containing the existing elements except those//LC:14038
     *         at the specified positions.//LC:14039
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14040
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14041
     * @since 3.0.1//LC:14042
     *///LC:14043
    public static short[] removeAll(final short[] array, final int... indices) {//LC:14044
        return (short[]) removeAll((Object) array, clone(indices));//LC:14045
    }//LC:14046
//LC:14047
    /**//LC:14048
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14049
     * from the specified array. All subsequent elements are shifted left.//LC:14050
     * For any element-to-be-removed specified in greater quantities than//LC:14051
     * contained in the original array, no change occurs beyond the//LC:14052
     * removal of the existing matching items.</p>//LC:14053
     *//LC:14054
     * <p>This method returns a new array with the same elements of the input//LC:14055
     * array except for the earliest-encountered occurrences of the specified//LC:14056
     * elements. The component type of the returned array is always the same//LC:14057
     * as that of the input array.</p>//LC:14058
     *//LC:14059
     * <pre>//LC:14060
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14061
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14062
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14063
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14064
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14065
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14066
     * </pre>//LC:14067
     *//LC:14068
     * @param array  the array to remove the element from, may be {@code null}//LC:14069
     * @param values the elements to be removed//LC:14070
     * @return A new array containing the existing elements except the//LC:14071
     *         earliest-encountered occurrences of the specified elements.//LC:14072
     * @since 3.0.1//LC:14073
     *///LC:14074
    public static short[] removeElements(final short[] array, final short... values) {//LC:14075
        if (isEmpty(array) || isEmpty(values)) {//LC:14076
            return clone(array);//LC:14077
        }//LC:14078
        final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);//LC:14079
        for (final short v : values) {//LC:14080
            final Short boxed = Short.valueOf(v);//LC:14081
            final MutableInt count = occurrences.get(boxed);//LC:14082
            if (count == null) {//LC:14083
                occurrences.put(boxed, new MutableInt(1));//LC:14084
            } else {//LC:14085
                count.increment();//LC:14086
            }//LC:14087
        }//LC:14088
        final BitSet toRemove = new BitSet();//LC:14089
        for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {//LC:14090
            final Short v = e.getKey();//LC:14091
            int found = 0;//LC:14092
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14093
                found = indexOf(array, v.shortValue(), found);//LC:14094
                if (found < 0) {//LC:14095
                    break;//LC:14096
                }//LC:14097
                toRemove.set(found++);//LC:14098
            }//LC:14099
        }//LC:14100
        return (short[]) removeAll(array, toRemove);//LC:14101
    }//LC:14102
//LC:14103
    /**//LC:14104
     * <p>Removes the elements at the specified positions from the specified array.//LC:14105
     * All remaining elements are shifted to the left.</p>//LC:14106
     *//LC:14107
     * <p>This method returns a new array with the same elements of the input//LC:14108
     * array except those at the specified positions. The component//LC:14109
     * type of the returned array is always the same as that of the input//LC:14110
     * array.</p>//LC:14111
     *//LC:14112
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14113
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14114
     *//LC:14115
     * <pre>//LC:14116
     * ArrayUtils.removeAll([1], 0)             = []//LC:14117
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14118
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14119
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14120
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14121
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14122
     * </pre>//LC:14123
     *//LC:14124
     * @param array   the array to remove the element from, may not be {@code null}//LC:14125
     * @param indices the positions of the elements to be removed//LC:14126
     * @return A new array containing the existing elements except those//LC:14127
     *         at the specified positions.//LC:14128
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14129
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14130
     * @since 3.0.1//LC:14131
     *///LC:14132
    public static int[] removeAll(final int[] array, final int... indices) {//LC:14133
        return (int[]) removeAll((Object) array, clone(indices));//LC:14134
    }//LC:14135
//LC:14136
    /**//LC:14137
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14138
     * from the specified array. All subsequent elements are shifted left.//LC:14139
     * For any element-to-be-removed specified in greater quantities than//LC:14140
     * contained in the original array, no change occurs beyond the//LC:14141
     * removal of the existing matching items.</p>//LC:14142
     *//LC:14143
     * <p>This method returns a new array with the same elements of the input//LC:14144
     * array except for the earliest-encountered occurrences of the specified//LC:14145
     * elements. The component type of the returned array is always the same//LC:14146
     * as that of the input array.</p>//LC:14147
     *//LC:14148
     * <pre>//LC:14149
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14150
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14151
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14152
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14153
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14154
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14155
     * </pre>//LC:14156
     *//LC:14157
     * @param array  the array to remove the element from, may be {@code null}//LC:14158
     * @param values the elements to be removed//LC:14159
     * @return A new array containing the existing elements except the//LC:14160
     *         earliest-encountered occurrences of the specified elements.//LC:14161
     * @since 3.0.1//LC:14162
     *///LC:14163
    public static int[] removeElements(final int[] array, final int... values) {//LC:14164
        if (isEmpty(array) || isEmpty(values)) {//LC:14165
            return clone(array);//LC:14166
        }//LC:14167
        final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);//LC:14168
        for (final int v : values) {//LC:14169
            final Integer boxed = Integer.valueOf(v);//LC:14170
            final MutableInt count = occurrences.get(boxed);//LC:14171
            if (count == null) {//LC:14172
                occurrences.put(boxed, new MutableInt(1));//LC:14173
            } else {//LC:14174
                count.increment();//LC:14175
            }//LC:14176
        }//LC:14177
        final BitSet toRemove = new BitSet();//LC:14178
        for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {//LC:14179
            final Integer v = e.getKey();//LC:14180
            int found = 0;//LC:14181
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14182
                found = indexOf(array, v.intValue(), found);//LC:14183
                if (found < 0) {//LC:14184
                    break;//LC:14185
                }//LC:14186
                toRemove.set(found++);//LC:14187
            }//LC:14188
        }//LC:14189
        return (int[]) removeAll(array, toRemove);//LC:14190
    }//LC:14191
//LC:14192
    /**//LC:14193
     * <p>Removes the elements at the specified positions from the specified array.//LC:14194
     * All remaining elements are shifted to the left.</p>//LC:14195
     *//LC:14196
     * <p>This method returns a new array with the same elements of the input//LC:14197
     * array except those at the specified positions. The component//LC:14198
     * type of the returned array is always the same as that of the input//LC:14199
     * array.</p>//LC:14200
     *//LC:14201
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14202
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14203
     *//LC:14204
     * <pre>//LC:14205
     * ArrayUtils.removeAll([1], 0)             = []//LC:14206
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14207
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14208
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14209
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14210
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14211
     * </pre>//LC:14212
     *//LC:14213
     * @param array   the array to remove the element from, may not be {@code null}//LC:14214
     * @param indices the positions of the elements to be removed//LC:14215
     * @return A new array containing the existing elements except those//LC:14216
     *         at the specified positions.//LC:14217
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14218
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14219
     * @since 3.0.1//LC:14220
     *///LC:14221
    public static char[] removeAll(final char[] array, final int... indices) {//LC:14222
        return (char[]) removeAll((Object) array, clone(indices));//LC:14223
    }//LC:14224
//LC:14225
    /**//LC:14226
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14227
     * from the specified array. All subsequent elements are shifted left.//LC:14228
     * For any element-to-be-removed specified in greater quantities than//LC:14229
     * contained in the original array, no change occurs beyond the//LC:14230
     * removal of the existing matching items.</p>//LC:14231
     *//LC:14232
     * <p>This method returns a new array with the same elements of the input//LC:14233
     * array except for the earliest-encountered occurrences of the specified//LC:14234
     * elements. The component type of the returned array is always the same//LC:14235
     * as that of the input array.</p>//LC:14236
     *//LC:14237
     * <pre>//LC:14238
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14239
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14240
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14241
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14242
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14243
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14244
     * </pre>//LC:14245
     *//LC:14246
     * @param array  the array to remove the element from, may be {@code null}//LC:14247
     * @param values the elements to be removed//LC:14248
     * @return A new array containing the existing elements except the//LC:14249
     *         earliest-encountered occurrences of the specified elements.//LC:14250
     * @since 3.0.1//LC:14251
     *///LC:14252
    public static char[] removeElements(final char[] array, final char... values) {//LC:14253
        if (isEmpty(array) || isEmpty(values)) {//LC:14254
            return clone(array);//LC:14255
        }//LC:14256
        final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);//LC:14257
        for (final char v : values) {//LC:14258
            final Character boxed = Character.valueOf(v);//LC:14259
            final MutableInt count = occurrences.get(boxed);//LC:14260
            if (count == null) {//LC:14261
                occurrences.put(boxed, new MutableInt(1));//LC:14262
            } else {//LC:14263
                count.increment();//LC:14264
            }//LC:14265
        }//LC:14266
        final BitSet toRemove = new BitSet();//LC:14267
        for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {//LC:14268
            final Character v = e.getKey();//LC:14269
            int found = 0;//LC:14270
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14271
                found = indexOf(array, v.charValue(), found);//LC:14272
                if (found < 0) {//LC:14273
                    break;//LC:14274
                }//LC:14275
                toRemove.set(found++);//LC:14276
            }//LC:14277
        }//LC:14278
        return (char[]) removeAll(array, toRemove);//LC:14279
    }//LC:14280
//LC:14281
    /**//LC:14282
     * <p>Removes the elements at the specified positions from the specified array.//LC:14283
     * All remaining elements are shifted to the left.</p>//LC:14284
     *//LC:14285
     * <p>This method returns a new array with the same elements of the input//LC:14286
     * array except those at the specified positions. The component//LC:14287
     * type of the returned array is always the same as that of the input//LC:14288
     * array.</p>//LC:14289
     *//LC:14290
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14291
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14292
     *//LC:14293
     * <pre>//LC:14294
     * ArrayUtils.removeAll([1], 0)             = []//LC:14295
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14296
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14297
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14298
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14299
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14300
     * </pre>//LC:14301
     *//LC:14302
     * @param array   the array to remove the element from, may not be {@code null}//LC:14303
     * @param indices the positions of the elements to be removed//LC:14304
     * @return A new array containing the existing elements except those//LC:14305
     *         at the specified positions.//LC:14306
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14307
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14308
     * @since 3.0.1//LC:14309
     *///LC:14310
    public static long[] removeAll(final long[] array, final int... indices) {//LC:14311
        return (long[]) removeAll((Object) array, clone(indices));//LC:14312
    }//LC:14313
//LC:14314
    /**//LC:14315
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14316
     * from the specified array. All subsequent elements are shifted left.//LC:14317
     * For any element-to-be-removed specified in greater quantities than//LC:14318
     * contained in the original array, no change occurs beyond the//LC:14319
     * removal of the existing matching items.</p>//LC:14320
     *//LC:14321
     * <p>This method returns a new array with the same elements of the input//LC:14322
     * array except for the earliest-encountered occurrences of the specified//LC:14323
     * elements. The component type of the returned array is always the same//LC:14324
     * as that of the input array.</p>//LC:14325
     *//LC:14326
     * <pre>//LC:14327
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14328
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14329
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14330
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14331
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14332
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14333
     * </pre>//LC:14334
     *//LC:14335
     * @param array  the array to remove the element from, may be {@code null}//LC:14336
     * @param values the elements to be removed//LC:14337
     * @return A new array containing the existing elements except the//LC:14338
     *         earliest-encountered occurrences of the specified elements.//LC:14339
     * @since 3.0.1//LC:14340
     *///LC:14341
    public static long[] removeElements(final long[] array, final long... values) {//LC:14342
        if (isEmpty(array) || isEmpty(values)) {//LC:14343
            return clone(array);//LC:14344
        }//LC:14345
        final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);//LC:14346
        for (final long v : values) {//LC:14347
            final Long boxed = Long.valueOf(v);//LC:14348
            final MutableInt count = occurrences.get(boxed);//LC:14349
            if (count == null) {//LC:14350
                occurrences.put(boxed, new MutableInt(1));//LC:14351
            } else {//LC:14352
                count.increment();//LC:14353
            }//LC:14354
        }//LC:14355
        final BitSet toRemove = new BitSet();//LC:14356
        for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {//LC:14357
            final Long v = e.getKey();//LC:14358
            int found = 0;//LC:14359
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14360
                found = indexOf(array, v.longValue(), found);//LC:14361
                if (found < 0) {//LC:14362
                    break;//LC:14363
                }//LC:14364
                toRemove.set(found++);//LC:14365
            }//LC:14366
        }//LC:14367
        return (long[]) removeAll(array, toRemove);//LC:14368
    }//LC:14369
//LC:14370
    /**//LC:14371
     * <p>Removes the elements at the specified positions from the specified array.//LC:14372
     * All remaining elements are shifted to the left.</p>//LC:14373
     *//LC:14374
     * <p>This method returns a new array with the same elements of the input//LC:14375
     * array except those at the specified positions. The component//LC:14376
     * type of the returned array is always the same as that of the input//LC:14377
     * array.</p>//LC:14378
     *//LC:14379
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14380
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14381
     *//LC:14382
     * <pre>//LC:14383
     * ArrayUtils.removeAll([1], 0)             = []//LC:14384
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14385
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14386
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14387
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14388
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14389
     * </pre>//LC:14390
     *//LC:14391
     * @param array   the array to remove the element from, may not be {@code null}//LC:14392
     * @param indices the positions of the elements to be removed//LC:14393
     * @return A new array containing the existing elements except those//LC:14394
     *         at the specified positions.//LC:14395
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14396
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14397
     * @since 3.0.1//LC:14398
     *///LC:14399
    public static float[] removeAll(final float[] array, final int... indices) {//LC:14400
        return (float[]) removeAll((Object) array, clone(indices));//LC:14401
    }//LC:14402
//LC:14403
    /**//LC:14404
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14405
     * from the specified array. All subsequent elements are shifted left.//LC:14406
     * For any element-to-be-removed specified in greater quantities than//LC:14407
     * contained in the original array, no change occurs beyond the//LC:14408
     * removal of the existing matching items.</p>//LC:14409
     *//LC:14410
     * <p>This method returns a new array with the same elements of the input//LC:14411
     * array except for the earliest-encountered occurrences of the specified//LC:14412
     * elements. The component type of the returned array is always the same//LC:14413
     * as that of the input array.</p>//LC:14414
     *//LC:14415
     * <pre>//LC:14416
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14417
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14418
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14419
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14420
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14421
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14422
     * </pre>//LC:14423
     *//LC:14424
     * @param array  the array to remove the element from, may be {@code null}//LC:14425
     * @param values the elements to be removed//LC:14426
     * @return A new array containing the existing elements except the//LC:14427
     *         earliest-encountered occurrences of the specified elements.//LC:14428
     * @since 3.0.1//LC:14429
     *///LC:14430
    public static float[] removeElements(final float[] array, final float... values) {//LC:14431
        if (isEmpty(array) || isEmpty(values)) {//LC:14432
            return clone(array);//LC:14433
        }//LC:14434
        final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);//LC:14435
        for (final float v : values) {//LC:14436
            final Float boxed = Float.valueOf(v);//LC:14437
            final MutableInt count = occurrences.get(boxed);//LC:14438
            if (count == null) {//LC:14439
                occurrences.put(boxed, new MutableInt(1));//LC:14440
            } else {//LC:14441
                count.increment();//LC:14442
            }//LC:14443
        }//LC:14444
        final BitSet toRemove = new BitSet();//LC:14445
        for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {//LC:14446
            final Float v = e.getKey();//LC:14447
            int found = 0;//LC:14448
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14449
                found = indexOf(array, v.floatValue(), found);//LC:14450
                if (found < 0) {//LC:14451
                    break;//LC:14452
                }//LC:14453
                toRemove.set(found++);//LC:14454
            }//LC:14455
        }//LC:14456
        return (float[]) removeAll(array, toRemove);//LC:14457
    }//LC:14458
//LC:14459
    /**//LC:14460
     * <p>Removes the elements at the specified positions from the specified array.//LC:14461
     * All remaining elements are shifted to the left.</p>//LC:14462
     *//LC:14463
     * <p>This method returns a new array with the same elements of the input//LC:14464
     * array except those at the specified positions. The component//LC:14465
     * type of the returned array is always the same as that of the input//LC:14466
     * array.</p>//LC:14467
     *//LC:14468
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14469
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14470
     *//LC:14471
     * <pre>//LC:14472
     * ArrayUtils.removeAll([1], 0)             = []//LC:14473
     * ArrayUtils.removeAll([2, 6], 0)          = [6]//LC:14474
     * ArrayUtils.removeAll([2, 6], 0, 1)       = []//LC:14475
     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]//LC:14476
     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]//LC:14477
     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []//LC:14478
     * </pre>//LC:14479
     *//LC:14480
     * @param array   the array to remove the element from, may not be {@code null}//LC:14481
     * @param indices the positions of the elements to be removed//LC:14482
     * @return A new array containing the existing elements except those//LC:14483
     *         at the specified positions.//LC:14484
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14485
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14486
     * @since 3.0.1//LC:14487
     *///LC:14488
    public static double[] removeAll(final double[] array, final int... indices) {//LC:14489
        return (double[]) removeAll((Object) array, clone(indices));//LC:14490
    }//LC:14491
//LC:14492
    /**//LC:14493
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14494
     * from the specified array. All subsequent elements are shifted left.//LC:14495
     * For any element-to-be-removed specified in greater quantities than//LC:14496
     * contained in the original array, no change occurs beyond the//LC:14497
     * removal of the existing matching items.</p>//LC:14498
     *//LC:14499
     * <p>This method returns a new array with the same elements of the input//LC:14500
     * array except for the earliest-encountered occurrences of the specified//LC:14501
     * elements. The component type of the returned array is always the same//LC:14502
     * as that of the input array.</p>//LC:14503
     *//LC:14504
     * <pre>//LC:14505
     * ArrayUtils.removeElements(null, 1, 2)      = null//LC:14506
     * ArrayUtils.removeElements([], 1, 2)        = []//LC:14507
     * ArrayUtils.removeElements([1], 2, 3)       = [1]//LC:14508
     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]//LC:14509
     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]//LC:14510
     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]//LC:14511
     * </pre>//LC:14512
     *//LC:14513
     * @param array  the array to remove the element from, may be {@code null}//LC:14514
     * @param values the elements to be removed//LC:14515
     * @return A new array containing the existing elements except the//LC:14516
     *         earliest-encountered occurrences of the specified elements.//LC:14517
     * @since 3.0.1//LC:14518
     *///LC:14519
    public static double[] removeElements(final double[] array, final double... values) {//LC:14520
        if (isEmpty(array) || isEmpty(values)) {//LC:14521
            return clone(array);//LC:14522
        }//LC:14523
        final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);//LC:14524
        for (final double v : values) {//LC:14525
            final Double boxed = Double.valueOf(v);//LC:14526
            final MutableInt count = occurrences.get(boxed);//LC:14527
            if (count == null) {//LC:14528
                occurrences.put(boxed, new MutableInt(1));//LC:14529
            } else {//LC:14530
                count.increment();//LC:14531
            }//LC:14532
        }//LC:14533
        final BitSet toRemove = new BitSet();//LC:14534
        for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {//LC:14535
            final Double v = e.getKey();//LC:14536
            int found = 0;//LC:14537
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14538
                found = indexOf(array, v.doubleValue(), found);//LC:14539
                if (found < 0) {//LC:14540
                    break;//LC:14541
                }//LC:14542
                toRemove.set(found++);//LC:14543
            }//LC:14544
        }//LC:14545
        return (double[]) removeAll(array, toRemove);//LC:14546
    }//LC:14547
//LC:14548
    /**//LC:14549
     * <p>Removes the elements at the specified positions from the specified array.//LC:14550
     * All remaining elements are shifted to the left.</p>//LC:14551
     *//LC:14552
     * <p>This method returns a new array with the same elements of the input//LC:14553
     * array except those at the specified positions. The component//LC:14554
     * type of the returned array is always the same as that of the input//LC:14555
     * array.</p>//LC:14556
     *//LC:14557
     * <p>If the input array is {@code null}, an IndexOutOfBoundsException//LC:14558
     * will be thrown, because in that case no valid index can be specified.</p>//LC:14559
     *//LC:14560
     * <pre>//LC:14561
     * ArrayUtils.removeAll([true, false, true], 0, 2) = [false]//LC:14562
     * ArrayUtils.removeAll([true, false, true], 1, 2) = [true]//LC:14563
     * </pre>//LC:14564
     *//LC:14565
     * @param array   the array to remove the element from, may not be {@code null}//LC:14566
     * @param indices the positions of the elements to be removed//LC:14567
     * @return A new array containing the existing elements except those//LC:14568
     *         at the specified positions.//LC:14569
     * @throws IndexOutOfBoundsException if any index is out of range//LC:14570
     * (index < 0 || index >= array.length), or if the array is {@code null}.//LC:14571
     * @since 3.0.1//LC:14572
     *///LC:14573
    public static boolean[] removeAll(final boolean[] array, final int... indices) {//LC:14574
        return (boolean[]) removeAll((Object) array, clone(indices));//LC:14575
    }//LC:14576
//LC:14577
    /**//LC:14578
     * <p>Removes occurrences of specified elements, in specified quantities,//LC:14579
     * from the specified array. All subsequent elements are shifted left.//LC:14580
     * For any element-to-be-removed specified in greater quantities than//LC:14581
     * contained in the original array, no change occurs beyond the//LC:14582
     * removal of the existing matching items.</p>//LC:14583
     *//LC:14584
     * <p>This method returns a new array with the same elements of the input//LC:14585
     * array except for the earliest-encountered occurrences of the specified//LC:14586
     * elements. The component type of the returned array is always the same//LC:14587
     * as that of the input array.</p>//LC:14588
     *//LC:14589
     * <pre>//LC:14590
     * ArrayUtils.removeElements(null, true, false)               = null//LC:14591
     * ArrayUtils.removeElements([], true, false)                 = []//LC:14592
     * ArrayUtils.removeElements([true], false, false)            = [true]//LC:14593
     * ArrayUtils.removeElements([true, false], true, true)       = [false]//LC:14594
     * ArrayUtils.removeElements([true, false, true], true)       = [false, true]//LC:14595
     * ArrayUtils.removeElements([true, false, true], true, true) = [false]//LC:14596
     * </pre>//LC:14597
     *//LC:14598
     * @param array  the array to remove the element from, may be {@code null}//LC:14599
     * @param values the elements to be removed//LC:14600
     * @return A new array containing the existing elements except the//LC:14601
     *         earliest-encountered occurrences of the specified elements.//LC:14602
     * @since 3.0.1//LC:14603
     *///LC:14604
    public static boolean[] removeElements(final boolean[] array, final boolean... values) {//LC:14605
        if (isEmpty(array) || isEmpty(values)) {//LC:14606
            return clone(array);//LC:14607
        }//LC:14608
        final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); // only two possible values here//LC:14609
        for (final boolean v : values) {//LC:14610
            final Boolean boxed = Boolean.valueOf(v);//LC:14611
            final MutableInt count = occurrences.get(boxed);//LC:14612
            if (count == null) {//LC:14613
                occurrences.put(boxed, new MutableInt(1));//LC:14614
            } else {//LC:14615
                count.increment();//LC:14616
            }//LC:14617
        }//LC:14618
        final BitSet toRemove = new BitSet();//LC:14619
        for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {//LC:14620
            final Boolean v = e.getKey();//LC:14621
            int found = 0;//LC:14622
            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {//LC:14623
                found = indexOf(array, v.booleanValue(), found);//LC:14624
                if (found < 0) {//LC:14625
                    break;//LC:14626
                }//LC:14627
                toRemove.set(found++);//LC:14628
            }//LC:14629
        }//LC:14630
        return (boolean[]) removeAll(array, toRemove);//LC:14631
    }//LC:14632
//LC:14633
    /**//LC:14634
     * Removes multiple array elements specified by index.//LC:14635
     * @param array source//LC:14636
     * @param indices to remove, WILL BE SORTED--so only clones of user-owned arrays!//LC:14637
     * @return new array of same type minus elements specified by unique values of {@code indices}//LC:14638
     * @since 3.0.1//LC:14639
     *///LC:14640
    // package protected for access by unit tests//LC:14641
    static Object removeAll(final Object array, final int... indices) {//LC:14642
        final int length = getLength(array);//LC:14643
        int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed//LC:14644
//LC:14645
        if (isNotEmpty(indices)) {//LC:14646
            Arrays.sort(indices);//LC:14647
//LC:14648
            int i = indices.length;//LC:14649
            int prevIndex = length;//LC:14650
            while (--i >= 0) {//LC:14651
                final int index = indices[i];//LC:14652
                if (index < 0 || index >= length) {//LC:14653
                    throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);//LC:14654
                }//LC:14655
                if (index >= prevIndex) {//LC:14656
                    continue;//LC:14657
                }//LC:14658
                diff++;//LC:14659
                prevIndex = index;//LC:14660
            }//LC:14661
        }//LC:14662
        final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);//LC:14663
        if (diff < length) {//LC:14664
            int end = length; // index just after last copy//LC:14665
            int dest = length - diff; // number of entries so far not copied//LC:14666
            for (int i = indices.length - 1; i >= 0; i--) {//LC:14667
                final int index = indices[i];//LC:14668
                if (end - index > 1) { // same as (cp > 0)//LC:14669
                    final int cp = end - index - 1;//LC:14670
                    dest -= cp;//LC:14671
                    System.arraycopy(array, index + 1, result, dest, cp);//LC:14672
                    // Afer this copy, we still have room for dest items.//LC:14673
                }//LC:14674
                end = index;//LC:14675
            }//LC:14676
            if (end > 0) {//LC:14677
                System.arraycopy(array, 0, result, 0, end);//LC:14678
            }//LC:14679
        }//LC:14680
        return result;//LC:14681
    }//LC:14682
//LC:14683
    /**//LC:14684
     * Removes multiple array elements specified by indices.//LC:14685
     *//LC:14686
     * @param array source//LC:14687
     * @param indices to remove//LC:14688
     * @return new array of same type minus elements specified by the set bits in {@code indices}//LC:14689
     * @since 3.2//LC:14690
     *///LC:14691
    // package protected for access by unit tests//LC:14692
    static Object removeAll(final Object array, final BitSet indices) {//LC:14693
        final int srcLength = ArrayUtils.getLength(array);//LC:14694
        // No need to check maxIndex here, because method only currently called from removeElements()//LC:14695
        // which guarantee to generate on;y valid bit entries.//LC:14696
//        final int maxIndex = indices.length();//LC:14697
//        if (maxIndex > srcLength) {//LC:14698
//            throw new IndexOutOfBoundsException("Index: " + (maxIndex-1) + ", Length: " + srcLength);//LC:14699
//        }//LC:14700
        final int removals = indices.cardinality(); // true bits are items to remove//LC:14701
        final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);//LC:14702
        int srcIndex=0;//LC:14703
        int destIndex=0;//LC:14704
        int count;//LC:14705
        int set;//LC:14706
        while((set = indices.nextSetBit(srcIndex)) != -1){//LC:14707
            count = set - srcIndex;//LC:14708
            if (count > 0) {//LC:14709
                System.arraycopy(array, srcIndex, result, destIndex, count);//LC:14710
                destIndex += count;//LC:14711
            }//LC:14712
            srcIndex = indices.nextClearBit(set);//LC:14713
        }//LC:14714
        count = srcLength - srcIndex;//LC:14715
        if (count > 0) {//LC:14716
            System.arraycopy(array, srcIndex, result, destIndex, count);//LC:14717
        }//LC:14718
        return result;//LC:14719
    }//LC:14720
}//LC:14721
//LC:14722
//LC:14723
/**//LC:14724
 * <p>Operations on {@code Object}.</p>//LC:14725
 *//LC:14726
 * <p>This class tries to handle {@code null} input gracefully.//LC:14727
 * An exception will generally not be thrown for a {@code null} input.//LC:14728
 * Each method documents its behaviour in more detail.</p>//LC:14729
 *//LC:14730
 * <p>#ThreadSafe#</p>//LC:14731
 * @since 1.0//LC:14732
 * @version $Id$//LC:14733
 *///LC:14734
//@Immutable//LC:14735
class ObjectUtils {//LC:14736
//LC:14737
    /**//LC:14738
     * <p>Singleton used as a {@code null} placeholder where//LC:14739
     * {@code null} has another meaning.</p>//LC:14740
     *//LC:14741
     * <p>For example, in a {@code HashMap} the//LC:14742
     * {@link java.util.HashMap#get(java.lang.Object)} method returns//LC:14743
     * {@code null} if the {@code Map} contains {@code null} or if there//LC:14744
     * is no matching key. The {@code Null} placeholder can be used to//LC:14745
     * distinguish between these two cases.</p>//LC:14746
     *//LC:14747
     * <p>Another example is {@code Hashtable}, where {@code null}//LC:14748
     * cannot be stored.</p>//LC:14749
     *//LC:14750
     * <p>This instance is Serializable.</p>//LC:14751
     *///LC:14752
    public static final Null NULL = new Null();//LC:14753
//LC:14754
    /**//LC:14755
     * <p>{@code ObjectUtils} instances should NOT be constructed in//LC:14756
     * standard programming. Instead, the static methods on the class should//LC:14757
     * be used, such as {@code ObjectUtils.defaultIfNull("a","b");}.</p>//LC:14758
     *//LC:14759
     * <p>This constructor is public to permit tools that require a JavaBean//LC:14760
     * instance to operate.</p>//LC:14761
     *///LC:14762
    public ObjectUtils() {//LC:14763
        super();//LC:14764
    }//LC:14765
//LC:14766
    // Defaulting//LC:14767
    //-----------------------------------------------------------------------//LC:14768
    /**//LC:14769
     * <p>Returns a default value if the object passed is {@code null}.</p>//LC:14770
     *//LC:14771
     * <pre>//LC:14772
     * ObjectUtils.defaultIfNull(null, null)      = null//LC:14773
     * ObjectUtils.defaultIfNull(null, "")        = ""//LC:14774
     * ObjectUtils.defaultIfNull(null, "zz")      = "zz"//LC:14775
     * ObjectUtils.defaultIfNull("abc", *)        = "abc"//LC:14776
     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE//LC:14777
     * </pre>//LC:14778
     *//LC:14779
     * @param <T> the type of the object//LC:14780
     * @param object  the {@code Object} to test, may be {@code null}//LC:14781
     * @param defaultValue  the default value to return, may be {@code null}//LC:14782
     * @return {@code object} if it is not {@code null}, defaultValue otherwise//LC:14783
     *///LC:14784
    public static <T> T defaultIfNull(final T object, final T defaultValue) {//LC:14785
        return object != null ? object : defaultValue;//LC:14786
    }//LC:14787
//LC:14788
    /**//LC:14789
     * <p>Returns the first value in the array which is not {@code null}.//LC:14790
     * If all the values are {@code null} or the array is {@code null}//LC:14791
     * or empty then {@code null} is returned.</p>//LC:14792
     *//LC:14793
     * <pre>//LC:14794
     * ObjectUtils.firstNonNull(null, null)      = null//LC:14795
     * ObjectUtils.firstNonNull(null, "")        = ""//LC:14796
     * ObjectUtils.firstNonNull(null, null, "")  = ""//LC:14797
     * ObjectUtils.firstNonNull(null, "zz")      = "zz"//LC:14798
     * ObjectUtils.firstNonNull("abc", *)        = "abc"//LC:14799
     * ObjectUtils.firstNonNull(null, "xyz", *)  = "xyz"//LC:14800
     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE//LC:14801
     * ObjectUtils.firstNonNull()                = null//LC:14802
     * </pre>//LC:14803
     *//LC:14804
     * @param <T> the component type of the array//LC:14805
     * @param values  the values to test, may be {@code null} or empty//LC:14806
     * @return the first value from {@code values} which is not {@code null},//LC:14807
     *  or {@code null} if there are no non-null values//LC:14808
     * @since 3.0//LC:14809
     *///LC:14810
    public static <T> T firstNonNull(final T... values) {//LC:14811
        if (values != null) {//LC:14812
            for (final T val : values) {//LC:14813
                if (val != null) {//LC:14814
                    return val;//LC:14815
                }//LC:14816
            }//LC:14817
        }//LC:14818
        return null;//LC:14819
    }//LC:14820
//LC:14821
    // Null-safe equals/hashCode//LC:14822
    //-----------------------------------------------------------------------//LC:14823
    /**//LC:14824
     * <p>Compares two objects for equality, where either one or both//LC:14825
     * objects may be {@code null}.</p>//LC:14826
     *//LC:14827
     * <pre>//LC:14828
     * ObjectUtils.equals(null, null)                  = true//LC:14829
     * ObjectUtils.equals(null, "")                    = false//LC:14830
     * ObjectUtils.equals("", null)                    = false//LC:14831
     * ObjectUtils.equals("", "")                      = true//LC:14832
     * ObjectUtils.equals(Boolean.TRUE, null)          = false//LC:14833
     * ObjectUtils.equals(Boolean.TRUE, "true")        = false//LC:14834
     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true//LC:14835
     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false//LC:14836
     * </pre>//LC:14837
     *//LC:14838
     * @param object1  the first object, may be {@code null}//LC:14839
     * @param object2  the second object, may be {@code null}//LC:14840
     * @return {@code true} if the values of both objects are the same//LC:14841
     *///LC:14842
    public static boolean equals(final Object object1, final Object object2) {//LC:14843
        if (object1 == object2) {//LC:14844
            return true;//LC:14845
        }//LC:14846
        if (object1 == null || object2 == null) {//LC:14847
            return false;//LC:14848
        }//LC:14849
        return object1.equals(object2);//LC:14850
    }//LC:14851
//LC:14852
    /**//LC:14853
     * <p>Compares two objects for inequality, where either one or both//LC:14854
     * objects may be {@code null}.</p>//LC:14855
     *//LC:14856
     * <pre>//LC:14857
     * ObjectUtils.notEqual(null, null)                  = false//LC:14858
     * ObjectUtils.notEqual(null, "")                    = true//LC:14859
     * ObjectUtils.notEqual("", null)                    = true//LC:14860
     * ObjectUtils.notEqual("", "")                      = false//LC:14861
     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true//LC:14862
     * ObjectUtils.notEqual(Boolean.TRUE, "true")        = true//LC:14863
     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false//LC:14864
     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true//LC:14865
     * </pre>//LC:14866
     *//LC:14867
     * @param object1  the first object, may be {@code null}//LC:14868
     * @param object2  the second object, may be {@code null}//LC:14869
     * @return {@code false} if the values of both objects are the same//LC:14870
     *///LC:14871
    public static boolean notEqual(final Object object1, final Object object2) {//LC:14872
        return ObjectUtils.equals(object1, object2) == false;//LC:14873
    }//LC:14874
//LC:14875
    /**//LC:14876
     * <p>Gets the hash code of an object returning zero when the//LC:14877
     * object is {@code null}.</p>//LC:14878
     *//LC:14879
     * <pre>//LC:14880
     * ObjectUtils.hashCode(null)   = 0//LC:14881
     * ObjectUtils.hashCode(obj)    = obj.hashCode()//LC:14882
     * </pre>//LC:14883
     *//LC:14884
     * @param obj  the object to obtain the hash code of, may be {@code null}//LC:14885
     * @return the hash code of the object, or zero if null//LC:14886
     * @since 2.1//LC:14887
     *///LC:14888
    public static int hashCode(final Object obj) {//LC:14889
        // hashCode(Object) retained for performance, as hash code is often critical//LC:14890
        return obj == null ? 0 : obj.hashCode();//LC:14891
    }//LC:14892
//LC:14893
    /**//LC:14894
     * <p>Gets the hash code for multiple objects.</p>//LC:14895
     *//LC:14896
     * <p>This allows a hash code to be rapidly calculated for a number of objects.//LC:14897
     * The hash code for a single object is the <em>not</em> same as {@link #hashCode(Object)}.//LC:14898
     * The hash code for multiple objects is the same as that calculated by an//LC:14899
     * {@code ArrayList} containing the specified objects.</p>//LC:14900
     *//LC:14901
     * <pre>//LC:14902
     * ObjectUtils.hashCodeMulti()                 = 1//LC:14903
     * ObjectUtils.hashCodeMulti((Object[]) null)  = 1//LC:14904
     * ObjectUtils.hashCodeMulti(a)                = 31 + a.hashCode()//LC:14905
     * ObjectUtils.hashCodeMulti(a,b)              = (31 + a.hashCode()) * 31 + b.hashCode()//LC:14906
     * ObjectUtils.hashCodeMulti(a,b,c)            = ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode()//LC:14907
     * </pre>//LC:14908
     *//LC:14909
     * @param objects  the objects to obtain the hash code of, may be {@code null}//LC:14910
     * @return the hash code of the objects, or zero if null//LC:14911
     * @since 3.0//LC:14912
     *///LC:14913
    public static int hashCodeMulti(final Object... objects) {//LC:14914
        int hash = 1;//LC:14915
        if (objects != null) {//LC:14916
            for (final Object object : objects) {//LC:14917
                hash = hash * 31 + ObjectUtils.hashCode(object);//LC:14918
            }//LC:14919
        }//LC:14920
        return hash;//LC:14921
    }//LC:14922
//LC:14923
    // Identity ToString//LC:14924
    //-----------------------------------------------------------------------//LC:14925
    /**//LC:14926
     * <p>Gets the toString that would be produced by {@code Object}//LC:14927
     * if a class did not override toString itself. {@code null}//LC:14928
     * will return {@code null}.</p>//LC:14929
     *//LC:14930
     * <pre>//LC:14931
     * ObjectUtils.identityToString(null)         = null//LC:14932
     * ObjectUtils.identityToString("")           = "java.lang.String@1e23"//LC:14933
     * ObjectUtils.identityToString(Boolean.TRUE) = "java.lang.Boolean@7fa"//LC:14934
     * </pre>//LC:14935
     *//LC:14936
     * @param object  the object to create a toString for, may be//LC:14937
     *  {@code null}//LC:14938
     * @return the default toString text, or {@code null} if//LC:14939
     *  {@code null} passed in//LC:14940
     *///LC:14941
    public static String identityToString(final Object object) {//LC:14942
        if (object == null) {//LC:14943
            return null;//LC:14944
        }//LC:14945
        final StringBuilder builder = new StringBuilder();//LC:14946
        identityToString(builder, object);//LC:14947
        return builder.toString();//LC:14948
    }//LC:14949
//LC:14950
    /**//LC:14951
     * <p>Appends the toString that would be produced by {@code Object}//LC:14952
     * if a class did not override toString itself. {@code null}//LC:14953
     * will throw a NullPointerException for either of the two parameters. </p>//LC:14954
     *//LC:14955
     * <pre>//LC:14956
     * ObjectUtils.identityToString(appendable, "")            = appendable.append("java.lang.String@1e23"//LC:14957
     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append("java.lang.Boolean@7fa"//LC:14958
     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append("java.lang.Boolean@7fa")//LC:14959
     * </pre>//LC:14960
     *//LC:14961
     * @param appendable  the appendable to append to//LC:14962
     * @param object  the object to create a toString for//LC:14963
     * @throws IOException//LC:14964
     * @since 3.2//LC:14965
     *///LC:14966
    public static void identityToString(final Appendable appendable, final Object object) throws IOException {//LC:14967
        if (object == null) {//LC:14968
            throw new NullPointerException("Cannot get the toString of a null identity");//LC:14969
        }//LC:14970
        appendable.append(object.getClass().getName())//LC:14971
                .append('@')//LC:14972
                .append(Integer.toHexString(System.identityHashCode(object)));//LC:14973
    }//LC:14974
//LC:14975
    /**//LC:14976
     * <p>Appends the toString that would be produced by {@code Object}//LC:14977
     * if a class did not override toString itself. {@code null}//LC:14978
     * will throw a NullPointerException for either of the two parameters. </p>//LC:14979
     *//LC:14980
     * <pre>//LC:14981
     * ObjectUtils.identityToString(builder, "")            = builder.append("java.lang.String@1e23"//LC:14982
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa"//LC:14983
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa")//LC:14984
     * </pre>//LC:14985
     *//LC:14986
     * @param builder  the builder to append to//LC:14987
     * @param object  the object to create a toString for//LC:14988
     * @since 3.2//LC:14989
     *///LC:14990
    public static void identityToString(final StrBuilder builder, final Object object) {//LC:14991
        if (object == null) {//LC:14992
            throw new NullPointerException("Cannot get the toString of a null identity");//LC:14993
        }//LC:14994
        builder.append(object.getClass().getName())//LC:14995
                .append('@')//LC:14996
                .append(Integer.toHexString(System.identityHashCode(object)));//LC:14997
    }//LC:14998
//LC:14999
    /**//LC:15000
     * <p>Appends the toString that would be produced by {@code Object}//LC:15001
     * if a class did not override toString itself. {@code null}//LC:15002
     * will throw a NullPointerException for either of the two parameters. </p>//LC:15003
     *//LC:15004
     * <pre>//LC:15005
     * ObjectUtils.identityToString(buf, "")            = buf.append("java.lang.String@1e23"//LC:15006
     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append("java.lang.Boolean@7fa"//LC:15007
     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append("java.lang.Boolean@7fa")//LC:15008
     * </pre>//LC:15009
     *//LC:15010
     * @param buffer  the buffer to append to//LC:15011
     * @param object  the object to create a toString for//LC:15012
     * @since 2.4//LC:15013
     *///LC:15014
    public static void identityToString(final StringBuffer buffer, final Object object) {//LC:15015
        if (object == null) {//LC:15016
            throw new NullPointerException("Cannot get the toString of a null identity");//LC:15017
        }//LC:15018
        buffer.append(object.getClass().getName())//LC:15019
                .append('@')//LC:15020
                .append(Integer.toHexString(System.identityHashCode(object)));//LC:15021
    }//LC:15022
//LC:15023
    /**//LC:15024
     * <p>Appends the toString that would be produced by {@code Object}//LC:15025
     * if a class did not override toString itself. {@code null}//LC:15026
     * will throw a NullPointerException for either of the two parameters. </p>//LC:15027
     *//LC:15028
     * <pre>//LC:15029
     * ObjectUtils.identityToString(builder, "")            = builder.append("java.lang.String@1e23"//LC:15030
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa"//LC:15031
     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append("java.lang.Boolean@7fa")//LC:15032
     * </pre>//LC:15033
     *//LC:15034
     * @param builder  the builder to append to//LC:15035
     * @param object  the object to create a toString for//LC:15036
     * @since 3.2//LC:15037
     *///LC:15038
    public static void identityToString(final StringBuilder builder, final Object object) {//LC:15039
        if (object == null) {//LC:15040
            throw new NullPointerException("Cannot get the toString of a null identity");//LC:15041
        }//LC:15042
        builder.append(object.getClass().getName())//LC:15043
                .append('@')//LC:15044
                .append(Integer.toHexString(System.identityHashCode(object)));//LC:15045
    }//LC:15046
//LC:15047
    // ToString//LC:15048
    //-----------------------------------------------------------------------//LC:15049
    /**//LC:15050
     * <p>Gets the {@code toString} of an {@code Object} returning//LC:15051
     * an empty string ("") if {@code null} input.</p>//LC:15052
     *//LC:15053
     * <pre>//LC:15054
     * ObjectUtils.toString(null)         = ""//LC:15055
     * ObjectUtils.toString("")           = ""//LC:15056
     * ObjectUtils.toString("bat")        = "bat"//LC:15057
     * ObjectUtils.toString(Boolean.TRUE) = "true"//LC:15058
     * </pre>//LC:15059
     *//LC:15060
     * @see StringUtils#defaultString(String)//LC:15061
     * @see String#valueOf(Object)//LC:15062
     * @param obj  the Object to {@code toString}, may be null//LC:15063
     * @return the passed in Object's toString, or {@code ""} if {@code null} input//LC:15064
     * @since 2.0//LC:15065
     *///LC:15066
    public static String toString(final Object obj) {//LC:15067
        return obj == null ? "" : obj.toString();//LC:15068
    }//LC:15069
//LC:15070
    /**//LC:15071
     * <p>Gets the {@code toString} of an {@code Object} returning//LC:15072
     * a specified text if {@code null} input.</p>//LC:15073
     *//LC:15074
     * <pre>//LC:15075
     * ObjectUtils.toString(null, null)           = null//LC:15076
     * ObjectUtils.toString(null, "null")         = "null"//LC:15077
     * ObjectUtils.toString("", "null")           = ""//LC:15078
     * ObjectUtils.toString("bat", "null")        = "bat"//LC:15079
     * ObjectUtils.toString(Boolean.TRUE, "null") = "true"//LC:15080
     * </pre>//LC:15081
     *//LC:15082
     * @see StringUtils#defaultString(String,String)//LC:15083
     * @see String#valueOf(Object)//LC:15084
     * @param obj  the Object to {@code toString}, may be null//LC:15085
     * @param nullStr  the String to return if {@code null} input, may be null//LC:15086
     * @return the passed in Object's toString, or {@code nullStr} if {@code null} input//LC:15087
     * @since 2.0//LC:15088
     *///LC:15089
    public static String toString(final Object obj, final String nullStr) {//LC:15090
        return obj == null ? nullStr : obj.toString();//LC:15091
    }//LC:15092
//LC:15093
    // Comparable//LC:15094
    //-----------------------------------------------------------------------//LC:15095
    /**//LC:15096
     * <p>Null safe comparison of Comparables.</p>//LC:15097
     *//LC:15098
     * @param <T> type of the values processed by this method//LC:15099
     * @param values the set of comparable values, may be null//LC:15100
     * @return//LC:15101
     *  <ul>//LC:15102
     *   <li>If any objects are non-null and unequal, the lesser object.//LC:15103
     *   <li>If all objects are non-null and equal, the first.//LC:15104
     *   <li>If any of the comparables are null, the lesser of the non-null objects.//LC:15105
     *   <li>If all the comparables are null, null is returned.//LC:15106
     *  </ul>//LC:15107
     *///LC:15108
    public static <T extends Comparable<? super T>> T min(final T... values) {//LC:15109
        T result = null;//LC:15110
        if (values != null) {//LC:15111
            for (final T value : values) {//LC:15112
                if (compare(value, result, true) < 0) {//LC:15113
                    result = value;//LC:15114
                }//LC:15115
            }//LC:15116
        }//LC:15117
        return result;//LC:15118
    }//LC:15119
//LC:15120
    /**//LC:15121
     * <p>Null safe comparison of Comparables.</p>//LC:15122
     *//LC:15123
     * @param <T> type of the values processed by this method//LC:15124
     * @param values the set of comparable values, may be null//LC:15125
     * @return//LC:15126
     *  <ul>//LC:15127
     *   <li>If any objects are non-null and unequal, the greater object.//LC:15128
     *   <li>If all objects are non-null and equal, the first.//LC:15129
     *   <li>If any of the comparables are null, the greater of the non-null objects.//LC:15130
     *   <li>If all the comparables are null, null is returned.//LC:15131
     *  </ul>//LC:15132
     *///LC:15133
    public static <T extends Comparable<? super T>> T max(final T... values) {//LC:15134
        T result = null;//LC:15135
        if (values != null) {//LC:15136
            for (final T value : values) {//LC:15137
                if (compare(value, result, false) > 0) {//LC:15138
                    result = value;//LC:15139
                }//LC:15140
            }//LC:15141
        }//LC:15142
        return result;//LC:15143
    }//LC:15144
//LC:15145
    /**//LC:15146
     * <p>Null safe comparison of Comparables.//LC:15147
     * {@code null} is assumed to be less than a non-{@code null} value.</p>//LC:15148
     *//LC:15149
     * @param <T> type of the values processed by this method//LC:15150
     * @param c1  the first comparable, may be null//LC:15151
     * @param c2  the second comparable, may be null//LC:15152
     * @return a negative value if c1 < c2, zero if c1 = c2//LC:15153
     *  and a positive value if c1 > c2//LC:15154
     *///LC:15155
    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {//LC:15156
        return compare(c1, c2, false);//LC:15157
    }//LC:15158
//LC:15159
    /**//LC:15160
     * <p>Null safe comparison of Comparables.</p>//LC:15161
     *//LC:15162
     * @param <T> type of the values processed by this method//LC:15163
     * @param c1  the first comparable, may be null//LC:15164
     * @param c2  the second comparable, may be null//LC:15165
     * @param nullGreater if true {@code null} is considered greater//LC:15166
     *  than a non-{@code null} value or if false {@code null} is//LC:15167
     *  considered less than a Non-{@code null} value//LC:15168
     * @return a negative value if c1 < c2, zero if c1 = c2//LC:15169
     *  and a positive value if c1 > c2//LC:15170
     * @see java.util.Comparator#compare(Object, Object)//LC:15171
     *///LC:15172
    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {//LC:15173
        if (c1 == c2) {//LC:15174
            return 0;//LC:15175
        } else if (c1 == null) {//LC:15176
            return nullGreater ? 1 : -1;//LC:15177
        } else if (c2 == null) {//LC:15178
            return nullGreater ? -1 : 1;//LC:15179
        }//LC:15180
        return c1.compareTo(c2);//LC:15181
    }//LC:15182
//LC:15183
    /**//LC:15184
     * Find the "best guess" middle value among comparables. If there is an even//LC:15185
     * number of total values, the lower of the two middle values will be returned.//LC:15186
     * @param <T> type of values processed by this method//LC:15187
     * @param items to compare//LC:15188
     * @return T at middle position//LC:15189
     * @throws NullPointerException if items is {@code null}//LC:15190
     * @throws IllegalArgumentException if items is empty or contains {@code null} values//LC:15191
     * @since 3.0.1//LC:15192
     *///LC:15193
    public static <T extends Comparable<? super T>> T median(final T... items) {//LC:15194
        Validate.notEmpty(items);//LC:15195
        Validate.noNullElements(items);//LC:15196
        final TreeSet<T> sort = new TreeSet<T>();//LC:15197
        Collections.addAll(sort, items);//LC:15198
        @SuppressWarnings("unchecked") //we know all items added were T instances//LC:15199
        final//LC:15200
        T result = (T) sort.toArray()[(sort.size() - 1) / 2];//LC:15201
        return result;//LC:15202
    }//LC:15203
//LC:15204
    /**//LC:15205
     * Find the "best guess" middle value among comparables. If there is an even//LC:15206
     * number of total values, the lower of the two middle values will be returned.//LC:15207
     * @param <T> type of values processed by this method//LC:15208
     * @param comparator to use for comparisons//LC:15209
     * @param items to compare//LC:15210
     * @return T at middle position//LC:15211
     * @throws NullPointerException if items or comparator is {@code null}//LC:15212
     * @throws IllegalArgumentException if items is empty or contains {@code null} values//LC:15213
     * @since 3.0.1//LC:15214
     *///LC:15215
    public static <T> T median(final Comparator<T> comparator, final T... items) {//LC:15216
        Validate.notEmpty(items, "null/empty items");//LC:15217
        Validate.noNullElements(items);//LC:15218
        Validate.notNull(comparator, "null comparator");//LC:15219
        final TreeSet<T> sort = new TreeSet<T>(comparator);//LC:15220
        Collections.addAll(sort, items);//LC:15221
        @SuppressWarnings("unchecked") //we know all items added were T instances//LC:15222
        final//LC:15223
        T result = (T) sort.toArray()[(sort.size() - 1) / 2];//LC:15224
        return result;//LC:15225
    }//LC:15226
//LC:15227
    // Mode//LC:15228
    //-----------------------------------------------------------------------//LC:15229
    /**//LC:15230
     * Find the most frequently occurring item.//LC:15231
     *//LC:15232
     * @param <T> type of values processed by this method//LC:15233
     * @param items to check//LC:15234
     * @return most populous T, {@code null} if non-unique or no items supplied//LC:15235
     * @since 3.0.1//LC:15236
     *///LC:15237
    public static <T> T mode(final T... items) {//LC:15238
        if (ArrayUtils.isNotEmpty(items)) {//LC:15239
            final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);//LC:15240
            for (final T t : items) {//LC:15241
                final MutableInt count = occurrences.get(t);//LC:15242
                if (count == null) {//LC:15243
                    occurrences.put(t, new MutableInt(1));//LC:15244
                } else {//LC:15245
                    count.increment();//LC:15246
                }//LC:15247
            }//LC:15248
            T result = null;//LC:15249
            int max = 0;//LC:15250
            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {//LC:15251
                final int cmp = e.getValue().intValue();//LC:15252
                if (cmp == max) {//LC:15253
                    result = null;//LC:15254
                } else if (cmp > max) {//LC:15255
                    max = cmp;//LC:15256
                    result = e.getKey();//LC:15257
                }//LC:15258
            }//LC:15259
            return result;//LC:15260
        }//LC:15261
        return null;//LC:15262
    }//LC:15263
//LC:15264
    // cloning//LC:15265
    //-----------------------------------------------------------------------//LC:15266
    /**//LC:15267
     * <p>Clone an object.</p>//LC:15268
     *//LC:15269
     * @param <T> the type of the object//LC:15270
     * @param obj  the object to clone, null returns null//LC:15271
     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}//LC:15272
     * @throws CloneFailedException if the object is cloneable and the clone operation fails//LC:15273
     * @since 3.0//LC:15274
     *///LC:15275
    public static <T> T clone(final T obj) throws Exception {//LC:15276
        if (obj instanceof Cloneable) {//LC:15277
            final Object result;//LC:15278
            if (obj.getClass().isArray()) {//LC:15279
                final Class<?> componentType = obj.getClass().getComponentType();//LC:15280
                if (!componentType.isPrimitive()) {//LC:15281
                    result = ((Object[]) obj).clone();//LC:15282
                } else {//LC:15283
                    int length = Array.getLength(obj);//LC:15284
                    result = Array.newInstance(componentType, length);//LC:15285
                    while (length-- > 0) {//LC:15286
                        Array.set(result, length, Array.get(obj, length));//LC:15287
                    }//LC:15288
                }//LC:15289
            } else {//LC:15290
                try {//LC:15291
                    final Method clone = obj.getClass().getMethod("clone");//LC:15292
                    result = clone.invoke(obj);//LC:15293
                } catch (final NoSuchMethodException e) {//LC:15294
                    throw new Exception("Cloneable type "//LC:15295
                            + obj.getClass().getName()//LC:15296
                            + " has no clone method", e);//LC:15297
                } catch (final IllegalAccessException e) {//LC:15298
                    throw new Exception("Cannot clone Cloneable type "//LC:15299
                            + obj.getClass().getName(), e);//LC:15300
                } catch (final InvocationTargetException e) {//LC:15301
                    throw new Exception("Exception cloning Cloneable type "//LC:15302
                            + obj.getClass().getName(), e.getCause());//LC:15303
                }//LC:15304
            }//LC:15305
            @SuppressWarnings("unchecked") // OK because input is of type T//LC:15306
            final T checked = (T) result;//LC:15307
            return checked;//LC:15308
        }//LC:15309
//LC:15310
        return null;//LC:15311
    }//LC:15312
//LC:15313
    /**//LC:15314
     * <p>Clone an object if possible.</p>//LC:15315
     *//LC:15316
     * <p>This method is similar to {@link #clone(Object)}, but will return the provided//LC:15317
     * instance as the return value instead of {@code null} if the instance//LC:15318
     * is not cloneable. This is more convenient if the caller uses different//LC:15319
     * implementations (e.g. of a service) and some of the implementations do not allow concurrent//LC:15320
     * processing or have state. In such cases the implementation can simply provide a proper//LC:15321
     * clone implementation and the caller's code does not have to change.</p>//LC:15322
     *//LC:15323
     * @param <T> the type of the object//LC:15324
     * @param obj  the object to clone, null returns null//LC:15325
     * @return the clone if the object implements {@link Cloneable} otherwise the object itself//LC:15326
     * @throws CloneFailedException if the object is cloneable and the clone operation fails//LC:15327
     * @since 3.0//LC:15328
     *///LC:15329
    public static <T> T cloneIfPossible(final T obj) throws Exception {//LC:15330
        final T clone = clone(obj);//LC:15331
        return clone == null ? obj : clone;//LC:15332
    }//LC:15333
//LC:15334
    // Null//LC:15335
    //-----------------------------------------------------------------------//LC:15336
    /**//LC:15337
     * <p>Class used as a null placeholder where {@code null}//LC:15338
     * has another meaning.</p>//LC:15339
     *//LC:15340
     * <p>For example, in a {@code HashMap} the//LC:15341
     * {@link java.util.HashMap#get(java.lang.Object)} method returns//LC:15342
     * {@code null} if the {@code Map} contains {@code null} or if there is//LC:15343
     * no matching key. The {@code Null} placeholder can be used to distinguish//LC:15344
     * between these two cases.</p>//LC:15345
     *//LC:15346
     * <p>Another example is {@code Hashtable}, where {@code null}//LC:15347
     * cannot be stored.</p>//LC:15348
     *///LC:15349
    public static class Null implements Serializable {//LC:15350
        /**//LC:15351
         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0//LC:15352
         *//LC:15353
         * @see java.io.Serializable//LC:15354
         *///LC:15355
        private static final long serialVersionUID = 7092611880189329093L;//LC:15356
//LC:15357
        /**//LC:15358
         * Restricted constructor - singleton.//LC:15359
         *///LC:15360
        Null() {//LC:15361
            super();//LC:15362
        }//LC:15363
//LC:15364
        /**//LC:15365
         * <p>Ensure singleton.</p>//LC:15366
         *//LC:15367
         * @return the singleton value//LC:15368
         *///LC:15369
        private Object readResolve() {//LC:15370
            return ObjectUtils.NULL;//LC:15371
        }//LC:15372
    }//LC:15373
//LC:15374
//LC:15375
    // Constants (LANG-816)://LC:15376
    /*//LC:15377
        These methods ensure constants are not inlined by javac.//LC:15378
        For example, typically a developer might declare a constant like so://LC:15379
//LC:15380
            public final static int MAGIC_NUMBER = 5;//LC:15381
//LC:15382
        Should a different jar file refer to this, and the MAGIC_NUMBER//LC:15383
        is changed a later date (e.g., MAGIC_NUMBER = 6), the different jar//LC:15384
        file will need to recompile itself.  This is because javac//LC:15385
        typically inlines the primitive or String constant directly into//LC:15386
        the bytecode, and removes the reference to the MAGIC_NUMBER field.//LC:15387
//LC:15388
        To help the other jar (so that it does not need to recompile//LC:15389
        when constants are changed) the original developer can declare//LC:15390
        their constant using one of the CONST() utility methods, instead://LC:15391
//LC:15392
            public final static int MAGIC_NUMBER = CONST(5);//LC:15393
     *///LC:15394
//LC:15395
//LC:15396
    /**//LC:15397
     * This method returns the provided value unchanged.//LC:15398
     * This can prevent javac from inlining a constant//LC:15399
     * field, e.g.,//LC:15400
     *//LC:15401
     * <pre>//LC:15402
     *     public final static boolean MAGIC_FLAG = ObjectUtils.CONST(true);//LC:15403
     * </pre>//LC:15404
     *//LC:15405
     * This way any jars that refer to this field do not//LC:15406
     * have to recompile themselves if the field's value//LC:15407
     * changes at some future date.//LC:15408
     *//LC:15409
     * @param v the boolean value to return//LC:15410
     * @return the boolean v, unchanged//LC:15411
     *///LC:15412
    public static boolean CONST(final boolean v) { return v; }//LC:15413
//LC:15414
    /**//LC:15415
     * This method returns the provided value unchanged.//LC:15416
     * This can prevent javac from inlining a constant//LC:15417
     * field, e.g.,//LC:15418
     *//LC:15419
     * <pre>//LC:15420
     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST((byte) 127);//LC:15421
     * </pre>//LC:15422
     *//LC:15423
     * This way any jars that refer to this field do not//LC:15424
     * have to recompile themselves if the field's value//LC:15425
     * changes at some future date.//LC:15426
     *//LC:15427
     * @param v the byte value to return//LC:15428
     * @return the byte v, unchanged//LC:15429
     *///LC:15430
    public static byte CONST(final byte v) { return v; }//LC:15431
//LC:15432
    /**//LC:15433
     * This method returns the provided value unchanged.//LC:15434
     * This can prevent javac from inlining a constant//LC:15435
     * field, e.g.,//LC:15436
     *//LC:15437
     * <pre>//LC:15438
     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);//LC:15439
     * </pre>//LC:15440
     *//LC:15441
     * This way any jars that refer to this field do not//LC:15442
     * have to recompile themselves if the field's value//LC:15443
     * changes at some future date.//LC:15444
     *//LC:15445
     * @param v the byte literal (as an int) value to return//LC:15446
     * @throws IllegalArgumentException if the value passed to v//LC:15447
     *         is larger than a byte, that is, smaller than -128 or//LC:15448
     *         larger than 127.//LC:15449
     * @return the byte v, unchanged//LC:15450
     *///LC:15451
    public static byte CONST_BYTE(final int v) throws IllegalArgumentException {//LC:15452
        if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {//LC:15453
            throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]");//LC:15454
        }//LC:15455
        return (byte) v;//LC:15456
    }//LC:15457
//LC:15458
    /**//LC:15459
     * This method returns the provided value unchanged.//LC:15460
     * This can prevent javac from inlining a constant//LC:15461
     * field, e.g.,//LC:15462
     *//LC:15463
     * <pre>//LC:15464
     *     public final static char MAGIC_CHAR = ObjectUtils.CONST('a');//LC:15465
     * </pre>//LC:15466
     *//LC:15467
     * This way any jars that refer to this field do not//LC:15468
     * have to recompile themselves if the field's value//LC:15469
     * changes at some future date.//LC:15470
     *//LC:15471
     * @param v the char value to return//LC:15472
     * @return the char v, unchanged//LC:15473
     *///LC:15474
    public static char CONST(final char v) { return v; }//LC:15475
//LC:15476
    /**//LC:15477
     * This method returns the provided value unchanged.//LC:15478
     * This can prevent javac from inlining a constant//LC:15479
     * field, e.g.,//LC:15480
     *//LC:15481
     * <pre>//LC:15482
     *     public final static short MAGIC_SHORT = ObjectUtils.CONST((short) 123);//LC:15483
     * </pre>//LC:15484
     *//LC:15485
     * This way any jars that refer to this field do not//LC:15486
     * have to recompile themselves if the field's value//LC:15487
     * changes at some future date.//LC:15488
     *//LC:15489
     * @param v the short value to return//LC:15490
     * @return the short v, unchanged//LC:15491
     *///LC:15492
    public static short CONST(final short v) { return v; }//LC:15493
//LC:15494
    /**//LC:15495
     * This method returns the provided value unchanged.//LC:15496
     * This can prevent javac from inlining a constant//LC:15497
     * field, e.g.,//LC:15498
     *//LC:15499
     * <pre>//LC:15500
     *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);//LC:15501
     * </pre>//LC:15502
     *//LC:15503
     * This way any jars that refer to this field do not//LC:15504
     * have to recompile themselves if the field's value//LC:15505
     * changes at some future date.//LC:15506
     *//LC:15507
     * @param v the short literal (as an int) value to return//LC:15508
     * @throws IllegalArgumentException if the value passed to v//LC:15509
     *         is larger than a short, that is, smaller than -32768 or//LC:15510
     *         larger than 32767.//LC:15511
     * @return the byte v, unchanged//LC:15512
     *///LC:15513
    public static short CONST_SHORT(final int v) throws IllegalArgumentException {//LC:15514
        if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {//LC:15515
            throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]");//LC:15516
        }//LC:15517
        return (short) v;//LC:15518
    }//LC:15519
//LC:15520
//LC:15521
    /**//LC:15522
     * This method returns the provided value unchanged.//LC:15523
     * This can prevent javac from inlining a constant//LC:15524
     * field, e.g.,//LC:15525
     *//LC:15526
     * <pre>//LC:15527
     *     public final static int MAGIC_INT = ObjectUtils.CONST(123);//LC:15528
     * </pre>//LC:15529
     *//LC:15530
     * This way any jars that refer to this field do not//LC:15531
     * have to recompile themselves if the field's value//LC:15532
     * changes at some future date.//LC:15533
     *//LC:15534
     * @param v the int value to return//LC:15535
     * @return the int v, unchanged//LC:15536
     *///LC:15537
    public static int CONST(final int v) { return v; }//LC:15538
//LC:15539
    /**//LC:15540
     * This method returns the provided value unchanged.//LC:15541
     * This can prevent javac from inlining a constant//LC:15542
     * field, e.g.,//LC:15543
     *//LC:15544
     * <pre>//LC:15545
     *     public final static long MAGIC_LONG = ObjectUtils.CONST(123L);//LC:15546
     * </pre>//LC:15547
     *//LC:15548
     * This way any jars that refer to this field do not//LC:15549
     * have to recompile themselves if the field's value//LC:15550
     * changes at some future date.//LC:15551
     *//LC:15552
     * @param v the long value to return//LC:15553
     * @return the long v, unchanged//LC:15554
     *///LC:15555
    public static long CONST(final long v) { return v; }//LC:15556
//LC:15557
    /**//LC:15558
     * This method returns the provided value unchanged.//LC:15559
     * This can prevent javac from inlining a constant//LC:15560
     * field, e.g.,//LC:15561
     *//LC:15562
     * <pre>//LC:15563
     *     public final static float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);//LC:15564
     * </pre>//LC:15565
     *//LC:15566
     * This way any jars that refer to this field do not//LC:15567
     * have to recompile themselves if the field's value//LC:15568
     * changes at some future date.//LC:15569
     *//LC:15570
     * @param v the float value to return//LC:15571
     * @return the float v, unchanged//LC:15572
     *///LC:15573
    public static float CONST(final float v) { return v; }//LC:15574
//LC:15575
    /**//LC:15576
     * This method returns the provided value unchanged.//LC:15577
     * This can prevent javac from inlining a constant//LC:15578
     * field, e.g.,//LC:15579
     *//LC:15580
     * <pre>//LC:15581
     *     public final static double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);//LC:15582
     * </pre>//LC:15583
     *//LC:15584
     * This way any jars that refer to this field do not//LC:15585
     * have to recompile themselves if the field's value//LC:15586
     * changes at some future date.//LC:15587
     *//LC:15588
     * @param v the double value to return//LC:15589
     * @return the double v, unchanged//LC:15590
     *///LC:15591
    public static double CONST(final double v) { return v; }//LC:15592
//LC:15593
    /**//LC:15594
     * This method returns the provided value unchanged.//LC:15595
     * This can prevent javac from inlining a constant//LC:15596
     * field, e.g.,//LC:15597
     *//LC:15598
     * <pre>//LC:15599
     *     public final static String MAGIC_STRING = ObjectUtils.CONST("abc");//LC:15600
     * </pre>//LC:15601
     *//LC:15602
     * This way any jars that refer to this field do not//LC:15603
     * have to recompile themselves if the field's value//LC:15604
     * changes at some future date.//LC:15605
     *//LC:15606
     * @param <T> the Object type//LC:15607
     * @param v the genericized Object value to return (typically a String).//LC:15608
     * @return the genericized Object v, unchanged (typically a String).//LC:15609
     *///LC:15610
    public static <T> T CONST(final T v) { return v; }//LC:15611
//LC:15612
}//LC:15613
//LC:15614
//LC:15615
/**//LC:15616
 * <p>Operations on char primitives and Character objects.</p>//LC:15617
 *//LC:15618
 * <p>This class tries to handle {@code null} input gracefully.//LC:15619
 * An exception will not be thrown for a {@code null} input.//LC:15620
 * Each method documents its behaviour in more detail.</p>//LC:15621
 *//LC:15622
 * <p>#ThreadSafe#</p>//LC:15623
 * @since 2.1//LC:15624
 * @version $Id$//LC:15625
 *///LC:15626
class CharUtils {//LC:15627
//LC:15628
    private static final String[] CHAR_STRING_ARRAY = new String[128];//LC:15629
//LC:15630
    /**//LC:15631
     * {@code \u000a} linefeed LF ('\n').//LC:15632
     *//LC:15633
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences//LC:15634
     *      for Character and String Literals</a>//LC:15635
     * @since 2.2//LC:15636
     *///LC:15637
    public static final char LF = '\n';//LC:15638
//LC:15639
    /**//LC:15640
     * {@code \u000d} carriage return CR ('\r').//LC:15641
     *//LC:15642
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences//LC:15643
     *      for Character and String Literals</a>//LC:15644
     * @since 2.2//LC:15645
     *///LC:15646
    public static final char CR = '\r';//LC:15647
//LC:15648
//LC:15649
    static {//LC:15650
        for (char c = 0; c < CHAR_STRING_ARRAY.length; c++) {//LC:15651
            CHAR_STRING_ARRAY[c] = String.valueOf(c);//LC:15652
        }//LC:15653
    }//LC:15654
//LC:15655
    /**//LC:15656
     * <p>{@code CharUtils} instances should NOT be constructed in standard programming.//LC:15657
     * Instead, the class should be used as {@code CharUtils.toString('c');}.</p>//LC:15658
     *//LC:15659
     * <p>This constructor is public to permit tools that require a JavaBean instance//LC:15660
     * to operate.</p>//LC:15661
     *///LC:15662
    public CharUtils() {//LC:15663
        super();//LC:15664
    }//LC:15665
//LC:15666
    //-----------------------------------------------------------------------//LC:15667
    /**//LC:15668
     * <p>Converts the character to a Character.</p>//LC:15669
     *//LC:15670
     * <p>For ASCII 7 bit characters, this uses a cache that will return the//LC:15671
     * same Character object each time.</p>//LC:15672
     *//LC:15673
     * <pre>//LC:15674
     *   CharUtils.toCharacterObject(' ')  = ' '//LC:15675
     *   CharUtils.toCharacterObject('A')  = 'A'//LC:15676
     * </pre>//LC:15677
     *//LC:15678
     * @deprecated Java 5 introduced {@link Character#valueOf(char)} which caches chars 0 through 127.//LC:15679
     * @param ch  the character to convert//LC:15680
     * @return a Character of the specified character//LC:15681
     *///LC:15682
    @Deprecated//LC:15683
    public static Character toCharacterObject(final char ch) {//LC:15684
        return Character.valueOf(ch);//LC:15685
    }//LC:15686
//LC:15687
    /**//LC:15688
     * <p>Converts the String to a Character using the first character, returning//LC:15689
     * null for empty Strings.</p>//LC:15690
     *//LC:15691
     * <p>For ASCII 7 bit characters, this uses a cache that will return the//LC:15692
     * same Character object each time.</p>//LC:15693
     *//LC:15694
     * <pre>//LC:15695
     *   CharUtils.toCharacterObject(null) = null//LC:15696
     *   CharUtils.toCharacterObject("")   = null//LC:15697
     *   CharUtils.toCharacterObject("A")  = 'A'//LC:15698
     *   CharUtils.toCharacterObject("BA") = 'B'//LC:15699
     * </pre>//LC:15700
     *//LC:15701
     * @param str  the character to convert//LC:15702
     * @return the Character value of the first letter of the String//LC:15703
     *///LC:15704
    public static Character toCharacterObject(final String str) {//LC:15705
        if (StringUtils.isEmpty(str)) {//LC:15706
            return null;//LC:15707
        }//LC:15708
        return Character.valueOf(str.charAt(0));//LC:15709
    }//LC:15710
//LC:15711
    //-----------------------------------------------------------------------//LC:15712
    /**//LC:15713
     * <p>Converts the Character to a char throwing an exception for {@code null}.</p>//LC:15714
     *//LC:15715
     * <pre>//LC:15716
     *   CharUtils.toChar(' ')  = ' '//LC:15717
     *   CharUtils.toChar('A')  = 'A'//LC:15718
     *   CharUtils.toChar(null) throws IllegalArgumentException//LC:15719
     * </pre>//LC:15720
     *//LC:15721
     * @param ch  the character to convert//LC:15722
     * @return the char value of the Character//LC:15723
     * @throws IllegalArgumentException if the Character is null//LC:15724
     *///LC:15725
    public static char toChar(final Character ch) {//LC:15726
        if (ch == null) {//LC:15727
            throw new IllegalArgumentException("The Character must not be null");//LC:15728
        }//LC:15729
        return ch.charValue();//LC:15730
    }//LC:15731
//LC:15732
    /**//LC:15733
     * <p>Converts the Character to a char handling {@code null}.</p>//LC:15734
     *//LC:15735
     * <pre>//LC:15736
     *   CharUtils.toChar(null, 'X') = 'X'//LC:15737
     *   CharUtils.toChar(' ', 'X')  = ' '//LC:15738
     *   CharUtils.toChar('A', 'X')  = 'A'//LC:15739
     * </pre>//LC:15740
     *//LC:15741
     * @param ch  the character to convert//LC:15742
     * @param defaultValue  the value to use if the  Character is null//LC:15743
     * @return the char value of the Character or the default if null//LC:15744
     *///LC:15745
    public static char toChar(final Character ch, final char defaultValue) {//LC:15746
        if (ch == null) {//LC:15747
            return defaultValue;//LC:15748
        }//LC:15749
        return ch.charValue();//LC:15750
    }//LC:15751
//LC:15752
    //-----------------------------------------------------------------------//LC:15753
    /**//LC:15754
     * <p>Converts the String to a char using the first character, throwing//LC:15755
     * an exception on empty Strings.</p>//LC:15756
     *//LC:15757
     * <pre>//LC:15758
     *   CharUtils.toChar("A")  = 'A'//LC:15759
     *   CharUtils.toChar("BA") = 'B'//LC:15760
     *   CharUtils.toChar(null) throws IllegalArgumentException//LC:15761
     *   CharUtils.toChar("")   throws IllegalArgumentException//LC:15762
     * </pre>//LC:15763
     *//LC:15764
     * @param str  the character to convert//LC:15765
     * @return the char value of the first letter of the String//LC:15766
     * @throws IllegalArgumentException if the String is empty//LC:15767
     *///LC:15768
    public static char toChar(final String str) {//LC:15769
        if (StringUtils.isEmpty(str)) {//LC:15770
            throw new IllegalArgumentException("The String must not be empty");//LC:15771
        }//LC:15772
        return str.charAt(0);//LC:15773
    }//LC:15774
//LC:15775
    /**//LC:15776
     * <p>Converts the String to a char using the first character, defaulting//LC:15777
     * the value on empty Strings.</p>//LC:15778
     *//LC:15779
     * <pre>//LC:15780
     *   CharUtils.toChar(null, 'X') = 'X'//LC:15781
     *   CharUtils.toChar("", 'X')   = 'X'//LC:15782
     *   CharUtils.toChar("A", 'X')  = 'A'//LC:15783
     *   CharUtils.toChar("BA", 'X') = 'B'//LC:15784
     * </pre>//LC:15785
     *//LC:15786
     * @param str  the character to convert//LC:15787
     * @param defaultValue  the value to use if the  Character is null//LC:15788
     * @return the char value of the first letter of the String or the default if null//LC:15789
     *///LC:15790
    public static char toChar(final String str, final char defaultValue) {//LC:15791
        if (StringUtils.isEmpty(str)) {//LC:15792
            return defaultValue;//LC:15793
        }//LC:15794
        return str.charAt(0);//LC:15795
    }//LC:15796
//LC:15797
    //-----------------------------------------------------------------------//LC:15798
    /**//LC:15799
     * <p>Converts the character to the Integer it represents, throwing an//LC:15800
     * exception if the character is not numeric.</p>//LC:15801
     *//LC:15802
     * <p>This method coverts the char '1' to the int 1 and so on.</p>//LC:15803
     *//LC:15804
     * <pre>//LC:15805
     *   CharUtils.toIntValue('3')  = 3//LC:15806
     *   CharUtils.toIntValue('A')  throws IllegalArgumentException//LC:15807
     * </pre>//LC:15808
     *//LC:15809
     * @param ch  the character to convert//LC:15810
     * @return the int value of the character//LC:15811
     * @throws IllegalArgumentException if the character is not ASCII numeric//LC:15812
     *///LC:15813
    public static int toIntValue(final char ch) {//LC:15814
        if (isAsciiNumeric(ch) == false) {//LC:15815
            throw new IllegalArgumentException("The character " + ch + " is not in the range '0' - '9'");//LC:15816
        }//LC:15817
        return ch - 48;//LC:15818
    }//LC:15819
//LC:15820
    /**//LC:15821
     * <p>Converts the character to the Integer it represents, throwing an//LC:15822
     * exception if the character is not numeric.</p>//LC:15823
     *//LC:15824
     * <p>This method coverts the char '1' to the int 1 and so on.</p>//LC:15825
     *//LC:15826
     * <pre>//LC:15827
     *   CharUtils.toIntValue('3', -1)  = 3//LC:15828
     *   CharUtils.toIntValue('A', -1)  = -1//LC:15829
     * </pre>//LC:15830
     *//LC:15831
     * @param ch  the character to convert//LC:15832
     * @param defaultValue  the default value to use if the character is not numeric//LC:15833
     * @return the int value of the character//LC:15834
     *///LC:15835
    public static int toIntValue(final char ch, final int defaultValue) {//LC:15836
        if (isAsciiNumeric(ch) == false) {//LC:15837
            return defaultValue;//LC:15838
        }//LC:15839
        return ch - 48;//LC:15840
    }//LC:15841
//LC:15842
    /**//LC:15843
     * <p>Converts the character to the Integer it represents, throwing an//LC:15844
     * exception if the character is not numeric.</p>//LC:15845
     *//LC:15846
     * <p>This method coverts the char '1' to the int 1 and so on.</p>//LC:15847
     *//LC:15848
     * <pre>//LC:15849
     *   CharUtils.toIntValue('3')  = 3//LC:15850
     *   CharUtils.toIntValue(null) throws IllegalArgumentException//LC:15851
     *   CharUtils.toIntValue('A')  throws IllegalArgumentException//LC:15852
     * </pre>//LC:15853
     *//LC:15854
     * @param ch  the character to convert, not null//LC:15855
     * @return the int value of the character//LC:15856
     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null//LC:15857
     *///LC:15858
    public static int toIntValue(final Character ch) {//LC:15859
        if (ch == null) {//LC:15860
            throw new IllegalArgumentException("The character must not be null");//LC:15861
        }//LC:15862
        return toIntValue(ch.charValue());//LC:15863
    }//LC:15864
//LC:15865
    /**//LC:15866
     * <p>Converts the character to the Integer it represents, throwing an//LC:15867
     * exception if the character is not numeric.</p>//LC:15868
     *//LC:15869
     * <p>This method coverts the char '1' to the int 1 and so on.</p>//LC:15870
     *//LC:15871
     * <pre>//LC:15872
     *   CharUtils.toIntValue(null, -1) = -1//LC:15873
     *   CharUtils.toIntValue('3', -1)  = 3//LC:15874
     *   CharUtils.toIntValue('A', -1)  = -1//LC:15875
     * </pre>//LC:15876
     *//LC:15877
     * @param ch  the character to convert//LC:15878
     * @param defaultValue  the default value to use if the character is not numeric//LC:15879
     * @return the int value of the character//LC:15880
     *///LC:15881
    public static int toIntValue(final Character ch, final int defaultValue) {//LC:15882
        if (ch == null) {//LC:15883
            return defaultValue;//LC:15884
        }//LC:15885
        return toIntValue(ch.charValue(), defaultValue);//LC:15886
    }//LC:15887
//LC:15888
    //-----------------------------------------------------------------------//LC:15889
    /**//LC:15890
     * <p>Converts the character to a String that contains the one character.</p>//LC:15891
     *//LC:15892
     * <p>For ASCII 7 bit characters, this uses a cache that will return the//LC:15893
     * same String object each time.</p>//LC:15894
     *//LC:15895
     * <pre>//LC:15896
     *   CharUtils.toString(' ')  = " "//LC:15897
     *   CharUtils.toString('A')  = "A"//LC:15898
     * </pre>//LC:15899
     *//LC:15900
     * @param ch  the character to convert//LC:15901
     * @return a String containing the one specified character//LC:15902
     *///LC:15903
    public static String toString(final char ch) {//LC:15904
        if (ch < 128) {//LC:15905
            return CHAR_STRING_ARRAY[ch];//LC:15906
        }//LC:15907
        return new String(new char[] {ch});//LC:15908
    }//LC:15909
//LC:15910
    /**//LC:15911
     * <p>Converts the character to a String that contains the one character.</p>//LC:15912
     *//LC:15913
     * <p>For ASCII 7 bit characters, this uses a cache that will return the//LC:15914
     * same String object each time.</p>//LC:15915
     *//LC:15916
     * <p>If {@code null} is passed in, {@code null} will be returned.</p>//LC:15917
     *//LC:15918
     * <pre>//LC:15919
     *   CharUtils.toString(null) = null//LC:15920
     *   CharUtils.toString(' ')  = " "//LC:15921
     *   CharUtils.toString('A')  = "A"//LC:15922
     * </pre>//LC:15923
     *//LC:15924
     * @param ch  the character to convert//LC:15925
     * @return a String containing the one specified character//LC:15926
     *///LC:15927
    public static String toString(final Character ch) {//LC:15928
        if (ch == null) {//LC:15929
            return null;//LC:15930
        }//LC:15931
        return toString(ch.charValue());//LC:15932
    }//LC:15933
//LC:15934
    //--------------------------------------------------------------------------//LC:15935
    /**//LC:15936
     * <p>Converts the string to the Unicode format '\u0020'.</p>//LC:15937
     *//LC:15938
     * <p>This format is the Java source code format.</p>//LC:15939
     *//LC:15940
     * <pre>//LC:15941
     *   CharUtils.unicodeEscaped(' ') = "\u0020"//LC:15942
     *   CharUtils.unicodeEscaped('A') = "\u0041"//LC:15943
     * </pre>//LC:15944
     *//LC:15945
     * @param ch  the character to convert//LC:15946
     * @return the escaped Unicode string//LC:15947
     *///LC:15948
    public static String unicodeEscaped(final char ch) {//LC:15949
        if (ch < 0x10) {//LC:15950
            return "\\u000" + Integer.toHexString(ch);//LC:15951
        } else if (ch < 0x100) {//LC:15952
            return "\\u00" + Integer.toHexString(ch);//LC:15953
        } else if (ch < 0x1000) {//LC:15954
            return "\\u0" + Integer.toHexString(ch);//LC:15955
        }//LC:15956
        return "\\u" + Integer.toHexString(ch);//LC:15957
    }//LC:15958
//LC:15959
    /**//LC:15960
     * <p>Converts the string to the Unicode format '\u0020'.</p>//LC:15961
     *//LC:15962
     * <p>This format is the Java source code format.</p>//LC:15963
     *//LC:15964
     * <p>If {@code null} is passed in, {@code null} will be returned.</p>//LC:15965
     *//LC:15966
     * <pre>//LC:15967
     *   CharUtils.unicodeEscaped(null) = null//LC:15968
     *   CharUtils.unicodeEscaped(' ')  = "\u0020"//LC:15969
     *   CharUtils.unicodeEscaped('A')  = "\u0041"//LC:15970
     * </pre>//LC:15971
     *//LC:15972
     * @param ch  the character to convert, may be null//LC:15973
     * @return the escaped Unicode string, null if null input//LC:15974
     *///LC:15975
    public static String unicodeEscaped(final Character ch) {//LC:15976
        if (ch == null) {//LC:15977
            return null;//LC:15978
        }//LC:15979
        return unicodeEscaped(ch.charValue());//LC:15980
    }//LC:15981
//LC:15982
    //--------------------------------------------------------------------------//LC:15983
    /**//LC:15984
     * <p>Checks whether the character is ASCII 7 bit.</p>//LC:15985
     *//LC:15986
     * <pre>//LC:15987
     *   CharUtils.isAscii('a')  = true//LC:15988
     *   CharUtils.isAscii('A')  = true//LC:15989
     *   CharUtils.isAscii('3')  = true//LC:15990
     *   CharUtils.isAscii('-')  = true//LC:15991
     *   CharUtils.isAscii('\n') = true//LC:15992
     *   CharUtils.isAscii('&copy;') = false//LC:15993
     * </pre>//LC:15994
     *//LC:15995
     * @param ch  the character to check//LC:15996
     * @return true if less than 128//LC:15997
     *///LC:15998
    public static boolean isAscii(final char ch) {//LC:15999
        return ch < 128;//LC:16000
    }//LC:16001
//LC:16002
    /**//LC:16003
     * <p>Checks whether the character is ASCII 7 bit printable.</p>//LC:16004
     *//LC:16005
     * <pre>//LC:16006
     *   CharUtils.isAsciiPrintable('a')  = true//LC:16007
     *   CharUtils.isAsciiPrintable('A')  = true//LC:16008
     *   CharUtils.isAsciiPrintable('3')  = true//LC:16009
     *   CharUtils.isAsciiPrintable('-')  = true//LC:16010
     *   CharUtils.isAsciiPrintable('\n') = false//LC:16011
     *   CharUtils.isAsciiPrintable('&copy;') = false//LC:16012
     * </pre>//LC:16013
     *//LC:16014
     * @param ch  the character to check//LC:16015
     * @return true if between 32 and 126 inclusive//LC:16016
     *///LC:16017
    public static boolean isAsciiPrintable(final char ch) {//LC:16018
        return ch >= 32 && ch < 127;//LC:16019
    }//LC:16020
//LC:16021
    /**//LC:16022
     * <p>Checks whether the character is ASCII 7 bit control.</p>//LC:16023
     *//LC:16024
     * <pre>//LC:16025
     *   CharUtils.isAsciiControl('a')  = false//LC:16026
     *   CharUtils.isAsciiControl('A')  = false//LC:16027
     *   CharUtils.isAsciiControl('3')  = false//LC:16028
     *   CharUtils.isAsciiControl('-')  = false//LC:16029
     *   CharUtils.isAsciiControl('\n') = true//LC:16030
     *   CharUtils.isAsciiControl('&copy;') = false//LC:16031
     * </pre>//LC:16032
     *//LC:16033
     * @param ch  the character to check//LC:16034
     * @return true if less than 32 or equals 127//LC:16035
     *///LC:16036
    public static boolean isAsciiControl(final char ch) {//LC:16037
        return ch < 32 || ch == 127;//LC:16038
    }//LC:16039
//LC:16040
    /**//LC:16041
     * <p>Checks whether the character is ASCII 7 bit alphabetic.</p>//LC:16042
     *//LC:16043
     * <pre>//LC:16044
     *   CharUtils.isAsciiAlpha('a')  = true//LC:16045
     *   CharUtils.isAsciiAlpha('A')  = true//LC:16046
     *   CharUtils.isAsciiAlpha('3')  = false//LC:16047
     *   CharUtils.isAsciiAlpha('-')  = false//LC:16048
     *   CharUtils.isAsciiAlpha('\n') = false//LC:16049
     *   CharUtils.isAsciiAlpha('&copy;') = false//LC:16050
     * </pre>//LC:16051
     *//LC:16052
     * @param ch  the character to check//LC:16053
     * @return true if between 65 and 90 or 97 and 122 inclusive//LC:16054
     *///LC:16055
    public static boolean isAsciiAlpha(final char ch) {//LC:16056
        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');//LC:16057
    }//LC:16058
//LC:16059
    /**//LC:16060
     * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p>//LC:16061
     *//LC:16062
     * <pre>//LC:16063
     *   CharUtils.isAsciiAlphaUpper('a')  = false//LC:16064
     *   CharUtils.isAsciiAlphaUpper('A')  = true//LC:16065
     *   CharUtils.isAsciiAlphaUpper('3')  = false//LC:16066
     *   CharUtils.isAsciiAlphaUpper('-')  = false//LC:16067
     *   CharUtils.isAsciiAlphaUpper('\n') = false//LC:16068
     *   CharUtils.isAsciiAlphaUpper('&copy;') = false//LC:16069
     * </pre>//LC:16070
     *//LC:16071
     * @param ch  the character to check//LC:16072
     * @return true if between 65 and 90 inclusive//LC:16073
     *///LC:16074
    public static boolean isAsciiAlphaUpper(final char ch) {//LC:16075
        return ch >= 'A' && ch <= 'Z';//LC:16076
    }//LC:16077
//LC:16078
    /**//LC:16079
     * <p>Checks whether the character is ASCII 7 bit alphabetic lower case.</p>//LC:16080
     *//LC:16081
     * <pre>//LC:16082
     *   CharUtils.isAsciiAlphaLower('a')  = true//LC:16083
     *   CharUtils.isAsciiAlphaLower('A')  = false//LC:16084
     *   CharUtils.isAsciiAlphaLower('3')  = false//LC:16085
     *   CharUtils.isAsciiAlphaLower('-')  = false//LC:16086
     *   CharUtils.isAsciiAlphaLower('\n') = false//LC:16087
     *   CharUtils.isAsciiAlphaLower('&copy;') = false//LC:16088
     * </pre>//LC:16089
     *//LC:16090
     * @param ch  the character to check//LC:16091
     * @return true if between 97 and 122 inclusive//LC:16092
     *///LC:16093
    public static boolean isAsciiAlphaLower(final char ch) {//LC:16094
        return ch >= 'a' && ch <= 'z';//LC:16095
    }//LC:16096
//LC:16097
    /**//LC:16098
     * <p>Checks whether the character is ASCII 7 bit numeric.</p>//LC:16099
     *//LC:16100
     * <pre>//LC:16101
     *   CharUtils.isAsciiNumeric('a')  = false//LC:16102
     *   CharUtils.isAsciiNumeric('A')  = false//LC:16103
     *   CharUtils.isAsciiNumeric('3')  = true//LC:16104
     *   CharUtils.isAsciiNumeric('-')  = false//LC:16105
     *   CharUtils.isAsciiNumeric('\n') = false//LC:16106
     *   CharUtils.isAsciiNumeric('&copy;') = false//LC:16107
     * </pre>//LC:16108
     *//LC:16109
     * @param ch  the character to check//LC:16110
     * @return true if between 48 and 57 inclusive//LC:16111
     *///LC:16112
    public static boolean isAsciiNumeric(final char ch) {//LC:16113
        return ch >= '0' && ch <= '9';//LC:16114
    }//LC:16115
//LC:16116
    /**//LC:16117
     * <p>Checks whether the character is ASCII 7 bit numeric.</p>//LC:16118
     *//LC:16119
     * <pre>//LC:16120
     *   CharUtils.isAsciiAlphanumeric('a')  = true//LC:16121
     *   CharUtils.isAsciiAlphanumeric('A')  = true//LC:16122
     *   CharUtils.isAsciiAlphanumeric('3')  = true//LC:16123
     *   CharUtils.isAsciiAlphanumeric('-')  = false//LC:16124
     *   CharUtils.isAsciiAlphanumeric('\n') = false//LC:16125
     *   CharUtils.isAsciiAlphanumeric('&copy;') = false//LC:16126
     * </pre>//LC:16127
     *//LC:16128
     * @param ch  the character to check//LC:16129
     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive//LC:16130
     *///LC:16131
    public static boolean isAsciiAlphanumeric(final char ch) {//LC:16132
        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');//LC:16133
    }//LC:16134
//LC:16135
}//LC:16136
//LC:16137
//LC:16138
/**//LC:16139
 * <p>Assists in implementing {@link Object#toString()} methods.</p>//LC:16140
 *//LC:16141
 * <p>This class enables a good and consistent <code>toString()</code> to be built for any//LC:16142
 * class or object. This class aims to simplify the process by:</p>//LC:16143
 * <ul>//LC:16144
 *  <li>allowing field names</li>//LC:16145
 *  <li>handling all types consistently</li>//LC:16146
 *  <li>handling nulls consistently</li>//LC:16147
 *  <li>outputting arrays and multi-dimensional arrays</li>//LC:16148
 *  <li>enabling the detail level to be controlled for Objects and Collections</li>//LC:16149
 *  <li>handling class hierarchies</li>//LC:16150
 * </ul>//LC:16151
 *//LC:16152
 * <p>To use this class write code as follows:</p>//LC:16153
 *//LC:16154
 * <pre>//LC:16155
 * public class Person {//LC:16156
 *   String name;//LC:16157
 *   int age;//LC:16158
 *   boolean smoker;//LC:16159
 *//LC:16160
 *   ...//LC:16161
 *//LC:16162
 *   public String toString() {//LC:16163
 *     return new ToStringBuilder(this).//LC:16164
 *       append("name", name).//LC:16165
 *       append("age", age).//LC:16166
 *       append("smoker", smoker).//LC:16167
 *       toString();//LC:16168
 *   }//LC:16169
 * }//LC:16170
 * </pre>//LC:16171
 *//LC:16172
 * <p>This will produce a toString of the format://LC:16173
 * <code>Person@7f54[name=Stephen,age=29,smoker=false]</code></p>//LC:16174
 *//LC:16175
 * <p>To add the superclass <code>toString</code>, use {@link #appendSuper}.//LC:16176
 * To append the <code>toString</code> from an object that is delegated//LC:16177
 * to (or any other object), use {@link #appendToString}.</p>//LC:16178
 *//LC:16179
 * <p>Alternatively, there is a method that uses reflection to determine//LC:16180
 * the fields to test. Because these fields are usually private, the method,//LC:16181
 * <code>reflectionToString</code>, uses <code>AccessibleObject.setAccessible</code> to//LC:16182
 * change the visibility of the fields. This will fail under a security manager,//LC:16183
 * unless the appropriate permissions are set up correctly. It is also//LC:16184
 * slower than testing explicitly.</p>//LC:16185
 *//LC:16186
 * <p>A typical invocation for this method would look like:</p>//LC:16187
 *//LC:16188
 * <pre>//LC:16189
 * public String toString() {//LC:16190
 *   return ToStringBuilder.reflectionToString(this);//LC:16191
 * }//LC:16192
 * </pre>//LC:16193
 *//LC:16194
 * <p>You can also use the builder to debug 3rd party objects:</p>//LC:16195
 *//LC:16196
 * <pre>//LC:16197
 * System.out.println("An object: " + ToStringBuilder.reflectionToString(anObject));//LC:16198
 * </pre>//LC:16199
 *//LC:16200
 * <p>The exact format of the <code>toString</code> is determined by//LC:16201
 * the {@link ToStringStyle} passed into the constructor.</p>//LC:16202
 *//LC:16203
 * @since 1.0//LC:16204
 * @version $Id$//LC:16205
 *///LC:16206
class ToStringBuilder implements Builder<String> {//LC:16207
//LC:16208
    /**//LC:16209
     * The default style of output to use, not null.//LC:16210
     *///LC:16211
    private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;//LC:16212
//LC:16213
    //----------------------------------------------------------------------------//LC:16214
//LC:16215
    /**//LC:16216
     * <p>Gets the default <code>ToStringStyle</code> to use.</p>//LC:16217
     *//LC:16218
     * <p>This method gets a singleton default value, typically for the whole JVM.//LC:16219
     * Changing this default should generally only be done during application startup.//LC:16220
     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead//LC:16221
     * of using this global default.</p>//LC:16222
     *//LC:16223
     * <p>This method can be used from multiple threads.//LC:16224
     * Internally, a <code>volatile</code> variable is used to provide the guarantee//LC:16225
     * that the latest value set using {@link #setDefaultStyle} is the value returned.//LC:16226
     * It is strongly recommended that the default style is only changed during application startup.</p>//LC:16227
     *//LC:16228
     * <p>One reason for changing the default could be to have a verbose style during//LC:16229
     * development and a compact style in production.</p>//LC:16230
     *//LC:16231
     * @return the default <code>ToStringStyle</code>, never null//LC:16232
     *///LC:16233
    public static ToStringStyle getDefaultStyle() {//LC:16234
        return defaultStyle;//LC:16235
    }//LC:16236
//LC:16237
    /**//LC:16238
     * <p>Sets the default <code>ToStringStyle</code> to use.</p>//LC:16239
     *//LC:16240
     * <p>This method sets a singleton default value, typically for the whole JVM.//LC:16241
     * Changing this default should generally only be done during application startup.//LC:16242
     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead//LC:16243
     * of changing this global default.</p>//LC:16244
     *//LC:16245
     * <p>This method is not intended for use from multiple threads.//LC:16246
     * Internally, a <code>volatile</code> variable is used to provide the guarantee//LC:16247
     * that the latest value set is the value returned from {@link #getDefaultStyle}.</p>//LC:16248
     *//LC:16249
     * @param style  the default <code>ToStringStyle</code>//LC:16250
     * @throws IllegalArgumentException if the style is <code>null</code>//LC:16251
     *///LC:16252
    public static void setDefaultStyle(final ToStringStyle style) {//LC:16253
        if (style == null) {//LC:16254
            throw new IllegalArgumentException("The style must not be null");//LC:16255
        }//LC:16256
        defaultStyle = style;//LC:16257
    }//LC:16258
//LC:16259
    //----------------------------------------------------------------------------//LC:16260
    /**//LC:16261
     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a//LC:16262
     * <code>toString</code> for the specified object.</p>//LC:16263
     *//LC:16264
     * @param object  the Object to be output//LC:16265
     * @return the String result//LC:16266
     * @see ReflectionToStringBuilder#toString(Object)//LC:16267
     *///LC:16268
    public static String reflectionToString(final Object object) {//LC:16269
        return ReflectionToStringBuilder.toString(object);//LC:16270
    }//LC:16271
//LC:16272
    /**//LC:16273
     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a//LC:16274
     * <code>toString</code> for the specified object.</p>//LC:16275
     *//LC:16276
     * @param object  the Object to be output//LC:16277
     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>//LC:16278
     * @return the String result//LC:16279
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)//LC:16280
     *///LC:16281
    public static String reflectionToString(final Object object, final ToStringStyle style) {//LC:16282
        return ReflectionToStringBuilder.toString(object, style);//LC:16283
    }//LC:16284
//LC:16285
    /**//LC:16286
     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a//LC:16287
     * <code>toString</code> for the specified object.</p>//LC:16288
     *//LC:16289
     * @param object  the Object to be output//LC:16290
     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>//LC:16291
     * @param outputTransients  whether to include transient fields//LC:16292
     * @return the String result//LC:16293
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)//LC:16294
     *///LC:16295
    public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) {//LC:16296
        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);//LC:16297
    }//LC:16298
//LC:16299
    /**//LC:16300
     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a//LC:16301
     * <code>toString</code> for the specified object.</p>//LC:16302
     *//LC:16303
     * @param <T> the type of the object//LC:16304
     * @param object  the Object to be output//LC:16305
     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>//LC:16306
     * @param outputTransients  whether to include transient fields//LC:16307
     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be <code>null</code>//LC:16308
     * @return the String result//LC:16309
     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)//LC:16310
     * @since 2.0//LC:16311
     *///LC:16312
    public static <T> String reflectionToString(//LC:16313
            final T object,//LC:16314
            final ToStringStyle style,//LC:16315
            final boolean outputTransients,//LC:16316
            final Class<? super T> reflectUpToClass) {//LC:16317
        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);//LC:16318
    }//LC:16319
//LC:16320
    //----------------------------------------------------------------------------//LC:16321
//LC:16322
    /**//LC:16323
     * Current toString buffer, not null.//LC:16324
     *///LC:16325
    private final StringBuffer buffer;//LC:16326
    /**//LC:16327
     * The object being output, may be null.//LC:16328
     *///LC:16329
    private final Object object;//LC:16330
    /**//LC:16331
     * The style of output to use, not null.//LC:16332
     *///LC:16333
    private final ToStringStyle style;//LC:16334
//LC:16335
    /**//LC:16336
     * <p>Constructs a builder for the specified object using the default output style.</p>//LC:16337
     *//LC:16338
     * <p>This default style is obtained from {@link #getDefaultStyle()}.</p>//LC:16339
     *//LC:16340
     * @param object  the Object to build a <code>toString</code> for, not recommended to be null//LC:16341
     *///LC:16342
    public ToStringBuilder(final Object object) {//LC:16343
        this(object, null, null);//LC:16344
    }//LC:16345
//LC:16346
    /**//LC:16347
     * <p>Constructs a builder for the specified object using the a defined output style.</p>//LC:16348
     *//LC:16349
     * <p>If the style is <code>null</code>, the default style is used.</p>//LC:16350
     *//LC:16351
     * @param object  the Object to build a <code>toString</code> for, not recommended to be null//LC:16352
     * @param style  the style of the <code>toString</code> to create, null uses the default style//LC:16353
     *///LC:16354
    public ToStringBuilder(final Object object, final ToStringStyle style) {//LC:16355
        this(object, style, null);//LC:16356
    }//LC:16357
//LC:16358
    /**//LC:16359
     * <p>Constructs a builder for the specified object.</p>//LC:16360
     *//LC:16361
     * <p>If the style is <code>null</code>, the default style is used.</p>//LC:16362
     *//LC:16363
     * <p>If the buffer is <code>null</code>, a new one is created.</p>//LC:16364
     *//LC:16365
     * @param object  the Object to build a <code>toString</code> for, not recommended to be null//LC:16366
     * @param style  the style of the <code>toString</code> to create, null uses the default style//LC:16367
     * @param buffer  the <code>StringBuffer</code> to populate, may be null//LC:16368
     *///LC:16369
    public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) {//LC:16370
        if (style == null) {//LC:16371
            style = getDefaultStyle();//LC:16372
        }//LC:16373
        if (buffer == null) {//LC:16374
            buffer = new StringBuffer(512);//LC:16375
        }//LC:16376
        this.buffer = buffer;//LC:16377
        this.style = style;//LC:16378
        this.object = object;//LC:16379
//LC:16380
        style.appendStart(buffer, object);//LC:16381
    }//LC:16382
//LC:16383
    //----------------------------------------------------------------------------//LC:16384
//LC:16385
    /**//LC:16386
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:16387
     * value.</p>//LC:16388
     *//LC:16389
     * @param value  the value to add to the <code>toString</code>//LC:16390
     * @return this//LC:16391
     *///LC:16392
    public ToStringBuilder append(final boolean value) {//LC:16393
        style.append(buffer, null, value);//LC:16394
        return this;//LC:16395
    }//LC:16396
//LC:16397
    //----------------------------------------------------------------------------//LC:16398
//LC:16399
    /**//LC:16400
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:16401
     * array.</p>//LC:16402
     *//LC:16403
     * @param array  the array to add to the <code>toString</code>//LC:16404
     * @return this//LC:16405
     *///LC:16406
    public ToStringBuilder append(final boolean[] array) {//LC:16407
        style.append(buffer, null, array, null);//LC:16408
        return this;//LC:16409
    }//LC:16410
//LC:16411
    //----------------------------------------------------------------------------//LC:16412
//LC:16413
    /**//LC:16414
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:16415
     * value.</p>//LC:16416
     *//LC:16417
     * @param value  the value to add to the <code>toString</code>//LC:16418
     * @return this//LC:16419
     *///LC:16420
    public ToStringBuilder append(final byte value) {//LC:16421
        style.append(buffer, null, value);//LC:16422
        return this;//LC:16423
    }//LC:16424
//LC:16425
    //----------------------------------------------------------------------------//LC:16426
//LC:16427
    /**//LC:16428
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:16429
     * array.</p>//LC:16430
     *//LC:16431
     * @param array  the array to add to the <code>toString</code>//LC:16432
     * @return this//LC:16433
     *///LC:16434
    public ToStringBuilder append(final byte[] array) {//LC:16435
        style.append(buffer, null, array, null);//LC:16436
        return this;//LC:16437
    }//LC:16438
//LC:16439
    //----------------------------------------------------------------------------//LC:16440
//LC:16441
    /**//LC:16442
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:16443
     * value.</p>//LC:16444
     *//LC:16445
     * @param value  the value to add to the <code>toString</code>//LC:16446
     * @return this//LC:16447
     *///LC:16448
    public ToStringBuilder append(final char value) {//LC:16449
        style.append(buffer, null, value);//LC:16450
        return this;//LC:16451
    }//LC:16452
//LC:16453
    //----------------------------------------------------------------------------//LC:16454
//LC:16455
    /**//LC:16456
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:16457
     * array.</p>//LC:16458
     *//LC:16459
     * @param array  the array to add to the <code>toString</code>//LC:16460
     * @return this//LC:16461
     *///LC:16462
    public ToStringBuilder append(final char[] array) {//LC:16463
        style.append(buffer, null, array, null);//LC:16464
        return this;//LC:16465
    }//LC:16466
//LC:16467
    //----------------------------------------------------------------------------//LC:16468
//LC:16469
    /**//LC:16470
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:16471
     * value.</p>//LC:16472
     *//LC:16473
     * @param value  the value to add to the <code>toString</code>//LC:16474
     * @return this//LC:16475
     *///LC:16476
    public ToStringBuilder append(final double value) {//LC:16477
        style.append(buffer, null, value);//LC:16478
        return this;//LC:16479
    }//LC:16480
//LC:16481
    //----------------------------------------------------------------------------//LC:16482
//LC:16483
    /**//LC:16484
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:16485
     * array.</p>//LC:16486
     *//LC:16487
     * @param array  the array to add to the <code>toString</code>//LC:16488
     * @return this//LC:16489
     *///LC:16490
    public ToStringBuilder append(final double[] array) {//LC:16491
        style.append(buffer, null, array, null);//LC:16492
        return this;//LC:16493
    }//LC:16494
//LC:16495
    //----------------------------------------------------------------------------//LC:16496
//LC:16497
    /**//LC:16498
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:16499
     * value.</p>//LC:16500
     *//LC:16501
     * @param value  the value to add to the <code>toString</code>//LC:16502
     * @return this//LC:16503
     *///LC:16504
    public ToStringBuilder append(final float value) {//LC:16505
        style.append(buffer, null, value);//LC:16506
        return this;//LC:16507
    }//LC:16508
//LC:16509
    //----------------------------------------------------------------------------//LC:16510
//LC:16511
    /**//LC:16512
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:16513
     * array.</p>//LC:16514
     *//LC:16515
     * @param array  the array to add to the <code>toString</code>//LC:16516
     * @return this//LC:16517
     *///LC:16518
    public ToStringBuilder append(final float[] array) {//LC:16519
        style.append(buffer, null, array, null);//LC:16520
        return this;//LC:16521
    }//LC:16522
//LC:16523
    //----------------------------------------------------------------------------//LC:16524
//LC:16525
    /**//LC:16526
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:16527
     * value.</p>//LC:16528
     *//LC:16529
     * @param value  the value to add to the <code>toString</code>//LC:16530
     * @return this//LC:16531
     *///LC:16532
    public ToStringBuilder append(final int value) {//LC:16533
        style.append(buffer, null, value);//LC:16534
        return this;//LC:16535
    }//LC:16536
//LC:16537
    //----------------------------------------------------------------------------//LC:16538
//LC:16539
    /**//LC:16540
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:16541
     * array.</p>//LC:16542
     *//LC:16543
     * @param array  the array to add to the <code>toString</code>//LC:16544
     * @return this//LC:16545
     *///LC:16546
    public ToStringBuilder append(final int[] array) {//LC:16547
        style.append(buffer, null, array, null);//LC:16548
        return this;//LC:16549
    }//LC:16550
//LC:16551
    //----------------------------------------------------------------------------//LC:16552
//LC:16553
    /**//LC:16554
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:16555
     * value.</p>//LC:16556
     *//LC:16557
     * @param value  the value to add to the <code>toString</code>//LC:16558
     * @return this//LC:16559
     *///LC:16560
    public ToStringBuilder append(final long value) {//LC:16561
        style.append(buffer, null, value);//LC:16562
        return this;//LC:16563
    }//LC:16564
//LC:16565
    //----------------------------------------------------------------------------//LC:16566
//LC:16567
    /**//LC:16568
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:16569
     * array.</p>//LC:16570
     *//LC:16571
     * @param array  the array to add to the <code>toString</code>//LC:16572
     * @return this//LC:16573
     *///LC:16574
    public ToStringBuilder append(final long[] array) {//LC:16575
        style.append(buffer, null, array, null);//LC:16576
        return this;//LC:16577
    }//LC:16578
//LC:16579
    //----------------------------------------------------------------------------//LC:16580
//LC:16581
    /**//LC:16582
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16583
     * value.</p>//LC:16584
     *//LC:16585
     * @param obj  the value to add to the <code>toString</code>//LC:16586
     * @return this//LC:16587
     *///LC:16588
    public ToStringBuilder append(final Object obj) {//LC:16589
        style.append(buffer, null, obj, null);//LC:16590
        return this;//LC:16591
    }//LC:16592
//LC:16593
    //----------------------------------------------------------------------------//LC:16594
//LC:16595
    /**//LC:16596
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16597
     * array.</p>//LC:16598
     *//LC:16599
     * @param array  the array to add to the <code>toString</code>//LC:16600
     * @return this//LC:16601
     *///LC:16602
    public ToStringBuilder append(final Object[] array) {//LC:16603
        style.append(buffer, null, array, null);//LC:16604
        return this;//LC:16605
    }//LC:16606
//LC:16607
    //----------------------------------------------------------------------------//LC:16608
//LC:16609
    /**//LC:16610
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:16611
     * value.</p>//LC:16612
     *//LC:16613
     * @param value  the value to add to the <code>toString</code>//LC:16614
     * @return this//LC:16615
     *///LC:16616
    public ToStringBuilder append(final short value) {//LC:16617
        style.append(buffer, null, value);//LC:16618
        return this;//LC:16619
    }//LC:16620
//LC:16621
    //----------------------------------------------------------------------------//LC:16622
//LC:16623
    /**//LC:16624
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:16625
     * array.</p>//LC:16626
     *//LC:16627
     * @param array  the array to add to the <code>toString</code>//LC:16628
     * @return this//LC:16629
     *///LC:16630
    public ToStringBuilder append(final short[] array) {//LC:16631
        style.append(buffer, null, array, null);//LC:16632
        return this;//LC:16633
    }//LC:16634
//LC:16635
    /**//LC:16636
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:16637
     * value.</p>//LC:16638
     *//LC:16639
     * @param fieldName  the field name//LC:16640
     * @param value  the value to add to the <code>toString</code>//LC:16641
     * @return this//LC:16642
     *///LC:16643
    public ToStringBuilder append(final String fieldName, final boolean value) {//LC:16644
        style.append(buffer, fieldName, value);//LC:16645
        return this;//LC:16646
    }//LC:16647
//LC:16648
    /**//LC:16649
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:16650
     * array.</p>//LC:16651
     *//LC:16652
     * @param fieldName  the field name//LC:16653
     * @param array  the array to add to the <code>hashCode</code>//LC:16654
     * @return this//LC:16655
     *///LC:16656
    public ToStringBuilder append(final String fieldName, final boolean[] array) {//LC:16657
        style.append(buffer, fieldName, array, null);//LC:16658
        return this;//LC:16659
    }//LC:16660
//LC:16661
    /**//LC:16662
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:16663
     * array.</p>//LC:16664
     *//LC:16665
     * <p>A boolean parameter controls the level of detail to show.//LC:16666
     * Setting <code>true</code> will output the array in full. Setting//LC:16667
     * <code>false</code> will output a summary, typically the size of//LC:16668
     * the array.</p>//LC:16669
     *//LC:16670
     * @param fieldName  the field name//LC:16671
     * @param array  the array to add to the <code>toString</code>//LC:16672
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16673
     *  for summary info//LC:16674
     * @return this//LC:16675
     *///LC:16676
    public ToStringBuilder append(final String fieldName, final boolean[] array, final boolean fullDetail) {//LC:16677
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16678
        return this;//LC:16679
    }//LC:16680
//LC:16681
    /**//LC:16682
     * <p>Append to the <code>toString</code> an <code>byte</code>//LC:16683
     * value.</p>//LC:16684
     *//LC:16685
     * @param fieldName  the field name//LC:16686
     * @param value  the value to add to the <code>toString</code>//LC:16687
     * @return this//LC:16688
     *///LC:16689
    public ToStringBuilder append(final String fieldName, final byte value) {//LC:16690
        style.append(buffer, fieldName, value);//LC:16691
        return this;//LC:16692
    }//LC:16693
//LC:16694
    /**//LC:16695
     * <p>Append to the <code>toString</code> a <code>byte</code> array.</p>//LC:16696
     *//LC:16697
     * @param fieldName  the field name//LC:16698
     * @param array  the array to add to the <code>toString</code>//LC:16699
     * @return this//LC:16700
     *///LC:16701
    public ToStringBuilder append(final String fieldName, final byte[] array) {//LC:16702
        style.append(buffer, fieldName, array, null);//LC:16703
        return this;//LC:16704
    }//LC:16705
//LC:16706
    /**//LC:16707
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:16708
     * array.</p>//LC:16709
     *//LC:16710
     * <p>A boolean parameter controls the level of detail to show.//LC:16711
     * Setting <code>true</code> will output the array in full. Setting//LC:16712
     * <code>false</code> will output a summary, typically the size of//LC:16713
     * the array.//LC:16714
     *//LC:16715
     * @param fieldName  the field name//LC:16716
     * @param array  the array to add to the <code>toString</code>//LC:16717
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16718
     *  for summary info//LC:16719
     * @return this//LC:16720
     *///LC:16721
    public ToStringBuilder append(final String fieldName, final byte[] array, final boolean fullDetail) {//LC:16722
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16723
        return this;//LC:16724
    }//LC:16725
//LC:16726
    /**//LC:16727
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:16728
     * value.</p>//LC:16729
     *//LC:16730
     * @param fieldName  the field name//LC:16731
     * @param value  the value to add to the <code>toString</code>//LC:16732
     * @return this//LC:16733
     *///LC:16734
    public ToStringBuilder append(final String fieldName, final char value) {//LC:16735
        style.append(buffer, fieldName, value);//LC:16736
        return this;//LC:16737
    }//LC:16738
//LC:16739
    /**//LC:16740
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:16741
     * array.</p>//LC:16742
     *//LC:16743
     * @param fieldName  the field name//LC:16744
     * @param array  the array to add to the <code>toString</code>//LC:16745
     * @return this//LC:16746
     *///LC:16747
    public ToStringBuilder append(final String fieldName, final char[] array) {//LC:16748
        style.append(buffer, fieldName, array, null);//LC:16749
        return this;//LC:16750
    }//LC:16751
//LC:16752
    /**//LC:16753
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:16754
     * array.</p>//LC:16755
     *//LC:16756
     * <p>A boolean parameter controls the level of detail to show.//LC:16757
     * Setting <code>true</code> will output the array in full. Setting//LC:16758
     * <code>false</code> will output a summary, typically the size of//LC:16759
     * the array.</p>//LC:16760
     *//LC:16761
     * @param fieldName  the field name//LC:16762
     * @param array  the array to add to the <code>toString</code>//LC:16763
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16764
     *  for summary info//LC:16765
     * @return this//LC:16766
     *///LC:16767
    public ToStringBuilder append(final String fieldName, final char[] array, final boolean fullDetail) {//LC:16768
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16769
        return this;//LC:16770
    }//LC:16771
//LC:16772
    /**//LC:16773
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:16774
     * value.</p>//LC:16775
     *//LC:16776
     * @param fieldName  the field name//LC:16777
     * @param value  the value to add to the <code>toString</code>//LC:16778
     * @return this//LC:16779
     *///LC:16780
    public ToStringBuilder append(final String fieldName, final double value) {//LC:16781
        style.append(buffer, fieldName, value);//LC:16782
        return this;//LC:16783
    }//LC:16784
//LC:16785
    /**//LC:16786
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:16787
     * array.</p>//LC:16788
     *//LC:16789
     * @param fieldName  the field name//LC:16790
     * @param array  the array to add to the <code>toString</code>//LC:16791
     * @return this//LC:16792
     *///LC:16793
    public ToStringBuilder append(final String fieldName, final double[] array) {//LC:16794
        style.append(buffer, fieldName, array, null);//LC:16795
        return this;//LC:16796
    }//LC:16797
//LC:16798
    /**//LC:16799
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:16800
     * array.</p>//LC:16801
     *//LC:16802
     * <p>A boolean parameter controls the level of detail to show.//LC:16803
     * Setting <code>true</code> will output the array in full. Setting//LC:16804
     * <code>false</code> will output a summary, typically the size of//LC:16805
     * the array.</p>//LC:16806
     *//LC:16807
     * @param fieldName  the field name//LC:16808
     * @param array  the array to add to the <code>toString</code>//LC:16809
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16810
     *  for summary info//LC:16811
     * @return this//LC:16812
     *///LC:16813
    public ToStringBuilder append(final String fieldName, final double[] array, final boolean fullDetail) {//LC:16814
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16815
        return this;//LC:16816
    }//LC:16817
//LC:16818
    /**//LC:16819
     * <p>Append to the <code>toString</code> an <code>float</code>//LC:16820
     * value.</p>//LC:16821
     *//LC:16822
     * @param fieldName  the field name//LC:16823
     * @param value  the value to add to the <code>toString</code>//LC:16824
     * @return this//LC:16825
     *///LC:16826
    public ToStringBuilder append(final String fieldName, final float value) {//LC:16827
        style.append(buffer, fieldName, value);//LC:16828
        return this;//LC:16829
    }//LC:16830
//LC:16831
    /**//LC:16832
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:16833
     * array.</p>//LC:16834
     *//LC:16835
     * @param fieldName  the field name//LC:16836
     * @param array  the array to add to the <code>toString</code>//LC:16837
     * @return this//LC:16838
     *///LC:16839
    public ToStringBuilder append(final String fieldName, final float[] array) {//LC:16840
        style.append(buffer, fieldName, array, null);//LC:16841
        return this;//LC:16842
    }//LC:16843
//LC:16844
    /**//LC:16845
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:16846
     * array.</p>//LC:16847
     *//LC:16848
     * <p>A boolean parameter controls the level of detail to show.//LC:16849
     * Setting <code>true</code> will output the array in full. Setting//LC:16850
     * <code>false</code> will output a summary, typically the size of//LC:16851
     * the array.</p>//LC:16852
     *//LC:16853
     * @param fieldName  the field name//LC:16854
     * @param array  the array to add to the <code>toString</code>//LC:16855
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16856
     *  for summary info//LC:16857
     * @return this//LC:16858
     *///LC:16859
    public ToStringBuilder append(final String fieldName, final float[] array, final boolean fullDetail) {//LC:16860
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16861
        return this;//LC:16862
    }//LC:16863
//LC:16864
    /**//LC:16865
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:16866
     * value.</p>//LC:16867
     *//LC:16868
     * @param fieldName  the field name//LC:16869
     * @param value  the value to add to the <code>toString</code>//LC:16870
     * @return this//LC:16871
     *///LC:16872
    public ToStringBuilder append(final String fieldName, final int value) {//LC:16873
        style.append(buffer, fieldName, value);//LC:16874
        return this;//LC:16875
    }//LC:16876
//LC:16877
    /**//LC:16878
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:16879
     * array.</p>//LC:16880
     *//LC:16881
     * @param fieldName  the field name//LC:16882
     * @param array  the array to add to the <code>toString</code>//LC:16883
     * @return this//LC:16884
     *///LC:16885
    public ToStringBuilder append(final String fieldName, final int[] array) {//LC:16886
        style.append(buffer, fieldName, array, null);//LC:16887
        return this;//LC:16888
    }//LC:16889
//LC:16890
    /**//LC:16891
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:16892
     * array.</p>//LC:16893
     *//LC:16894
     * <p>A boolean parameter controls the level of detail to show.//LC:16895
     * Setting <code>true</code> will output the array in full. Setting//LC:16896
     * <code>false</code> will output a summary, typically the size of//LC:16897
     * the array.</p>//LC:16898
     *//LC:16899
     * @param fieldName  the field name//LC:16900
     * @param array  the array to add to the <code>toString</code>//LC:16901
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16902
     *  for summary info//LC:16903
     * @return this//LC:16904
     *///LC:16905
    public ToStringBuilder append(final String fieldName, final int[] array, final boolean fullDetail) {//LC:16906
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16907
        return this;//LC:16908
    }//LC:16909
//LC:16910
    /**//LC:16911
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:16912
     * value.</p>//LC:16913
     *//LC:16914
     * @param fieldName  the field name//LC:16915
     * @param value  the value to add to the <code>toString</code>//LC:16916
     * @return this//LC:16917
     *///LC:16918
    public ToStringBuilder append(final String fieldName, final long value) {//LC:16919
        style.append(buffer, fieldName, value);//LC:16920
        return this;//LC:16921
    }//LC:16922
//LC:16923
    /**//LC:16924
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:16925
     * array.</p>//LC:16926
     *//LC:16927
     * @param fieldName  the field name//LC:16928
     * @param array  the array to add to the <code>toString</code>//LC:16929
     * @return this//LC:16930
     *///LC:16931
    public ToStringBuilder append(final String fieldName, final long[] array) {//LC:16932
        style.append(buffer, fieldName, array, null);//LC:16933
        return this;//LC:16934
    }//LC:16935
//LC:16936
    /**//LC:16937
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:16938
     * array.</p>//LC:16939
     *//LC:16940
     * <p>A boolean parameter controls the level of detail to show.//LC:16941
     * Setting <code>true</code> will output the array in full. Setting//LC:16942
     * <code>false</code> will output a summary, typically the size of//LC:16943
     * the array.</p>//LC:16944
     *//LC:16945
     * @param fieldName  the field name//LC:16946
     * @param array  the array to add to the <code>toString</code>//LC:16947
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:16948
     *  for summary info//LC:16949
     * @return this//LC:16950
     *///LC:16951
    public ToStringBuilder append(final String fieldName, final long[] array, final boolean fullDetail) {//LC:16952
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:16953
        return this;//LC:16954
    }//LC:16955
//LC:16956
    /**//LC:16957
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16958
     * value.</p>//LC:16959
     *//LC:16960
     * @param fieldName  the field name//LC:16961
     * @param obj  the value to add to the <code>toString</code>//LC:16962
     * @return this//LC:16963
     *///LC:16964
    public ToStringBuilder append(final String fieldName, final Object obj) {//LC:16965
        style.append(buffer, fieldName, obj, null);//LC:16966
        return this;//LC:16967
    }//LC:16968
//LC:16969
    /**//LC:16970
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16971
     * value.</p>//LC:16972
     *//LC:16973
     * @param fieldName  the field name//LC:16974
     * @param obj  the value to add to the <code>toString</code>//LC:16975
     * @param fullDetail  <code>true</code> for detail,//LC:16976
     *  <code>false</code> for summary info//LC:16977
     * @return this//LC:16978
     *///LC:16979
    public ToStringBuilder append(final String fieldName, final Object obj, final boolean fullDetail) {//LC:16980
        style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail));//LC:16981
        return this;//LC:16982
    }//LC:16983
//LC:16984
    /**//LC:16985
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16986
     * array.</p>//LC:16987
     *//LC:16988
     * @param fieldName  the field name//LC:16989
     * @param array  the array to add to the <code>toString</code>//LC:16990
     * @return this//LC:16991
     *///LC:16992
    public ToStringBuilder append(final String fieldName, final Object[] array) {//LC:16993
        style.append(buffer, fieldName, array, null);//LC:16994
        return this;//LC:16995
    }//LC:16996
//LC:16997
    /**//LC:16998
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:16999
     * array.</p>//LC:17000
     *//LC:17001
     * <p>A boolean parameter controls the level of detail to show.//LC:17002
     * Setting <code>true</code> will output the array in full. Setting//LC:17003
     * <code>false</code> will output a summary, typically the size of//LC:17004
     * the array.</p>//LC:17005
     *//LC:17006
     * @param fieldName  the field name//LC:17007
     * @param array  the array to add to the <code>toString</code>//LC:17008
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:17009
     *  for summary info//LC:17010
     * @return this//LC:17011
     *///LC:17012
    public ToStringBuilder append(final String fieldName, final Object[] array, final boolean fullDetail) {//LC:17013
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:17014
        return this;//LC:17015
    }//LC:17016
//LC:17017
    /**//LC:17018
     * <p>Append to the <code>toString</code> an <code>short</code>//LC:17019
     * value.</p>//LC:17020
     *//LC:17021
     * @param fieldName  the field name//LC:17022
     * @param value  the value to add to the <code>toString</code>//LC:17023
     * @return this//LC:17024
     *///LC:17025
    public ToStringBuilder append(final String fieldName, final short value) {//LC:17026
        style.append(buffer, fieldName, value);//LC:17027
        return this;//LC:17028
    }//LC:17029
//LC:17030
    /**//LC:17031
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:17032
     * array.</p>//LC:17033
     *//LC:17034
     * @param fieldName  the field name//LC:17035
     * @param array  the array to add to the <code>toString</code>//LC:17036
     * @return this//LC:17037
     *///LC:17038
    public ToStringBuilder append(final String fieldName, final short[] array) {//LC:17039
        style.append(buffer, fieldName, array, null);//LC:17040
        return this;//LC:17041
    }//LC:17042
//LC:17043
    /**//LC:17044
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:17045
     * array.</p>//LC:17046
     *//LC:17047
     * <p>A boolean parameter controls the level of detail to show.//LC:17048
     * Setting <code>true</code> will output the array in full. Setting//LC:17049
     * <code>false</code> will output a summary, typically the size of//LC:17050
     * the array.//LC:17051
     *//LC:17052
     * @param fieldName  the field name//LC:17053
     * @param array  the array to add to the <code>toString</code>//LC:17054
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:17055
     *  for summary info//LC:17056
     * @return this//LC:17057
     *///LC:17058
    public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {//LC:17059
        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));//LC:17060
        return this;//LC:17061
    }//LC:17062
//LC:17063
    /**//LC:17064
     * <p>Appends with the same format as the default <code>Object toString()//LC:17065
     * </code> method. Appends the class name followed by//LC:17066
     * {@link System#identityHashCode(java.lang.Object)}.</p>//LC:17067
     *//LC:17068
     * @param object  the <code>Object</code> whose class name and id to output//LC:17069
     * @return this//LC:17070
     * @since 2.0//LC:17071
     *///LC:17072
    public ToStringBuilder appendAsObjectToString(final Object object) {//LC:17073
        ObjectUtils.identityToString(this.getStringBuffer(), object);//LC:17074
        return this;//LC:17075
    }//LC:17076
//LC:17077
    //----------------------------------------------------------------------------//LC:17078
//LC:17079
    /**//LC:17080
     * <p>Append the <code>toString</code> from the superclass.</p>//LC:17081
     *//LC:17082
     * <p>This method assumes that the superclass uses the same <code>ToStringStyle</code>//LC:17083
     * as this one.</p>//LC:17084
     *//LC:17085
     * <p>If <code>superToString</code> is <code>null</code>, no change is made.</p>//LC:17086
     *//LC:17087
     * @param superToString  the result of <code>super.toString()</code>//LC:17088
     * @return this//LC:17089
     * @since 2.0//LC:17090
     *///LC:17091
    public ToStringBuilder appendSuper(final String superToString) {//LC:17092
        if (superToString != null) {//LC:17093
            style.appendSuper(buffer, superToString);//LC:17094
        }//LC:17095
        return this;//LC:17096
    }//LC:17097
//LC:17098
    /**//LC:17099
     * <p>Append the <code>toString</code> from another object.</p>//LC:17100
     *//LC:17101
     * <p>This method is useful where a class delegates most of the implementation of//LC:17102
     * its properties to another class. You can then call <code>toString()</code> on//LC:17103
     * the other class and pass the result into this method.</p>//LC:17104
     *//LC:17105
     * <pre>//LC:17106
     *   private AnotherObject delegate;//LC:17107
     *   private String fieldInThisClass;//LC:17108
     *//LC:17109
     *   public String toString() {//LC:17110
     *     return new ToStringBuilder(this).//LC:17111
     *       appendToString(delegate.toString()).//LC:17112
     *       append(fieldInThisClass).//LC:17113
     *       toString();//LC:17114
     *   }</pre>//LC:17115
     *//LC:17116
     * <p>This method assumes that the other object uses the same <code>ToStringStyle</code>//LC:17117
     * as this one.</p>//LC:17118
     *//LC:17119
     * <p>If the <code>toString</code> is <code>null</code>, no change is made.</p>//LC:17120
     *//LC:17121
     * @param toString  the result of <code>toString()</code> on another object//LC:17122
     * @return this//LC:17123
     * @since 2.0//LC:17124
     *///LC:17125
    public ToStringBuilder appendToString(final String toString) {//LC:17126
        if (toString != null) {//LC:17127
            style.appendToString(buffer, toString);//LC:17128
        }//LC:17129
        return this;//LC:17130
    }//LC:17131
//LC:17132
    /**//LC:17133
     * <p>Returns the <code>Object</code> being output.</p>//LC:17134
     *//LC:17135
     * @return The object being output.//LC:17136
     * @since 2.0//LC:17137
     *///LC:17138
    public Object getObject() {//LC:17139
        return object;//LC:17140
    }//LC:17141
//LC:17142
    /**//LC:17143
     * <p>Gets the <code>StringBuffer</code> being populated.</p>//LC:17144
     *//LC:17145
     * @return the <code>StringBuffer</code> being populated//LC:17146
     *///LC:17147
    public StringBuffer getStringBuffer() {//LC:17148
        return buffer;//LC:17149
    }//LC:17150
//LC:17151
    //----------------------------------------------------------------------------//LC:17152
//LC:17153
    /**//LC:17154
     * <p>Gets the <code>ToStringStyle</code> being used.</p>//LC:17155
     *//LC:17156
     * @return the <code>ToStringStyle</code> being used//LC:17157
     * @since 2.0//LC:17158
     *///LC:17159
    public ToStringStyle getStyle() {//LC:17160
        return style;//LC:17161
    }//LC:17162
//LC:17163
    /**//LC:17164
     * <p>Returns the built <code>toString</code>.</p>//LC:17165
     *//LC:17166
     * <p>This method appends the end of data indicator, and can only be called once.//LC:17167
     * Use {@link #getStringBuffer} to get the current string state.</p>//LC:17168
     *//LC:17169
     * <p>If the object is <code>null</code>, return the style's <code>nullText</code></p>//LC:17170
     *//LC:17171
     * @return the String <code>toString</code>//LC:17172
     *///LC:17173
    @Override//LC:17174
    public String toString() {//LC:17175
        if (this.getObject() == null) {//LC:17176
            this.getStringBuffer().append(this.getStyle().getNullText());//LC:17177
        } else {//LC:17178
            style.appendEnd(this.getStringBuffer(), this.getObject());//LC:17179
        }//LC:17180
        return this.getStringBuffer().toString();//LC:17181
    }//LC:17182
//LC:17183
    /**//LC:17184
     * Returns the String that was build as an object representation. The//LC:17185
     * default implementation utilizes the {@link #toString()} implementation.//LC:17186
     *//LC:17187
     * @return the String <code>toString</code>//LC:17188
     *//LC:17189
     * @see #toString()//LC:17190
     *//LC:17191
     * @since 3.0//LC:17192
     *///LC:17193
    @Override//LC:17194
    public String build() {//LC:17195
        return toString();//LC:17196
    }//LC:17197
}//LC:17198
//LC:17199
//LC:17200
/**//LC:17201
 * <p>Controls <code>String</code> formatting for {@link ToStringBuilder}.//LC:17202
 * The main public interface is always via <code>ToStringBuilder</code>.</p>//LC:17203
 *//LC:17204
 * <p>These classes are intended to be used as <code>Singletons</code>.//LC:17205
 * There is no need to instantiate a new style each time. A program//LC:17206
 * will generally use one of the predefined constants on this class.//LC:17207
 * Alternatively, the {@link StandardToStringStyle} class can be used//LC:17208
 * to set the individual settings. Thus most styles can be achieved//LC:17209
 * without subclassing.</p>//LC:17210
 *//LC:17211
 * <p>If required, a subclass can override as many or as few of the//LC:17212
 * methods as it requires. Each object type (from <code>boolean</code>//LC:17213
 * to <code>long</code> to <code>Object</code> to <code>int[]</code>) has//LC:17214
 * its own methods to output it. Most have two versions, detail and summary.//LC:17215
 *//LC:17216
 * <p>For example, the detail version of the array based methods will//LC:17217
 * output the whole array, whereas the summary method will just output//LC:17218
 * the array length.</p>//LC:17219
 *//LC:17220
 * <p>If you want to format the output of certain objects, such as dates, you//LC:17221
 * must create a subclass and override a method.//LC:17222
 * <pre>//LC:17223
 * public class MyStyle extends ToStringStyle {//LC:17224
 *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {//LC:17225
 *     if (value instanceof Date) {//LC:17226
 *       value = new SimpleDateFormat("yyyy-MM-dd").format(value);//LC:17227
 *     }//LC:17228
 *     buffer.append(value);//LC:17229
 *   }//LC:17230
 * }//LC:17231
 * </pre>//LC:17232
 * </p>//LC:17233
 *//LC:17234
 * @since 1.0//LC:17235
 * @version $Id$//LC:17236
 *///LC:17237
abstract class ToStringStyle implements Serializable {//LC:17238
//LC:17239
    /**//LC:17240
     * Serialization version ID.//LC:17241
     *///LC:17242
    private static final long serialVersionUID = -2587890625525655916L;//LC:17243
//LC:17244
    /**//LC:17245
     * The default toString style. Using the Using the <code>Person</code>//LC:17246
     * example from {@link ToStringBuilder}, the output would look like this://LC:17247
     *//LC:17248
     * <pre>//LC:17249
     * Person@182f0db[name=John Doe,age=33,smoker=false]//LC:17250
     * </pre>//LC:17251
     *///LC:17252
    public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();//LC:17253
//LC:17254
    /**//LC:17255
     * The multi line toString style. Using the Using the <code>Person</code>//LC:17256
     * example from {@link ToStringBuilder}, the output would look like this://LC:17257
     *//LC:17258
     * <pre>//LC:17259
     * Person@182f0db[//LC:17260
     *   name=John Doe//LC:17261
     *   age=33//LC:17262
     *   smoker=false//LC:17263
     * ]//LC:17264
     * </pre>//LC:17265
     *///LC:17266
    public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();//LC:17267
//LC:17268
    /**//LC:17269
     * The no field names toString style. Using the Using the//LC:17270
     * <code>Person</code> example from {@link ToStringBuilder}, the output//LC:17271
     * would look like this://LC:17272
     *//LC:17273
     * <pre>//LC:17274
     * Person@182f0db[John Doe,33,false]//LC:17275
     * </pre>//LC:17276
     *///LC:17277
    public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();//LC:17278
//LC:17279
    /**//LC:17280
     * The short prefix toString style. Using the <code>Person</code> example//LC:17281
     * from {@link ToStringBuilder}, the output would look like this://LC:17282
     *//LC:17283
     * <pre>//LC:17284
     * Person[name=John Doe,age=33,smoker=false]//LC:17285
     * </pre>//LC:17286
     *//LC:17287
     * @since 2.1//LC:17288
     *///LC:17289
    public static final ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle();//LC:17290
//LC:17291
    /**//LC:17292
     * The simple toString style. Using the Using the <code>Person</code>//LC:17293
     * example from {@link ToStringBuilder}, the output would look like this://LC:17294
     *//LC:17295
     * <pre>//LC:17296
     * John Doe,33,false//LC:17297
     * </pre>//LC:17298
     *///LC:17299
    public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();//LC:17300
//LC:17301
    /**//LC:17302
     * <p>//LC:17303
     * A registry of objects used by <code>reflectionToString</code> methods//LC:17304
     * to detect cyclical object references and avoid infinite loops.//LC:17305
     * </p>//LC:17306
     *///LC:17307
    private static final ThreadLocal<WeakHashMap<Object, Object>> REGISTRY =//LC:17308
            new ThreadLocal<WeakHashMap<Object,Object>>();//LC:17309
    /*//LC:17310
     * Note that objects of this class are generally shared between threads, so//LC:17311
     * an instance variable would not be suitable here.//LC:17312
     *//LC:17313
     * In normal use the registry should always be left empty, because the caller//LC:17314
     * should call toString() which will clean up.//LC:17315
     *//LC:17316
     * See LANG-792//LC:17317
     *///LC:17318
//LC:17319
    /**//LC:17320
     * <p>//LC:17321
     * Returns the registry of objects being traversed by the <code>reflectionToString</code>//LC:17322
     * methods in the current thread.//LC:17323
     * </p>//LC:17324
     *//LC:17325
     * @return Set the registry of objects being traversed//LC:17326
     *///LC:17327
    static Map<Object, Object> getRegistry() {//LC:17328
        return REGISTRY.get();//LC:17329
    }//LC:17330
//LC:17331
    /**//LC:17332
     * <p>//LC:17333
     * Returns <code>true</code> if the registry contains the given object.//LC:17334
     * Used by the reflection methods to avoid infinite loops.//LC:17335
     * </p>//LC:17336
     *//LC:17337
     * @param value//LC:17338
     *                  The object to lookup in the registry.//LC:17339
     * @return boolean <code>true</code> if the registry contains the given//LC:17340
     *             object.//LC:17341
     *///LC:17342
    static boolean isRegistered(final Object value) {//LC:17343
        final Map<Object, Object> m = getRegistry();//LC:17344
        return m != null && m.containsKey(value);//LC:17345
    }//LC:17346
//LC:17347
    /**//LC:17348
     * <p>//LC:17349
     * Registers the given object. Used by the reflection methods to avoid//LC:17350
     * infinite loops.//LC:17351
     * </p>//LC:17352
     *//LC:17353
     * @param value//LC:17354
     *                  The object to register.//LC:17355
     *///LC:17356
    static void register(final Object value) {//LC:17357
        if (value != null) {//LC:17358
            final Map<Object, Object> m = getRegistry();//LC:17359
            if (m == null) {//LC:17360
                REGISTRY.set(new WeakHashMap<Object, Object>());//LC:17361
            }//LC:17362
            getRegistry().put(value, null);//LC:17363
        }//LC:17364
    }//LC:17365
//LC:17366
    /**//LC:17367
     * <p>//LC:17368
     * Unregisters the given object.//LC:17369
     * </p>//LC:17370
     *//LC:17371
     * <p>//LC:17372
     * Used by the reflection methods to avoid infinite loops.//LC:17373
     * </p>//LC:17374
     *//LC:17375
     * @param value//LC:17376
     *                  The object to unregister.//LC:17377
     *///LC:17378
    static void unregister(final Object value) {//LC:17379
        if (value != null) {//LC:17380
            final Map<Object, Object> m = getRegistry();//LC:17381
            if (m != null) {//LC:17382
                m.remove(value);//LC:17383
                if (m.isEmpty()) {//LC:17384
                    REGISTRY.remove();//LC:17385
                }//LC:17386
            }//LC:17387
        }//LC:17388
    }//LC:17389
//LC:17390
    /**//LC:17391
     * Whether to use the field names, the default is <code>true</code>.//LC:17392
     *///LC:17393
    private boolean useFieldNames = true;//LC:17394
//LC:17395
    /**//LC:17396
     * Whether to use the class name, the default is <code>true</code>.//LC:17397
     *///LC:17398
    private boolean useClassName = true;//LC:17399
//LC:17400
    /**//LC:17401
     * Whether to use short class names, the default is <code>false</code>.//LC:17402
     *///LC:17403
    private boolean useShortClassName = false;//LC:17404
//LC:17405
    /**//LC:17406
     * Whether to use the identity hash code, the default is <code>true</code>.//LC:17407
     *///LC:17408
    private boolean useIdentityHashCode = true;//LC:17409
//LC:17410
    /**//LC:17411
     * The content start <code>'['</code>.//LC:17412
     *///LC:17413
    private String contentStart = "[";//LC:17414
//LC:17415
    /**//LC:17416
     * The content end <code>']'</code>.//LC:17417
     *///LC:17418
    private String contentEnd = "]";//LC:17419
//LC:17420
    /**//LC:17421
     * The field name value separator <code>'='</code>.//LC:17422
     *///LC:17423
    private String fieldNameValueSeparator = "=";//LC:17424
//LC:17425
    /**//LC:17426
     * Whether the field separator should be added before any other fields.//LC:17427
     *///LC:17428
    private boolean fieldSeparatorAtStart = false;//LC:17429
//LC:17430
    /**//LC:17431
     * Whether the field separator should be added after any other fields.//LC:17432
     *///LC:17433
    private boolean fieldSeparatorAtEnd = false;//LC:17434
//LC:17435
    /**//LC:17436
     * The field separator <code>','</code>.//LC:17437
     *///LC:17438
    private String fieldSeparator = ",";//LC:17439
//LC:17440
    /**//LC:17441
     * The array start <code>'{'</code>.//LC:17442
     *///LC:17443
    private String arrayStart = "{";//LC:17444
//LC:17445
    /**//LC:17446
     * The array separator <code>','</code>.//LC:17447
     *///LC:17448
    private String arraySeparator = ",";//LC:17449
//LC:17450
    /**//LC:17451
     * The detail for array content.//LC:17452
     *///LC:17453
    private boolean arrayContentDetail = true;//LC:17454
//LC:17455
    /**//LC:17456
     * The array end <code>'}'</code>.//LC:17457
     *///LC:17458
    private String arrayEnd = "}";//LC:17459
//LC:17460
    /**//LC:17461
     * The value to use when fullDetail is <code>null</code>,//LC:17462
     * the default value is <code>true</code>.//LC:17463
     *///LC:17464
    private boolean defaultFullDetail = true;//LC:17465
//LC:17466
    /**//LC:17467
     * The <code>null</code> text <code>'&lt;null&gt;'</code>.//LC:17468
     *///LC:17469
    private String nullText = "<null>";//LC:17470
//LC:17471
    /**//LC:17472
     * The summary size text start <code>'<size'</code>.//LC:17473
     *///LC:17474
    private String sizeStartText = "<size=";//LC:17475
//LC:17476
    /**//LC:17477
     * The summary size text start <code>'&gt;'</code>.//LC:17478
     *///LC:17479
    private String sizeEndText = ">";//LC:17480
//LC:17481
    /**//LC:17482
     * The summary object text start <code>'&lt;'</code>.//LC:17483
     *///LC:17484
    private String summaryObjectStartText = "<";//LC:17485
//LC:17486
    /**//LC:17487
     * The summary object text start <code>'&gt;'</code>.//LC:17488
     *///LC:17489
    private String summaryObjectEndText = ">";//LC:17490
//LC:17491
    //----------------------------------------------------------------------------//LC:17492
//LC:17493
    /**//LC:17494
     * <p>Constructor.</p>//LC:17495
     *///LC:17496
    protected ToStringStyle() {//LC:17497
        super();//LC:17498
    }//LC:17499
//LC:17500
    //----------------------------------------------------------------------------//LC:17501
//LC:17502
    /**//LC:17503
     * <p>Append to the <code>toString</code> the superclass toString.</p>//LC:17504
     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>//LC:17505
     *//LC:17506
     * <p>A <code>null</code> <code>superToString</code> is ignored.</p>//LC:17507
     *//LC:17508
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17509
     * @param superToString  the <code>super.toString()</code>//LC:17510
     * @since 2.0//LC:17511
     *///LC:17512
    public void appendSuper(final StringBuffer buffer, final String superToString) {//LC:17513
        appendToString(buffer, superToString);//LC:17514
    }//LC:17515
//LC:17516
    /**//LC:17517
     * <p>Append to the <code>toString</code> another toString.</p>//LC:17518
     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>//LC:17519
     *//LC:17520
     * <p>A <code>null</code> <code>toString</code> is ignored.</p>//LC:17521
     *//LC:17522
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17523
     * @param toString  the additional <code>toString</code>//LC:17524
     * @since 2.0//LC:17525
     *///LC:17526
    public void appendToString(final StringBuffer buffer, final String toString) {//LC:17527
        if (toString != null) {//LC:17528
            final int pos1 = toString.indexOf(contentStart) + contentStart.length();//LC:17529
            final int pos2 = toString.lastIndexOf(contentEnd);//LC:17530
            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {//LC:17531
                final String data = toString.substring(pos1, pos2);//LC:17532
                if (fieldSeparatorAtStart) {//LC:17533
                    removeLastFieldSeparator(buffer);//LC:17534
                }//LC:17535
                buffer.append(data);//LC:17536
                appendFieldSeparator(buffer);//LC:17537
            }//LC:17538
        }//LC:17539
    }//LC:17540
//LC:17541
    /**//LC:17542
     * <p>Append to the <code>toString</code> the start of data indicator.</p>//LC:17543
     *//LC:17544
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17545
     * @param object  the <code>Object</code> to build a <code>toString</code> for//LC:17546
     *///LC:17547
    public void appendStart(final StringBuffer buffer, final Object object) {//LC:17548
        if (object != null) {//LC:17549
            appendClassName(buffer, object);//LC:17550
            appendIdentityHashCode(buffer, object);//LC:17551
            appendContentStart(buffer);//LC:17552
            if (fieldSeparatorAtStart) {//LC:17553
                appendFieldSeparator(buffer);//LC:17554
            }//LC:17555
        }//LC:17556
    }//LC:17557
//LC:17558
    /**//LC:17559
     * <p>Append to the <code>toString</code> the end of data indicator.</p>//LC:17560
     *//LC:17561
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17562
     * @param object  the <code>Object</code> to build a//LC:17563
     *  <code>toString</code> for.//LC:17564
     *///LC:17565
    public void appendEnd(final StringBuffer buffer, final Object object) {//LC:17566
        if (this.fieldSeparatorAtEnd == false) {//LC:17567
            removeLastFieldSeparator(buffer);//LC:17568
        }//LC:17569
        appendContentEnd(buffer);//LC:17570
        unregister(object);//LC:17571
    }//LC:17572
//LC:17573
    /**//LC:17574
     * <p>Remove the last field separator from the buffer.</p>//LC:17575
     *//LC:17576
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17577
     * @since 2.0//LC:17578
     *///LC:17579
    protected void removeLastFieldSeparator(final StringBuffer buffer) {//LC:17580
        final int len = buffer.length();//LC:17581
        final int sepLen = fieldSeparator.length();//LC:17582
        if (len > 0 && sepLen > 0 && len >= sepLen) {//LC:17583
            boolean match = true;//LC:17584
            for (int i = 0; i < sepLen; i++) {//LC:17585
                if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {//LC:17586
                    match = false;//LC:17587
                    break;//LC:17588
                }//LC:17589
            }//LC:17590
            if (match) {//LC:17591
                buffer.setLength(len - sepLen);//LC:17592
            }//LC:17593
        }//LC:17594
    }//LC:17595
//LC:17596
    //----------------------------------------------------------------------------//LC:17597
//LC:17598
    /**//LC:17599
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:17600
     * value, printing the full <code>toString</code> of the//LC:17601
     * <code>Object</code> passed in.</p>//LC:17602
     *//LC:17603
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17604
     * @param fieldName  the field name//LC:17605
     * @param value  the value to add to the <code>toString</code>//LC:17606
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:17607
     *  for summary info, <code>null</code> for style decides//LC:17608
     *///LC:17609
    public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) {//LC:17610
        appendFieldStart(buffer, fieldName);//LC:17611
//LC:17612
        if (value == null) {//LC:17613
            appendNullText(buffer, fieldName);//LC:17614
//LC:17615
        } else {//LC:17616
            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));//LC:17617
        }//LC:17618
//LC:17619
        appendFieldEnd(buffer, fieldName);//LC:17620
    }//LC:17621
//LC:17622
    /**//LC:17623
     * <p>Append to the <code>toString</code> an <code>Object</code>,//LC:17624
     * correctly interpreting its type.</p>//LC:17625
     *//LC:17626
     * <p>This method performs the main lookup by Class type to correctly//LC:17627
     * route arrays, <code>Collections</code>, <code>Maps</code> and//LC:17628
     * <code>Objects</code> to the appropriate method.</p>//LC:17629
     *//LC:17630
     * <p>Either detail or summary views can be specified.</p>//LC:17631
     *//LC:17632
     * <p>If a cycle is detected, an object will be appended with the//LC:17633
     * <code>Object.toString()</code> format.</p>//LC:17634
     *//LC:17635
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17636
     * @param fieldName  the field name, typically not used as already appended//LC:17637
     * @param value  the value to add to the <code>toString</code>,//LC:17638
     *  not <code>null</code>//LC:17639
     * @param detail  output detail or not//LC:17640
     *///LC:17641
    protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) {//LC:17642
        if (isRegistered(value)//LC:17643
                && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {//LC:17644
            appendCyclicObject(buffer, fieldName, value);//LC:17645
            return;//LC:17646
        }//LC:17647
//LC:17648
        register(value);//LC:17649
//LC:17650
        try {//LC:17651
            if (value instanceof Collection<?>) {//LC:17652
                if (detail) {//LC:17653
                    appendDetail(buffer, fieldName, (Collection<?>) value);//LC:17654
                } else {//LC:17655
                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());//LC:17656
                }//LC:17657
//LC:17658
            } else if (value instanceof Map<?, ?>) {//LC:17659
                if (detail) {//LC:17660
                    appendDetail(buffer, fieldName, (Map<?, ?>) value);//LC:17661
                } else {//LC:17662
                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());//LC:17663
                }//LC:17664
//LC:17665
            } else if (value instanceof long[]) {//LC:17666
                if (detail) {//LC:17667
                    appendDetail(buffer, fieldName, (long[]) value);//LC:17668
                } else {//LC:17669
                    appendSummary(buffer, fieldName, (long[]) value);//LC:17670
                }//LC:17671
//LC:17672
            } else if (value instanceof int[]) {//LC:17673
                if (detail) {//LC:17674
                    appendDetail(buffer, fieldName, (int[]) value);//LC:17675
                } else {//LC:17676
                    appendSummary(buffer, fieldName, (int[]) value);//LC:17677
                }//LC:17678
//LC:17679
            } else if (value instanceof short[]) {//LC:17680
                if (detail) {//LC:17681
                    appendDetail(buffer, fieldName, (short[]) value);//LC:17682
                } else {//LC:17683
                    appendSummary(buffer, fieldName, (short[]) value);//LC:17684
                }//LC:17685
//LC:17686
            } else if (value instanceof byte[]) {//LC:17687
                if (detail) {//LC:17688
                    appendDetail(buffer, fieldName, (byte[]) value);//LC:17689
                } else {//LC:17690
                    appendSummary(buffer, fieldName, (byte[]) value);//LC:17691
                }//LC:17692
//LC:17693
            } else if (value instanceof char[]) {//LC:17694
                if (detail) {//LC:17695
                    appendDetail(buffer, fieldName, (char[]) value);//LC:17696
                } else {//LC:17697
                    appendSummary(buffer, fieldName, (char[]) value);//LC:17698
                }//LC:17699
//LC:17700
            } else if (value instanceof double[]) {//LC:17701
                if (detail) {//LC:17702
                    appendDetail(buffer, fieldName, (double[]) value);//LC:17703
                } else {//LC:17704
                    appendSummary(buffer, fieldName, (double[]) value);//LC:17705
                }//LC:17706
//LC:17707
            } else if (value instanceof float[]) {//LC:17708
                if (detail) {//LC:17709
                    appendDetail(buffer, fieldName, (float[]) value);//LC:17710
                } else {//LC:17711
                    appendSummary(buffer, fieldName, (float[]) value);//LC:17712
                }//LC:17713
//LC:17714
            } else if (value instanceof boolean[]) {//LC:17715
                if (detail) {//LC:17716
                    appendDetail(buffer, fieldName, (boolean[]) value);//LC:17717
                } else {//LC:17718
                    appendSummary(buffer, fieldName, (boolean[]) value);//LC:17719
                }//LC:17720
//LC:17721
            } else if (value.getClass().isArray()) {//LC:17722
                if (detail) {//LC:17723
                    appendDetail(buffer, fieldName, (Object[]) value);//LC:17724
                } else {//LC:17725
                    appendSummary(buffer, fieldName, (Object[]) value);//LC:17726
                }//LC:17727
//LC:17728
            } else {//LC:17729
                if (detail) {//LC:17730
                    appendDetail(buffer, fieldName, value);//LC:17731
                } else {//LC:17732
                    appendSummary(buffer, fieldName, value);//LC:17733
                }//LC:17734
            }//LC:17735
        } finally {//LC:17736
            unregister(value);//LC:17737
        }//LC:17738
    }//LC:17739
//LC:17740
    /**//LC:17741
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:17742
     * value that has been detected to participate in a cycle. This//LC:17743
     * implementation will print the standard string value of the value.</p>//LC:17744
     *//LC:17745
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17746
     * @param fieldName  the field name, typically not used as already appended//LC:17747
     * @param value  the value to add to the <code>toString</code>,//LC:17748
     *  not <code>null</code>//LC:17749
     *//LC:17750
     * @since 2.2//LC:17751
     *///LC:17752
    protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) {//LC:17753
        ObjectUtils.identityToString(buffer, value);//LC:17754
    }//LC:17755
//LC:17756
    /**//LC:17757
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:17758
     * value, printing the full detail of the <code>Object</code>.</p>//LC:17759
     *//LC:17760
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17761
     * @param fieldName  the field name, typically not used as already appended//LC:17762
     * @param value  the value to add to the <code>toString</code>,//LC:17763
     *  not <code>null</code>//LC:17764
     *///LC:17765
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) {//LC:17766
        buffer.append(value);//LC:17767
    }//LC:17768
//LC:17769
    /**//LC:17770
     * <p>Append to the <code>toString</code> a <code>Collection</code>.</p>//LC:17771
     *//LC:17772
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17773
     * @param fieldName  the field name, typically not used as already appended//LC:17774
     * @param coll  the <code>Collection</code> to add to the//LC:17775
     *  <code>toString</code>, not <code>null</code>//LC:17776
     *///LC:17777
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) {//LC:17778
        buffer.append(coll);//LC:17779
    }//LC:17780
//LC:17781
    /**//LC:17782
     * <p>Append to the <code>toString</code> a <code>Map<code>.</p>//LC:17783
     *//LC:17784
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17785
     * @param fieldName  the field name, typically not used as already appended//LC:17786
     * @param map  the <code>Map</code> to add to the <code>toString</code>,//LC:17787
     *  not <code>null</code>//LC:17788
     *///LC:17789
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) {//LC:17790
        buffer.append(map);//LC:17791
    }//LC:17792
//LC:17793
    /**//LC:17794
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:17795
     * value, printing a summary of the <code>Object</code>.</P>//LC:17796
     *//LC:17797
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17798
     * @param fieldName  the field name, typically not used as already appended//LC:17799
     * @param value  the value to add to the <code>toString</code>,//LC:17800
     *  not <code>null</code>//LC:17801
     *///LC:17802
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) {//LC:17803
        buffer.append(summaryObjectStartText);//LC:17804
        buffer.append(getShortClassName(value.getClass()));//LC:17805
        buffer.append(summaryObjectEndText);//LC:17806
    }//LC:17807
//LC:17808
    //----------------------------------------------------------------------------//LC:17809
//LC:17810
    /**//LC:17811
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:17812
     * value.</p>//LC:17813
     *//LC:17814
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17815
     * @param fieldName  the field name//LC:17816
     * @param value  the value to add to the <code>toString</code>//LC:17817
     *///LC:17818
    public void append(final StringBuffer buffer, final String fieldName, final long value) {//LC:17819
        appendFieldStart(buffer, fieldName);//LC:17820
        appendDetail(buffer, fieldName, value);//LC:17821
        appendFieldEnd(buffer, fieldName);//LC:17822
    }//LC:17823
//LC:17824
    /**//LC:17825
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:17826
     * value.</p>//LC:17827
     *//LC:17828
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17829
     * @param fieldName  the field name, typically not used as already appended//LC:17830
     * @param value  the value to add to the <code>toString</code>//LC:17831
     *///LC:17832
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) {//LC:17833
        buffer.append(value);//LC:17834
    }//LC:17835
//LC:17836
    //----------------------------------------------------------------------------//LC:17837
//LC:17838
    /**//LC:17839
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:17840
     * value.</p>//LC:17841
     *//LC:17842
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17843
     * @param fieldName  the field name//LC:17844
     * @param value  the value to add to the <code>toString</code>//LC:17845
     *///LC:17846
    public void append(final StringBuffer buffer, final String fieldName, final int value) {//LC:17847
        appendFieldStart(buffer, fieldName);//LC:17848
        appendDetail(buffer, fieldName, value);//LC:17849
        appendFieldEnd(buffer, fieldName);//LC:17850
    }//LC:17851
//LC:17852
    /**//LC:17853
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:17854
     * value.</p>//LC:17855
     *//LC:17856
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17857
     * @param fieldName  the field name, typically not used as already appended//LC:17858
     * @param value  the value to add to the <code>toString</code>//LC:17859
     *///LC:17860
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) {//LC:17861
        buffer.append(value);//LC:17862
    }//LC:17863
//LC:17864
    //----------------------------------------------------------------------------//LC:17865
//LC:17866
    /**//LC:17867
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:17868
     * value.</p>//LC:17869
     *//LC:17870
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17871
     * @param fieldName  the field name//LC:17872
     * @param value  the value to add to the <code>toString</code>//LC:17873
     *///LC:17874
    public void append(final StringBuffer buffer, final String fieldName, final short value) {//LC:17875
        appendFieldStart(buffer, fieldName);//LC:17876
        appendDetail(buffer, fieldName, value);//LC:17877
        appendFieldEnd(buffer, fieldName);//LC:17878
    }//LC:17879
//LC:17880
    /**//LC:17881
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:17882
     * value.</p>//LC:17883
     *//LC:17884
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17885
     * @param fieldName  the field name, typically not used as already appended//LC:17886
     * @param value  the value to add to the <code>toString</code>//LC:17887
     *///LC:17888
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) {//LC:17889
        buffer.append(value);//LC:17890
    }//LC:17891
//LC:17892
    //----------------------------------------------------------------------------//LC:17893
//LC:17894
    /**//LC:17895
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:17896
     * value.</p>//LC:17897
     *//LC:17898
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17899
     * @param fieldName  the field name//LC:17900
     * @param value  the value to add to the <code>toString</code>//LC:17901
     *///LC:17902
    public void append(final StringBuffer buffer, final String fieldName, final byte value) {//LC:17903
        appendFieldStart(buffer, fieldName);//LC:17904
        appendDetail(buffer, fieldName, value);//LC:17905
        appendFieldEnd(buffer, fieldName);//LC:17906
    }//LC:17907
//LC:17908
    /**//LC:17909
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:17910
     * value.</p>//LC:17911
     *//LC:17912
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17913
     * @param fieldName  the field name, typically not used as already appended//LC:17914
     * @param value  the value to add to the <code>toString</code>//LC:17915
     *///LC:17916
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) {//LC:17917
        buffer.append(value);//LC:17918
    }//LC:17919
//LC:17920
    //----------------------------------------------------------------------------//LC:17921
//LC:17922
    /**//LC:17923
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:17924
     * value.</p>//LC:17925
     *//LC:17926
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17927
     * @param fieldName  the field name//LC:17928
     * @param value  the value to add to the <code>toString</code>//LC:17929
     *///LC:17930
    public void append(final StringBuffer buffer, final String fieldName, final char value) {//LC:17931
        appendFieldStart(buffer, fieldName);//LC:17932
        appendDetail(buffer, fieldName, value);//LC:17933
        appendFieldEnd(buffer, fieldName);//LC:17934
    }//LC:17935
//LC:17936
    /**//LC:17937
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:17938
     * value.</p>//LC:17939
     *//LC:17940
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17941
     * @param fieldName  the field name, typically not used as already appended//LC:17942
     * @param value  the value to add to the <code>toString</code>//LC:17943
     *///LC:17944
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) {//LC:17945
        buffer.append(value);//LC:17946
    }//LC:17947
//LC:17948
    //----------------------------------------------------------------------------//LC:17949
//LC:17950
    /**//LC:17951
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:17952
     * value.</p>//LC:17953
     *//LC:17954
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17955
     * @param fieldName  the field name//LC:17956
     * @param value  the value to add to the <code>toString</code>//LC:17957
     *///LC:17958
    public void append(final StringBuffer buffer, final String fieldName, final double value) {//LC:17959
        appendFieldStart(buffer, fieldName);//LC:17960
        appendDetail(buffer, fieldName, value);//LC:17961
        appendFieldEnd(buffer, fieldName);//LC:17962
    }//LC:17963
//LC:17964
    /**//LC:17965
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:17966
     * value.</p>//LC:17967
     *//LC:17968
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17969
     * @param fieldName  the field name, typically not used as already appended//LC:17970
     * @param value  the value to add to the <code>toString</code>//LC:17971
     *///LC:17972
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) {//LC:17973
        buffer.append(value);//LC:17974
    }//LC:17975
//LC:17976
    //----------------------------------------------------------------------------//LC:17977
//LC:17978
    /**//LC:17979
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:17980
     * value.</p>//LC:17981
     *//LC:17982
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17983
     * @param fieldName  the field name//LC:17984
     * @param value  the value to add to the <code>toString</code>//LC:17985
     *///LC:17986
    public void append(final StringBuffer buffer, final String fieldName, final float value) {//LC:17987
        appendFieldStart(buffer, fieldName);//LC:17988
        appendDetail(buffer, fieldName, value);//LC:17989
        appendFieldEnd(buffer, fieldName);//LC:17990
    }//LC:17991
//LC:17992
    /**//LC:17993
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:17994
     * value.</p>//LC:17995
     *//LC:17996
     * @param buffer  the <code>StringBuffer</code> to populate//LC:17997
     * @param fieldName  the field name, typically not used as already appended//LC:17998
     * @param value  the value to add to the <code>toString</code>//LC:17999
     *///LC:18000
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) {//LC:18001
        buffer.append(value);//LC:18002
    }//LC:18003
//LC:18004
    //----------------------------------------------------------------------------//LC:18005
//LC:18006
    /**//LC:18007
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:18008
     * value.</p>//LC:18009
     *//LC:18010
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18011
     * @param fieldName  the field name//LC:18012
     * @param value  the value to add to the <code>toString</code>//LC:18013
     *///LC:18014
    public void append(final StringBuffer buffer, final String fieldName, final boolean value) {//LC:18015
        appendFieldStart(buffer, fieldName);//LC:18016
        appendDetail(buffer, fieldName, value);//LC:18017
        appendFieldEnd(buffer, fieldName);//LC:18018
    }//LC:18019
//LC:18020
    /**//LC:18021
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:18022
     * value.</p>//LC:18023
     *//LC:18024
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18025
     * @param fieldName  the field name, typically not used as already appended//LC:18026
     * @param value  the value to add to the <code>toString</code>//LC:18027
     *///LC:18028
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) {//LC:18029
        buffer.append(value);//LC:18030
    }//LC:18031
//LC:18032
    /**//LC:18033
     * <p>Append to the <code>toString</code> an <code>Object</code>//LC:18034
     * array.</p>//LC:18035
     *//LC:18036
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18037
     * @param fieldName  the field name//LC:18038
     * @param array  the array to add to the toString//LC:18039
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18040
     *  for summary info, <code>null</code> for style decides//LC:18041
     *///LC:18042
    public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) {//LC:18043
        appendFieldStart(buffer, fieldName);//LC:18044
//LC:18045
        if (array == null) {//LC:18046
            appendNullText(buffer, fieldName);//LC:18047
//LC:18048
        } else if (isFullDetail(fullDetail)) {//LC:18049
            appendDetail(buffer, fieldName, array);//LC:18050
//LC:18051
        } else {//LC:18052
            appendSummary(buffer, fieldName, array);//LC:18053
        }//LC:18054
//LC:18055
        appendFieldEnd(buffer, fieldName);//LC:18056
    }//LC:18057
//LC:18058
    //----------------------------------------------------------------------------//LC:18059
//LC:18060
    /**//LC:18061
     * <p>Append to the <code>toString</code> the detail of an//LC:18062
     * <code>Object</code> array.</p>//LC:18063
     *//LC:18064
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18065
     * @param fieldName  the field name, typically not used as already appended//LC:18066
     * @param array  the array to add to the <code>toString</code>,//LC:18067
     *  not <code>null</code>//LC:18068
     *///LC:18069
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) {//LC:18070
        buffer.append(arrayStart);//LC:18071
        for (int i = 0; i < array.length; i++) {//LC:18072
            final Object item = array[i];//LC:18073
            if (i > 0) {//LC:18074
                buffer.append(arraySeparator);//LC:18075
            }//LC:18076
            if (item == null) {//LC:18077
                appendNullText(buffer, fieldName);//LC:18078
//LC:18079
            } else {//LC:18080
                appendInternal(buffer, fieldName, item, arrayContentDetail);//LC:18081
            }//LC:18082
        }//LC:18083
        buffer.append(arrayEnd);//LC:18084
    }//LC:18085
//LC:18086
    /**//LC:18087
     * <p>Append to the <code>toString</code> the detail of an array type.</p>//LC:18088
     *//LC:18089
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18090
     * @param fieldName  the field name, typically not used as already appended//LC:18091
     * @param array  the array to add to the <code>toString</code>,//LC:18092
     *  not <code>null</code>//LC:18093
     * @since 2.0//LC:18094
     *///LC:18095
    protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) {//LC:18096
        buffer.append(arrayStart);//LC:18097
        final int length = Array.getLength(array);//LC:18098
        for (int i = 0; i < length; i++) {//LC:18099
            final Object item = Array.get(array, i);//LC:18100
            if (i > 0) {//LC:18101
                buffer.append(arraySeparator);//LC:18102
            }//LC:18103
            if (item == null) {//LC:18104
                appendNullText(buffer, fieldName);//LC:18105
//LC:18106
            } else {//LC:18107
                appendInternal(buffer, fieldName, item, arrayContentDetail);//LC:18108
            }//LC:18109
        }//LC:18110
        buffer.append(arrayEnd);//LC:18111
    }//LC:18112
//LC:18113
    /**//LC:18114
     * <p>Append to the <code>toString</code> a summary of an//LC:18115
     * <code>Object</code> array.</p>//LC:18116
     *//LC:18117
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18118
     * @param fieldName  the field name, typically not used as already appended//LC:18119
     * @param array  the array to add to the <code>toString</code>,//LC:18120
     *  not <code>null</code>//LC:18121
     *///LC:18122
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) {//LC:18123
        appendSummarySize(buffer, fieldName, array.length);//LC:18124
    }//LC:18125
//LC:18126
    //----------------------------------------------------------------------------//LC:18127
//LC:18128
    /**//LC:18129
     * <p>Append to the <code>toString</code> a <code>long</code>//LC:18130
     * array.</p>//LC:18131
     *//LC:18132
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18133
     * @param fieldName  the field name//LC:18134
     * @param array  the array to add to the <code>toString</code>//LC:18135
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18136
     *  for summary info, <code>null</code> for style decides//LC:18137
     *///LC:18138
    public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) {//LC:18139
        appendFieldStart(buffer, fieldName);//LC:18140
//LC:18141
        if (array == null) {//LC:18142
            appendNullText(buffer, fieldName);//LC:18143
//LC:18144
        } else if (isFullDetail(fullDetail)) {//LC:18145
            appendDetail(buffer, fieldName, array);//LC:18146
//LC:18147
        } else {//LC:18148
            appendSummary(buffer, fieldName, array);//LC:18149
        }//LC:18150
//LC:18151
        appendFieldEnd(buffer, fieldName);//LC:18152
    }//LC:18153
//LC:18154
    /**//LC:18155
     * <p>Append to the <code>toString</code> the detail of a//LC:18156
     * <code>long</code> array.</p>//LC:18157
     *//LC:18158
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18159
     * @param fieldName  the field name, typically not used as already appended//LC:18160
     * @param array  the array to add to the <code>toString</code>,//LC:18161
     *  not <code>null</code>//LC:18162
     *///LC:18163
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) {//LC:18164
        buffer.append(arrayStart);//LC:18165
        for (int i = 0; i < array.length; i++) {//LC:18166
            if (i > 0) {//LC:18167
                buffer.append(arraySeparator);//LC:18168
            }//LC:18169
            appendDetail(buffer, fieldName, array[i]);//LC:18170
        }//LC:18171
        buffer.append(arrayEnd);//LC:18172
    }//LC:18173
//LC:18174
    /**//LC:18175
     * <p>Append to the <code>toString</code> a summary of a//LC:18176
     * <code>long</code> array.</p>//LC:18177
     *//LC:18178
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18179
     * @param fieldName  the field name, typically not used as already appended//LC:18180
     * @param array  the array to add to the <code>toString</code>,//LC:18181
     *  not <code>null</code>//LC:18182
     *///LC:18183
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) {//LC:18184
        appendSummarySize(buffer, fieldName, array.length);//LC:18185
    }//LC:18186
//LC:18187
    //----------------------------------------------------------------------------//LC:18188
//LC:18189
    /**//LC:18190
     * <p>Append to the <code>toString</code> an <code>int</code>//LC:18191
     * array.</p>//LC:18192
     *//LC:18193
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18194
     * @param fieldName  the field name//LC:18195
     * @param array  the array to add to the <code>toString</code>//LC:18196
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18197
     *  for summary info, <code>null</code> for style decides//LC:18198
     *///LC:18199
    public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) {//LC:18200
        appendFieldStart(buffer, fieldName);//LC:18201
//LC:18202
        if (array == null) {//LC:18203
            appendNullText(buffer, fieldName);//LC:18204
//LC:18205
        } else if (isFullDetail(fullDetail)) {//LC:18206
            appendDetail(buffer, fieldName, array);//LC:18207
//LC:18208
        } else {//LC:18209
            appendSummary(buffer, fieldName, array);//LC:18210
        }//LC:18211
//LC:18212
        appendFieldEnd(buffer, fieldName);//LC:18213
    }//LC:18214
//LC:18215
    /**//LC:18216
     * <p>Append to the <code>toString</code> the detail of an//LC:18217
     * <code>int</code> array.</p>//LC:18218
     *//LC:18219
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18220
     * @param fieldName  the field name, typically not used as already appended//LC:18221
     * @param array  the array to add to the <code>toString</code>,//LC:18222
     *  not <code>null</code>//LC:18223
     *///LC:18224
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) {//LC:18225
        buffer.append(arrayStart);//LC:18226
        for (int i = 0; i < array.length; i++) {//LC:18227
            if (i > 0) {//LC:18228
                buffer.append(arraySeparator);//LC:18229
            }//LC:18230
            appendDetail(buffer, fieldName, array[i]);//LC:18231
        }//LC:18232
        buffer.append(arrayEnd);//LC:18233
    }//LC:18234
//LC:18235
    /**//LC:18236
     * <p>Append to the <code>toString</code> a summary of an//LC:18237
     * <code>int</code> array.</p>//LC:18238
     *//LC:18239
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18240
     * @param fieldName  the field name, typically not used as already appended//LC:18241
     * @param array  the array to add to the <code>toString</code>,//LC:18242
     *  not <code>null</code>//LC:18243
     *///LC:18244
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) {//LC:18245
        appendSummarySize(buffer, fieldName, array.length);//LC:18246
    }//LC:18247
//LC:18248
    //----------------------------------------------------------------------------//LC:18249
//LC:18250
    /**//LC:18251
     * <p>Append to the <code>toString</code> a <code>short</code>//LC:18252
     * array.</p>//LC:18253
     *//LC:18254
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18255
     * @param fieldName  the field name//LC:18256
     * @param array  the array to add to the <code>toString</code>//LC:18257
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18258
     *  for summary info, <code>null</code> for style decides//LC:18259
     *///LC:18260
    public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) {//LC:18261
        appendFieldStart(buffer, fieldName);//LC:18262
//LC:18263
        if (array == null) {//LC:18264
            appendNullText(buffer, fieldName);//LC:18265
//LC:18266
        } else if (isFullDetail(fullDetail)) {//LC:18267
            appendDetail(buffer, fieldName, array);//LC:18268
//LC:18269
        } else {//LC:18270
            appendSummary(buffer, fieldName, array);//LC:18271
        }//LC:18272
//LC:18273
        appendFieldEnd(buffer, fieldName);//LC:18274
    }//LC:18275
//LC:18276
    /**//LC:18277
     * <p>Append to the <code>toString</code> the detail of a//LC:18278
     * <code>short</code> array.</p>//LC:18279
     *//LC:18280
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18281
     * @param fieldName  the field name, typically not used as already appended//LC:18282
     * @param array  the array to add to the <code>toString</code>,//LC:18283
     *  not <code>null</code>//LC:18284
     *///LC:18285
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) {//LC:18286
        buffer.append(arrayStart);//LC:18287
        for (int i = 0; i < array.length; i++) {//LC:18288
            if (i > 0) {//LC:18289
                buffer.append(arraySeparator);//LC:18290
            }//LC:18291
            appendDetail(buffer, fieldName, array[i]);//LC:18292
        }//LC:18293
        buffer.append(arrayEnd);//LC:18294
    }//LC:18295
//LC:18296
    /**//LC:18297
     * <p>Append to the <code>toString</code> a summary of a//LC:18298
     * <code>short</code> array.</p>//LC:18299
     *//LC:18300
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18301
     * @param fieldName  the field name, typically not used as already appended//LC:18302
     * @param array  the array to add to the <code>toString</code>,//LC:18303
     *  not <code>null</code>//LC:18304
     *///LC:18305
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) {//LC:18306
        appendSummarySize(buffer, fieldName, array.length);//LC:18307
    }//LC:18308
//LC:18309
    //----------------------------------------------------------------------------//LC:18310
//LC:18311
    /**//LC:18312
     * <p>Append to the <code>toString</code> a <code>byte</code>//LC:18313
     * array.</p>//LC:18314
     *//LC:18315
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18316
     * @param fieldName  the field name//LC:18317
     * @param array  the array to add to the <code>toString</code>//LC:18318
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18319
     *  for summary info, <code>null</code> for style decides//LC:18320
     *///LC:18321
    public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) {//LC:18322
        appendFieldStart(buffer, fieldName);//LC:18323
//LC:18324
        if (array == null) {//LC:18325
            appendNullText(buffer, fieldName);//LC:18326
//LC:18327
        } else if (isFullDetail(fullDetail)) {//LC:18328
            appendDetail(buffer, fieldName, array);//LC:18329
//LC:18330
        } else {//LC:18331
            appendSummary(buffer, fieldName, array);//LC:18332
        }//LC:18333
//LC:18334
        appendFieldEnd(buffer, fieldName);//LC:18335
    }//LC:18336
//LC:18337
    /**//LC:18338
     * <p>Append to the <code>toString</code> the detail of a//LC:18339
     * <code>byte</code> array.</p>//LC:18340
     *//LC:18341
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18342
     * @param fieldName  the field name, typically not used as already appended//LC:18343
     * @param array  the array to add to the <code>toString</code>,//LC:18344
     *  not <code>null</code>//LC:18345
     *///LC:18346
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) {//LC:18347
        buffer.append(arrayStart);//LC:18348
        for (int i = 0; i < array.length; i++) {//LC:18349
            if (i > 0) {//LC:18350
                buffer.append(arraySeparator);//LC:18351
            }//LC:18352
            appendDetail(buffer, fieldName, array[i]);//LC:18353
        }//LC:18354
        buffer.append(arrayEnd);//LC:18355
    }//LC:18356
//LC:18357
    /**//LC:18358
     * <p>Append to the <code>toString</code> a summary of a//LC:18359
     * <code>byte</code> array.</p>//LC:18360
     *//LC:18361
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18362
     * @param fieldName  the field name, typically not used as already appended//LC:18363
     * @param array  the array to add to the <code>toString</code>,//LC:18364
     *  not <code>null</code>//LC:18365
     *///LC:18366
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) {//LC:18367
        appendSummarySize(buffer, fieldName, array.length);//LC:18368
    }//LC:18369
//LC:18370
    //----------------------------------------------------------------------------//LC:18371
//LC:18372
    /**//LC:18373
     * <p>Append to the <code>toString</code> a <code>char</code>//LC:18374
     * array.</p>//LC:18375
     *//LC:18376
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18377
     * @param fieldName  the field name//LC:18378
     * @param array  the array to add to the <code>toString</code>//LC:18379
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18380
     *  for summary info, <code>null</code> for style decides//LC:18381
     *///LC:18382
    public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) {//LC:18383
        appendFieldStart(buffer, fieldName);//LC:18384
//LC:18385
        if (array == null) {//LC:18386
            appendNullText(buffer, fieldName);//LC:18387
//LC:18388
        } else if (isFullDetail(fullDetail)) {//LC:18389
            appendDetail(buffer, fieldName, array);//LC:18390
//LC:18391
        } else {//LC:18392
            appendSummary(buffer, fieldName, array);//LC:18393
        }//LC:18394
//LC:18395
        appendFieldEnd(buffer, fieldName);//LC:18396
    }//LC:18397
//LC:18398
    /**//LC:18399
     * <p>Append to the <code>toString</code> the detail of a//LC:18400
     * <code>char</code> array.</p>//LC:18401
     *//LC:18402
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18403
     * @param fieldName  the field name, typically not used as already appended//LC:18404
     * @param array  the array to add to the <code>toString</code>,//LC:18405
     *  not <code>null</code>//LC:18406
     *///LC:18407
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) {//LC:18408
        buffer.append(arrayStart);//LC:18409
        for (int i = 0; i < array.length; i++) {//LC:18410
            if (i > 0) {//LC:18411
                buffer.append(arraySeparator);//LC:18412
            }//LC:18413
            appendDetail(buffer, fieldName, array[i]);//LC:18414
        }//LC:18415
        buffer.append(arrayEnd);//LC:18416
    }//LC:18417
//LC:18418
    /**//LC:18419
     * <p>Append to the <code>toString</code> a summary of a//LC:18420
     * <code>char</code> array.</p>//LC:18421
     *//LC:18422
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18423
     * @param fieldName  the field name, typically not used as already appended//LC:18424
     * @param array  the array to add to the <code>toString</code>,//LC:18425
     *  not <code>null</code>//LC:18426
     *///LC:18427
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) {//LC:18428
        appendSummarySize(buffer, fieldName, array.length);//LC:18429
    }//LC:18430
//LC:18431
    //----------------------------------------------------------------------------//LC:18432
//LC:18433
    /**//LC:18434
     * <p>Append to the <code>toString</code> a <code>double</code>//LC:18435
     * array.</p>//LC:18436
     *//LC:18437
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18438
     * @param fieldName  the field name//LC:18439
     * @param array  the array to add to the toString//LC:18440
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18441
     *  for summary info, <code>null</code> for style decides//LC:18442
     *///LC:18443
    public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) {//LC:18444
        appendFieldStart(buffer, fieldName);//LC:18445
//LC:18446
        if (array == null) {//LC:18447
            appendNullText(buffer, fieldName);//LC:18448
//LC:18449
        } else if (isFullDetail(fullDetail)) {//LC:18450
            appendDetail(buffer, fieldName, array);//LC:18451
//LC:18452
        } else {//LC:18453
            appendSummary(buffer, fieldName, array);//LC:18454
        }//LC:18455
//LC:18456
        appendFieldEnd(buffer, fieldName);//LC:18457
    }//LC:18458
//LC:18459
    /**//LC:18460
     * <p>Append to the <code>toString</code> the detail of a//LC:18461
     * <code>double</code> array.</p>//LC:18462
     *//LC:18463
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18464
     * @param fieldName  the field name, typically not used as already appended//LC:18465
     * @param array  the array to add to the <code>toString</code>,//LC:18466
     *  not <code>null</code>//LC:18467
     *///LC:18468
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) {//LC:18469
        buffer.append(arrayStart);//LC:18470
        for (int i = 0; i < array.length; i++) {//LC:18471
            if (i > 0) {//LC:18472
                buffer.append(arraySeparator);//LC:18473
            }//LC:18474
            appendDetail(buffer, fieldName, array[i]);//LC:18475
        }//LC:18476
        buffer.append(arrayEnd);//LC:18477
    }//LC:18478
//LC:18479
    /**//LC:18480
     * <p>Append to the <code>toString</code> a summary of a//LC:18481
     * <code>double</code> array.</p>//LC:18482
     *//LC:18483
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18484
     * @param fieldName  the field name, typically not used as already appended//LC:18485
     * @param array  the array to add to the <code>toString</code>,//LC:18486
     *  not <code>null</code>//LC:18487
     *///LC:18488
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) {//LC:18489
        appendSummarySize(buffer, fieldName, array.length);//LC:18490
    }//LC:18491
//LC:18492
    //----------------------------------------------------------------------------//LC:18493
//LC:18494
    /**//LC:18495
     * <p>Append to the <code>toString</code> a <code>float</code>//LC:18496
     * array.</p>//LC:18497
     *//LC:18498
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18499
     * @param fieldName  the field name//LC:18500
     * @param array  the array to add to the toString//LC:18501
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18502
     *  for summary info, <code>null</code> for style decides//LC:18503
     *///LC:18504
    public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) {//LC:18505
        appendFieldStart(buffer, fieldName);//LC:18506
//LC:18507
        if (array == null) {//LC:18508
            appendNullText(buffer, fieldName);//LC:18509
//LC:18510
        } else if (isFullDetail(fullDetail)) {//LC:18511
            appendDetail(buffer, fieldName, array);//LC:18512
//LC:18513
        } else {//LC:18514
            appendSummary(buffer, fieldName, array);//LC:18515
        }//LC:18516
//LC:18517
        appendFieldEnd(buffer, fieldName);//LC:18518
    }//LC:18519
//LC:18520
    /**//LC:18521
     * <p>Append to the <code>toString</code> the detail of a//LC:18522
     * <code>float</code> array.</p>//LC:18523
     *//LC:18524
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18525
     * @param fieldName  the field name, typically not used as already appended//LC:18526
     * @param array  the array to add to the <code>toString</code>,//LC:18527
     *  not <code>null</code>//LC:18528
     *///LC:18529
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) {//LC:18530
        buffer.append(arrayStart);//LC:18531
        for (int i = 0; i < array.length; i++) {//LC:18532
            if (i > 0) {//LC:18533
                buffer.append(arraySeparator);//LC:18534
            }//LC:18535
            appendDetail(buffer, fieldName, array[i]);//LC:18536
        }//LC:18537
        buffer.append(arrayEnd);//LC:18538
    }//LC:18539
//LC:18540
    /**//LC:18541
     * <p>Append to the <code>toString</code> a summary of a//LC:18542
     * <code>float</code> array.</p>//LC:18543
     *//LC:18544
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18545
     * @param fieldName  the field name, typically not used as already appended//LC:18546
     * @param array  the array to add to the <code>toString</code>,//LC:18547
     *  not <code>null</code>//LC:18548
     *///LC:18549
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) {//LC:18550
        appendSummarySize(buffer, fieldName, array.length);//LC:18551
    }//LC:18552
//LC:18553
    //----------------------------------------------------------------------------//LC:18554
//LC:18555
    /**//LC:18556
     * <p>Append to the <code>toString</code> a <code>boolean</code>//LC:18557
     * array.</p>//LC:18558
     *//LC:18559
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18560
     * @param fieldName  the field name//LC:18561
     * @param array  the array to add to the toString//LC:18562
     * @param fullDetail  <code>true</code> for detail, <code>false</code>//LC:18563
     *  for summary info, <code>null</code> for style decides//LC:18564
     *///LC:18565
    public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {//LC:18566
        appendFieldStart(buffer, fieldName);//LC:18567
//LC:18568
        if (array == null) {//LC:18569
            appendNullText(buffer, fieldName);//LC:18570
//LC:18571
        } else if (isFullDetail(fullDetail)) {//LC:18572
            appendDetail(buffer, fieldName, array);//LC:18573
//LC:18574
        } else {//LC:18575
            appendSummary(buffer, fieldName, array);//LC:18576
        }//LC:18577
//LC:18578
        appendFieldEnd(buffer, fieldName);//LC:18579
    }//LC:18580
//LC:18581
    /**//LC:18582
     * <p>Append to the <code>toString</code> the detail of a//LC:18583
     * <code>boolean</code> array.</p>//LC:18584
     *//LC:18585
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18586
     * @param fieldName  the field name, typically not used as already appended//LC:18587
     * @param array  the array to add to the <code>toString</code>,//LC:18588
     *  not <code>null</code>//LC:18589
     *///LC:18590
    protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {//LC:18591
        buffer.append(arrayStart);//LC:18592
        for (int i = 0; i < array.length; i++) {//LC:18593
            if (i > 0) {//LC:18594
                buffer.append(arraySeparator);//LC:18595
            }//LC:18596
            appendDetail(buffer, fieldName, array[i]);//LC:18597
        }//LC:18598
        buffer.append(arrayEnd);//LC:18599
    }//LC:18600
//LC:18601
    /**//LC:18602
     * <p>Append to the <code>toString</code> a summary of a//LC:18603
     * <code>boolean</code> array.</p>//LC:18604
     *//LC:18605
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18606
     * @param fieldName  the field name, typically not used as already appended//LC:18607
     * @param array  the array to add to the <code>toString</code>,//LC:18608
     *  not <code>null</code>//LC:18609
     *///LC:18610
    protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {//LC:18611
        appendSummarySize(buffer, fieldName, array.length);//LC:18612
    }//LC:18613
//LC:18614
    //----------------------------------------------------------------------------//LC:18615
//LC:18616
    /**//LC:18617
     * <p>Append to the <code>toString</code> the class name.</p>//LC:18618
     *//LC:18619
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18620
     * @param object  the <code>Object</code> whose name to output//LC:18621
     *///LC:18622
    protected void appendClassName(final StringBuffer buffer, final Object object) {//LC:18623
        if (useClassName && object != null) {//LC:18624
            register(object);//LC:18625
            if (useShortClassName) {//LC:18626
                buffer.append(getShortClassName(object.getClass()));//LC:18627
            } else {//LC:18628
                buffer.append(object.getClass().getName());//LC:18629
            }//LC:18630
        }//LC:18631
    }//LC:18632
//LC:18633
    /**//LC:18634
     * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>//LC:18635
     *//LC:18636
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18637
     * @param object  the <code>Object</code> whose id to output//LC:18638
     *///LC:18639
    protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) {//LC:18640
        if (this.isUseIdentityHashCode() && object!=null) {//LC:18641
            register(object);//LC:18642
            buffer.append('@');//LC:18643
            buffer.append(Integer.toHexString(System.identityHashCode(object)));//LC:18644
        }//LC:18645
    }//LC:18646
//LC:18647
    /**//LC:18648
     * <p>Append to the <code>toString</code> the content start.</p>//LC:18649
     *//LC:18650
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18651
     *///LC:18652
    protected void appendContentStart(final StringBuffer buffer) {//LC:18653
        buffer.append(contentStart);//LC:18654
    }//LC:18655
//LC:18656
    /**//LC:18657
     * <p>Append to the <code>toString</code> the content end.</p>//LC:18658
     *//LC:18659
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18660
     *///LC:18661
    protected void appendContentEnd(final StringBuffer buffer) {//LC:18662
        buffer.append(contentEnd);//LC:18663
    }//LC:18664
//LC:18665
    /**//LC:18666
     * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>//LC:18667
     *//LC:18668
     * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>//LC:18669
     *//LC:18670
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18671
     * @param fieldName  the field name, typically not used as already appended//LC:18672
     *///LC:18673
    protected void appendNullText(final StringBuffer buffer, final String fieldName) {//LC:18674
        buffer.append(nullText);//LC:18675
    }//LC:18676
//LC:18677
    /**//LC:18678
     * <p>Append to the <code>toString</code> the field separator.</p>//LC:18679
     *//LC:18680
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18681
     *///LC:18682
    protected void appendFieldSeparator(final StringBuffer buffer) {//LC:18683
        buffer.append(fieldSeparator);//LC:18684
    }//LC:18685
//LC:18686
    /**//LC:18687
     * <p>Append to the <code>toString</code> the field start.</p>//LC:18688
     *//LC:18689
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18690
     * @param fieldName  the field name//LC:18691
     *///LC:18692
    protected void appendFieldStart(final StringBuffer buffer, final String fieldName) {//LC:18693
        if (useFieldNames && fieldName != null) {//LC:18694
            buffer.append(fieldName);//LC:18695
            buffer.append(fieldNameValueSeparator);//LC:18696
        }//LC:18697
    }//LC:18698
//LC:18699
    /**//LC:18700
     * <p>Append to the <code>toString<code> the field end.</p>//LC:18701
     *//LC:18702
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18703
     * @param fieldName  the field name, typically not used as already appended//LC:18704
     *///LC:18705
    protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) {//LC:18706
        appendFieldSeparator(buffer);//LC:18707
    }//LC:18708
//LC:18709
    /**//LC:18710
     * <p>Append to the <code>toString</code> a size summary.</p>//LC:18711
     *//LC:18712
     * <p>The size summary is used to summarize the contents of//LC:18713
     * <code>Collections</code>, <code>Maps</code> and arrays.</p>//LC:18714
     *//LC:18715
     * <p>The output consists of a prefix, the passed in size//LC:18716
     * and a suffix.</p>//LC:18717
     *//LC:18718
     * <p>The default format is <code>'&lt;size=n&gt;'<code>.</p>//LC:18719
     *//LC:18720
     * @param buffer  the <code>StringBuffer</code> to populate//LC:18721
     * @param fieldName  the field name, typically not used as already appended//LC:18722
     * @param size  the size to append//LC:18723
     *///LC:18724
    protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) {//LC:18725
        buffer.append(sizeStartText);//LC:18726
        buffer.append(size);//LC:18727
        buffer.append(sizeEndText);//LC:18728
    }//LC:18729
//LC:18730
    /**//LC:18731
     * <p>Is this field to be output in full detail.</p>//LC:18732
     *//LC:18733
     * <p>This method converts a detail request into a detail level.//LC:18734
     * The calling code may request full detail (<code>true</code>),//LC:18735
     * but a subclass might ignore that and always return//LC:18736
     * <code>false</code>. The calling code may pass in//LC:18737
     * <code>null</code> indicating that it doesn't care about//LC:18738
     * the detail level. In this case the default detail level is//LC:18739
     * used.</p>//LC:18740
     *//LC:18741
     * @param fullDetailRequest  the detail level requested//LC:18742
     * @return whether full detail is to be shown//LC:18743
     *///LC:18744
    protected boolean isFullDetail(final Boolean fullDetailRequest) {//LC:18745
        if (fullDetailRequest == null) {//LC:18746
            return defaultFullDetail;//LC:18747
        }//LC:18748
        return fullDetailRequest.booleanValue();//LC:18749
    }//LC:18750
//LC:18751
    /**//LC:18752
     * <p>Gets the short class name for a class.</p>//LC:18753
     *//LC:18754
     * <p>The short class name is the classname excluding//LC:18755
     * the package name.</p>//LC:18756
     *//LC:18757
     * @param cls  the <code>Class</code> to get the short name of//LC:18758
     * @return the short name//LC:18759
     *///LC:18760
    protected String getShortClassName(final Class<?> cls) {//LC:18761
        return ClassUtils.getShortClassName(cls);//LC:18762
    }//LC:18763
//LC:18764
    // Setters and getters for the customizable parts of the style//LC:18765
    // These methods are not expected to be overridden, except to make public//LC:18766
    // (They are not public so that immutable subclasses can be written)//LC:18767
    //---------------------------------------------------------------------//LC:18768
//LC:18769
    /**//LC:18770
     * <p>Gets whether to use the class name.</p>//LC:18771
     *//LC:18772
     * @return the current useClassName flag//LC:18773
     *///LC:18774
    protected boolean isUseClassName() {//LC:18775
        return useClassName;//LC:18776
    }//LC:18777
//LC:18778
    /**//LC:18779
     * <p>Sets whether to use the class name.</p>//LC:18780
     *//LC:18781
     * @param useClassName  the new useClassName flag//LC:18782
     *///LC:18783
    protected void setUseClassName(final boolean useClassName) {//LC:18784
        this.useClassName = useClassName;//LC:18785
    }//LC:18786
//LC:18787
    //---------------------------------------------------------------------//LC:18788
//LC:18789
    /**//LC:18790
     * <p>Gets whether to output short or long class names.</p>//LC:18791
     *//LC:18792
     * @return the current useShortClassName flag//LC:18793
     * @since 2.0//LC:18794
     *///LC:18795
    protected boolean isUseShortClassName() {//LC:18796
        return useShortClassName;//LC:18797
    }//LC:18798
//LC:18799
    /**//LC:18800
     * <p>Sets whether to output short or long class names.</p>//LC:18801
     *//LC:18802
     * @param useShortClassName  the new useShortClassName flag//LC:18803
     * @since 2.0//LC:18804
     *///LC:18805
    protected void setUseShortClassName(final boolean useShortClassName) {//LC:18806
        this.useShortClassName = useShortClassName;//LC:18807
    }//LC:18808
//LC:18809
    //---------------------------------------------------------------------//LC:18810
//LC:18811
    /**//LC:18812
     * <p>Gets whether to use the identity hash code.</p>//LC:18813
     *//LC:18814
     * @return the current useIdentityHashCode flag//LC:18815
     *///LC:18816
    protected boolean isUseIdentityHashCode() {//LC:18817
        return useIdentityHashCode;//LC:18818
    }//LC:18819
//LC:18820
    /**//LC:18821
     * <p>Sets whether to use the identity hash code.</p>//LC:18822
     *//LC:18823
     * @param useIdentityHashCode  the new useIdentityHashCode flag//LC:18824
     *///LC:18825
    protected void setUseIdentityHashCode(final boolean useIdentityHashCode) {//LC:18826
        this.useIdentityHashCode = useIdentityHashCode;//LC:18827
    }//LC:18828
//LC:18829
    //---------------------------------------------------------------------//LC:18830
//LC:18831
    /**//LC:18832
     * <p>Gets whether to use the field names passed in.</p>//LC:18833
     *//LC:18834
     * @return the current useFieldNames flag//LC:18835
     *///LC:18836
    protected boolean isUseFieldNames() {//LC:18837
        return useFieldNames;//LC:18838
    }//LC:18839
//LC:18840
    /**//LC:18841
     * <p>Sets whether to use the field names passed in.</p>//LC:18842
     *//LC:18843
     * @param useFieldNames  the new useFieldNames flag//LC:18844
     *///LC:18845
    protected void setUseFieldNames(final boolean useFieldNames) {//LC:18846
        this.useFieldNames = useFieldNames;//LC:18847
    }//LC:18848
//LC:18849
    //---------------------------------------------------------------------//LC:18850
//LC:18851
    /**//LC:18852
     * <p>Gets whether to use full detail when the caller doesn't//LC:18853
     * specify.</p>//LC:18854
     *//LC:18855
     * @return the current defaultFullDetail flag//LC:18856
     *///LC:18857
    protected boolean isDefaultFullDetail() {//LC:18858
        return defaultFullDetail;//LC:18859
    }//LC:18860
//LC:18861
    /**//LC:18862
     * <p>Sets whether to use full detail when the caller doesn't//LC:18863
     * specify.</p>//LC:18864
     *//LC:18865
     * @param defaultFullDetail  the new defaultFullDetail flag//LC:18866
     *///LC:18867
    protected void setDefaultFullDetail(final boolean defaultFullDetail) {//LC:18868
        this.defaultFullDetail = defaultFullDetail;//LC:18869
    }//LC:18870
//LC:18871
    //---------------------------------------------------------------------//LC:18872
//LC:18873
    /**//LC:18874
     * <p>Gets whether to output array content detail.</p>//LC:18875
     *//LC:18876
     * @return the current array content detail setting//LC:18877
     *///LC:18878
    protected boolean isArrayContentDetail() {//LC:18879
        return arrayContentDetail;//LC:18880
    }//LC:18881
//LC:18882
    /**//LC:18883
     * <p>Sets whether to output array content detail.</p>//LC:18884
     *//LC:18885
     * @param arrayContentDetail  the new arrayContentDetail flag//LC:18886
     *///LC:18887
    protected void setArrayContentDetail(final boolean arrayContentDetail) {//LC:18888
        this.arrayContentDetail = arrayContentDetail;//LC:18889
    }//LC:18890
//LC:18891
    //---------------------------------------------------------------------//LC:18892
//LC:18893
    /**//LC:18894
     * <p>Gets the array start text.</p>//LC:18895
     *//LC:18896
     * @return the current array start text//LC:18897
     *///LC:18898
    protected String getArrayStart() {//LC:18899
        return arrayStart;//LC:18900
    }//LC:18901
//LC:18902
    /**//LC:18903
     * <p>Sets the array start text.</p>//LC:18904
     *//LC:18905
     * <p><code>null</code> is accepted, but will be converted to//LC:18906
     * an empty String.</p>//LC:18907
     *//LC:18908
     * @param arrayStart  the new array start text//LC:18909
     *///LC:18910
    protected void setArrayStart(String arrayStart) {//LC:18911
        if (arrayStart == null) {//LC:18912
            arrayStart = "";//LC:18913
        }//LC:18914
        this.arrayStart = arrayStart;//LC:18915
    }//LC:18916
//LC:18917
    //---------------------------------------------------------------------//LC:18918
//LC:18919
    /**//LC:18920
     * <p>Gets the array end text.</p>//LC:18921
     *//LC:18922
     * @return the current array end text//LC:18923
     *///LC:18924
    protected String getArrayEnd() {//LC:18925
        return arrayEnd;//LC:18926
    }//LC:18927
//LC:18928
    /**//LC:18929
     * <p>Sets the array end text.</p>//LC:18930
     *//LC:18931
     * <p><code>null</code> is accepted, but will be converted to//LC:18932
     * an empty String.</p>//LC:18933
     *//LC:18934
     * @param arrayEnd  the new array end text//LC:18935
     *///LC:18936
    protected void setArrayEnd(String arrayEnd) {//LC:18937
        if (arrayEnd == null) {//LC:18938
            arrayEnd = "";//LC:18939
        }//LC:18940
        this.arrayEnd = arrayEnd;//LC:18941
    }//LC:18942
//LC:18943
    //---------------------------------------------------------------------//LC:18944
//LC:18945
    /**//LC:18946
     * <p>Gets the array separator text.</p>//LC:18947
     *//LC:18948
     * @return the current array separator text//LC:18949
     *///LC:18950
    protected String getArraySeparator() {//LC:18951
        return arraySeparator;//LC:18952
    }//LC:18953
//LC:18954
    /**//LC:18955
     * <p>Sets the array separator text.</p>//LC:18956
     *//LC:18957
     * <p><code>null</code> is accepted, but will be converted to//LC:18958
     * an empty String.</p>//LC:18959
     *//LC:18960
     * @param arraySeparator  the new array separator text//LC:18961
     *///LC:18962
    protected void setArraySeparator(String arraySeparator) {//LC:18963
        if (arraySeparator == null) {//LC:18964
            arraySeparator = "";//LC:18965
        }//LC:18966
        this.arraySeparator = arraySeparator;//LC:18967
    }//LC:18968
//LC:18969
    //---------------------------------------------------------------------//LC:18970
//LC:18971
    /**//LC:18972
     * <p>Gets the content start text.</p>//LC:18973
     *//LC:18974
     * @return the current content start text//LC:18975
     *///LC:18976
    protected String getContentStart() {//LC:18977
        return contentStart;//LC:18978
    }//LC:18979
//LC:18980
    /**//LC:18981
     * <p>Sets the content start text.</p>//LC:18982
     *//LC:18983
     * <p><code>null</code> is accepted, but will be converted to//LC:18984
     * an empty String.</p>//LC:18985
     *//LC:18986
     * @param contentStart  the new content start text//LC:18987
     *///LC:18988
    protected void setContentStart(String contentStart) {//LC:18989
        if (contentStart == null) {//LC:18990
            contentStart = "";//LC:18991
        }//LC:18992
        this.contentStart = contentStart;//LC:18993
    }//LC:18994
//LC:18995
    //---------------------------------------------------------------------//LC:18996
//LC:18997
    /**//LC:18998
     * <p>Gets the content end text.</p>//LC:18999
     *//LC:19000
     * @return the current content end text//LC:19001
     *///LC:19002
    protected String getContentEnd() {//LC:19003
        return contentEnd;//LC:19004
    }//LC:19005
//LC:19006
    /**//LC:19007
     * <p>Sets the content end text.</p>//LC:19008
     *//LC:19009
     * <p><code>null</code> is accepted, but will be converted to//LC:19010
     * an empty String.</p>//LC:19011
     *//LC:19012
     * @param contentEnd  the new content end text//LC:19013
     *///LC:19014
    protected void setContentEnd(String contentEnd) {//LC:19015
        if (contentEnd == null) {//LC:19016
            contentEnd = "";//LC:19017
        }//LC:19018
        this.contentEnd = contentEnd;//LC:19019
    }//LC:19020
//LC:19021
    //---------------------------------------------------------------------//LC:19022
//LC:19023
    /**//LC:19024
     * <p>Gets the field name value separator text.</p>//LC:19025
     *//LC:19026
     * @return the current field name value separator text//LC:19027
     *///LC:19028
    protected String getFieldNameValueSeparator() {//LC:19029
        return fieldNameValueSeparator;//LC:19030
    }//LC:19031
//LC:19032
    /**//LC:19033
     * <p>Sets the field name value separator text.</p>//LC:19034
     *//LC:19035
     * <p><code>null</code> is accepted, but will be converted to//LC:19036
     * an empty String.</p>//LC:19037
     *//LC:19038
     * @param fieldNameValueSeparator  the new field name value separator text//LC:19039
     *///LC:19040
    protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {//LC:19041
        if (fieldNameValueSeparator == null) {//LC:19042
            fieldNameValueSeparator = "";//LC:19043
        }//LC:19044
        this.fieldNameValueSeparator = fieldNameValueSeparator;//LC:19045
    }//LC:19046
//LC:19047
    //---------------------------------------------------------------------//LC:19048
//LC:19049
    /**//LC:19050
     * <p>Gets the field separator text.</p>//LC:19051
     *//LC:19052
     * @return the current field separator text//LC:19053
     *///LC:19054
    protected String getFieldSeparator() {//LC:19055
        return fieldSeparator;//LC:19056
    }//LC:19057
//LC:19058
    /**//LC:19059
     * <p>Sets the field separator text.</p>//LC:19060
     *//LC:19061
     * <p><code>null</code> is accepted, but will be converted to//LC:19062
     * an empty String.</p>//LC:19063
     *//LC:19064
     * @param fieldSeparator  the new field separator text//LC:19065
     *///LC:19066
    protected void setFieldSeparator(String fieldSeparator) {//LC:19067
        if (fieldSeparator == null) {//LC:19068
            fieldSeparator = "";//LC:19069
        }//LC:19070
        this.fieldSeparator = fieldSeparator;//LC:19071
    }//LC:19072
//LC:19073
    //---------------------------------------------------------------------//LC:19074
//LC:19075
    /**//LC:19076
     * <p>Gets whether the field separator should be added at the start//LC:19077
     * of each buffer.</p>//LC:19078
     *//LC:19079
     * @return the fieldSeparatorAtStart flag//LC:19080
     * @since 2.0//LC:19081
     *///LC:19082
    protected boolean isFieldSeparatorAtStart() {//LC:19083
        return fieldSeparatorAtStart;//LC:19084
    }//LC:19085
//LC:19086
    /**//LC:19087
     * <p>Sets whether the field separator should be added at the start//LC:19088
     * of each buffer.</p>//LC:19089
     *//LC:19090
     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag//LC:19091
     * @since 2.0//LC:19092
     *///LC:19093
    protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) {//LC:19094
        this.fieldSeparatorAtStart = fieldSeparatorAtStart;//LC:19095
    }//LC:19096
//LC:19097
    //---------------------------------------------------------------------//LC:19098
//LC:19099
    /**//LC:19100
     * <p>Gets whether the field separator should be added at the end//LC:19101
     * of each buffer.</p>//LC:19102
     *//LC:19103
     * @return fieldSeparatorAtEnd flag//LC:19104
     * @since 2.0//LC:19105
     *///LC:19106
    protected boolean isFieldSeparatorAtEnd() {//LC:19107
        return fieldSeparatorAtEnd;//LC:19108
    }//LC:19109
//LC:19110
    /**//LC:19111
     * <p>Sets whether the field separator should be added at the end//LC:19112
     * of each buffer.</p>//LC:19113
     *//LC:19114
     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag//LC:19115
     * @since 2.0//LC:19116
     *///LC:19117
    protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) {//LC:19118
        this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;//LC:19119
    }//LC:19120
//LC:19121
    //---------------------------------------------------------------------//LC:19122
//LC:19123
    /**//LC:19124
     * <p>Gets the text to output when <code>null</code> found.</p>//LC:19125
     *//LC:19126
     * @return the current text to output when null found//LC:19127
     *///LC:19128
    protected String getNullText() {//LC:19129
        return nullText;//LC:19130
    }//LC:19131
//LC:19132
    /**//LC:19133
     * <p>Sets the text to output when <code>null</code> found.</p>//LC:19134
     *//LC:19135
     * <p><code>null</code> is accepted, but will be converted to//LC:19136
     * an empty String.</p>//LC:19137
     *//LC:19138
     * @param nullText  the new text to output when null found//LC:19139
     *///LC:19140
    protected void setNullText(String nullText) {//LC:19141
        if (nullText == null) {//LC:19142
            nullText = "";//LC:19143
        }//LC:19144
        this.nullText = nullText;//LC:19145
    }//LC:19146
//LC:19147
    //---------------------------------------------------------------------//LC:19148
//LC:19149
    /**//LC:19150
     * <p>Gets the start text to output when a <code>Collection</code>,//LC:19151
     * <code>Map</code> or array size is output.</p>//LC:19152
     *//LC:19153
     * <p>This is output before the size value.</p>//LC:19154
     *//LC:19155
     * @return the current start of size text//LC:19156
     *///LC:19157
    protected String getSizeStartText() {//LC:19158
        return sizeStartText;//LC:19159
    }//LC:19160
//LC:19161
    /**//LC:19162
     * <p>Sets the start text to output when a <code>Collection</code>,//LC:19163
     * <code>Map</code> or array size is output.</p>//LC:19164
     *//LC:19165
     * <p>This is output before the size value.</p>//LC:19166
     *//LC:19167
     * <p><code>null</code> is accepted, but will be converted to//LC:19168
     * an empty String.</p>//LC:19169
     *//LC:19170
     * @param sizeStartText  the new start of size text//LC:19171
     *///LC:19172
    protected void setSizeStartText(String sizeStartText) {//LC:19173
        if (sizeStartText == null) {//LC:19174
            sizeStartText = "";//LC:19175
        }//LC:19176
        this.sizeStartText = sizeStartText;//LC:19177
    }//LC:19178
//LC:19179
    //---------------------------------------------------------------------//LC:19180
//LC:19181
    /**//LC:19182
     * <p>Gets the end text to output when a <code>Collection</code>,//LC:19183
     * <code>Map</code> or array size is output.</p>//LC:19184
     *//LC:19185
     * <p>This is output after the size value.</p>//LC:19186
     *//LC:19187
     * @return the current end of size text//LC:19188
     *///LC:19189
    protected String getSizeEndText() {//LC:19190
        return sizeEndText;//LC:19191
    }//LC:19192
//LC:19193
    /**//LC:19194
     * <p>Sets the end text to output when a <code>Collection</code>,//LC:19195
     * <code>Map</code> or array size is output.</p>//LC:19196
     *//LC:19197
     * <p>This is output after the size value.</p>//LC:19198
     *//LC:19199
     * <p><code>null</code> is accepted, but will be converted to//LC:19200
     * an empty String.</p>//LC:19201
     *//LC:19202
     * @param sizeEndText  the new end of size text//LC:19203
     *///LC:19204
    protected void setSizeEndText(String sizeEndText) {//LC:19205
        if (sizeEndText == null) {//LC:19206
            sizeEndText = "";//LC:19207
        }//LC:19208
        this.sizeEndText = sizeEndText;//LC:19209
    }//LC:19210
//LC:19211
    //---------------------------------------------------------------------//LC:19212
//LC:19213
    /**//LC:19214
     * <p>Gets the start text to output when an <code>Object</code> is//LC:19215
     * output in summary mode.</p>//LC:19216
     *//LC:19217
     * <p>This is output before the size value.</p>//LC:19218
     *//LC:19219
     * @return the current start of summary text//LC:19220
     *///LC:19221
    protected String getSummaryObjectStartText() {//LC:19222
        return summaryObjectStartText;//LC:19223
    }//LC:19224
//LC:19225
    /**//LC:19226
     * <p>Sets the start text to output when an <code>Object</code> is//LC:19227
     * output in summary mode.</p>//LC:19228
     *//LC:19229
     * <p>This is output before the size value.</p>//LC:19230
     *//LC:19231
     * <p><code>null</code> is accepted, but will be converted to//LC:19232
     * an empty String.</p>//LC:19233
     *//LC:19234
     * @param summaryObjectStartText  the new start of summary text//LC:19235
     *///LC:19236
    protected void setSummaryObjectStartText(String summaryObjectStartText) {//LC:19237
        if (summaryObjectStartText == null) {//LC:19238
            summaryObjectStartText = "";//LC:19239
        }//LC:19240
        this.summaryObjectStartText = summaryObjectStartText;//LC:19241
    }//LC:19242
//LC:19243
    //---------------------------------------------------------------------//LC:19244
//LC:19245
    /**//LC:19246
     * <p>Gets the end text to output when an <code>Object</code> is//LC:19247
     * output in summary mode.</p>//LC:19248
     *//LC:19249
     * <p>This is output after the size value.</p>//LC:19250
     *//LC:19251
     * @return the current end of summary text//LC:19252
     *///LC:19253
    protected String getSummaryObjectEndText() {//LC:19254
        return summaryObjectEndText;//LC:19255
    }//LC:19256
//LC:19257
    /**//LC:19258
     * <p>Sets the end text to output when an <code>Object</code> is//LC:19259
     * output in summary mode.</p>//LC:19260
     *//LC:19261
     * <p>This is output after the size value.</p>//LC:19262
     *//LC:19263
     * <p><code>null</code> is accepted, but will be converted to//LC:19264
     * an empty String.</p>//LC:19265
     *//LC:19266
     * @param summaryObjectEndText  the new end of summary text//LC:19267
     *///LC:19268
    protected void setSummaryObjectEndText(String summaryObjectEndText) {//LC:19269
        if (summaryObjectEndText == null) {//LC:19270
            summaryObjectEndText = "";//LC:19271
        }//LC:19272
        this.summaryObjectEndText = summaryObjectEndText;//LC:19273
    }//LC:19274
//LC:19275
    //----------------------------------------------------------------------------//LC:19276
//LC:19277
    /**//LC:19278
     * <p>Default <code>ToStringStyle</code>.</p>//LC:19279
     *//LC:19280
     * <p>This is an inner class rather than using//LC:19281
     * <code>StandardToStringStyle</code> to ensure its immutability.</p>//LC:19282
     *///LC:19283
    private static final class DefaultToStringStyle extends ToStringStyle {//LC:19284
//LC:19285
        /**//LC:19286
         * Required for serialization support.//LC:19287
         *//LC:19288
         * @see java.io.Serializable//LC:19289
         *///LC:19290
        private static final long serialVersionUID = 1L;//LC:19291
//LC:19292
        /**//LC:19293
         * <p>Constructor.</p>//LC:19294
         *//LC:19295
         * <p>Use the static constant rather than instantiating.</p>//LC:19296
         *///LC:19297
        DefaultToStringStyle() {//LC:19298
            super();//LC:19299
        }//LC:19300
//LC:19301
        /**//LC:19302
         * <p>Ensure <code>Singleton</code> after serialization.</p>//LC:19303
         *//LC:19304
         * @return the singleton//LC:19305
         *///LC:19306
        private Object readResolve() {//LC:19307
            return ToStringStyle.DEFAULT_STYLE;//LC:19308
        }//LC:19309
//LC:19310
    }//LC:19311
//LC:19312
    //----------------------------------------------------------------------------//LC:19313
//LC:19314
    /**//LC:19315
     * <p><code>ToStringStyle</code> that does not print out//LC:19316
     * the field names.</p>//LC:19317
     *//LC:19318
     * <p>This is an inner class rather than using//LC:19319
     * <code>StandardToStringStyle</code> to ensure its immutability.//LC:19320
     *///LC:19321
    private static final class NoFieldNameToStringStyle extends ToStringStyle {//LC:19322
//LC:19323
        private static final long serialVersionUID = 1L;//LC:19324
//LC:19325
        /**//LC:19326
         * <p>Constructor.</p>//LC:19327
         *//LC:19328
         * <p>Use the static constant rather than instantiating.</p>//LC:19329
         *///LC:19330
        NoFieldNameToStringStyle() {//LC:19331
            super();//LC:19332
            this.setUseFieldNames(false);//LC:19333
        }//LC:19334
//LC:19335
        /**//LC:19336
         * <p>Ensure <code>Singleton</code> after serialization.</p>//LC:19337
         *//LC:19338
         * @return the singleton//LC:19339
         *///LC:19340
        private Object readResolve() {//LC:19341
            return ToStringStyle.NO_FIELD_NAMES_STYLE;//LC:19342
        }//LC:19343
//LC:19344
    }//LC:19345
//LC:19346
    //----------------------------------------------------------------------------//LC:19347
//LC:19348
    /**//LC:19349
     * <p><code>ToStringStyle</code> that prints out the short//LC:19350
     * class name and no identity hashcode.</p>//LC:19351
     *//LC:19352
     * <p>This is an inner class rather than using//LC:19353
     * <code>StandardToStringStyle</code> to ensure its immutability.</p>//LC:19354
     *///LC:19355
    private static final class ShortPrefixToStringStyle extends ToStringStyle {//LC:19356
//LC:19357
        private static final long serialVersionUID = 1L;//LC:19358
//LC:19359
        /**//LC:19360
         * <p>Constructor.</p>//LC:19361
         *//LC:19362
         * <p>Use the static constant rather than instantiating.</p>//LC:19363
         *///LC:19364
        ShortPrefixToStringStyle() {//LC:19365
            super();//LC:19366
            this.setUseShortClassName(true);//LC:19367
            this.setUseIdentityHashCode(false);//LC:19368
        }//LC:19369
//LC:19370
        /**//LC:19371
         * <p>Ensure <code>Singleton</ode> after serialization.</p>//LC:19372
         * @return the singleton//LC:19373
         *///LC:19374
        private Object readResolve() {//LC:19375
            return ToStringStyle.SHORT_PREFIX_STYLE;//LC:19376
        }//LC:19377
//LC:19378
    }//LC:19379
//LC:19380
    /**//LC:19381
     * <p><code>ToStringStyle</code> that does not print out the//LC:19382
     * classname, identity hashcode, content start or field name.</p>//LC:19383
     *//LC:19384
     * <p>This is an inner class rather than using//LC:19385
     * <code>StandardToStringStyle</code> to ensure its immutability.</p>//LC:19386
     *///LC:19387
    private static final class SimpleToStringStyle extends ToStringStyle {//LC:19388
//LC:19389
        private static final long serialVersionUID = 1L;//LC:19390
//LC:19391
        /**//LC:19392
         * <p>Constructor.</p>//LC:19393
         *//LC:19394
         * <p>Use the static constant rather than instantiating.</p>//LC:19395
         *///LC:19396
        SimpleToStringStyle() {//LC:19397
            super();//LC:19398
            this.setUseClassName(false);//LC:19399
            this.setUseIdentityHashCode(false);//LC:19400
            this.setUseFieldNames(false);//LC:19401
            this.setContentStart("");//LC:19402
            this.setContentEnd("");//LC:19403
        }//LC:19404
//LC:19405
        /**//LC:19406
         * <p>Ensure <code>Singleton</ode> after serialization.</p>//LC:19407
         * @return the singleton//LC:19408
         *///LC:19409
        private Object readResolve() {//LC:19410
            return ToStringStyle.SIMPLE_STYLE;//LC:19411
        }//LC:19412
//LC:19413
    }//LC:19414
//LC:19415
    //----------------------------------------------------------------------------//LC:19416
//LC:19417
    /**//LC:19418
     * <p><code>ToStringStyle</code> that outputs on multiple lines.</p>//LC:19419
     *//LC:19420
     * <p>This is an inner class rather than using//LC:19421
     * <code>StandardToStringStyle</code> to ensure its immutability.</p>//LC:19422
     *///LC:19423
    private static final class MultiLineToStringStyle extends ToStringStyle {//LC:19424
//LC:19425
        private static final long serialVersionUID = 1L;//LC:19426
//LC:19427
        /**//LC:19428
         * <p>Constructor.</p>//LC:19429
         *//LC:19430
         * <p>Use the static constant rather than instantiating.</p>//LC:19431
         *///LC:19432
        MultiLineToStringStyle() {//LC:19433
            super();//LC:19434
            this.setContentStart("[");//LC:19435
            this.setFieldSeparator(SystemUtils.LINE_SEPARATOR + "  ");//LC:19436
            this.setFieldSeparatorAtStart(true);//LC:19437
            this.setContentEnd(SystemUtils.LINE_SEPARATOR + "]");//LC:19438
        }//LC:19439
//LC:19440
        /**//LC:19441
         * <p>Ensure <code>Singleton</code> after serialization.</p>//LC:19442
         *//LC:19443
         * @return the singleton//LC:19444
         *///LC:19445
        private Object readResolve() {//LC:19446
            return ToStringStyle.MULTI_LINE_STYLE;//LC:19447
        }//LC:19448
//LC:19449
    }//LC:19450
//LC:19451
}//LC:19452
//LC:19453
//LC:19454
/**//LC:19455
 * <p>//LC:19456
 * Assists in implementing {@link Object#hashCode()} methods.//LC:19457
 * </p>//LC:19458
 *//LC:19459
 * <p>//LC:19460
 * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in//LC:19461
 * the book <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a> by Joshua Bloch. Writing a//LC:19462
 * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.//LC:19463
 * </p>//LC:19464
 *//LC:19465
 * <p>//LC:19466
 * The following is the approach taken. When appending a data field, the current total is multiplied by the//LC:19467
 * multiplier then a relevant value//LC:19468
 * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then//LC:19469
 * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.//LC:19470
 * </p>//LC:19471
 *//LC:19472
 * <p>//LC:19473
 * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be//LC:19474
 * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>//LC:19475
 * method.//LC:19476
 * </p>//LC:19477
 *//LC:19478
 * <p>//LC:19479
 * To use this class write code as follows://LC:19480
 * </p>//LC:19481
 *//LC:19482
 * <pre>//LC:19483
 * public class Person {//LC:19484
 *   String name;//LC:19485
 *   int age;//LC:19486
 *   boolean smoker;//LC:19487
 *   ...//LC:19488
 *//LC:19489
 *   public int hashCode() {//LC:19490
 *     // you pick a hard-coded, randomly chosen, non-zero, odd number//LC:19491
 *     // ideally different for each class//LC:19492
 *     return new HashCodeBuilder(17, 37).//LC:19493
 *       append(name).//LC:19494
 *       append(age).//LC:19495
 *       append(smoker).//LC:19496
 *       toHashCode();//LC:19497
 *   }//LC:19498
 * }//LC:19499
 * </pre>//LC:19500
 *//LC:19501
 * <p>//LC:19502
 * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.//LC:19503
 * </p>//LC:19504
 *//LC:19505
 * <p>//LC:19506
 * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are//LC:19507
 * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>//LC:19508
 * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions//LC:19509
 * are set up correctly. It is also slower than testing explicitly.//LC:19510
 * </p>//LC:19511
 *//LC:19512
 * <p>//LC:19513
 * A typical invocation for this method would look like://LC:19514
 * </p>//LC:19515
 *//LC:19516
 * <pre>//LC:19517
 * public int hashCode() {//LC:19518
 *   return HashCodeBuilder.reflectionHashCode(this);//LC:19519
 * }//LC:19520
 * </pre>//LC:19521
 *//LC:19522
 * @since 1.0//LC:19523
 * @version $Id$//LC:19524
 *///LC:19525
class HashCodeBuilder implements Builder<Integer> {//LC:19526
    /**//LC:19527
     * <p>//LC:19528
     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.//LC:19529
     * </p>//LC:19530
     *//LC:19531
     * @since 2.3//LC:19532
     *///LC:19533
    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();//LC:19534
//LC:19535
    /*//LC:19536
     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()//LC:19537
     * we are in the process of calculating.//LC:19538
     *//LC:19539
     * So we generate a one-to-one mapping from the original object to a new object.//LC:19540
     *//LC:19541
     * Now HashSet uses equals() to determine if two elements with the same hashcode really//LC:19542
     * are equal, so we also need to ensure that the replacement objects are only equal//LC:19543
     * if the original objects are identical.//LC:19544
     *//LC:19545
     * The original implementation (2.4 and before) used the System.indentityHashCode()//LC:19546
     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)//LC:19547
     *//LC:19548
     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)//LC:19549
     * to disambiguate the duplicate ids.//LC:19550
     *///LC:19551
//LC:19552
    /**//LC:19553
     * <p>//LC:19554
     * Returns the registry of objects being traversed by the reflection methods in the current thread.//LC:19555
     * </p>//LC:19556
     *//LC:19557
     * @return Set the registry of objects being traversed//LC:19558
     * @since 2.3//LC:19559
     *///LC:19560
    static Set<IDKey> getRegistry() {//LC:19561
        return REGISTRY.get();//LC:19562
    }//LC:19563
//LC:19564
    /**//LC:19565
     * <p>//LC:19566
     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid//LC:19567
     * infinite loops.//LC:19568
     * </p>//LC:19569
     *//LC:19570
     * @param value//LC:19571
     *            The object to lookup in the registry.//LC:19572
     * @return boolean <code>true</code> if the registry contains the given object.//LC:19573
     * @since 2.3//LC:19574
     *///LC:19575
    static boolean isRegistered(final Object value) {//LC:19576
        final Set<IDKey> registry = getRegistry();//LC:19577
        return registry != null && registry.contains(new IDKey(value));//LC:19578
    }//LC:19579
//LC:19580
    /**//LC:19581
     * <p>//LC:19582
     * Appends the fields and values defined by the given object of the given <code>Class</code>.//LC:19583
     * </p>//LC:19584
     *//LC:19585
     * @param object//LC:19586
     *            the object to append details of//LC:19587
     * @param clazz//LC:19588
     *            the class to append details of//LC:19589
     * @param builder//LC:19590
     *            the builder to append to//LC:19591
     * @param useTransients//LC:19592
     *            whether to use transient fields//LC:19593
     * @param excludeFields//LC:19594
     *            Collection of String field names to exclude from use in calculation of hash code//LC:19595
     *///LC:19596
    private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients,//LC:19597
                                         final String[] excludeFields) {//LC:19598
        if (isRegistered(object)) {//LC:19599
            return;//LC:19600
        }//LC:19601
        try {//LC:19602
            register(object);//LC:19603
            final Field[] fields = clazz.getDeclaredFields();//LC:19604
            AccessibleObject.setAccessible(fields, true);//LC:19605
            for (final Field field : fields) {//LC:19606
                if (!ArrayUtils.contains(excludeFields, field.getName())//LC:19607
                        && (field.getName().indexOf('$') == -1)//LC:19608
                        && (useTransients || !Modifier.isTransient(field.getModifiers()))//LC:19609
                        && (!Modifier.isStatic(field.getModifiers()))) {//LC:19610
                    try {//LC:19611
                        final Object fieldValue = field.get(object);//LC:19612
                        builder.append(fieldValue);//LC:19613
                    } catch (final IllegalAccessException e) {//LC:19614
                        // this can't happen. Would get a Security exception instead//LC:19615
                        // throw a runtime exception in case the impossible happens.//LC:19616
                        throw new InternalError("Unexpected IllegalAccessException");//LC:19617
                    }//LC:19618
                }//LC:19619
            }//LC:19620
        } finally {//LC:19621
            unregister(object);//LC:19622
        }//LC:19623
    }//LC:19624
//LC:19625
    /**//LC:19626
     * <p>//LC:19627
     * This method uses reflection to build a valid hash code.//LC:19628
     * </p>//LC:19629
     *//LC:19630
     * <p>//LC:19631
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19632
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19633
     * also not as efficient as testing explicitly.//LC:19634
     * </p>//LC:19635
     *//LC:19636
     * <p>//LC:19637
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the//LC:19638
     * <code>Object</code>.//LC:19639
     * </p>//LC:19640
     *//LC:19641
     * <p>//LC:19642
     * Static fields will not be tested. Superclass fields will be included.//LC:19643
     * </p>//LC:19644
     *//LC:19645
     * <p>//LC:19646
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,//LC:19647
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.//LC:19648
     * </p>//LC:19649
     *//LC:19650
     * @param initialNonZeroOddNumber//LC:19651
     *            a non-zero, odd number used as the initial value//LC:19652
     * @param multiplierNonZeroOddNumber//LC:19653
     *            a non-zero, odd number used as the multiplier//LC:19654
     * @param object//LC:19655
     *            the Object to create a <code>hashCode</code> for//LC:19656
     * @return int hash code//LC:19657
     * @throws IllegalArgumentException//LC:19658
     *             if the Object is <code>null</code>//LC:19659
     * @throws IllegalArgumentException//LC:19660
     *             if the number is zero or even//LC:19661
     *///LC:19662
    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object) {//LC:19663
        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);//LC:19664
    }//LC:19665
//LC:19666
    /**//LC:19667
     * <p>//LC:19668
     * This method uses reflection to build a valid hash code.//LC:19669
     * </p>//LC:19670
     *//LC:19671
     * <p>//LC:19672
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19673
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19674
     * also not as efficient as testing explicitly.//LC:19675
     * </p>//LC:19676
     *//LC:19677
     * <p>//LC:19678
     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they//LC:19679
     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.//LC:19680
     * </p>//LC:19681
     *//LC:19682
     * <p>//LC:19683
     * Static fields will not be tested. Superclass fields will be included.//LC:19684
     * </p>//LC:19685
     *//LC:19686
     * <p>//LC:19687
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,//LC:19688
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.//LC:19689
     * </p>//LC:19690
     *//LC:19691
     * @param initialNonZeroOddNumber//LC:19692
     *            a non-zero, odd number used as the initial value//LC:19693
     * @param multiplierNonZeroOddNumber//LC:19694
     *            a non-zero, odd number used as the multiplier//LC:19695
     * @param object//LC:19696
     *            the Object to create a <code>hashCode</code> for//LC:19697
     * @param testTransients//LC:19698
     *            whether to include transient fields//LC:19699
     * @return int hash code//LC:19700
     * @throws IllegalArgumentException//LC:19701
     *             if the Object is <code>null</code>//LC:19702
     * @throws IllegalArgumentException//LC:19703
     *             if the number is zero or even//LC:19704
     *///LC:19705
    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object,//LC:19706
                                         final boolean testTransients) {//LC:19707
        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);//LC:19708
    }//LC:19709
//LC:19710
    /**//LC:19711
     * <p>//LC:19712
     * This method uses reflection to build a valid hash code.//LC:19713
     * </p>//LC:19714
     *//LC:19715
     * <p>//LC:19716
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19717
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19718
     * also not as efficient as testing explicitly.//LC:19719
     * </p>//LC:19720
     *//LC:19721
     * <p>//LC:19722
     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they//LC:19723
     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.//LC:19724
     * </p>//LC:19725
     *//LC:19726
     * <p>//LC:19727
     * Static fields will not be included. Superclass fields will be included up to and including the specified//LC:19728
     * superclass. A null superclass is treated as java.lang.Object.//LC:19729
     * </p>//LC:19730
     *//LC:19731
     * <p>//LC:19732
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,//LC:19733
     * however this is not vital. Prime numbers are preferred, especially for the multiplier.//LC:19734
     * </p>//LC:19735
     *//LC:19736
     * @param <T>//LC:19737
     *            the type of the object involved//LC:19738
     * @param initialNonZeroOddNumber//LC:19739
     *            a non-zero, odd number used as the initial value//LC:19740
     * @param multiplierNonZeroOddNumber//LC:19741
     *            a non-zero, odd number used as the multiplier//LC:19742
     * @param object//LC:19743
     *            the Object to create a <code>hashCode</code> for//LC:19744
     * @param testTransients//LC:19745
     *            whether to include transient fields//LC:19746
     * @param reflectUpToClass//LC:19747
     *            the superclass to reflect up to (inclusive), may be <code>null</code>//LC:19748
     * @param excludeFields//LC:19749
     *            array of field names to exclude from use in calculation of hash code//LC:19750
     * @return int hash code//LC:19751
     * @throws IllegalArgumentException//LC:19752
     *             if the Object is <code>null</code>//LC:19753
     * @throws IllegalArgumentException//LC:19754
     *             if the number is zero or even//LC:19755
     * @since 2.0//LC:19756
     *///LC:19757
    public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object,//LC:19758
                                             final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) {//LC:19759
//LC:19760
        if (object == null) {//LC:19761
            throw new IllegalArgumentException("The object to build a hash code for must not be null");//LC:19762
        }//LC:19763
        final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);//LC:19764
        Class<?> clazz = object.getClass();//LC:19765
        reflectionAppend(object, clazz, builder, testTransients, excludeFields);//LC:19766
        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {//LC:19767
            clazz = clazz.getSuperclass();//LC:19768
            reflectionAppend(object, clazz, builder, testTransients, excludeFields);//LC:19769
        }//LC:19770
        return builder.toHashCode();//LC:19771
    }//LC:19772
//LC:19773
    /**//LC:19774
     * <p>//LC:19775
     * This method uses reflection to build a valid hash code.//LC:19776
     * </p>//LC:19777
     *//LC:19778
     * <p>//LC:19779
     * This constructor uses two hard coded choices for the constants needed to build a hash code.//LC:19780
     * </p>//LC:19781
     *//LC:19782
     * <p>//LC:19783
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19784
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19785
     * also not as efficient as testing explicitly.//LC:19786
     * </p>//LC:19787
     *//LC:19788
     * <P>//LC:19789
     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they//LC:19790
     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.//LC:19791
     * </p>//LC:19792
     *//LC:19793
     * <p>//LC:19794
     * Static fields will not be tested. Superclass fields will be included.//LC:19795
     * </p>//LC:19796
     *//LC:19797
     * @param object//LC:19798
     *            the Object to create a <code>hashCode</code> for//LC:19799
     * @param testTransients//LC:19800
     *            whether to include transient fields//LC:19801
     * @return int hash code//LC:19802
     * @throws IllegalArgumentException//LC:19803
     *             if the object is <code>null</code>//LC:19804
     *///LC:19805
    public static int reflectionHashCode(final Object object, final boolean testTransients) {//LC:19806
        return reflectionHashCode(17, 37, object, testTransients, null);//LC:19807
    }//LC:19808
//LC:19809
    /**//LC:19810
     * <p>//LC:19811
     * This method uses reflection to build a valid hash code.//LC:19812
     * </p>//LC:19813
     *//LC:19814
     * <p>//LC:19815
     * This constructor uses two hard coded choices for the constants needed to build a hash code.//LC:19816
     * </p>//LC:19817
     *//LC:19818
     * <p>//LC:19819
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19820
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19821
     * also not as efficient as testing explicitly.//LC:19822
     * </p>//LC:19823
     *//LC:19824
     * <p>//LC:19825
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the//LC:19826
     * <code>Object</code>.//LC:19827
     * </p>//LC:19828
     *//LC:19829
     * <p>//LC:19830
     * Static fields will not be tested. Superclass fields will be included.//LC:19831
     * </p>//LC:19832
     *//LC:19833
     * @param object//LC:19834
     *            the Object to create a <code>hashCode</code> for//LC:19835
     * @param excludeFields//LC:19836
     *            Collection of String field names to exclude from use in calculation of hash code//LC:19837
     * @return int hash code//LC:19838
     * @throws IllegalArgumentException//LC:19839
     *             if the object is <code>null</code>//LC:19840
     *///LC:19841
    public static int reflectionHashCode(final Object object, final Collection<String> excludeFields) {//LC:19842
        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));//LC:19843
    }//LC:19844
//LC:19845
    // -------------------------------------------------------------------------//LC:19846
//LC:19847
    /**//LC:19848
     * <p>//LC:19849
     * This method uses reflection to build a valid hash code.//LC:19850
     * </p>//LC:19851
     *//LC:19852
     * <p>//LC:19853
     * This constructor uses two hard coded choices for the constants needed to build a hash code.//LC:19854
     * </p>//LC:19855
     *//LC:19856
     * <p>//LC:19857
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:19858
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:19859
     * also not as efficient as testing explicitly.//LC:19860
     * </p>//LC:19861
     *//LC:19862
     * <p>//LC:19863
     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the//LC:19864
     * <code>Object</code>.//LC:19865
     * </p>//LC:19866
     *//LC:19867
     * <p>//LC:19868
     * Static fields will not be tested. Superclass fields will be included.//LC:19869
     * </p>//LC:19870
     *//LC:19871
     * @param object//LC:19872
     *            the Object to create a <code>hashCode</code> for//LC:19873
     * @param excludeFields//LC:19874
     *            array of field names to exclude from use in calculation of hash code//LC:19875
     * @return int hash code//LC:19876
     * @throws IllegalArgumentException//LC:19877
     *             if the object is <code>null</code>//LC:19878
     *///LC:19879
    public static int reflectionHashCode(final Object object, final String... excludeFields) {//LC:19880
        return reflectionHashCode(17, 37, object, false, null, excludeFields);//LC:19881
    }//LC:19882
//LC:19883
    /**//LC:19884
     * <p>//LC:19885
     * Registers the given object. Used by the reflection methods to avoid infinite loops.//LC:19886
     * </p>//LC:19887
     *//LC:19888
     * @param value//LC:19889
     *            The object to register.//LC:19890
     *///LC:19891
    static void register(final Object value) {//LC:19892
        synchronized (HashCodeBuilder.class) {//LC:19893
            if (getRegistry() == null) {//LC:19894
                REGISTRY.set(new HashSet<IDKey>());//LC:19895
            }//LC:19896
        }//LC:19897
        getRegistry().add(new IDKey(value));//LC:19898
    }//LC:19899
//LC:19900
    /**//LC:19901
     * <p>//LC:19902
     * Unregisters the given object.//LC:19903
     * </p>//LC:19904
     *//LC:19905
     * <p>//LC:19906
     * Used by the reflection methods to avoid infinite loops.//LC:19907
     *//LC:19908
     * @param value//LC:19909
     *            The object to unregister.//LC:19910
     * @since 2.3//LC:19911
     *///LC:19912
    static void unregister(final Object value) {//LC:19913
        Set<IDKey> registry = getRegistry();//LC:19914
        if (registry != null) {//LC:19915
            registry.remove(new IDKey(value));//LC:19916
            synchronized (HashCodeBuilder.class) {//LC:19917
                //read again//LC:19918
                registry = getRegistry();//LC:19919
                if (registry != null && registry.isEmpty()) {//LC:19920
                    REGISTRY.remove();//LC:19921
                }//LC:19922
            }//LC:19923
        }//LC:19924
    }//LC:19925
//LC:19926
    /**//LC:19927
     * Constant to use in building the hashCode.//LC:19928
     *///LC:19929
    private final int iConstant;//LC:19930
//LC:19931
    /**//LC:19932
     * Running total of the hashCode.//LC:19933
     *///LC:19934
    private int iTotal = 0;//LC:19935
//LC:19936
    /**//LC:19937
     * <p>//LC:19938
     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.//LC:19939
     * </p>//LC:19940
     *///LC:19941
    public HashCodeBuilder() {//LC:19942
        iConstant = 37;//LC:19943
        iTotal = 17;//LC:19944
    }//LC:19945
//LC:19946
    /**//LC:19947
     * <p>//LC:19948
     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,//LC:19949
     * however this is not vital.//LC:19950
     * </p>//LC:19951
     *//LC:19952
     * <p>//LC:19953
     * Prime numbers are preferred, especially for the multiplier.//LC:19954
     * </p>//LC:19955
     *//LC:19956
     * @param initialNonZeroOddNumber//LC:19957
     *            a non-zero, odd number used as the initial value//LC:19958
     * @param multiplierNonZeroOddNumber//LC:19959
     *            a non-zero, odd number used as the multiplier//LC:19960
     * @throws IllegalArgumentException//LC:19961
     *             if the number is zero or even//LC:19962
     *///LC:19963
    public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) {//LC:19964
        if (initialNonZeroOddNumber == 0) {//LC:19965
            throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value");//LC:19966
        }//LC:19967
        if (initialNonZeroOddNumber % 2 == 0) {//LC:19968
            throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value");//LC:19969
        }//LC:19970
        if (multiplierNonZeroOddNumber == 0) {//LC:19971
            throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier");//LC:19972
        }//LC:19973
        if (multiplierNonZeroOddNumber % 2 == 0) {//LC:19974
            throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier");//LC:19975
        }//LC:19976
        iConstant = multiplierNonZeroOddNumber;//LC:19977
        iTotal = initialNonZeroOddNumber;//LC:19978
    }//LC:19979
//LC:19980
    /**//LC:19981
     * <p>//LC:19982
     * Append a <code>hashCode</code> for a <code>boolean</code>.//LC:19983
     * </p>//LC:19984
     * <p>//LC:19985
     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.//LC:19986
     * </p>//LC:19987
     * <p>//LC:19988
     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes//LC:19989
     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances//LC:19990
     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances//LC:19991
     * that represent <code>false</code>.//LC:19992
     * </p>//LC:19993
     * <p>//LC:19994
     * This is in accordance with the <quote>Effective Java</quote> design.//LC:19995
     * </p>//LC:19996
     *//LC:19997
     * @param value//LC:19998
     *            the boolean to add to the <code>hashCode</code>//LC:19999
     * @return this//LC:20000
     *///LC:20001
    public HashCodeBuilder append(final boolean value) {//LC:20002
        iTotal = iTotal * iConstant + (value ? 0 : 1);//LC:20003
        return this;//LC:20004
    }//LC:20005
//LC:20006
    /**//LC:20007
     * <p>//LC:20008
     * Append a <code>hashCode</code> for a <code>boolean</code> array.//LC:20009
     * </p>//LC:20010
     *//LC:20011
     * @param array//LC:20012
     *            the array to add to the <code>hashCode</code>//LC:20013
     * @return this//LC:20014
     *///LC:20015
    public HashCodeBuilder append(final boolean[] array) {//LC:20016
        if (array == null) {//LC:20017
            iTotal = iTotal * iConstant;//LC:20018
        } else {//LC:20019
            for (final boolean element : array) {//LC:20020
                append(element);//LC:20021
            }//LC:20022
        }//LC:20023
        return this;//LC:20024
    }//LC:20025
//LC:20026
    // -------------------------------------------------------------------------//LC:20027
//LC:20028
    /**//LC:20029
     * <p>//LC:20030
     * Append a <code>hashCode</code> for a <code>byte</code>.//LC:20031
     * </p>//LC:20032
     *//LC:20033
     * @param value//LC:20034
     *            the byte to add to the <code>hashCode</code>//LC:20035
     * @return this//LC:20036
     *///LC:20037
    public HashCodeBuilder append(final byte value) {//LC:20038
        iTotal = iTotal * iConstant + value;//LC:20039
        return this;//LC:20040
    }//LC:20041
//LC:20042
    // -------------------------------------------------------------------------//LC:20043
//LC:20044
    /**//LC:20045
     * <p>//LC:20046
     * Append a <code>hashCode</code> for a <code>byte</code> array.//LC:20047
     * </p>//LC:20048
     *//LC:20049
     * @param array//LC:20050
     *            the array to add to the <code>hashCode</code>//LC:20051
     * @return this//LC:20052
     *///LC:20053
    public HashCodeBuilder append(final byte[] array) {//LC:20054
        if (array == null) {//LC:20055
            iTotal = iTotal * iConstant;//LC:20056
        } else {//LC:20057
            for (final byte element : array) {//LC:20058
                append(element);//LC:20059
            }//LC:20060
        }//LC:20061
        return this;//LC:20062
    }//LC:20063
//LC:20064
    /**//LC:20065
     * <p>//LC:20066
     * Append a <code>hashCode</code> for a <code>char</code>.//LC:20067
     * </p>//LC:20068
     *//LC:20069
     * @param value//LC:20070
     *            the char to add to the <code>hashCode</code>//LC:20071
     * @return this//LC:20072
     *///LC:20073
    public HashCodeBuilder append(final char value) {//LC:20074
        iTotal = iTotal * iConstant + value;//LC:20075
        return this;//LC:20076
    }//LC:20077
//LC:20078
    /**//LC:20079
     * <p>//LC:20080
     * Append a <code>hashCode</code> for a <code>char</code> array.//LC:20081
     * </p>//LC:20082
     *//LC:20083
     * @param array//LC:20084
     *            the array to add to the <code>hashCode</code>//LC:20085
     * @return this//LC:20086
     *///LC:20087
    public HashCodeBuilder append(final char[] array) {//LC:20088
        if (array == null) {//LC:20089
            iTotal = iTotal * iConstant;//LC:20090
        } else {//LC:20091
            for (final char element : array) {//LC:20092
                append(element);//LC:20093
            }//LC:20094
        }//LC:20095
        return this;//LC:20096
    }//LC:20097
//LC:20098
    /**//LC:20099
     * <p>//LC:20100
     * Append a <code>hashCode</code> for a <code>double</code>.//LC:20101
     * </p>//LC:20102
     *//LC:20103
     * @param value//LC:20104
     *            the double to add to the <code>hashCode</code>//LC:20105
     * @return this//LC:20106
     *///LC:20107
    public HashCodeBuilder append(final double value) {//LC:20108
        return append(Double.doubleToLongBits(value));//LC:20109
    }//LC:20110
//LC:20111
    /**//LC:20112
     * <p>//LC:20113
     * Append a <code>hashCode</code> for a <code>double</code> array.//LC:20114
     * </p>//LC:20115
     *//LC:20116
     * @param array//LC:20117
     *            the array to add to the <code>hashCode</code>//LC:20118
     * @return this//LC:20119
     *///LC:20120
    public HashCodeBuilder append(final double[] array) {//LC:20121
        if (array == null) {//LC:20122
            iTotal = iTotal * iConstant;//LC:20123
        } else {//LC:20124
            for (final double element : array) {//LC:20125
                append(element);//LC:20126
            }//LC:20127
        }//LC:20128
        return this;//LC:20129
    }//LC:20130
//LC:20131
    /**//LC:20132
     * <p>//LC:20133
     * Append a <code>hashCode</code> for a <code>float</code>.//LC:20134
     * </p>//LC:20135
     *//LC:20136
     * @param value//LC:20137
     *            the float to add to the <code>hashCode</code>//LC:20138
     * @return this//LC:20139
     *///LC:20140
    public HashCodeBuilder append(final float value) {//LC:20141
        iTotal = iTotal * iConstant + Float.floatToIntBits(value);//LC:20142
        return this;//LC:20143
    }//LC:20144
//LC:20145
    /**//LC:20146
     * <p>//LC:20147
     * Append a <code>hashCode</code> for a <code>float</code> array.//LC:20148
     * </p>//LC:20149
     *//LC:20150
     * @param array//LC:20151
     *            the array to add to the <code>hashCode</code>//LC:20152
     * @return this//LC:20153
     *///LC:20154
    public HashCodeBuilder append(final float[] array) {//LC:20155
        if (array == null) {//LC:20156
            iTotal = iTotal * iConstant;//LC:20157
        } else {//LC:20158
            for (final float element : array) {//LC:20159
                append(element);//LC:20160
            }//LC:20161
        }//LC:20162
        return this;//LC:20163
    }//LC:20164
//LC:20165
    /**//LC:20166
     * <p>//LC:20167
     * Append a <code>hashCode</code> for an <code>int</code>.//LC:20168
     * </p>//LC:20169
     *//LC:20170
     * @param value//LC:20171
     *            the int to add to the <code>hashCode</code>//LC:20172
     * @return this//LC:20173
     *///LC:20174
    public HashCodeBuilder append(final int value) {//LC:20175
        iTotal = iTotal * iConstant + value;//LC:20176
        return this;//LC:20177
    }//LC:20178
//LC:20179
    /**//LC:20180
     * <p>//LC:20181
     * Append a <code>hashCode</code> for an <code>int</code> array.//LC:20182
     * </p>//LC:20183
     *//LC:20184
     * @param array//LC:20185
     *            the array to add to the <code>hashCode</code>//LC:20186
     * @return this//LC:20187
     *///LC:20188
    public HashCodeBuilder append(final int[] array) {//LC:20189
        if (array == null) {//LC:20190
            iTotal = iTotal * iConstant;//LC:20191
        } else {//LC:20192
            for (final int element : array) {//LC:20193
                append(element);//LC:20194
            }//LC:20195
        }//LC:20196
        return this;//LC:20197
    }//LC:20198
//LC:20199
    /**//LC:20200
     * <p>//LC:20201
     * Append a <code>hashCode</code> for a <code>long</code>.//LC:20202
     * </p>//LC:20203
     *//LC:20204
     * @param value//LC:20205
     *            the long to add to the <code>hashCode</code>//LC:20206
     * @return this//LC:20207
     *///LC:20208
    // NOTE: This method uses >> and not >>> as Effective Java and//LC:20209
    //       Long.hashCode do. Ideally we should switch to >>> at//LC:20210
    //       some stage. There are backwards compat issues, so//LC:20211
    //       that will have to wait for the time being. cf LANG-342.//LC:20212
    public HashCodeBuilder append(final long value) {//LC:20213
        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));//LC:20214
        return this;//LC:20215
    }//LC:20216
//LC:20217
    /**//LC:20218
     * <p>//LC:20219
     * Append a <code>hashCode</code> for a <code>long</code> array.//LC:20220
     * </p>//LC:20221
     *//LC:20222
     * @param array//LC:20223
     *            the array to add to the <code>hashCode</code>//LC:20224
     * @return this//LC:20225
     *///LC:20226
    public HashCodeBuilder append(final long[] array) {//LC:20227
        if (array == null) {//LC:20228
            iTotal = iTotal * iConstant;//LC:20229
        } else {//LC:20230
            for (final long element : array) {//LC:20231
                append(element);//LC:20232
            }//LC:20233
        }//LC:20234
        return this;//LC:20235
    }//LC:20236
//LC:20237
    /**//LC:20238
     * <p>//LC:20239
     * Append a <code>hashCode</code> for an <code>Object</code>.//LC:20240
     * </p>//LC:20241
     *//LC:20242
     * @param object//LC:20243
     *            the Object to add to the <code>hashCode</code>//LC:20244
     * @return this//LC:20245
     *///LC:20246
    public HashCodeBuilder append(final Object object) {//LC:20247
        if (object == null) {//LC:20248
            iTotal = iTotal * iConstant;//LC:20249
//LC:20250
        } else {//LC:20251
            if(object.getClass().isArray()) {//LC:20252
                // 'Switch' on type of array, to dispatch to the correct handler//LC:20253
                // This handles multi dimensional arrays//LC:20254
                if (object instanceof long[]) {//LC:20255
                    append((long[]) object);//LC:20256
                } else if (object instanceof int[]) {//LC:20257
                    append((int[]) object);//LC:20258
                } else if (object instanceof short[]) {//LC:20259
                    append((short[]) object);//LC:20260
                } else if (object instanceof char[]) {//LC:20261
                    append((char[]) object);//LC:20262
                } else if (object instanceof byte[]) {//LC:20263
                    append((byte[]) object);//LC:20264
                } else if (object instanceof double[]) {//LC:20265
                    append((double[]) object);//LC:20266
                } else if (object instanceof float[]) {//LC:20267
                    append((float[]) object);//LC:20268
                } else if (object instanceof boolean[]) {//LC:20269
                    append((boolean[]) object);//LC:20270
                } else {//LC:20271
                    // Not an array of primitives//LC:20272
                    append((Object[]) object);//LC:20273
                }//LC:20274
            } else {//LC:20275
                iTotal = iTotal * iConstant + object.hashCode();//LC:20276
            }//LC:20277
        }//LC:20278
        return this;//LC:20279
    }//LC:20280
//LC:20281
    /**//LC:20282
     * <p>//LC:20283
     * Append a <code>hashCode</code> for an <code>Object</code> array.//LC:20284
     * </p>//LC:20285
     *//LC:20286
     * @param array//LC:20287
     *            the array to add to the <code>hashCode</code>//LC:20288
     * @return this//LC:20289
     *///LC:20290
    public HashCodeBuilder append(final Object[] array) {//LC:20291
        if (array == null) {//LC:20292
            iTotal = iTotal * iConstant;//LC:20293
        } else {//LC:20294
            for (final Object element : array) {//LC:20295
                append(element);//LC:20296
            }//LC:20297
        }//LC:20298
        return this;//LC:20299
    }//LC:20300
//LC:20301
    /**//LC:20302
     * <p>//LC:20303
     * Append a <code>hashCode</code> for a <code>short</code>.//LC:20304
     * </p>//LC:20305
     *//LC:20306
     * @param value//LC:20307
     *            the short to add to the <code>hashCode</code>//LC:20308
     * @return this//LC:20309
     *///LC:20310
    public HashCodeBuilder append(final short value) {//LC:20311
        iTotal = iTotal * iConstant + value;//LC:20312
        return this;//LC:20313
    }//LC:20314
//LC:20315
    /**//LC:20316
     * <p>//LC:20317
     * Append a <code>hashCode</code> for a <code>short</code> array.//LC:20318
     * </p>//LC:20319
     *//LC:20320
     * @param array//LC:20321
     *            the array to add to the <code>hashCode</code>//LC:20322
     * @return this//LC:20323
     *///LC:20324
    public HashCodeBuilder append(final short[] array) {//LC:20325
        if (array == null) {//LC:20326
            iTotal = iTotal * iConstant;//LC:20327
        } else {//LC:20328
            for (final short element : array) {//LC:20329
                append(element);//LC:20330
            }//LC:20331
        }//LC:20332
        return this;//LC:20333
    }//LC:20334
//LC:20335
    /**//LC:20336
     * <p>//LC:20337
     * Adds the result of super.hashCode() to this builder.//LC:20338
     * </p>//LC:20339
     *//LC:20340
     * @param superHashCode//LC:20341
     *            the result of calling <code>super.hashCode()</code>//LC:20342
     * @return this HashCodeBuilder, used to chain calls.//LC:20343
     * @since 2.0//LC:20344
     *///LC:20345
    public HashCodeBuilder appendSuper(final int superHashCode) {//LC:20346
        iTotal = iTotal * iConstant + superHashCode;//LC:20347
        return this;//LC:20348
    }//LC:20349
//LC:20350
    /**//LC:20351
     * <p>//LC:20352
     * Return the computed <code>hashCode</code>.//LC:20353
     * </p>//LC:20354
     *//LC:20355
     * @return <code>hashCode</code> based on the fields appended//LC:20356
     *///LC:20357
    public int toHashCode() {//LC:20358
        return iTotal;//LC:20359
    }//LC:20360
//LC:20361
    /**//LC:20362
     * Returns the computed <code>hashCode</code>.//LC:20363
     *//LC:20364
     * @return <code>hashCode</code> based on the fields appended//LC:20365
     *//LC:20366
     * @since 3.0//LC:20367
     *///LC:20368
    @Override//LC:20369
    public Integer build() {//LC:20370
        return Integer.valueOf(toHashCode());//LC:20371
    }//LC:20372
//LC:20373
    /**//LC:20374
     * <p>//LC:20375
     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood//LC:20376
     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for//LC:20377
     * HashCodeBuilder itself is.</p>//LC:20378
     *//LC:20379
     * @return <code>hashCode</code> based on the fields appended//LC:20380
     * @since 2.5//LC:20381
     *///LC:20382
    @Override//LC:20383
    public int hashCode() {//LC:20384
        return toHashCode();//LC:20385
    }//LC:20386
//LC:20387
}//LC:20388
//LC:20389
//LC:20390
/**//LC:20391
 * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>//LC:20392
 *//LC:20393
 * <p> This class provides methods to build a good equals method for any//LC:20394
 * class. It follows rules laid out in//LC:20395
 * <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>//LC:20396
 * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,//LC:20397
 * <code>floats</code>, and arrays can be tricky. Also, making sure that//LC:20398
 * <code>equals()</code> and <code>hashCode()</code> are consistent can be//LC:20399
 * difficult.</p>//LC:20400
 *//LC:20401
 * <p>Two Objects that compare as equals must generate the same hash code,//LC:20402
 * but two Objects with the same hash code do not have to be equal.</p>//LC:20403
 *//LC:20404
 * <p>All relevant fields should be included in the calculation of equals.//LC:20405
 * Derived fields may be ignored. In particular, any field used in//LC:20406
 * generating a hash code must be used in the equals method, and vice//LC:20407
 * versa.</p>//LC:20408
 *//LC:20409
 * <p>Typical use for the code is as follows:</p>//LC:20410
 * <pre>//LC:20411
 * public boolean equals(Object obj) {//LC:20412
 *   if (obj == null) { return false; }//LC:20413
 *   if (obj == this) { return true; }//LC:20414
 *   if (obj.getClass() != getClass()) {//LC:20415
 *     return false;//LC:20416
 *   }//LC:20417
 *   MyClass rhs = (MyClass) obj;//LC:20418
 *   return new EqualsBuilder()//LC:20419
 *                 .appendSuper(super.equals(obj))//LC:20420
 *                 .append(field1, rhs.field1)//LC:20421
 *                 .append(field2, rhs.field2)//LC:20422
 *                 .append(field3, rhs.field3)//LC:20423
 *                 .isEquals();//LC:20424
 *  }//LC:20425
 * </pre>//LC:20426
 *//LC:20427
 * <p> Alternatively, there is a method that uses reflection to determine//LC:20428
 * the fields to test. Because these fields are usually private, the method,//LC:20429
 * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to//LC:20430
 * change the visibility of the fields. This will fail under a security//LC:20431
 * manager, unless the appropriate permissions are set up correctly. It is//LC:20432
 * also slower than testing explicitly.</p>//LC:20433
 *//LC:20434
 * <p> A typical invocation for this method would look like:</p>//LC:20435
 * <pre>//LC:20436
 * public boolean equals(Object obj) {//LC:20437
 *   return EqualsBuilder.reflectionEquals(this, obj);//LC:20438
 * }//LC:20439
 * </pre>//LC:20440
 *//LC:20441
 * @since 1.0//LC:20442
 * @version $Id$//LC:20443
 *///LC:20444
class EqualsBuilder implements Builder<Boolean> {//LC:20445
//LC:20446
    /**//LC:20447
     * <p>//LC:20448
     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.//LC:20449
     * </p>//LC:20450
     *//LC:20451
     * @since 3.0//LC:20452
     *///LC:20453
    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();//LC:20454
//LC:20455
    /*//LC:20456
     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()//LC:20457
     * we are in the process of calculating.//LC:20458
     *//LC:20459
     * So we generate a one-to-one mapping from the original object to a new object.//LC:20460
     *//LC:20461
     * Now HashSet uses equals() to determine if two elements with the same hashcode really//LC:20462
     * are equal, so we also need to ensure that the replacement objects are only equal//LC:20463
     * if the original objects are identical.//LC:20464
     *//LC:20465
     * The original implementation (2.4 and before) used the System.indentityHashCode()//LC:20466
     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)//LC:20467
     *//LC:20468
     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)//LC:20469
     * to disambiguate the duplicate ids.//LC:20470
     *///LC:20471
//LC:20472
    /**//LC:20473
     * <p>//LC:20474
     * Returns the registry of object pairs being traversed by the reflection//LC:20475
     * methods in the current thread.//LC:20476
     * </p>//LC:20477
     *//LC:20478
     * @return Set the registry of objects being traversed//LC:20479
     * @since 3.0//LC:20480
     *///LC:20481
    static Set<Pair<IDKey, IDKey>> getRegistry() {//LC:20482
        return REGISTRY.get();//LC:20483
    }//LC:20484
//LC:20485
    /**//LC:20486
     * <p>//LC:20487
     * Converters value pair into a register pair.//LC:20488
     * </p>//LC:20489
     *//LC:20490
     * @param lhs <code>this</code> object//LC:20491
     * @param rhs the other object//LC:20492
     *//LC:20493
     * @return the pair//LC:20494
     *///LC:20495
    static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {//LC:20496
        final IDKey left = new IDKey(lhs);//LC:20497
        final IDKey right = new IDKey(rhs);//LC:20498
        return Pair.of(left, right);//LC:20499
    }//LC:20500
//LC:20501
    /**//LC:20502
     * <p>//LC:20503
     * Returns <code>true</code> if the registry contains the given object pair.//LC:20504
     * Used by the reflection methods to avoid infinite loops.//LC:20505
     * Objects might be swapped therefore a check is needed if the object pair//LC:20506
     * is registered in given or swapped order.//LC:20507
     * </p>//LC:20508
     *//LC:20509
     * @param lhs <code>this</code> object to lookup in registry//LC:20510
     * @param rhs the other object to lookup on registry//LC:20511
     * @return boolean <code>true</code> if the registry contains the given object.//LC:20512
     * @since 3.0//LC:20513
     *///LC:20514
    static boolean isRegistered(final Object lhs, final Object rhs) {//LC:20515
        final Set<Pair<IDKey, IDKey>> registry = getRegistry();//LC:20516
        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);//LC:20517
        final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());//LC:20518
//LC:20519
        return registry != null//LC:20520
                && (registry.contains(pair) || registry.contains(swappedPair));//LC:20521
    }//LC:20522
//LC:20523
    /**//LC:20524
     * <p>//LC:20525
     * Registers the given object pair.//LC:20526
     * Used by the reflection methods to avoid infinite loops.//LC:20527
     * </p>//LC:20528
     *//LC:20529
     * @param lhs <code>this</code> object to register//LC:20530
     * @param rhs the other object to register//LC:20531
     *///LC:20532
    static void register(final Object lhs, final Object rhs) {//LC:20533
        synchronized (EqualsBuilder.class) {//LC:20534
            if (getRegistry() == null) {//LC:20535
                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());//LC:20536
            }//LC:20537
        }//LC:20538
//LC:20539
        final Set<Pair<IDKey, IDKey>> registry = getRegistry();//LC:20540
        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);//LC:20541
        registry.add(pair);//LC:20542
    }//LC:20543
//LC:20544
    /**//LC:20545
     * <p>//LC:20546
     * Unregisters the given object pair.//LC:20547
     * </p>//LC:20548
     *//LC:20549
     * <p>//LC:20550
     * Used by the reflection methods to avoid infinite loops.//LC:20551
     *//LC:20552
     * @param lhs <code>this</code> object to unregister//LC:20553
     * @param rhs the other object to unregister//LC:20554
     * @since 3.0//LC:20555
     *///LC:20556
    static void unregister(final Object lhs, final Object rhs) {//LC:20557
        Set<Pair<IDKey, IDKey>> registry = getRegistry();//LC:20558
        if (registry != null) {//LC:20559
            final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);//LC:20560
            registry.remove(pair);//LC:20561
            synchronized (EqualsBuilder.class) {//LC:20562
                //read again//LC:20563
                registry = getRegistry();//LC:20564
                if (registry != null && registry.isEmpty()) {//LC:20565
                    REGISTRY.remove();//LC:20566
                }//LC:20567
            }//LC:20568
        }//LC:20569
    }//LC:20570
//LC:20571
    /**//LC:20572
     * If the fields tested are equals.//LC:20573
     * The default value is <code>true</code>.//LC:20574
     *///LC:20575
    private boolean isEquals = true;//LC:20576
//LC:20577
    /**//LC:20578
     * <p>Constructor for EqualsBuilder.</p>//LC:20579
     *//LC:20580
     * <p>Starts off assuming that equals is <code>true</code>.</p>//LC:20581
     * @see Object#equals(Object)//LC:20582
     *///LC:20583
    public EqualsBuilder() {//LC:20584
        // do nothing for now.//LC:20585
    }//LC:20586
//LC:20587
    //-------------------------------------------------------------------------//LC:20588
//LC:20589
    /**//LC:20590
     * <p>This method uses reflection to determine if the two <code>Object</code>s//LC:20591
     * are equal.</p>//LC:20592
     *//LC:20593
     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private//LC:20594
     * fields. This means that it will throw a security exception if run under//LC:20595
     * a security manager, if the permissions are not set up correctly. It is also//LC:20596
     * not as efficient as testing explicitly.</p>//LC:20597
     *//LC:20598
     * <p>Transient members will be not be tested, as they are likely derived//LC:20599
     * fields, and not part of the value of the Object.</p>//LC:20600
     *//LC:20601
     * <p>Static fields will not be tested. Superclass fields will be included.</p>//LC:20602
     *//LC:20603
     * @param lhs  <code>this</code> object//LC:20604
     * @param rhs  the other object//LC:20605
     * @param excludeFields  Collection of String field names to exclude from testing//LC:20606
     * @return <code>true</code> if the two Objects have tested equals.//LC:20607
     *///LC:20608
    public static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields) {//LC:20609
        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));//LC:20610
    }//LC:20611
//LC:20612
    /**//LC:20613
     * <p>This method uses reflection to determine if the two <code>Object</code>s//LC:20614
     * are equal.</p>//LC:20615
     *//LC:20616
     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private//LC:20617
     * fields. This means that it will throw a security exception if run under//LC:20618
     * a security manager, if the permissions are not set up correctly. It is also//LC:20619
     * not as efficient as testing explicitly.</p>//LC:20620
     *//LC:20621
     * <p>Transient members will be not be tested, as they are likely derived//LC:20622
     * fields, and not part of the value of the Object.</p>//LC:20623
     *//LC:20624
     * <p>Static fields will not be tested. Superclass fields will be included.</p>//LC:20625
     *//LC:20626
     * @param lhs  <code>this</code> object//LC:20627
     * @param rhs  the other object//LC:20628
     * @param excludeFields  array of field names to exclude from testing//LC:20629
     * @return <code>true</code> if the two Objects have tested equals.//LC:20630
     *///LC:20631
    public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) {//LC:20632
        return reflectionEquals(lhs, rhs, false, null, excludeFields);//LC:20633
    }//LC:20634
//LC:20635
    /**//LC:20636
     * <p>This method uses reflection to determine if the two <code>Object</code>s//LC:20637
     * are equal.</p>//LC:20638
     *//LC:20639
     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private//LC:20640
     * fields. This means that it will throw a security exception if run under//LC:20641
     * a security manager, if the permissions are not set up correctly. It is also//LC:20642
     * not as efficient as testing explicitly.</p>//LC:20643
     *//LC:20644
     * <p>If the TestTransients parameter is set to <code>true</code>, transient//LC:20645
     * members will be tested, otherwise they are ignored, as they are likely//LC:20646
     * derived fields, and not part of the value of the <code>Object</code>.</p>//LC:20647
     *//LC:20648
     * <p>Static fields will not be tested. Superclass fields will be included.</p>//LC:20649
     *//LC:20650
     * @param lhs  <code>this</code> object//LC:20651
     * @param rhs  the other object//LC:20652
     * @param testTransients  whether to include transient fields//LC:20653
     * @return <code>true</code> if the two Objects have tested equals.//LC:20654
     *///LC:20655
    public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) {//LC:20656
        return reflectionEquals(lhs, rhs, testTransients, null);//LC:20657
    }//LC:20658
//LC:20659
    /**//LC:20660
     * <p>This method uses reflection to determine if the two <code>Object</code>s//LC:20661
     * are equal.</p>//LC:20662
     *//LC:20663
     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private//LC:20664
     * fields. This means that it will throw a security exception if run under//LC:20665
     * a security manager, if the permissions are not set up correctly. It is also//LC:20666
     * not as efficient as testing explicitly.</p>//LC:20667
     *//LC:20668
     * <p>If the testTransients parameter is set to <code>true</code>, transient//LC:20669
     * members will be tested, otherwise they are ignored, as they are likely//LC:20670
     * derived fields, and not part of the value of the <code>Object</code>.</p>//LC:20671
     *//LC:20672
     * <p>Static fields will not be included. Superclass fields will be appended//LC:20673
     * up to and including the specified superclass. A null superclass is treated//LC:20674
     * as java.lang.Object.</p>//LC:20675
     *//LC:20676
     * @param lhs  <code>this</code> object//LC:20677
     * @param rhs  the other object//LC:20678
     * @param testTransients  whether to include transient fields//LC:20679
     * @param reflectUpToClass  the superclass to reflect up to (inclusive),//LC:20680
     *  may be <code>null</code>//LC:20681
     * @param excludeFields  array of field names to exclude from testing//LC:20682
     * @return <code>true</code> if the two Objects have tested equals.//LC:20683
     * @since 2.0//LC:20684
     *///LC:20685
    public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass,//LC:20686
                                           final String... excludeFields) {//LC:20687
        if (lhs == rhs) {//LC:20688
            return true;//LC:20689
        }//LC:20690
        if (lhs == null || rhs == null) {//LC:20691
            return false;//LC:20692
        }//LC:20693
        // Find the leaf class since there may be transients in the leaf//LC:20694
        // class or in classes between the leaf and root.//LC:20695
        // If we are not testing transients or a subclass has no ivars,//LC:20696
        // then a subclass can test equals to a superclass.//LC:20697
        final Class<?> lhsClass = lhs.getClass();//LC:20698
        final Class<?> rhsClass = rhs.getClass();//LC:20699
        Class<?> testClass;//LC:20700
        if (lhsClass.isInstance(rhs)) {//LC:20701
            testClass = lhsClass;//LC:20702
            if (!rhsClass.isInstance(lhs)) {//LC:20703
                // rhsClass is a subclass of lhsClass//LC:20704
                testClass = rhsClass;//LC:20705
            }//LC:20706
        } else if (rhsClass.isInstance(lhs)) {//LC:20707
            testClass = rhsClass;//LC:20708
            if (!lhsClass.isInstance(rhs)) {//LC:20709
                // lhsClass is a subclass of rhsClass//LC:20710
                testClass = lhsClass;//LC:20711
            }//LC:20712
        } else {//LC:20713
            // The two classes are not related.//LC:20714
            return false;//LC:20715
        }//LC:20716
        final EqualsBuilder equalsBuilder = new EqualsBuilder();//LC:20717
        try {//LC:20718
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);//LC:20719
            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {//LC:20720
                testClass = testClass.getSuperclass();//LC:20721
                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);//LC:20722
            }//LC:20723
        } catch (final IllegalArgumentException e) {//LC:20724
            // In this case, we tried to test a subclass vs. a superclass and//LC:20725
            // the subclass has ivars or the ivars are transient and//LC:20726
            // we are testing transients.//LC:20727
            // If a subclass has ivars that we are trying to test them, we get an//LC:20728
            // exception and we know that the objects are not equal.//LC:20729
            return false;//LC:20730
        }//LC:20731
        return equalsBuilder.isEquals();//LC:20732
    }//LC:20733
//LC:20734
    /**//LC:20735
     * <p>Appends the fields and values defined by the given object of the//LC:20736
     * given Class.</p>//LC:20737
     *//LC:20738
     * @param lhs  the left hand object//LC:20739
     * @param rhs  the right hand object//LC:20740
     * @param clazz  the class to append details of//LC:20741
     * @param builder  the builder to append to//LC:20742
     * @param useTransients  whether to test transient fields//LC:20743
     * @param excludeFields  array of field names to exclude from testing//LC:20744
     *///LC:20745
    private static void reflectionAppend(//LC:20746
            final Object lhs,//LC:20747
            final Object rhs,//LC:20748
            final Class<?> clazz,//LC:20749
            final EqualsBuilder builder,//LC:20750
            final boolean useTransients,//LC:20751
            final String[] excludeFields) {//LC:20752
//LC:20753
        if (isRegistered(lhs, rhs)) {//LC:20754
            return;//LC:20755
        }//LC:20756
//LC:20757
        try {//LC:20758
            register(lhs, rhs);//LC:20759
            final Field[] fields = clazz.getDeclaredFields();//LC:20760
            AccessibleObject.setAccessible(fields, true);//LC:20761
            for (int i = 0; i < fields.length && builder.isEquals; i++) {//LC:20762
                final Field f = fields[i];//LC:20763
                if (!ArrayUtils.contains(excludeFields, f.getName())//LC:20764
                        && (f.getName().indexOf('$') == -1)//LC:20765
                        && (useTransients || !Modifier.isTransient(f.getModifiers()))//LC:20766
                        && (!Modifier.isStatic(f.getModifiers()))) {//LC:20767
                    try {//LC:20768
                        builder.append(f.get(lhs), f.get(rhs));//LC:20769
                    } catch (final IllegalAccessException e) {//LC:20770
                        //this can't happen. Would get a Security exception instead//LC:20771
                        //throw a runtime exception in case the impossible happens.//LC:20772
                        throw new InternalError("Unexpected IllegalAccessException");//LC:20773
                    }//LC:20774
                }//LC:20775
            }//LC:20776
        } finally {//LC:20777
            unregister(lhs, rhs);//LC:20778
        }//LC:20779
    }//LC:20780
//LC:20781
    //-------------------------------------------------------------------------//LC:20782
//LC:20783
    /**//LC:20784
     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>//LC:20785
     *//LC:20786
     * @param superEquals  the result of calling <code>super.equals()</code>//LC:20787
     * @return EqualsBuilder - used to chain calls.//LC:20788
     * @since 2.0//LC:20789
     *///LC:20790
    public EqualsBuilder appendSuper(final boolean superEquals) {//LC:20791
        if (isEquals == false) {//LC:20792
            return this;//LC:20793
        }//LC:20794
        isEquals = superEquals;//LC:20795
        return this;//LC:20796
    }//LC:20797
//LC:20798
    //-------------------------------------------------------------------------//LC:20799
//LC:20800
    /**//LC:20801
     * <p>Test if two <code>Object</code>s are equal using their//LC:20802
     * <code>equals</code> method.</p>//LC:20803
     *//LC:20804
     * @param lhs  the left hand object//LC:20805
     * @param rhs  the right hand object//LC:20806
     * @return EqualsBuilder - used to chain calls.//LC:20807
     *///LC:20808
    public EqualsBuilder append(final Object lhs, final Object rhs) {//LC:20809
        if (isEquals == false) {//LC:20810
            return this;//LC:20811
        }//LC:20812
        if (lhs == rhs) {//LC:20813
            return this;//LC:20814
        }//LC:20815
        if (lhs == null || rhs == null) {//LC:20816
            this.setEquals(false);//LC:20817
            return this;//LC:20818
        }//LC:20819
        final Class<?> lhsClass = lhs.getClass();//LC:20820
        if (!lhsClass.isArray()) {//LC:20821
            // The simple case, not an array, just test the element//LC:20822
            isEquals = lhs.equals(rhs);//LC:20823
        } else if (lhs.getClass() != rhs.getClass()) {//LC:20824
            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]//LC:20825
            this.setEquals(false);//LC:20826
        }//LC:20827
        // 'Switch' on type of array, to dispatch to the correct handler//LC:20828
        // This handles multi dimensional arrays of the same depth//LC:20829
        else if (lhs instanceof long[]) {//LC:20830
            append((long[]) lhs, (long[]) rhs);//LC:20831
        } else if (lhs instanceof int[]) {//LC:20832
            append((int[]) lhs, (int[]) rhs);//LC:20833
        } else if (lhs instanceof short[]) {//LC:20834
            append((short[]) lhs, (short[]) rhs);//LC:20835
        } else if (lhs instanceof char[]) {//LC:20836
            append((char[]) lhs, (char[]) rhs);//LC:20837
        } else if (lhs instanceof byte[]) {//LC:20838
            append((byte[]) lhs, (byte[]) rhs);//LC:20839
        } else if (lhs instanceof double[]) {//LC:20840
            append((double[]) lhs, (double[]) rhs);//LC:20841
        } else if (lhs instanceof float[]) {//LC:20842
            append((float[]) lhs, (float[]) rhs);//LC:20843
        } else if (lhs instanceof boolean[]) {//LC:20844
            append((boolean[]) lhs, (boolean[]) rhs);//LC:20845
        } else {//LC:20846
            // Not an array of primitives//LC:20847
            append((Object[]) lhs, (Object[]) rhs);//LC:20848
        }//LC:20849
        return this;//LC:20850
    }//LC:20851
//LC:20852
    /**//LC:20853
     * <p>//LC:20854
     * Test if two <code>long</code> s are equal.//LC:20855
     * </p>//LC:20856
     *//LC:20857
     * @param lhs//LC:20858
     *                  the left hand <code>long</code>//LC:20859
     * @param rhs//LC:20860
     *                  the right hand <code>long</code>//LC:20861
     * @return EqualsBuilder - used to chain calls.//LC:20862
     *///LC:20863
    public EqualsBuilder append(final long lhs, final long rhs) {//LC:20864
        if (isEquals == false) {//LC:20865
            return this;//LC:20866
        }//LC:20867
        isEquals = (lhs == rhs);//LC:20868
        return this;//LC:20869
    }//LC:20870
//LC:20871
    /**//LC:20872
     * <p>Test if two <code>int</code>s are equal.</p>//LC:20873
     *//LC:20874
     * @param lhs  the left hand <code>int</code>//LC:20875
     * @param rhs  the right hand <code>int</code>//LC:20876
     * @return EqualsBuilder - used to chain calls.//LC:20877
     *///LC:20878
    public EqualsBuilder append(final int lhs, final int rhs) {//LC:20879
        if (isEquals == false) {//LC:20880
            return this;//LC:20881
        }//LC:20882
        isEquals = (lhs == rhs);//LC:20883
        return this;//LC:20884
    }//LC:20885
//LC:20886
    /**//LC:20887
     * <p>Test if two <code>short</code>s are equal.</p>//LC:20888
     *//LC:20889
     * @param lhs  the left hand <code>short</code>//LC:20890
     * @param rhs  the right hand <code>short</code>//LC:20891
     * @return EqualsBuilder - used to chain calls.//LC:20892
     *///LC:20893
    public EqualsBuilder append(final short lhs, final short rhs) {//LC:20894
        if (isEquals == false) {//LC:20895
            return this;//LC:20896
        }//LC:20897
        isEquals = (lhs == rhs);//LC:20898
        return this;//LC:20899
    }//LC:20900
//LC:20901
    /**//LC:20902
     * <p>Test if two <code>char</code>s are equal.</p>//LC:20903
     *//LC:20904
     * @param lhs  the left hand <code>char</code>//LC:20905
     * @param rhs  the right hand <code>char</code>//LC:20906
     * @return EqualsBuilder - used to chain calls.//LC:20907
     *///LC:20908
    public EqualsBuilder append(final char lhs, final char rhs) {//LC:20909
        if (isEquals == false) {//LC:20910
            return this;//LC:20911
        }//LC:20912
        isEquals = (lhs == rhs);//LC:20913
        return this;//LC:20914
    }//LC:20915
//LC:20916
    /**//LC:20917
     * <p>Test if two <code>byte</code>s are equal.</p>//LC:20918
     *//LC:20919
     * @param lhs  the left hand <code>byte</code>//LC:20920
     * @param rhs  the right hand <code>byte</code>//LC:20921
     * @return EqualsBuilder - used to chain calls.//LC:20922
     *///LC:20923
    public EqualsBuilder append(final byte lhs, final byte rhs) {//LC:20924
        if (isEquals == false) {//LC:20925
            return this;//LC:20926
        }//LC:20927
        isEquals = (lhs == rhs);//LC:20928
        return this;//LC:20929
    }//LC:20930
//LC:20931
    /**//LC:20932
     * <p>Test if two <code>double</code>s are equal by testing that the//LC:20933
     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>//LC:20934
     *//LC:20935
     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>//LC:20936
     *//LC:20937
     * <p>It is compatible with the hash code generated by//LC:20938
     * <code>HashCodeBuilder</code>.</p>//LC:20939
     *//LC:20940
     * @param lhs  the left hand <code>double</code>//LC:20941
     * @param rhs  the right hand <code>double</code>//LC:20942
     * @return EqualsBuilder - used to chain calls.//LC:20943
     *///LC:20944
    public EqualsBuilder append(final double lhs, final double rhs) {//LC:20945
        if (isEquals == false) {//LC:20946
            return this;//LC:20947
        }//LC:20948
        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));//LC:20949
    }//LC:20950
//LC:20951
    /**//LC:20952
     * <p>Test if two <code>float</code>s are equal byt testing that the//LC:20953
     * pattern of bits returned by doubleToLong are equal.</p>//LC:20954
     *//LC:20955
     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>//LC:20956
     *//LC:20957
     * <p>It is compatible with the hash code generated by//LC:20958
     * <code>HashCodeBuilder</code>.</p>//LC:20959
     *//LC:20960
     * @param lhs  the left hand <code>float</code>//LC:20961
     * @param rhs  the right hand <code>float</code>//LC:20962
     * @return EqualsBuilder - used to chain calls.//LC:20963
     *///LC:20964
    public EqualsBuilder append(final float lhs, final float rhs) {//LC:20965
        if (isEquals == false) {//LC:20966
            return this;//LC:20967
        }//LC:20968
        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));//LC:20969
    }//LC:20970
//LC:20971
    /**//LC:20972
     * <p>Test if two <code>booleans</code>s are equal.</p>//LC:20973
     *//LC:20974
     * @param lhs  the left hand <code>boolean</code>//LC:20975
     * @param rhs  the right hand <code>boolean</code>//LC:20976
     * @return EqualsBuilder - used to chain calls.//LC:20977
     *///LC:20978
    public EqualsBuilder append(final boolean lhs, final boolean rhs) {//LC:20979
        if (isEquals == false) {//LC:20980
            return this;//LC:20981
        }//LC:20982
        isEquals = (lhs == rhs);//LC:20983
        return this;//LC:20984
    }//LC:20985
//LC:20986
    /**//LC:20987
     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>//LC:20988
     *//LC:20989
     * <p>This also will be called for the top level of//LC:20990
     * multi-dimensional, ragged, and multi-typed arrays.</p>//LC:20991
     *//LC:20992
     * @param lhs  the left hand <code>Object[]</code>//LC:20993
     * @param rhs  the right hand <code>Object[]</code>//LC:20994
     * @return EqualsBuilder - used to chain calls.//LC:20995
     *///LC:20996
    public EqualsBuilder append(final Object[] lhs, final Object[] rhs) {//LC:20997
        if (isEquals == false) {//LC:20998
            return this;//LC:20999
        }//LC:21000
        if (lhs == rhs) {//LC:21001
            return this;//LC:21002
        }//LC:21003
        if (lhs == null || rhs == null) {//LC:21004
            this.setEquals(false);//LC:21005
            return this;//LC:21006
        }//LC:21007
        if (lhs.length != rhs.length) {//LC:21008
            this.setEquals(false);//LC:21009
            return this;//LC:21010
        }//LC:21011
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21012
            append(lhs[i], rhs[i]);//LC:21013
        }//LC:21014
        return this;//LC:21015
    }//LC:21016
//LC:21017
    /**//LC:21018
     * <p>Deep comparison of array of <code>long</code>. Length and all//LC:21019
     * values are compared.</p>//LC:21020
     *//LC:21021
     * <p>The method {@link #append(long, long)} is used.</p>//LC:21022
     *//LC:21023
     * @param lhs  the left hand <code>long[]</code>//LC:21024
     * @param rhs  the right hand <code>long[]</code>//LC:21025
     * @return EqualsBuilder - used to chain calls.//LC:21026
     *///LC:21027
    public EqualsBuilder append(final long[] lhs, final long[] rhs) {//LC:21028
        if (isEquals == false) {//LC:21029
            return this;//LC:21030
        }//LC:21031
        if (lhs == rhs) {//LC:21032
            return this;//LC:21033
        }//LC:21034
        if (lhs == null || rhs == null) {//LC:21035
            this.setEquals(false);//LC:21036
            return this;//LC:21037
        }//LC:21038
        if (lhs.length != rhs.length) {//LC:21039
            this.setEquals(false);//LC:21040
            return this;//LC:21041
        }//LC:21042
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21043
            append(lhs[i], rhs[i]);//LC:21044
        }//LC:21045
        return this;//LC:21046
    }//LC:21047
//LC:21048
    /**//LC:21049
     * <p>Deep comparison of array of <code>int</code>. Length and all//LC:21050
     * values are compared.</p>//LC:21051
     *//LC:21052
     * <p>The method {@link #append(int, int)} is used.</p>//LC:21053
     *//LC:21054
     * @param lhs  the left hand <code>int[]</code>//LC:21055
     * @param rhs  the right hand <code>int[]</code>//LC:21056
     * @return EqualsBuilder - used to chain calls.//LC:21057
     *///LC:21058
    public EqualsBuilder append(final int[] lhs, final int[] rhs) {//LC:21059
        if (isEquals == false) {//LC:21060
            return this;//LC:21061
        }//LC:21062
        if (lhs == rhs) {//LC:21063
            return this;//LC:21064
        }//LC:21065
        if (lhs == null || rhs == null) {//LC:21066
            this.setEquals(false);//LC:21067
            return this;//LC:21068
        }//LC:21069
        if (lhs.length != rhs.length) {//LC:21070
            this.setEquals(false);//LC:21071
            return this;//LC:21072
        }//LC:21073
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21074
            append(lhs[i], rhs[i]);//LC:21075
        }//LC:21076
        return this;//LC:21077
    }//LC:21078
//LC:21079
    /**//LC:21080
     * <p>Deep comparison of array of <code>short</code>. Length and all//LC:21081
     * values are compared.</p>//LC:21082
     *//LC:21083
     * <p>The method {@link #append(short, short)} is used.</p>//LC:21084
     *//LC:21085
     * @param lhs  the left hand <code>short[]</code>//LC:21086
     * @param rhs  the right hand <code>short[]</code>//LC:21087
     * @return EqualsBuilder - used to chain calls.//LC:21088
     *///LC:21089
    public EqualsBuilder append(final short[] lhs, final short[] rhs) {//LC:21090
        if (isEquals == false) {//LC:21091
            return this;//LC:21092
        }//LC:21093
        if (lhs == rhs) {//LC:21094
            return this;//LC:21095
        }//LC:21096
        if (lhs == null || rhs == null) {//LC:21097
            this.setEquals(false);//LC:21098
            return this;//LC:21099
        }//LC:21100
        if (lhs.length != rhs.length) {//LC:21101
            this.setEquals(false);//LC:21102
            return this;//LC:21103
        }//LC:21104
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21105
            append(lhs[i], rhs[i]);//LC:21106
        }//LC:21107
        return this;//LC:21108
    }//LC:21109
//LC:21110
    /**//LC:21111
     * <p>Deep comparison of array of <code>char</code>. Length and all//LC:21112
     * values are compared.</p>//LC:21113
     *//LC:21114
     * <p>The method {@link #append(char, char)} is used.</p>//LC:21115
     *//LC:21116
     * @param lhs  the left hand <code>char[]</code>//LC:21117
     * @param rhs  the right hand <code>char[]</code>//LC:21118
     * @return EqualsBuilder - used to chain calls.//LC:21119
     *///LC:21120
    public EqualsBuilder append(final char[] lhs, final char[] rhs) {//LC:21121
        if (isEquals == false) {//LC:21122
            return this;//LC:21123
        }//LC:21124
        if (lhs == rhs) {//LC:21125
            return this;//LC:21126
        }//LC:21127
        if (lhs == null || rhs == null) {//LC:21128
            this.setEquals(false);//LC:21129
            return this;//LC:21130
        }//LC:21131
        if (lhs.length != rhs.length) {//LC:21132
            this.setEquals(false);//LC:21133
            return this;//LC:21134
        }//LC:21135
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21136
            append(lhs[i], rhs[i]);//LC:21137
        }//LC:21138
        return this;//LC:21139
    }//LC:21140
//LC:21141
    /**//LC:21142
     * <p>Deep comparison of array of <code>byte</code>. Length and all//LC:21143
     * values are compared.</p>//LC:21144
     *//LC:21145
     * <p>The method {@link #append(byte, byte)} is used.</p>//LC:21146
     *//LC:21147
     * @param lhs  the left hand <code>byte[]</code>//LC:21148
     * @param rhs  the right hand <code>byte[]</code>//LC:21149
     * @return EqualsBuilder - used to chain calls.//LC:21150
     *///LC:21151
    public EqualsBuilder append(final byte[] lhs, final byte[] rhs) {//LC:21152
        if (isEquals == false) {//LC:21153
            return this;//LC:21154
        }//LC:21155
        if (lhs == rhs) {//LC:21156
            return this;//LC:21157
        }//LC:21158
        if (lhs == null || rhs == null) {//LC:21159
            this.setEquals(false);//LC:21160
            return this;//LC:21161
        }//LC:21162
        if (lhs.length != rhs.length) {//LC:21163
            this.setEquals(false);//LC:21164
            return this;//LC:21165
        }//LC:21166
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21167
            append(lhs[i], rhs[i]);//LC:21168
        }//LC:21169
        return this;//LC:21170
    }//LC:21171
//LC:21172
    /**//LC:21173
     * <p>Deep comparison of array of <code>double</code>. Length and all//LC:21174
     * values are compared.</p>//LC:21175
     *//LC:21176
     * <p>The method {@link #append(double, double)} is used.</p>//LC:21177
     *//LC:21178
     * @param lhs  the left hand <code>double[]</code>//LC:21179
     * @param rhs  the right hand <code>double[]</code>//LC:21180
     * @return EqualsBuilder - used to chain calls.//LC:21181
     *///LC:21182
    public EqualsBuilder append(final double[] lhs, final double[] rhs) {//LC:21183
        if (isEquals == false) {//LC:21184
            return this;//LC:21185
        }//LC:21186
        if (lhs == rhs) {//LC:21187
            return this;//LC:21188
        }//LC:21189
        if (lhs == null || rhs == null) {//LC:21190
            this.setEquals(false);//LC:21191
            return this;//LC:21192
        }//LC:21193
        if (lhs.length != rhs.length) {//LC:21194
            this.setEquals(false);//LC:21195
            return this;//LC:21196
        }//LC:21197
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21198
            append(lhs[i], rhs[i]);//LC:21199
        }//LC:21200
        return this;//LC:21201
    }//LC:21202
//LC:21203
    /**//LC:21204
     * <p>Deep comparison of array of <code>float</code>. Length and all//LC:21205
     * values are compared.</p>//LC:21206
     *//LC:21207
     * <p>The method {@link #append(float, float)} is used.</p>//LC:21208
     *//LC:21209
     * @param lhs  the left hand <code>float[]</code>//LC:21210
     * @param rhs  the right hand <code>float[]</code>//LC:21211
     * @return EqualsBuilder - used to chain calls.//LC:21212
     *///LC:21213
    public EqualsBuilder append(final float[] lhs, final float[] rhs) {//LC:21214
        if (isEquals == false) {//LC:21215
            return this;//LC:21216
        }//LC:21217
        if (lhs == rhs) {//LC:21218
            return this;//LC:21219
        }//LC:21220
        if (lhs == null || rhs == null) {//LC:21221
            this.setEquals(false);//LC:21222
            return this;//LC:21223
        }//LC:21224
        if (lhs.length != rhs.length) {//LC:21225
            this.setEquals(false);//LC:21226
            return this;//LC:21227
        }//LC:21228
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21229
            append(lhs[i], rhs[i]);//LC:21230
        }//LC:21231
        return this;//LC:21232
    }//LC:21233
//LC:21234
    /**//LC:21235
     * <p>Deep comparison of array of <code>boolean</code>. Length and all//LC:21236
     * values are compared.</p>//LC:21237
     *//LC:21238
     * <p>The method {@link #append(boolean, boolean)} is used.</p>//LC:21239
     *//LC:21240
     * @param lhs  the left hand <code>boolean[]</code>//LC:21241
     * @param rhs  the right hand <code>boolean[]</code>//LC:21242
     * @return EqualsBuilder - used to chain calls.//LC:21243
     *///LC:21244
    public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {//LC:21245
        if (isEquals == false) {//LC:21246
            return this;//LC:21247
        }//LC:21248
        if (lhs == rhs) {//LC:21249
            return this;//LC:21250
        }//LC:21251
        if (lhs == null || rhs == null) {//LC:21252
            this.setEquals(false);//LC:21253
            return this;//LC:21254
        }//LC:21255
        if (lhs.length != rhs.length) {//LC:21256
            this.setEquals(false);//LC:21257
            return this;//LC:21258
        }//LC:21259
        for (int i = 0; i < lhs.length && isEquals; ++i) {//LC:21260
            append(lhs[i], rhs[i]);//LC:21261
        }//LC:21262
        return this;//LC:21263
    }//LC:21264
//LC:21265
    /**//LC:21266
     * <p>Returns <code>true</code> if the fields that have been checked//LC:21267
     * are all equal.</p>//LC:21268
     *//LC:21269
     * @return boolean//LC:21270
     *///LC:21271
    public boolean isEquals() {//LC:21272
        return this.isEquals;//LC:21273
    }//LC:21274
//LC:21275
    /**//LC:21276
     * <p>Returns <code>true</code> if the fields that have been checked//LC:21277
     * are all equal.</p>//LC:21278
     *//LC:21279
     * @return <code>true</code> if all of the fields that have been checked//LC:21280
     *         are equal, <code>false</code> otherwise.//LC:21281
     *//LC:21282
     * @since 3.0//LC:21283
     *///LC:21284
    @Override//LC:21285
    public Boolean build() {//LC:21286
        return Boolean.valueOf(isEquals());//LC:21287
    }//LC:21288
//LC:21289
    /**//LC:21290
     * Sets the <code>isEquals</code> value.//LC:21291
     *//LC:21292
     * @param isEquals The value to set.//LC:21293
     * @since 2.1//LC:21294
     *///LC:21295
    protected void setEquals(final boolean isEquals) {//LC:21296
        this.isEquals = isEquals;//LC:21297
    }//LC:21298
//LC:21299
    /**//LC:21300
     * Reset the EqualsBuilder so you can use the same object again//LC:21301
     * @since 2.5//LC:21302
     *///LC:21303
    public void reset() {//LC:21304
        this.isEquals = true;//LC:21305
    }//LC:21306
}//LC:21307
//LC:21308
//LC:21309
/**//LC:21310
 * A mutable <code>int</code> wrapper.//LC:21311
 * <p>//LC:21312
 * Note that as MutableInt does not extend Integer, it is not treated by String.format as an Integer parameter.//LC:21313
 *//LC:21314
 * @see Integer//LC:21315
 * @since 2.1//LC:21316
 * @version $Id$//LC:21317
 *///LC:21318
class MutableInt extends Number implements Comparable<MutableInt>, Mutable<Number> {//LC:21319
//LC:21320
    /**//LC:21321
     * Required for serialization support.//LC:21322
     *//LC:21323
     * @see java.io.Serializable//LC:21324
     *///LC:21325
    private static final long serialVersionUID = 512176391864L;//LC:21326
//LC:21327
    /** The mutable value. *///LC:21328
    private int value;//LC:21329
//LC:21330
    /**//LC:21331
     * Constructs a new MutableInt with the default value of zero.//LC:21332
     *///LC:21333
    public MutableInt() {//LC:21334
        super();//LC:21335
    }//LC:21336
//LC:21337
    /**//LC:21338
     * Constructs a new MutableInt with the specified value.//LC:21339
     *//LC:21340
     * @param value  the initial value to store//LC:21341
     *///LC:21342
    public MutableInt(final int value) {//LC:21343
        super();//LC:21344
        this.value = value;//LC:21345
    }//LC:21346
//LC:21347
    /**//LC:21348
     * Constructs a new MutableInt with the specified value.//LC:21349
     *//LC:21350
     * @param value  the initial value to store, not null//LC:21351
     * @throws NullPointerException if the object is null//LC:21352
     *///LC:21353
    public MutableInt(final Number value) {//LC:21354
        super();//LC:21355
        this.value = value.intValue();//LC:21356
    }//LC:21357
//LC:21358
    /**//LC:21359
     * Constructs a new MutableInt parsing the given string.//LC:21360
     *//LC:21361
     * @param value  the string to parse, not null//LC:21362
     * @throws NumberFormatException if the string cannot be parsed into an int//LC:21363
     * @since 2.5//LC:21364
     *///LC:21365
    public MutableInt(final String value) throws NumberFormatException {//LC:21366
        super();//LC:21367
        this.value = Integer.parseInt(value);//LC:21368
    }//LC:21369
//LC:21370
    //-----------------------------------------------------------------------//LC:21371
    /**//LC:21372
     * Gets the value as a Integer instance.//LC:21373
     *//LC:21374
     * @return the value as a Integer, never null//LC:21375
     *///LC:21376
    @Override//LC:21377
    public Integer getValue() {//LC:21378
        return Integer.valueOf(this.value);//LC:21379
    }//LC:21380
//LC:21381
    /**//LC:21382
     * Sets the value.//LC:21383
     *//LC:21384
     * @param value  the value to set//LC:21385
     *///LC:21386
    public void setValue(final int value) {//LC:21387
        this.value = value;//LC:21388
    }//LC:21389
//LC:21390
    /**//LC:21391
     * Sets the value from any Number instance.//LC:21392
     *//LC:21393
     * @param value  the value to set, not null//LC:21394
     * @throws NullPointerException if the object is null//LC:21395
     *///LC:21396
    @Override//LC:21397
    public void setValue(final Number value) {//LC:21398
        this.value = value.intValue();//LC:21399
    }//LC:21400
//LC:21401
    //-----------------------------------------------------------------------//LC:21402
    /**//LC:21403
     * Increments the value.//LC:21404
     *//LC:21405
     * @since Commons Lang 2.2//LC:21406
     *///LC:21407
    public void increment() {//LC:21408
        value++;//LC:21409
    }//LC:21410
//LC:21411
    /**//LC:21412
     * Decrements the value.//LC:21413
     *//LC:21414
     * @since Commons Lang 2.2//LC:21415
     *///LC:21416
    public void decrement() {//LC:21417
        value--;//LC:21418
    }//LC:21419
//LC:21420
    //-----------------------------------------------------------------------//LC:21421
    /**//LC:21422
     * Adds a value to the value of this instance.//LC:21423
     *//LC:21424
     * @param operand  the value to add, not null//LC:21425
     * @since Commons Lang 2.2//LC:21426
     *///LC:21427
    public void add(final int operand) {//LC:21428
        this.value += operand;//LC:21429
    }//LC:21430
//LC:21431
    /**//LC:21432
     * Adds a value to the value of this instance.//LC:21433
     *//LC:21434
     * @param operand  the value to add, not null//LC:21435
     * @throws NullPointerException if the object is null//LC:21436
     * @since Commons Lang 2.2//LC:21437
     *///LC:21438
    public void add(final Number operand) {//LC:21439
        this.value += operand.intValue();//LC:21440
    }//LC:21441
//LC:21442
    /**//LC:21443
     * Subtracts a value from the value of this instance.//LC:21444
     *//LC:21445
     * @param operand  the value to subtract, not null//LC:21446
     * @since Commons Lang 2.2//LC:21447
     *///LC:21448
    public void subtract(final int operand) {//LC:21449
        this.value -= operand;//LC:21450
    }//LC:21451
//LC:21452
    /**//LC:21453
     * Subtracts a value from the value of this instance.//LC:21454
     *//LC:21455
     * @param operand  the value to subtract, not null//LC:21456
     * @throws NullPointerException if the object is null//LC:21457
     * @since Commons Lang 2.2//LC:21458
     *///LC:21459
    public void subtract(final Number operand) {//LC:21460
        this.value -= operand.intValue();//LC:21461
    }//LC:21462
//LC:21463
    //-----------------------------------------------------------------------//LC:21464
    // shortValue and byteValue rely on Number implementation//LC:21465
    /**//LC:21466
     * Returns the value of this MutableInt as an int.//LC:21467
     *//LC:21468
     * @return the numeric value represented by this object after conversion to type int.//LC:21469
     *///LC:21470
    @Override//LC:21471
    public int intValue() {//LC:21472
        return value;//LC:21473
    }//LC:21474
//LC:21475
    /**//LC:21476
     * Returns the value of this MutableInt as a long.//LC:21477
     *//LC:21478
     * @return the numeric value represented by this object after conversion to type long.//LC:21479
     *///LC:21480
    @Override//LC:21481
    public long longValue() {//LC:21482
        return value;//LC:21483
    }//LC:21484
//LC:21485
    /**//LC:21486
     * Returns the value of this MutableInt as a float.//LC:21487
     *//LC:21488
     * @return the numeric value represented by this object after conversion to type float.//LC:21489
     *///LC:21490
    @Override//LC:21491
    public float floatValue() {//LC:21492
        return value;//LC:21493
    }//LC:21494
//LC:21495
    /**//LC:21496
     * Returns the value of this MutableInt as a double.//LC:21497
     *//LC:21498
     * @return the numeric value represented by this object after conversion to type double.//LC:21499
     *///LC:21500
    @Override//LC:21501
    public double doubleValue() {//LC:21502
        return value;//LC:21503
    }//LC:21504
//LC:21505
    //-----------------------------------------------------------------------//LC:21506
    /**//LC:21507
     * Gets this mutable as an instance of Integer.//LC:21508
     *//LC:21509
     * @return a Integer instance containing the value from this mutable, never null//LC:21510
     *///LC:21511
    public Integer toInteger() {//LC:21512
        return Integer.valueOf(intValue());//LC:21513
    }//LC:21514
//LC:21515
    //-----------------------------------------------------------------------//LC:21516
    /**//LC:21517
     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is//LC:21518
     * not <code>null</code> and is a <code>MutableInt</code> object that contains the same <code>int</code> value//LC:21519
     * as this object.//LC:21520
     *//LC:21521
     * @param obj  the object to compare with, null returns false//LC:21522
     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.//LC:21523
     *///LC:21524
    @Override//LC:21525
    public boolean equals(final Object obj) {//LC:21526
        if (obj instanceof MutableInt) {//LC:21527
            return value == ((MutableInt) obj).intValue();//LC:21528
        }//LC:21529
        return false;//LC:21530
    }//LC:21531
//LC:21532
    /**//LC:21533
     * Returns a suitable hash code for this mutable.//LC:21534
     *//LC:21535
     * @return a suitable hash code//LC:21536
     *///LC:21537
    @Override//LC:21538
    public int hashCode() {//LC:21539
        return value;//LC:21540
    }//LC:21541
//LC:21542
    //-----------------------------------------------------------------------//LC:21543
    /**//LC:21544
     * Compares this mutable to another in ascending order.//LC:21545
     *//LC:21546
     * @param other  the other mutable to compare to, not null//LC:21547
     * @return negative if this is less, zero if equal, positive if greater//LC:21548
     *///LC:21549
    @Override//LC:21550
    public int compareTo(final MutableInt other) {//LC:21551
        final int anotherVal = other.value;//LC:21552
        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);//LC:21553
    }//LC:21554
//LC:21555
    //-----------------------------------------------------------------------//LC:21556
    /**//LC:21557
     * Returns the String value of this mutable.//LC:21558
     *//LC:21559
     * @return the mutable value as a string//LC:21560
     *///LC:21561
    @Override//LC:21562
    public String toString() {//LC:21563
        return String.valueOf(value);//LC:21564
    }//LC:21565
//LC:21566
}//LC:21567
//LC:21568
//LC:21569
/**//LC:21570
 * Builds a string from constituent parts providing a more flexible and powerful API//LC:21571
 * than StringBuffer.//LC:21572
 * <p>//LC:21573
 * The main differences from StringBuffer/StringBuilder are://LC:21574
 * <ul>//LC:21575
 * <li>Not synchronized</li>//LC:21576
 * <li>Not final</li>//LC:21577
 * <li>Subclasses have direct access to character array</li>//LC:21578
 * <li>Additional methods//LC:21579
 *  <ul>//LC:21580
 *   <li>appendWithSeparators - adds an array of values, with a separator</li>//LC:21581
 *   <li>appendPadding - adds a length padding characters</li>//LC:21582
 *   <li>appendFixedLength - adds a fixed width field to the builder</li>//LC:21583
 *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>//LC:21584
 *   <li>delete - delete char or string</li>//LC:21585
 *   <li>replace - search and replace for a char or string</li>//LC:21586
 *   <li>leftString/rightString/midString - substring without exceptions</li>//LC:21587
 *   <li>contains - whether the builder contains a char or string</li>//LC:21588
 *   <li>size/clear/isEmpty - collections style API methods</li>//LC:21589
 *  </ul>//LC:21590
 * </li>//LC:21591
 * </ul>//LC:21592
 * <li>Views//LC:21593
 *  <ul>//LC:21594
 *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>//LC:21595
 *   <li>asReader - uses the internal buffer as the source of a Reader</li>//LC:21596
 *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>//LC:21597
 *  </ul>//LC:21598
 * </li>//LC:21599
 * </ul>//LC:21600
 * <p>//LC:21601
 * The aim has been to provide an API that mimics very closely what StringBuffer//LC:21602
 * provides, but with additional methods. It should be noted that some edge cases,//LC:21603
 * with invalid indices or null input, have been altered - see individual methods.//LC:21604
 * The biggest of these changes is that by default, null will not output the text//LC:21605
 * 'null'. This can be controlled by a property, {@link #setNullText(String)}.//LC:21606
 * <p>//LC:21607
 * Prior to 3.0, this class implemented Cloneable but did not implement the//LC:21608
 * clone method so could not be used. From 3.0 onwards it no longer implements//LC:21609
 * the interface.//LC:21610
 *//LC:21611
 * @since 2.2//LC:21612
 * @version $Id$//LC:21613
 *///LC:21614
class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {//LC:21615
//LC:21616
    /**//LC:21617
     * The extra capacity for new builders.//LC:21618
     *///LC:21619
    static final int CAPACITY = 32;//LC:21620
//LC:21621
    /**//LC:21622
     * Required for serialization support.//LC:21623
     *//LC:21624
     * @see java.io.Serializable//LC:21625
     *///LC:21626
    private static final long serialVersionUID = 7628716375283629643L;//LC:21627
//LC:21628
    /** Internal data storage. *///LC:21629
    protected char[] buffer; // TODO make private?//LC:21630
    /** Current size of the buffer. *///LC:21631
    protected int size; // TODO make private?//LC:21632
    /** The new line. *///LC:21633
    private String newLine;//LC:21634
    /** The null text. *///LC:21635
    private String nullText;//LC:21636
//LC:21637
    //-----------------------------------------------------------------------//LC:21638
    /**//LC:21639
     * Constructor that creates an empty builder initial capacity 32 characters.//LC:21640
     *///LC:21641
    public StrBuilder() {//LC:21642
        this(CAPACITY);//LC:21643
    }//LC:21644
//LC:21645
    /**//LC:21646
     * Constructor that creates an empty builder the specified initial capacity.//LC:21647
     *//LC:21648
     * @param initialCapacity  the initial capacity, zero or less will be converted to 32//LC:21649
     *///LC:21650
    public StrBuilder(int initialCapacity) {//LC:21651
        super();//LC:21652
        if (initialCapacity <= 0) {//LC:21653
            initialCapacity = CAPACITY;//LC:21654
        }//LC:21655
        buffer = new char[initialCapacity];//LC:21656
    }//LC:21657
//LC:21658
    /**//LC:21659
     * Constructor that creates a builder from the string, allocating//LC:21660
     * 32 extra characters for growth.//LC:21661
     *//LC:21662
     * @param str  the string to copy, null treated as blank string//LC:21663
     *///LC:21664
    public StrBuilder(final String str) {//LC:21665
        super();//LC:21666
        if (str == null) {//LC:21667
            buffer = new char[CAPACITY];//LC:21668
        } else {//LC:21669
            buffer = new char[str.length() + CAPACITY];//LC:21670
            append(str);//LC:21671
        }//LC:21672
    }//LC:21673
//LC:21674
    //-----------------------------------------------------------------------//LC:21675
    /**//LC:21676
     * Gets the text to be appended when a new line is added.//LC:21677
     *//LC:21678
     * @return the new line text, null means use system default//LC:21679
     *///LC:21680
    public String getNewLineText() {//LC:21681
        return newLine;//LC:21682
    }//LC:21683
//LC:21684
    /**//LC:21685
     * Sets the text to be appended when a new line is added.//LC:21686
     *//LC:21687
     * @param newLine  the new line text, null means use system default//LC:21688
     * @return this, to enable chaining//LC:21689
     *///LC:21690
    public StrBuilder setNewLineText(final String newLine) {//LC:21691
        this.newLine = newLine;//LC:21692
        return this;//LC:21693
    }//LC:21694
//LC:21695
    //-----------------------------------------------------------------------//LC:21696
    /**//LC:21697
     * Gets the text to be appended when null is added.//LC:21698
     *//LC:21699
     * @return the null text, null means no append//LC:21700
     *///LC:21701
    public String getNullText() {//LC:21702
        return nullText;//LC:21703
    }//LC:21704
//LC:21705
    /**//LC:21706
     * Sets the text to be appended when null is added.//LC:21707
     *//LC:21708
     * @param nullText  the null text, null means no append//LC:21709
     * @return this, to enable chaining//LC:21710
     *///LC:21711
    public StrBuilder setNullText(String nullText) {//LC:21712
        if (nullText != null && nullText.isEmpty()) {//LC:21713
            nullText = null;//LC:21714
        }//LC:21715
        this.nullText = nullText;//LC:21716
        return this;//LC:21717
    }//LC:21718
//LC:21719
    //-----------------------------------------------------------------------//LC:21720
    /**//LC:21721
     * Gets the length of the string builder.//LC:21722
     *//LC:21723
     * @return the length//LC:21724
     *///LC:21725
    @Override//LC:21726
    public int length() {//LC:21727
        return size;//LC:21728
    }//LC:21729
//LC:21730
    /**//LC:21731
     * Updates the length of the builder by either dropping the last characters//LC:21732
     * or adding filler of Unicode zero.//LC:21733
     *//LC:21734
     * @param length  the length to set to, must be zero or positive//LC:21735
     * @return this, to enable chaining//LC:21736
     * @throws IndexOutOfBoundsException if the length is negative//LC:21737
     *///LC:21738
    public StrBuilder setLength(final int length) {//LC:21739
        if (length < 0) {//LC:21740
            throw new StringIndexOutOfBoundsException(length);//LC:21741
        }//LC:21742
        if (length < size) {//LC:21743
            size = length;//LC:21744
        } else if (length > size) {//LC:21745
            ensureCapacity(length);//LC:21746
            final int oldEnd = size;//LC:21747
            final int newEnd = length;//LC:21748
            size = length;//LC:21749
            for (int i = oldEnd; i < newEnd; i++) {//LC:21750
                buffer[i] = '\0';//LC:21751
            }//LC:21752
        }//LC:21753
        return this;//LC:21754
    }//LC:21755
//LC:21756
    //-----------------------------------------------------------------------//LC:21757
    /**//LC:21758
     * Gets the current size of the internal character array buffer.//LC:21759
     *//LC:21760
     * @return the capacity//LC:21761
     *///LC:21762
    public int capacity() {//LC:21763
        return buffer.length;//LC:21764
    }//LC:21765
//LC:21766
    /**//LC:21767
     * Checks the capacity and ensures that it is at least the size specified.//LC:21768
     *//LC:21769
     * @param capacity  the capacity to ensure//LC:21770
     * @return this, to enable chaining//LC:21771
     *///LC:21772
    public StrBuilder ensureCapacity(final int capacity) {//LC:21773
        if (capacity > buffer.length) {//LC:21774
            final char[] old = buffer;//LC:21775
            buffer = new char[capacity * 2];//LC:21776
            System.arraycopy(old, 0, buffer, 0, size);//LC:21777
        }//LC:21778
        return this;//LC:21779
    }//LC:21780
//LC:21781
    /**//LC:21782
     * Minimizes the capacity to the actual length of the string.//LC:21783
     *//LC:21784
     * @return this, to enable chaining//LC:21785
     *///LC:21786
    public StrBuilder minimizeCapacity() {//LC:21787
        if (buffer.length > length()) {//LC:21788
            final char[] old = buffer;//LC:21789
            buffer = new char[length()];//LC:21790
            System.arraycopy(old, 0, buffer, 0, size);//LC:21791
        }//LC:21792
        return this;//LC:21793
    }//LC:21794
//LC:21795
    //-----------------------------------------------------------------------//LC:21796
    /**//LC:21797
     * Gets the length of the string builder.//LC:21798
     * <p>//LC:21799
     * This method is the same as {@link #length()} and is provided to match the//LC:21800
     * API of Collections.//LC:21801
     *//LC:21802
     * @return the length//LC:21803
     *///LC:21804
    public int size() {//LC:21805
        return size;//LC:21806
    }//LC:21807
//LC:21808
    /**//LC:21809
     * Checks is the string builder is empty (convenience Collections API style method).//LC:21810
     * <p>//LC:21811
     * This method is the same as checking {@link #length()} and is provided to match the//LC:21812
     * API of Collections.//LC:21813
     *//LC:21814
     * @return <code>true</code> if the size is <code>0</code>.//LC:21815
     *///LC:21816
    public boolean isEmpty() {//LC:21817
        return size == 0;//LC:21818
    }//LC:21819
//LC:21820
    /**//LC:21821
     * Clears the string builder (convenience Collections API style method).//LC:21822
     * <p>//LC:21823
     * This method does not reduce the size of the internal character buffer.//LC:21824
     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.//LC:21825
     * <p>//LC:21826
     * This method is the same as {@link #setLength(int)} called with zero//LC:21827
     * and is provided to match the API of Collections.//LC:21828
     *//LC:21829
     * @return this, to enable chaining//LC:21830
     *///LC:21831
    public StrBuilder clear() {//LC:21832
        size = 0;//LC:21833
        return this;//LC:21834
    }//LC:21835
//LC:21836
    //-----------------------------------------------------------------------//LC:21837
    /**//LC:21838
     * Gets the character at the specified index.//LC:21839
     *//LC:21840
     * @see #setCharAt(int, char)//LC:21841
     * @see #deleteCharAt(int)//LC:21842
     * @param index  the index to retrieve, must be valid//LC:21843
     * @return the character at the index//LC:21844
     * @throws IndexOutOfBoundsException if the index is invalid//LC:21845
     *///LC:21846
    @Override//LC:21847
    public char charAt(final int index) {//LC:21848
        if (index < 0 || index >= length()) {//LC:21849
            throw new StringIndexOutOfBoundsException(index);//LC:21850
        }//LC:21851
        return buffer[index];//LC:21852
    }//LC:21853
//LC:21854
    /**//LC:21855
     * Sets the character at the specified index.//LC:21856
     *//LC:21857
     * @see #charAt(int)//LC:21858
     * @see #deleteCharAt(int)//LC:21859
     * @param index  the index to set//LC:21860
     * @param ch  the new character//LC:21861
     * @return this, to enable chaining//LC:21862
     * @throws IndexOutOfBoundsException if the index is invalid//LC:21863
     *///LC:21864
    public StrBuilder setCharAt(final int index, final char ch) {//LC:21865
        if (index < 0 || index >= length()) {//LC:21866
            throw new StringIndexOutOfBoundsException(index);//LC:21867
        }//LC:21868
        buffer[index] = ch;//LC:21869
        return this;//LC:21870
    }//LC:21871
//LC:21872
    /**//LC:21873
     * Deletes the character at the specified index.//LC:21874
     *//LC:21875
     * @see #charAt(int)//LC:21876
     * @see #setCharAt(int, char)//LC:21877
     * @param index  the index to delete//LC:21878
     * @return this, to enable chaining//LC:21879
     * @throws IndexOutOfBoundsException if the index is invalid//LC:21880
     *///LC:21881
    public StrBuilder deleteCharAt(final int index) {//LC:21882
        if (index < 0 || index >= size) {//LC:21883
            throw new StringIndexOutOfBoundsException(index);//LC:21884
        }//LC:21885
        deleteImpl(index, index + 1, 1);//LC:21886
        return this;//LC:21887
    }//LC:21888
//LC:21889
    //-----------------------------------------------------------------------//LC:21890
    /**//LC:21891
     * Copies the builder's character array into a new character array.//LC:21892
     *//LC:21893
     * @return a new array that represents the contents of the builder//LC:21894
     *///LC:21895
    public char[] toCharArray() {//LC:21896
        if (size == 0) {//LC:21897
            return ArrayUtils.EMPTY_CHAR_ARRAY;//LC:21898
        }//LC:21899
        final char chars[] = new char[size];//LC:21900
        System.arraycopy(buffer, 0, chars, 0, size);//LC:21901
        return chars;//LC:21902
    }//LC:21903
//LC:21904
    /**//LC:21905
     * Copies part of the builder's character array into a new character array.//LC:21906
     *//LC:21907
     * @param startIndex  the start index, inclusive, must be valid//LC:21908
     * @param endIndex  the end index, exclusive, must be valid except that//LC:21909
     *  if too large it is treated as end of string//LC:21910
     * @return a new array that holds part of the contents of the builder//LC:21911
     * @throws IndexOutOfBoundsException if startIndex is invalid,//LC:21912
     *  or if endIndex is invalid (but endIndex greater than size is valid)//LC:21913
     *///LC:21914
    public char[] toCharArray(final int startIndex, int endIndex) {//LC:21915
        endIndex = validateRange(startIndex, endIndex);//LC:21916
        final int len = endIndex - startIndex;//LC:21917
        if (len == 0) {//LC:21918
            return ArrayUtils.EMPTY_CHAR_ARRAY;//LC:21919
        }//LC:21920
        final char chars[] = new char[len];//LC:21921
        System.arraycopy(buffer, startIndex, chars, 0, len);//LC:21922
        return chars;//LC:21923
    }//LC:21924
//LC:21925
    /**//LC:21926
     * Copies the character array into the specified array.//LC:21927
     *//LC:21928
     * @param destination  the destination array, null will cause an array to be created//LC:21929
     * @return the input array, unless that was null or too small//LC:21930
     *///LC:21931
    public char[] getChars(char[] destination) {//LC:21932
        final int len = length();//LC:21933
        if (destination == null || destination.length < len) {//LC:21934
            destination = new char[len];//LC:21935
        }//LC:21936
        System.arraycopy(buffer, 0, destination, 0, len);//LC:21937
        return destination;//LC:21938
    }//LC:21939
//LC:21940
    /**//LC:21941
     * Copies the character array into the specified array.//LC:21942
     *//LC:21943
     * @param startIndex  first index to copy, inclusive, must be valid//LC:21944
     * @param endIndex  last index, exclusive, must be valid//LC:21945
     * @param destination  the destination array, must not be null or too small//LC:21946
     * @param destinationIndex  the index to start copying in destination//LC:21947
     * @throws NullPointerException if the array is null//LC:21948
     * @throws IndexOutOfBoundsException if any index is invalid//LC:21949
     *///LC:21950
    public void getChars(final int startIndex, final int endIndex, final char destination[], final int destinationIndex) {//LC:21951
        if (startIndex < 0) {//LC:21952
            throw new StringIndexOutOfBoundsException(startIndex);//LC:21953
        }//LC:21954
        if (endIndex < 0 || endIndex > length()) {//LC:21955
            throw new StringIndexOutOfBoundsException(endIndex);//LC:21956
        }//LC:21957
        if (startIndex > endIndex) {//LC:21958
            throw new StringIndexOutOfBoundsException("end < start");//LC:21959
        }//LC:21960
        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);//LC:21961
    }//LC:21962
//LC:21963
    //-----------------------------------------------------------------------//LC:21964
    /**//LC:21965
     * Appends the new line string to this string builder.//LC:21966
     * <p>//LC:21967
     * The new line string can be altered using {@link #setNewLineText(String)}.//LC:21968
     * This might be used to force the output to always use Unix line endings//LC:21969
     * even when on Windows.//LC:21970
     *//LC:21971
     * @return this, to enable chaining//LC:21972
     *///LC:21973
    public StrBuilder appendNewLine() {//LC:21974
        if (newLine == null)  {//LC:21975
            append(SystemUtils.LINE_SEPARATOR);//LC:21976
            return this;//LC:21977
        }//LC:21978
        return append(newLine);//LC:21979
    }//LC:21980
//LC:21981
    /**//LC:21982
     * Appends the text representing <code>null</code> to this string builder.//LC:21983
     *//LC:21984
     * @return this, to enable chaining//LC:21985
     *///LC:21986
    public StrBuilder appendNull() {//LC:21987
        if (nullText == null)  {//LC:21988
            return this;//LC:21989
        }//LC:21990
        return append(nullText);//LC:21991
    }//LC:21992
//LC:21993
    /**//LC:21994
     * Appends an object to this string builder.//LC:21995
     * Appending null will call {@link #appendNull()}.//LC:21996
     *//LC:21997
     * @param obj  the object to append//LC:21998
     * @return this, to enable chaining//LC:21999
     *///LC:22000
    public StrBuilder append(final Object obj) {//LC:22001
        if (obj == null) {//LC:22002
            return appendNull();//LC:22003
        }//LC:22004
        return append(obj.toString());//LC:22005
    }//LC:22006
//LC:22007
    /**//LC:22008
     * Appends a CharSequence to this string builder.//LC:22009
     * Appending null will call {@link #appendNull()}.//LC:22010
     *//LC:22011
     * @param seq  the CharSequence to append//LC:22012
     * @return this, to enable chaining//LC:22013
     * @since 3.0//LC:22014
     *///LC:22015
    @Override//LC:22016
    public StrBuilder append(final CharSequence seq) {//LC:22017
        if (seq == null) {//LC:22018
            return appendNull();//LC:22019
        }//LC:22020
        return append(seq.toString());//LC:22021
    }//LC:22022
//LC:22023
    /**//LC:22024
     * Appends part of a CharSequence to this string builder.//LC:22025
     * Appending null will call {@link #appendNull()}.//LC:22026
     *//LC:22027
     * @param seq  the CharSequence to append//LC:22028
     * @param startIndex  the start index, inclusive, must be valid//LC:22029
     * @param length  the length to append, must be valid//LC:22030
     * @return this, to enable chaining//LC:22031
     * @since 3.0//LC:22032
     *///LC:22033
    @Override//LC:22034
    public StrBuilder append(final CharSequence seq, final int startIndex, final int length) {//LC:22035
        if (seq == null) {//LC:22036
            return appendNull();//LC:22037
        }//LC:22038
        return append(seq.toString(), startIndex, length);//LC:22039
    }//LC:22040
//LC:22041
    /**//LC:22042
     * Appends a string to this string builder.//LC:22043
     * Appending null will call {@link #appendNull()}.//LC:22044
     *//LC:22045
     * @param str  the string to append//LC:22046
     * @return this, to enable chaining//LC:22047
     *///LC:22048
    public StrBuilder append(final String str) {//LC:22049
        if (str == null) {//LC:22050
            return appendNull();//LC:22051
        }//LC:22052
        final int strLen = str.length();//LC:22053
        if (strLen > 0) {//LC:22054
            final int len = length();//LC:22055
            ensureCapacity(len + strLen);//LC:22056
            str.getChars(0, strLen, buffer, len);//LC:22057
            size += strLen;//LC:22058
        }//LC:22059
        return this;//LC:22060
    }//LC:22061
//LC:22062
//LC:22063
    /**//LC:22064
     * Appends part of a string to this string builder.//LC:22065
     * Appending null will call {@link #appendNull()}.//LC:22066
     *//LC:22067
     * @param str  the string to append//LC:22068
     * @param startIndex  the start index, inclusive, must be valid//LC:22069
     * @param length  the length to append, must be valid//LC:22070
     * @return this, to enable chaining//LC:22071
     *///LC:22072
    public StrBuilder append(final String str, final int startIndex, final int length) {//LC:22073
        if (str == null) {//LC:22074
            return appendNull();//LC:22075
        }//LC:22076
        if (startIndex < 0 || startIndex > str.length()) {//LC:22077
            throw new StringIndexOutOfBoundsException("startIndex must be valid");//LC:22078
        }//LC:22079
        if (length < 0 || (startIndex + length) > str.length()) {//LC:22080
            throw new StringIndexOutOfBoundsException("length must be valid");//LC:22081
        }//LC:22082
        if (length > 0) {//LC:22083
            final int len = length();//LC:22084
            ensureCapacity(len + length);//LC:22085
            str.getChars(startIndex, startIndex + length, buffer, len);//LC:22086
            size += length;//LC:22087
        }//LC:22088
        return this;//LC:22089
    }//LC:22090
//LC:22091
    /**//LC:22092
     * Calls {@link String#format(String, Object...)} and appends the result.//LC:22093
     *//LC:22094
     * @param format the format string//LC:22095
     * @param objs the objects to use in the format string//LC:22096
     * @return {@code this} to enable chaining//LC:22097
     * @see String#format(String, Object...)//LC:22098
     * @since 3.2//LC:22099
     *///LC:22100
    public StrBuilder append(final String format, final Object... objs) {//LC:22101
        return append(String.format(format, objs));//LC:22102
    }//LC:22103
//LC:22104
    /**//LC:22105
     * Appends a string buffer to this string builder.//LC:22106
     * Appending null will call {@link #appendNull()}.//LC:22107
     *//LC:22108
     * @param str  the string buffer to append//LC:22109
     * @return this, to enable chaining//LC:22110
     *///LC:22111
    public StrBuilder append(final StringBuffer str) {//LC:22112
        if (str == null) {//LC:22113
            return appendNull();//LC:22114
        }//LC:22115
        final int strLen = str.length();//LC:22116
        if (strLen > 0) {//LC:22117
            final int len = length();//LC:22118
            ensureCapacity(len + strLen);//LC:22119
            str.getChars(0, strLen, buffer, len);//LC:22120
            size += strLen;//LC:22121
        }//LC:22122
        return this;//LC:22123
    }//LC:22124
//LC:22125
    /**//LC:22126
     * Appends part of a string buffer to this string builder.//LC:22127
     * Appending null will call {@link #appendNull()}.//LC:22128
     *//LC:22129
     * @param str  the string to append//LC:22130
     * @param startIndex  the start index, inclusive, must be valid//LC:22131
     * @param length  the length to append, must be valid//LC:22132
     * @return this, to enable chaining//LC:22133
     *///LC:22134
    public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {//LC:22135
        if (str == null) {//LC:22136
            return appendNull();//LC:22137
        }//LC:22138
        if (startIndex < 0 || startIndex > str.length()) {//LC:22139
            throw new StringIndexOutOfBoundsException("startIndex must be valid");//LC:22140
        }//LC:22141
        if (length < 0 || (startIndex + length) > str.length()) {//LC:22142
            throw new StringIndexOutOfBoundsException("length must be valid");//LC:22143
        }//LC:22144
        if (length > 0) {//LC:22145
            final int len = length();//LC:22146
            ensureCapacity(len + length);//LC:22147
            str.getChars(startIndex, startIndex + length, buffer, len);//LC:22148
            size += length;//LC:22149
        }//LC:22150
        return this;//LC:22151
    }//LC:22152
//LC:22153
    /**//LC:22154
     * Appends a StringBuilder to this string builder.//LC:22155
     * Appending null will call {@link #appendNull()}.//LC:22156
     *//LC:22157
     * @param str the StringBuilder to append//LC:22158
     * @return this, to enable chaining//LC:22159
     * @since 3.2//LC:22160
     *///LC:22161
    public StrBuilder append(final StringBuilder str) {//LC:22162
        if (str == null) {//LC:22163
            return appendNull();//LC:22164
        }//LC:22165
        final int strLen = str.length();//LC:22166
        if (strLen > 0) {//LC:22167
            final int len = length();//LC:22168
            ensureCapacity(len + strLen);//LC:22169
            str.getChars(0, strLen, buffer, len);//LC:22170
            size += strLen;//LC:22171
        }//LC:22172
        return this;//LC:22173
    }//LC:22174
//LC:22175
    /**//LC:22176
     * Appends part of a StringBuilder to this string builder.//LC:22177
     * Appending null will call {@link #appendNull()}.//LC:22178
     *//LC:22179
     * @param str the StringBuilder to append//LC:22180
     * @param startIndex the start index, inclusive, must be valid//LC:22181
     * @param length the length to append, must be valid//LC:22182
     * @return this, to enable chaining//LC:22183
     * @since 3.2//LC:22184
     *///LC:22185
    public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {//LC:22186
        if (str == null) {//LC:22187
            return appendNull();//LC:22188
        }//LC:22189
        if (startIndex < 0 || startIndex > str.length()) {//LC:22190
            throw new StringIndexOutOfBoundsException("startIndex must be valid");//LC:22191
        }//LC:22192
        if (length < 0 || (startIndex + length) > str.length()) {//LC:22193
            throw new StringIndexOutOfBoundsException("length must be valid");//LC:22194
        }//LC:22195
        if (length > 0) {//LC:22196
            final int len = length();//LC:22197
            ensureCapacity(len + length);//LC:22198
            str.getChars(startIndex, startIndex + length, buffer, len);//LC:22199
            size += length;//LC:22200
        }//LC:22201
        return this;//LC:22202
    }//LC:22203
//LC:22204
    /**//LC:22205
     * Appends another string builder to this string builder.//LC:22206
     * Appending null will call {@link #appendNull()}.//LC:22207
     *//LC:22208
     * @param str  the string builder to append//LC:22209
     * @return this, to enable chaining//LC:22210
     *///LC:22211
    public StrBuilder append(final StrBuilder str) {//LC:22212
        if (str == null) {//LC:22213
            return appendNull();//LC:22214
        }//LC:22215
        final int strLen = str.length();//LC:22216
        if (strLen > 0) {//LC:22217
            final int len = length();//LC:22218
            ensureCapacity(len + strLen);//LC:22219
            System.arraycopy(str.buffer, 0, buffer, len, strLen);//LC:22220
            size += strLen;//LC:22221
        }//LC:22222
        return this;//LC:22223
    }//LC:22224
//LC:22225
    /**//LC:22226
     * Appends part of a string builder to this string builder.//LC:22227
     * Appending null will call {@link #appendNull()}.//LC:22228
     *//LC:22229
     * @param str  the string to append//LC:22230
     * @param startIndex  the start index, inclusive, must be valid//LC:22231
     * @param length  the length to append, must be valid//LC:22232
     * @return this, to enable chaining//LC:22233
     *///LC:22234
    public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {//LC:22235
        if (str == null) {//LC:22236
            return appendNull();//LC:22237
        }//LC:22238
        if (startIndex < 0 || startIndex > str.length()) {//LC:22239
            throw new StringIndexOutOfBoundsException("startIndex must be valid");//LC:22240
        }//LC:22241
        if (length < 0 || (startIndex + length) > str.length()) {//LC:22242
            throw new StringIndexOutOfBoundsException("length must be valid");//LC:22243
        }//LC:22244
        if (length > 0) {//LC:22245
            final int len = length();//LC:22246
            ensureCapacity(len + length);//LC:22247
            str.getChars(startIndex, startIndex + length, buffer, len);//LC:22248
            size += length;//LC:22249
        }//LC:22250
        return this;//LC:22251
    }//LC:22252
//LC:22253
    /**//LC:22254
     * Appends a char array to the string builder.//LC:22255
     * Appending null will call {@link #appendNull()}.//LC:22256
     *//LC:22257
     * @param chars  the char array to append//LC:22258
     * @return this, to enable chaining//LC:22259
     *///LC:22260
    public StrBuilder append(final char[] chars) {//LC:22261
        if (chars == null) {//LC:22262
            return appendNull();//LC:22263
        }//LC:22264
        final int strLen = chars.length;//LC:22265
        if (strLen > 0) {//LC:22266
            final int len = length();//LC:22267
            ensureCapacity(len + strLen);//LC:22268
            System.arraycopy(chars, 0, buffer, len, strLen);//LC:22269
            size += strLen;//LC:22270
        }//LC:22271
        return this;//LC:22272
    }//LC:22273
//LC:22274
    /**//LC:22275
     * Appends a char array to the string builder.//LC:22276
     * Appending null will call {@link #appendNull()}.//LC:22277
     *//LC:22278
     * @param chars  the char array to append//LC:22279
     * @param startIndex  the start index, inclusive, must be valid//LC:22280
     * @param length  the length to append, must be valid//LC:22281
     * @return this, to enable chaining//LC:22282
     *///LC:22283
    public StrBuilder append(final char[] chars, final int startIndex, final int length) {//LC:22284
        if (chars == null) {//LC:22285
            return appendNull();//LC:22286
        }//LC:22287
        if (startIndex < 0 || startIndex > chars.length) {//LC:22288
            throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length);//LC:22289
        }//LC:22290
        if (length < 0 || (startIndex + length) > chars.length) {//LC:22291
            throw new StringIndexOutOfBoundsException("Invalid length: " + length);//LC:22292
        }//LC:22293
        if (length > 0) {//LC:22294
            final int len = length();//LC:22295
            ensureCapacity(len + length);//LC:22296
            System.arraycopy(chars, startIndex, buffer, len, length);//LC:22297
            size += length;//LC:22298
        }//LC:22299
        return this;//LC:22300
    }//LC:22301
//LC:22302
    /**//LC:22303
     * Appends a boolean value to the string builder.//LC:22304
     *//LC:22305
     * @param value  the value to append//LC:22306
     * @return this, to enable chaining//LC:22307
     *///LC:22308
    public StrBuilder append(final boolean value) {//LC:22309
        if (value) {//LC:22310
            ensureCapacity(size + 4);//LC:22311
            buffer[size++] = 't';//LC:22312
            buffer[size++] = 'r';//LC:22313
            buffer[size++] = 'u';//LC:22314
            buffer[size++] = 'e';//LC:22315
        } else {//LC:22316
            ensureCapacity(size + 5);//LC:22317
            buffer[size++] = 'f';//LC:22318
            buffer[size++] = 'a';//LC:22319
            buffer[size++] = 'l';//LC:22320
            buffer[size++] = 's';//LC:22321
            buffer[size++] = 'e';//LC:22322
        }//LC:22323
        return this;//LC:22324
    }//LC:22325
//LC:22326
    /**//LC:22327
     * Appends a char value to the string builder.//LC:22328
     *//LC:22329
     * @param ch  the value to append//LC:22330
     * @return this, to enable chaining//LC:22331
     * @since 3.0//LC:22332
     *///LC:22333
    @Override//LC:22334
    public StrBuilder append(final char ch) {//LC:22335
        final int len = length();//LC:22336
        ensureCapacity(len + 1);//LC:22337
        buffer[size++] = ch;//LC:22338
        return this;//LC:22339
    }//LC:22340
//LC:22341
    /**//LC:22342
     * Appends an int value to the string builder using <code>String.valueOf</code>.//LC:22343
     *//LC:22344
     * @param value  the value to append//LC:22345
     * @return this, to enable chaining//LC:22346
     *///LC:22347
    public StrBuilder append(final int value) {//LC:22348
        return append(String.valueOf(value));//LC:22349
    }//LC:22350
//LC:22351
    /**//LC:22352
     * Appends a long value to the string builder using <code>String.valueOf</code>.//LC:22353
     *//LC:22354
     * @param value  the value to append//LC:22355
     * @return this, to enable chaining//LC:22356
     *///LC:22357
    public StrBuilder append(final long value) {//LC:22358
        return append(String.valueOf(value));//LC:22359
    }//LC:22360
//LC:22361
    /**//LC:22362
     * Appends a float value to the string builder using <code>String.valueOf</code>.//LC:22363
     *//LC:22364
     * @param value  the value to append//LC:22365
     * @return this, to enable chaining//LC:22366
     *///LC:22367
    public StrBuilder append(final float value) {//LC:22368
        return append(String.valueOf(value));//LC:22369
    }//LC:22370
//LC:22371
    /**//LC:22372
     * Appends a double value to the string builder using <code>String.valueOf</code>.//LC:22373
     *//LC:22374
     * @param value  the value to append//LC:22375
     * @return this, to enable chaining//LC:22376
     *///LC:22377
    public StrBuilder append(final double value) {//LC:22378
        return append(String.valueOf(value));//LC:22379
    }//LC:22380
//LC:22381
    //-----------------------------------------------------------------------//LC:22382
    /**//LC:22383
     * Appends an object followed by a new line to this string builder.//LC:22384
     * Appending null will call {@link #appendNull()}.//LC:22385
     *//LC:22386
     * @param obj  the object to append//LC:22387
     * @return this, to enable chaining//LC:22388
     * @since 2.3//LC:22389
     *///LC:22390
    public StrBuilder appendln(final Object obj) {//LC:22391
        return append(obj).appendNewLine();//LC:22392
    }//LC:22393
//LC:22394
    /**//LC:22395
     * Appends a string followed by a new line to this string builder.//LC:22396
     * Appending null will call {@link #appendNull()}.//LC:22397
     *//LC:22398
     * @param str  the string to append//LC:22399
     * @return this, to enable chaining//LC:22400
     * @since 2.3//LC:22401
     *///LC:22402
    public StrBuilder appendln(final String str) {//LC:22403
        return append(str).appendNewLine();//LC:22404
    }//LC:22405
//LC:22406
    /**//LC:22407
     * Appends part of a string followed by a new line to this string builder.//LC:22408
     * Appending null will call {@link #appendNull()}.//LC:22409
     *//LC:22410
     * @param str  the string to append//LC:22411
     * @param startIndex  the start index, inclusive, must be valid//LC:22412
     * @param length  the length to append, must be valid//LC:22413
     * @return this, to enable chaining//LC:22414
     * @since 2.3//LC:22415
     *///LC:22416
    public StrBuilder appendln(final String str, final int startIndex, final int length) {//LC:22417
        return append(str, startIndex, length).appendNewLine();//LC:22418
    }//LC:22419
//LC:22420
    /**//LC:22421
     * Calls {@link String#format(String, Object...)} and appends the result.//LC:22422
     *//LC:22423
     * @param format the format string//LC:22424
     * @param objs the objects to use in the format string//LC:22425
     * @return {@code this} to enable chaining//LC:22426
     * @see String#format(String, Object...)//LC:22427
     * @since 3.2//LC:22428
     *///LC:22429
    public StrBuilder appendln(final String format, final Object... objs) {//LC:22430
        return append(format, objs).appendNewLine();//LC:22431
    }//LC:22432
//LC:22433
    /**//LC:22434
     * Appends a string buffer followed by a new line to this string builder.//LC:22435
     * Appending null will call {@link #appendNull()}.//LC:22436
     *//LC:22437
     * @param str  the string buffer to append//LC:22438
     * @return this, to enable chaining//LC:22439
     * @since 2.3//LC:22440
     *///LC:22441
    public StrBuilder appendln(final StringBuffer str) {//LC:22442
        return append(str).appendNewLine();//LC:22443
    }//LC:22444
//LC:22445
    /**//LC:22446
     * Appends a string builder followed by a new line to this string builder.//LC:22447
     * Appending null will call {@link #appendNull()}.//LC:22448
     *//LC:22449
     * @param str  the string builder to append//LC:22450
     * @return this, to enable chaining//LC:22451
     * @since 3.2//LC:22452
     *///LC:22453
    public StrBuilder appendln(final StringBuilder str) {//LC:22454
        return append(str).appendNewLine();//LC:22455
    }//LC:22456
//LC:22457
    /**//LC:22458
     * Appends part of a string builder followed by a new line to this string builder.//LC:22459
     * Appending null will call {@link #appendNull()}.//LC:22460
     *//LC:22461
     * @param str  the string builder to append//LC:22462
     * @param startIndex  the start index, inclusive, must be valid//LC:22463
     * @param length  the length to append, must be valid//LC:22464
     * @return this, to enable chaining//LC:22465
     * @since 3.2//LC:22466
     *///LC:22467
    public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) {//LC:22468
        return append(str, startIndex, length).appendNewLine();//LC:22469
    }//LC:22470
//LC:22471
    /**//LC:22472
     * Appends part of a string buffer followed by a new line to this string builder.//LC:22473
     * Appending null will call {@link #appendNull()}.//LC:22474
     *//LC:22475
     * @param str  the string to append//LC:22476
     * @param startIndex  the start index, inclusive, must be valid//LC:22477
     * @param length  the length to append, must be valid//LC:22478
     * @return this, to enable chaining//LC:22479
     * @since 2.3//LC:22480
     *///LC:22481
    public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) {//LC:22482
        return append(str, startIndex, length).appendNewLine();//LC:22483
    }//LC:22484
//LC:22485
    /**//LC:22486
     * Appends another string builder followed by a new line to this string builder.//LC:22487
     * Appending null will call {@link #appendNull()}.//LC:22488
     *//LC:22489
     * @param str  the string builder to append//LC:22490
     * @return this, to enable chaining//LC:22491
     * @since 2.3//LC:22492
     *///LC:22493
    public StrBuilder appendln(final StrBuilder str) {//LC:22494
        return append(str).appendNewLine();//LC:22495
    }//LC:22496
//LC:22497
    /**//LC:22498
     * Appends part of a string builder followed by a new line to this string builder.//LC:22499
     * Appending null will call {@link #appendNull()}.//LC:22500
     *//LC:22501
     * @param str  the string to append//LC:22502
     * @param startIndex  the start index, inclusive, must be valid//LC:22503
     * @param length  the length to append, must be valid//LC:22504
     * @return this, to enable chaining//LC:22505
     * @since 2.3//LC:22506
     *///LC:22507
    public StrBuilder appendln(final StrBuilder str, final int startIndex, final int length) {//LC:22508
        return append(str, startIndex, length).appendNewLine();//LC:22509
    }//LC:22510
//LC:22511
    /**//LC:22512
     * Appends a char array followed by a new line to the string builder.//LC:22513
     * Appending null will call {@link #appendNull()}.//LC:22514
     *//LC:22515
     * @param chars  the char array to append//LC:22516
     * @return this, to enable chaining//LC:22517
     * @since 2.3//LC:22518
     *///LC:22519
    public StrBuilder appendln(final char[] chars) {//LC:22520
        return append(chars).appendNewLine();//LC:22521
    }//LC:22522
//LC:22523
    /**//LC:22524
     * Appends a char array followed by a new line to the string builder.//LC:22525
     * Appending null will call {@link #appendNull()}.//LC:22526
     *//LC:22527
     * @param chars  the char array to append//LC:22528
     * @param startIndex  the start index, inclusive, must be valid//LC:22529
     * @param length  the length to append, must be valid//LC:22530
     * @return this, to enable chaining//LC:22531
     * @since 2.3//LC:22532
     *///LC:22533
    public StrBuilder appendln(final char[] chars, final int startIndex, final int length) {//LC:22534
        return append(chars, startIndex, length).appendNewLine();//LC:22535
    }//LC:22536
//LC:22537
    /**//LC:22538
     * Appends a boolean value followed by a new line to the string builder.//LC:22539
     *//LC:22540
     * @param value  the value to append//LC:22541
     * @return this, to enable chaining//LC:22542
     * @since 2.3//LC:22543
     *///LC:22544
    public StrBuilder appendln(final boolean value) {//LC:22545
        return append(value).appendNewLine();//LC:22546
    }//LC:22547
//LC:22548
    /**//LC:22549
     * Appends a char value followed by a new line to the string builder.//LC:22550
     *//LC:22551
     * @param ch  the value to append//LC:22552
     * @return this, to enable chaining//LC:22553
     * @since 2.3//LC:22554
     *///LC:22555
    public StrBuilder appendln(final char ch) {//LC:22556
        return append(ch).appendNewLine();//LC:22557
    }//LC:22558
//LC:22559
    /**//LC:22560
     * Appends an int value followed by a new line to the string builder using <code>String.valueOf</code>.//LC:22561
     *//LC:22562
     * @param value  the value to append//LC:22563
     * @return this, to enable chaining//LC:22564
     * @since 2.3//LC:22565
     *///LC:22566
    public StrBuilder appendln(final int value) {//LC:22567
        return append(value).appendNewLine();//LC:22568
    }//LC:22569
//LC:22570
    /**//LC:22571
     * Appends a long value followed by a new line to the string builder using <code>String.valueOf</code>.//LC:22572
     *//LC:22573
     * @param value  the value to append//LC:22574
     * @return this, to enable chaining//LC:22575
     * @since 2.3//LC:22576
     *///LC:22577
    public StrBuilder appendln(final long value) {//LC:22578
        return append(value).appendNewLine();//LC:22579
    }//LC:22580
//LC:22581
    /**//LC:22582
     * Appends a float value followed by a new line to the string builder using <code>String.valueOf</code>.//LC:22583
     *//LC:22584
     * @param value  the value to append//LC:22585
     * @return this, to enable chaining//LC:22586
     * @since 2.3//LC:22587
     *///LC:22588
    public StrBuilder appendln(final float value) {//LC:22589
        return append(value).appendNewLine();//LC:22590
    }//LC:22591
//LC:22592
    /**//LC:22593
     * Appends a double value followed by a new line to the string builder using <code>String.valueOf</code>.//LC:22594
     *//LC:22595
     * @param value  the value to append//LC:22596
     * @return this, to enable chaining//LC:22597
     * @since 2.3//LC:22598
     *///LC:22599
    public StrBuilder appendln(final double value) {//LC:22600
        return append(value).appendNewLine();//LC:22601
    }//LC:22602
//LC:22603
    //-----------------------------------------------------------------------//LC:22604
    /**//LC:22605
     * Appends each item in an array to the builder without any separators.//LC:22606
     * Appending a null array will have no effect.//LC:22607
     * Each object is appended using {@link #append(Object)}.//LC:22608
     *//LC:22609
     * @param <T>  the element type//LC:22610
     * @param array  the array to append//LC:22611
     * @return this, to enable chaining//LC:22612
     * @since 2.3//LC:22613
     *///LC:22614
    public <T> StrBuilder appendAll(final T... array) {//LC:22615
        if (array != null && array.length > 0) {//LC:22616
            for (final Object element : array) {//LC:22617
                append(element);//LC:22618
            }//LC:22619
        }//LC:22620
        return this;//LC:22621
    }//LC:22622
//LC:22623
    /**//LC:22624
     * Appends each item in a iterable to the builder without any separators.//LC:22625
     * Appending a null iterable will have no effect.//LC:22626
     * Each object is appended using {@link #append(Object)}.//LC:22627
     *//LC:22628
     * @param iterable  the iterable to append//LC:22629
     * @return this, to enable chaining//LC:22630
     * @since 2.3//LC:22631
     *///LC:22632
    public StrBuilder appendAll(final Iterable<?> iterable) {//LC:22633
        if (iterable != null) {//LC:22634
            for (final Object o : iterable) {//LC:22635
                append(o);//LC:22636
            }//LC:22637
        }//LC:22638
        return this;//LC:22639
    }//LC:22640
//LC:22641
    /**//LC:22642
     * Appends each item in an iterator to the builder without any separators.//LC:22643
     * Appending a null iterator will have no effect.//LC:22644
     * Each object is appended using {@link #append(Object)}.//LC:22645
     *//LC:22646
     * @param it  the iterator to append//LC:22647
     * @return this, to enable chaining//LC:22648
     * @since 2.3//LC:22649
     *///LC:22650
    public StrBuilder appendAll(final Iterator<?> it) {//LC:22651
        if (it != null) {//LC:22652
            while (it.hasNext()) {//LC:22653
                append(it.next());//LC:22654
            }//LC:22655
        }//LC:22656
        return this;//LC:22657
    }//LC:22658
//LC:22659
    //-----------------------------------------------------------------------//LC:22660
    /**//LC:22661
     * Appends an array placing separators between each value, but//LC:22662
     * not before the first or after the last.//LC:22663
     * Appending a null array will have no effect.//LC:22664
     * Each object is appended using {@link #append(Object)}.//LC:22665
     *//LC:22666
     * @param array  the array to append//LC:22667
     * @param separator  the separator to use, null means no separator//LC:22668
     * @return this, to enable chaining//LC:22669
     *///LC:22670
    public StrBuilder appendWithSeparators(final Object[] array, String separator) {//LC:22671
        if (array != null && array.length > 0) {//LC:22672
            separator = ObjectUtils.toString(separator);//LC:22673
            append(array[0]);//LC:22674
            for (int i = 1; i < array.length; i++) {//LC:22675
                append(separator);//LC:22676
                append(array[i]);//LC:22677
            }//LC:22678
        }//LC:22679
        return this;//LC:22680
    }//LC:22681
//LC:22682
    /**//LC:22683
     * Appends a iterable placing separators between each value, but//LC:22684
     * not before the first or after the last.//LC:22685
     * Appending a null iterable will have no effect.//LC:22686
     * Each object is appended using {@link #append(Object)}.//LC:22687
     *//LC:22688
     * @param iterable  the iterable to append//LC:22689
     * @param separator  the separator to use, null means no separator//LC:22690
     * @return this, to enable chaining//LC:22691
     *///LC:22692
    public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) {//LC:22693
        if (iterable != null) {//LC:22694
            separator = ObjectUtils.toString(separator);//LC:22695
            final Iterator<?> it = iterable.iterator();//LC:22696
            while (it.hasNext()) {//LC:22697
                append(it.next());//LC:22698
                if (it.hasNext()) {//LC:22699
                    append(separator);//LC:22700
                }//LC:22701
            }//LC:22702
        }//LC:22703
        return this;//LC:22704
    }//LC:22705
//LC:22706
    /**//LC:22707
     * Appends an iterator placing separators between each value, but//LC:22708
     * not before the first or after the last.//LC:22709
     * Appending a null iterator will have no effect.//LC:22710
     * Each object is appended using {@link #append(Object)}.//LC:22711
     *//LC:22712
     * @param it  the iterator to append//LC:22713
     * @param separator  the separator to use, null means no separator//LC:22714
     * @return this, to enable chaining//LC:22715
     *///LC:22716
    public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {//LC:22717
        if (it != null) {//LC:22718
            separator = ObjectUtils.toString(separator);//LC:22719
            while (it.hasNext()) {//LC:22720
                append(it.next());//LC:22721
                if (it.hasNext()) {//LC:22722
                    append(separator);//LC:22723
                }//LC:22724
            }//LC:22725
        }//LC:22726
        return this;//LC:22727
    }//LC:22728
//LC:22729
    //-----------------------------------------------------------------------//LC:22730
    /**//LC:22731
     * Appends a separator if the builder is currently non-empty.//LC:22732
     * Appending a null separator will have no effect.//LC:22733
     * The separator is appended using {@link #append(String)}.//LC:22734
     * <p>//LC:22735
     * This method is useful for adding a separator each time around the//LC:22736
     * loop except the first.//LC:22737
     * <pre>//LC:22738
     * for (Iterator it = list.iterator(); it.hasNext(); ) {//LC:22739
     *   appendSeparator(",");//LC:22740
     *   append(it.next());//LC:22741
     * }//LC:22742
     * </pre>//LC:22743
     * Note that for this simple example, you should use//LC:22744
     * {@link #appendWithSeparators(Iterable, String)}.//LC:22745
     *//LC:22746
     * @param separator  the separator to use, null means no separator//LC:22747
     * @return this, to enable chaining//LC:22748
     * @since 2.3//LC:22749
     *///LC:22750
    public StrBuilder appendSeparator(final String separator) {//LC:22751
        return appendSeparator(separator, null);//LC:22752
    }//LC:22753
//LC:22754
    /**//LC:22755
     * Appends one of both separators to the StrBuilder.//LC:22756
     * If the builder is currently empty it will append the defaultIfEmpty-separator//LC:22757
     * Otherwise it will append the standard-separator//LC:22758
     *//LC:22759
     * Appending a null separator will have no effect.//LC:22760
     * The separator is appended using {@link #append(String)}.//LC:22761
     * <p>//LC:22762
     * This method is for example useful for constructing queries//LC:22763
     * <pre>//LC:22764
     * StrBuilder whereClause = new StrBuilder();//LC:22765
     * if(searchCommand.getPriority() != null) {//LC:22766
     *  whereClause.appendSeparator(" and", " where");//LC:22767
     *  whereClause.append(" priority = ?")//LC:22768
     * }//LC:22769
     * if(searchCommand.getComponent() != null) {//LC:22770
     *  whereClause.appendSeparator(" and", " where");//LC:22771
     *  whereClause.append(" component = ?")//LC:22772
     * }//LC:22773
     * selectClause.append(whereClause)//LC:22774
     * </pre>//LC:22775
     *//LC:22776
     * @param standard the separator if builder is not empty, null means no separator//LC:22777
     * @param defaultIfEmpty the separator if builder is empty, null means no separator//LC:22778
     * @return this, to enable chaining//LC:22779
     * @since 2.5//LC:22780
     *///LC:22781
    public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) {//LC:22782
        final String str = isEmpty() ? defaultIfEmpty : standard;//LC:22783
        if (str != null) {//LC:22784
            append(str);//LC:22785
        }//LC:22786
        return this;//LC:22787
    }//LC:22788
//LC:22789
    /**//LC:22790
     * Appends a separator if the builder is currently non-empty.//LC:22791
     * The separator is appended using {@link #append(char)}.//LC:22792
     * <p>//LC:22793
     * This method is useful for adding a separator each time around the//LC:22794
     * loop except the first.//LC:22795
     * <pre>//LC:22796
     * for (Iterator it = list.iterator(); it.hasNext(); ) {//LC:22797
     *   appendSeparator(',');//LC:22798
     *   append(it.next());//LC:22799
     * }//LC:22800
     * </pre>//LC:22801
     * Note that for this simple example, you should use//LC:22802
     * {@link #appendWithSeparators(Iterable, String)}.//LC:22803
     *//LC:22804
     * @param separator  the separator to use//LC:22805
     * @return this, to enable chaining//LC:22806
     * @since 2.3//LC:22807
     *///LC:22808
    public StrBuilder appendSeparator(final char separator) {//LC:22809
        if (size() > 0) {//LC:22810
            append(separator);//LC:22811
        }//LC:22812
        return this;//LC:22813
    }//LC:22814
//LC:22815
    /**//LC:22816
     * Append one of both separators to the builder//LC:22817
     * If the builder is currently empty it will append the defaultIfEmpty-separator//LC:22818
     * Otherwise it will append the standard-separator//LC:22819
     *//LC:22820
     * The separator is appended using {@link #append(char)}.//LC:22821
     * @param standard the separator if builder is not empty//LC:22822
     * @param defaultIfEmpty the separator if builder is empty//LC:22823
     * @return this, to enable chaining//LC:22824
     * @since 2.5//LC:22825
     *///LC:22826
    public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) {//LC:22827
        if (size() > 0) {//LC:22828
            append(standard);//LC:22829
        } else {//LC:22830
            append(defaultIfEmpty);//LC:22831
        }//LC:22832
        return this;//LC:22833
    }//LC:22834
    /**//LC:22835
     * Appends a separator to the builder if the loop index is greater than zero.//LC:22836
     * Appending a null separator will have no effect.//LC:22837
     * The separator is appended using {@link #append(String)}.//LC:22838
     * <p>//LC:22839
     * This method is useful for adding a separator each time around the//LC:22840
     * loop except the first.//LC:22841
     * <pre>//LC:22842
     * for (int i = 0; i < list.size(); i++) {//LC:22843
     *   appendSeparator(",", i);//LC:22844
     *   append(list.get(i));//LC:22845
     * }//LC:22846
     * </pre>//LC:22847
     * Note that for this simple example, you should use//LC:22848
     * {@link #appendWithSeparators(Iterable, String)}.//LC:22849
     *//LC:22850
     * @param separator  the separator to use, null means no separator//LC:22851
     * @param loopIndex  the loop index//LC:22852
     * @return this, to enable chaining//LC:22853
     * @since 2.3//LC:22854
     *///LC:22855
    public StrBuilder appendSeparator(final String separator, final int loopIndex) {//LC:22856
        if (separator != null && loopIndex > 0) {//LC:22857
            append(separator);//LC:22858
        }//LC:22859
        return this;//LC:22860
    }//LC:22861
//LC:22862
    /**//LC:22863
     * Appends a separator to the builder if the loop index is greater than zero.//LC:22864
     * The separator is appended using {@link #append(char)}.//LC:22865
     * <p>//LC:22866
     * This method is useful for adding a separator each time around the//LC:22867
     * loop except the first.//LC:22868
     * <pre>//LC:22869
     * for (int i = 0; i < list.size(); i++) {//LC:22870
     *   appendSeparator(",", i);//LC:22871
     *   append(list.get(i));//LC:22872
     * }//LC:22873
     * </pre>//LC:22874
     * Note that for this simple example, you should use//LC:22875
     * {@link #appendWithSeparators(Iterable, String)}.//LC:22876
     *//LC:22877
     * @param separator  the separator to use//LC:22878
     * @param loopIndex  the loop index//LC:22879
     * @return this, to enable chaining//LC:22880
     * @since 2.3//LC:22881
     *///LC:22882
    public StrBuilder appendSeparator(final char separator, final int loopIndex) {//LC:22883
        if (loopIndex > 0) {//LC:22884
            append(separator);//LC:22885
        }//LC:22886
        return this;//LC:22887
    }//LC:22888
//LC:22889
    //-----------------------------------------------------------------------//LC:22890
    /**//LC:22891
     * Appends the pad character to the builder the specified number of times.//LC:22892
     *//LC:22893
     * @param length  the length to append, negative means no append//LC:22894
     * @param padChar  the character to append//LC:22895
     * @return this, to enable chaining//LC:22896
     *///LC:22897
    public StrBuilder appendPadding(final int length, final char padChar) {//LC:22898
        if (length >= 0) {//LC:22899
            ensureCapacity(size + length);//LC:22900
            for (int i = 0; i < length; i++) {//LC:22901
                buffer[size++] = padChar;//LC:22902
            }//LC:22903
        }//LC:22904
        return this;//LC:22905
    }//LC:22906
//LC:22907
    //-----------------------------------------------------------------------//LC:22908
    /**//LC:22909
     * Appends an object to the builder padding on the left to a fixed width.//LC:22910
     * The <code>toString</code> of the object is used.//LC:22911
     * If the object is larger than the length, the left hand side is lost.//LC:22912
     * If the object is null, the null text value is used.//LC:22913
     *//LC:22914
     * @param obj  the object to append, null uses null text//LC:22915
     * @param width  the fixed field width, zero or negative has no effect//LC:22916
     * @param padChar  the pad character to use//LC:22917
     * @return this, to enable chaining//LC:22918
     *///LC:22919
    public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {//LC:22920
        if (width > 0) {//LC:22921
            ensureCapacity(size + width);//LC:22922
            String str = (obj == null ? getNullText() : obj.toString());//LC:22923
            if (str == null) {//LC:22924
                str = "";//LC:22925
            }//LC:22926
            final int strLen = str.length();//LC:22927
            if (strLen >= width) {//LC:22928
                str.getChars(strLen - width, strLen, buffer, size);//LC:22929
            } else {//LC:22930
                final int padLen = width - strLen;//LC:22931
                for (int i = 0; i < padLen; i++) {//LC:22932
                    buffer[size + i] = padChar;//LC:22933
                }//LC:22934
                str.getChars(0, strLen, buffer, size + padLen);//LC:22935
            }//LC:22936
            size += width;//LC:22937
        }//LC:22938
        return this;//LC:22939
    }//LC:22940
//LC:22941
    /**//LC:22942
     * Appends an object to the builder padding on the left to a fixed width.//LC:22943
     * The <code>String.valueOf</code> of the <code>int</code> value is used.//LC:22944
     * If the formatted value is larger than the length, the left hand side is lost.//LC:22945
     *//LC:22946
     * @param value  the value to append//LC:22947
     * @param width  the fixed field width, zero or negative has no effect//LC:22948
     * @param padChar  the pad character to use//LC:22949
     * @return this, to enable chaining//LC:22950
     *///LC:22951
    public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {//LC:22952
        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);//LC:22953
    }//LC:22954
//LC:22955
    /**//LC:22956
     * Appends an object to the builder padding on the right to a fixed length.//LC:22957
     * The <code>toString</code> of the object is used.//LC:22958
     * If the object is larger than the length, the right hand side is lost.//LC:22959
     * If the object is null, null text value is used.//LC:22960
     *//LC:22961
     * @param obj  the object to append, null uses null text//LC:22962
     * @param width  the fixed field width, zero or negative has no effect//LC:22963
     * @param padChar  the pad character to use//LC:22964
     * @return this, to enable chaining//LC:22965
     *///LC:22966
    public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {//LC:22967
        if (width > 0) {//LC:22968
            ensureCapacity(size + width);//LC:22969
            String str = (obj == null ? getNullText() : obj.toString());//LC:22970
            if (str == null) {//LC:22971
                str = "";//LC:22972
            }//LC:22973
            final int strLen = str.length();//LC:22974
            if (strLen >= width) {//LC:22975
                str.getChars(0, width, buffer, size);//LC:22976
            } else {//LC:22977
                final int padLen = width - strLen;//LC:22978
                str.getChars(0, strLen, buffer, size);//LC:22979
                for (int i = 0; i < padLen; i++) {//LC:22980
                    buffer[size + strLen + i] = padChar;//LC:22981
                }//LC:22982
            }//LC:22983
            size += width;//LC:22984
        }//LC:22985
        return this;//LC:22986
    }//LC:22987
//LC:22988
    /**//LC:22989
     * Appends an object to the builder padding on the right to a fixed length.//LC:22990
     * The <code>String.valueOf</code> of the <code>int</code> value is used.//LC:22991
     * If the object is larger than the length, the right hand side is lost.//LC:22992
     *//LC:22993
     * @param value  the value to append//LC:22994
     * @param width  the fixed field width, zero or negative has no effect//LC:22995
     * @param padChar  the pad character to use//LC:22996
     * @return this, to enable chaining//LC:22997
     *///LC:22998
    public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {//LC:22999
        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);//LC:23000
    }//LC:23001
//LC:23002
    //-----------------------------------------------------------------------//LC:23003
    /**//LC:23004
     * Inserts the string representation of an object into this builder.//LC:23005
     * Inserting null will use the stored null text value.//LC:23006
     *//LC:23007
     * @param index  the index to add at, must be valid//LC:23008
     * @param obj  the object to insert//LC:23009
     * @return this, to enable chaining//LC:23010
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23011
     *///LC:23012
    public StrBuilder insert(final int index, final Object obj) {//LC:23013
        if (obj == null) {//LC:23014
            return insert(index, nullText);//LC:23015
        }//LC:23016
        return insert(index, obj.toString());//LC:23017
    }//LC:23018
//LC:23019
    /**//LC:23020
     * Inserts the string into this builder.//LC:23021
     * Inserting null will use the stored null text value.//LC:23022
     *//LC:23023
     * @param index  the index to add at, must be valid//LC:23024
     * @param str  the string to insert//LC:23025
     * @return this, to enable chaining//LC:23026
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23027
     *///LC:23028
    public StrBuilder insert(final int index, String str) {//LC:23029
        validateIndex(index);//LC:23030
        if (str == null) {//LC:23031
            str = nullText;//LC:23032
        }//LC:23033
        if (str != null) {//LC:23034
            final int strLen = str.length();//LC:23035
            if (strLen > 0) {//LC:23036
                final int newSize = size + strLen;//LC:23037
                ensureCapacity(newSize);//LC:23038
                System.arraycopy(buffer, index, buffer, index + strLen, size - index);//LC:23039
                size = newSize;//LC:23040
                str.getChars(0, strLen, buffer, index);//LC:23041
            }//LC:23042
        }//LC:23043
        return this;//LC:23044
    }//LC:23045
//LC:23046
    /**//LC:23047
     * Inserts the character array into this builder.//LC:23048
     * Inserting null will use the stored null text value.//LC:23049
     *//LC:23050
     * @param index  the index to add at, must be valid//LC:23051
     * @param chars  the char array to insert//LC:23052
     * @return this, to enable chaining//LC:23053
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23054
     *///LC:23055
    public StrBuilder insert(final int index, final char chars[]) {//LC:23056
        validateIndex(index);//LC:23057
        if (chars == null) {//LC:23058
            return insert(index, nullText);//LC:23059
        }//LC:23060
        final int len = chars.length;//LC:23061
        if (len > 0) {//LC:23062
            ensureCapacity(size + len);//LC:23063
            System.arraycopy(buffer, index, buffer, index + len, size - index);//LC:23064
            System.arraycopy(chars, 0, buffer, index, len);//LC:23065
            size += len;//LC:23066
        }//LC:23067
        return this;//LC:23068
    }//LC:23069
//LC:23070
    /**//LC:23071
     * Inserts part of the character array into this builder.//LC:23072
     * Inserting null will use the stored null text value.//LC:23073
     *//LC:23074
     * @param index  the index to add at, must be valid//LC:23075
     * @param chars  the char array to insert//LC:23076
     * @param offset  the offset into the character array to start at, must be valid//LC:23077
     * @param length  the length of the character array part to copy, must be positive//LC:23078
     * @return this, to enable chaining//LC:23079
     * @throws IndexOutOfBoundsException if any index is invalid//LC:23080
     *///LC:23081
    public StrBuilder insert(final int index, final char chars[], final int offset, final int length) {//LC:23082
        validateIndex(index);//LC:23083
        if (chars == null) {//LC:23084
            return insert(index, nullText);//LC:23085
        }//LC:23086
        if (offset < 0 || offset > chars.length) {//LC:23087
            throw new StringIndexOutOfBoundsException("Invalid offset: " + offset);//LC:23088
        }//LC:23089
        if (length < 0 || offset + length > chars.length) {//LC:23090
            throw new StringIndexOutOfBoundsException("Invalid length: " + length);//LC:23091
        }//LC:23092
        if (length > 0) {//LC:23093
            ensureCapacity(size + length);//LC:23094
            System.arraycopy(buffer, index, buffer, index + length, size - index);//LC:23095
            System.arraycopy(chars, offset, buffer, index, length);//LC:23096
            size += length;//LC:23097
        }//LC:23098
        return this;//LC:23099
    }//LC:23100
//LC:23101
    /**//LC:23102
     * Inserts the value into this builder.//LC:23103
     *//LC:23104
     * @param index  the index to add at, must be valid//LC:23105
     * @param value  the value to insert//LC:23106
     * @return this, to enable chaining//LC:23107
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23108
     *///LC:23109
    public StrBuilder insert(int index, final boolean value) {//LC:23110
        validateIndex(index);//LC:23111
        if (value) {//LC:23112
            ensureCapacity(size + 4);//LC:23113
            System.arraycopy(buffer, index, buffer, index + 4, size - index);//LC:23114
            buffer[index++] = 't';//LC:23115
            buffer[index++] = 'r';//LC:23116
            buffer[index++] = 'u';//LC:23117
            buffer[index] = 'e';//LC:23118
            size += 4;//LC:23119
        } else {//LC:23120
            ensureCapacity(size + 5);//LC:23121
            System.arraycopy(buffer, index, buffer, index + 5, size - index);//LC:23122
            buffer[index++] = 'f';//LC:23123
            buffer[index++] = 'a';//LC:23124
            buffer[index++] = 'l';//LC:23125
            buffer[index++] = 's';//LC:23126
            buffer[index] = 'e';//LC:23127
            size += 5;//LC:23128
        }//LC:23129
        return this;//LC:23130
    }//LC:23131
//LC:23132
    /**//LC:23133
     * Inserts the value into this builder.//LC:23134
     *//LC:23135
     * @param index  the index to add at, must be valid//LC:23136
     * @param value  the value to insert//LC:23137
     * @return this, to enable chaining//LC:23138
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23139
     *///LC:23140
    public StrBuilder insert(final int index, final char value) {//LC:23141
        validateIndex(index);//LC:23142
        ensureCapacity(size + 1);//LC:23143
        System.arraycopy(buffer, index, buffer, index + 1, size - index);//LC:23144
        buffer[index] = value;//LC:23145
        size++;//LC:23146
        return this;//LC:23147
    }//LC:23148
//LC:23149
    /**//LC:23150
     * Inserts the value into this builder.//LC:23151
     *//LC:23152
     * @param index  the index to add at, must be valid//LC:23153
     * @param value  the value to insert//LC:23154
     * @return this, to enable chaining//LC:23155
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23156
     *///LC:23157
    public StrBuilder insert(final int index, final int value) {//LC:23158
        return insert(index, String.valueOf(value));//LC:23159
    }//LC:23160
//LC:23161
    /**//LC:23162
     * Inserts the value into this builder.//LC:23163
     *//LC:23164
     * @param index  the index to add at, must be valid//LC:23165
     * @param value  the value to insert//LC:23166
     * @return this, to enable chaining//LC:23167
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23168
     *///LC:23169
    public StrBuilder insert(final int index, final long value) {//LC:23170
        return insert(index, String.valueOf(value));//LC:23171
    }//LC:23172
//LC:23173
    /**//LC:23174
     * Inserts the value into this builder.//LC:23175
     *//LC:23176
     * @param index  the index to add at, must be valid//LC:23177
     * @param value  the value to insert//LC:23178
     * @return this, to enable chaining//LC:23179
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23180
     *///LC:23181
    public StrBuilder insert(final int index, final float value) {//LC:23182
        return insert(index, String.valueOf(value));//LC:23183
    }//LC:23184
//LC:23185
    /**//LC:23186
     * Inserts the value into this builder.//LC:23187
     *//LC:23188
     * @param index  the index to add at, must be valid//LC:23189
     * @param value  the value to insert//LC:23190
     * @return this, to enable chaining//LC:23191
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23192
     *///LC:23193
    public StrBuilder insert(final int index, final double value) {//LC:23194
        return insert(index, String.valueOf(value));//LC:23195
    }//LC:23196
//LC:23197
    //-----------------------------------------------------------------------//LC:23198
    /**//LC:23199
     * Internal method to delete a range without validation.//LC:23200
     *//LC:23201
     * @param startIndex  the start index, must be valid//LC:23202
     * @param endIndex  the end index (exclusive), must be valid//LC:23203
     * @param len  the length, must be valid//LC:23204
     * @throws IndexOutOfBoundsException if any index is invalid//LC:23205
     *///LC:23206
    private void deleteImpl(final int startIndex, final int endIndex, final int len) {//LC:23207
        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);//LC:23208
        size -= len;//LC:23209
    }//LC:23210
//LC:23211
    /**//LC:23212
     * Deletes the characters between the two specified indices.//LC:23213
     *//LC:23214
     * @param startIndex  the start index, inclusive, must be valid//LC:23215
     * @param endIndex  the end index, exclusive, must be valid except//LC:23216
     *  that if too large it is treated as end of string//LC:23217
     * @return this, to enable chaining//LC:23218
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23219
     *///LC:23220
    public StrBuilder delete(final int startIndex, int endIndex) {//LC:23221
        endIndex = validateRange(startIndex, endIndex);//LC:23222
        final int len = endIndex - startIndex;//LC:23223
        if (len > 0) {//LC:23224
            deleteImpl(startIndex, endIndex, len);//LC:23225
        }//LC:23226
        return this;//LC:23227
    }//LC:23228
//LC:23229
    //-----------------------------------------------------------------------//LC:23230
    /**//LC:23231
     * Deletes the character wherever it occurs in the builder.//LC:23232
     *//LC:23233
     * @param ch  the character to delete//LC:23234
     * @return this, to enable chaining//LC:23235
     *///LC:23236
    public StrBuilder deleteAll(final char ch) {//LC:23237
        for (int i = 0; i < size; i++) {//LC:23238
            if (buffer[i] == ch) {//LC:23239
                final int start = i;//LC:23240
                while (++i < size) {//LC:23241
                    if (buffer[i] != ch) {//LC:23242
                        break;//LC:23243
                    }//LC:23244
                }//LC:23245
                final int len = i - start;//LC:23246
                deleteImpl(start, i, len);//LC:23247
                i -= len;//LC:23248
            }//LC:23249
        }//LC:23250
        return this;//LC:23251
    }//LC:23252
//LC:23253
    /**//LC:23254
     * Deletes the character wherever it occurs in the builder.//LC:23255
     *//LC:23256
     * @param ch  the character to delete//LC:23257
     * @return this, to enable chaining//LC:23258
     *///LC:23259
    public StrBuilder deleteFirst(final char ch) {//LC:23260
        for (int i = 0; i < size; i++) {//LC:23261
            if (buffer[i] == ch) {//LC:23262
                deleteImpl(i, i + 1, 1);//LC:23263
                break;//LC:23264
            }//LC:23265
        }//LC:23266
        return this;//LC:23267
    }//LC:23268
//LC:23269
    //-----------------------------------------------------------------------//LC:23270
    /**//LC:23271
     * Deletes the string wherever it occurs in the builder.//LC:23272
     *//LC:23273
     * @param str  the string to delete, null causes no action//LC:23274
     * @return this, to enable chaining//LC:23275
     *///LC:23276
    public StrBuilder deleteAll(final String str) {//LC:23277
        final int len = (str == null ? 0 : str.length());//LC:23278
        if (len > 0) {//LC:23279
            int index = indexOf(str, 0);//LC:23280
            while (index >= 0) {//LC:23281
                deleteImpl(index, index + len, len);//LC:23282
                index = indexOf(str, index);//LC:23283
            }//LC:23284
        }//LC:23285
        return this;//LC:23286
    }//LC:23287
//LC:23288
    /**//LC:23289
     * Deletes the string wherever it occurs in the builder.//LC:23290
     *//LC:23291
     * @param str  the string to delete, null causes no action//LC:23292
     * @return this, to enable chaining//LC:23293
     *///LC:23294
    public StrBuilder deleteFirst(final String str) {//LC:23295
        final int len = (str == null ? 0 : str.length());//LC:23296
        if (len > 0) {//LC:23297
            final int index = indexOf(str, 0);//LC:23298
            if (index >= 0) {//LC:23299
                deleteImpl(index, index + len, len);//LC:23300
            }//LC:23301
        }//LC:23302
        return this;//LC:23303
    }//LC:23304
//LC:23305
    //-----------------------------------------------------------------------//LC:23306
    /**//LC:23307
     * Deletes all parts of the builder that the matcher matches.//LC:23308
     * <p>//LC:23309
     * Matchers can be used to perform advanced deletion behaviour.//LC:23310
     * For example you could write a matcher to delete all occurrences//LC:23311
     * where the character 'a' is followed by a number.//LC:23312
     *//LC:23313
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23314
     * @return this, to enable chaining//LC:23315
     *///LC:23316
    public StrBuilder deleteAll(final StrMatcher matcher) {//LC:23317
        return replace(matcher, null, 0, size, -1);//LC:23318
    }//LC:23319
//LC:23320
    /**//LC:23321
     * Deletes the first match within the builder using the specified matcher.//LC:23322
     * <p>//LC:23323
     * Matchers can be used to perform advanced deletion behaviour.//LC:23324
     * For example you could write a matcher to delete//LC:23325
     * where the character 'a' is followed by a number.//LC:23326
     *//LC:23327
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23328
     * @return this, to enable chaining//LC:23329
     *///LC:23330
    public StrBuilder deleteFirst(final StrMatcher matcher) {//LC:23331
        return replace(matcher, null, 0, size, 1);//LC:23332
    }//LC:23333
//LC:23334
    //-----------------------------------------------------------------------//LC:23335
    /**//LC:23336
     * Internal method to delete a range without validation.//LC:23337
     *//LC:23338
     * @param startIndex  the start index, must be valid//LC:23339
     * @param endIndex  the end index (exclusive), must be valid//LC:23340
     * @param removeLen  the length to remove (endIndex - startIndex), must be valid//LC:23341
     * @param insertStr  the string to replace with, null means delete range//LC:23342
     * @param insertLen  the length of the insert string, must be valid//LC:23343
     * @throws IndexOutOfBoundsException if any index is invalid//LC:23344
     *///LC:23345
    private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) {//LC:23346
        final int newSize = size - removeLen + insertLen;//LC:23347
        if (insertLen != removeLen) {//LC:23348
            ensureCapacity(newSize);//LC:23349
            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);//LC:23350
            size = newSize;//LC:23351
        }//LC:23352
        if (insertLen > 0) {//LC:23353
            insertStr.getChars(0, insertLen, buffer, startIndex);//LC:23354
        }//LC:23355
    }//LC:23356
//LC:23357
    /**//LC:23358
     * Replaces a portion of the string builder with another string.//LC:23359
     * The length of the inserted string does not have to match the removed length.//LC:23360
     *//LC:23361
     * @param startIndex  the start index, inclusive, must be valid//LC:23362
     * @param endIndex  the end index, exclusive, must be valid except//LC:23363
     *  that if too large it is treated as end of string//LC:23364
     * @param replaceStr  the string to replace with, null means delete range//LC:23365
     * @return this, to enable chaining//LC:23366
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23367
     *///LC:23368
    public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) {//LC:23369
        endIndex = validateRange(startIndex, endIndex);//LC:23370
        final int insertLen = (replaceStr == null ? 0 : replaceStr.length());//LC:23371
        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);//LC:23372
        return this;//LC:23373
    }//LC:23374
//LC:23375
    //-----------------------------------------------------------------------//LC:23376
    /**//LC:23377
     * Replaces the search character with the replace character//LC:23378
     * throughout the builder.//LC:23379
     *//LC:23380
     * @param search  the search character//LC:23381
     * @param replace  the replace character//LC:23382
     * @return this, to enable chaining//LC:23383
     *///LC:23384
    public StrBuilder replaceAll(final char search, final char replace) {//LC:23385
        if (search != replace) {//LC:23386
            for (int i = 0; i < size; i++) {//LC:23387
                if (buffer[i] == search) {//LC:23388
                    buffer[i] = replace;//LC:23389
                }//LC:23390
            }//LC:23391
        }//LC:23392
        return this;//LC:23393
    }//LC:23394
//LC:23395
    /**//LC:23396
     * Replaces the first instance of the search character with the//LC:23397
     * replace character in the builder.//LC:23398
     *//LC:23399
     * @param search  the search character//LC:23400
     * @param replace  the replace character//LC:23401
     * @return this, to enable chaining//LC:23402
     *///LC:23403
    public StrBuilder replaceFirst(final char search, final char replace) {//LC:23404
        if (search != replace) {//LC:23405
            for (int i = 0; i < size; i++) {//LC:23406
                if (buffer[i] == search) {//LC:23407
                    buffer[i] = replace;//LC:23408
                    break;//LC:23409
                }//LC:23410
            }//LC:23411
        }//LC:23412
        return this;//LC:23413
    }//LC:23414
//LC:23415
    //-----------------------------------------------------------------------//LC:23416
    /**//LC:23417
     * Replaces the search string with the replace string throughout the builder.//LC:23418
     *//LC:23419
     * @param searchStr  the search string, null causes no action to occur//LC:23420
     * @param replaceStr  the replace string, null is equivalent to an empty string//LC:23421
     * @return this, to enable chaining//LC:23422
     *///LC:23423
    public StrBuilder replaceAll(final String searchStr, final String replaceStr) {//LC:23424
        final int searchLen = (searchStr == null ? 0 : searchStr.length());//LC:23425
        if (searchLen > 0) {//LC:23426
            final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());//LC:23427
            int index = indexOf(searchStr, 0);//LC:23428
            while (index >= 0) {//LC:23429
                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);//LC:23430
                index = indexOf(searchStr, index + replaceLen);//LC:23431
            }//LC:23432
        }//LC:23433
        return this;//LC:23434
    }//LC:23435
//LC:23436
    /**//LC:23437
     * Replaces the first instance of the search string with the replace string.//LC:23438
     *//LC:23439
     * @param searchStr  the search string, null causes no action to occur//LC:23440
     * @param replaceStr  the replace string, null is equivalent to an empty string//LC:23441
     * @return this, to enable chaining//LC:23442
     *///LC:23443
    public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {//LC:23444
        final int searchLen = (searchStr == null ? 0 : searchStr.length());//LC:23445
        if (searchLen > 0) {//LC:23446
            final int index = indexOf(searchStr, 0);//LC:23447
            if (index >= 0) {//LC:23448
                final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());//LC:23449
                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);//LC:23450
            }//LC:23451
        }//LC:23452
        return this;//LC:23453
    }//LC:23454
//LC:23455
    //-----------------------------------------------------------------------//LC:23456
    /**//LC:23457
     * Replaces all matches within the builder with the replace string.//LC:23458
     * <p>//LC:23459
     * Matchers can be used to perform advanced replace behaviour.//LC:23460
     * For example you could write a matcher to replace all occurrences//LC:23461
     * where the character 'a' is followed by a number.//LC:23462
     *//LC:23463
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23464
     * @param replaceStr  the replace string, null is equivalent to an empty string//LC:23465
     * @return this, to enable chaining//LC:23466
     *///LC:23467
    public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {//LC:23468
        return replace(matcher, replaceStr, 0, size, -1);//LC:23469
    }//LC:23470
//LC:23471
    /**//LC:23472
     * Replaces the first match within the builder with the replace string.//LC:23473
     * <p>//LC:23474
     * Matchers can be used to perform advanced replace behaviour.//LC:23475
     * For example you could write a matcher to replace//LC:23476
     * where the character 'a' is followed by a number.//LC:23477
     *//LC:23478
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23479
     * @param replaceStr  the replace string, null is equivalent to an empty string//LC:23480
     * @return this, to enable chaining//LC:23481
     *///LC:23482
    public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {//LC:23483
        return replace(matcher, replaceStr, 0, size, 1);//LC:23484
    }//LC:23485
//LC:23486
    // -----------------------------------------------------------------------//LC:23487
    /**//LC:23488
     * Advanced search and replaces within the builder using a matcher.//LC:23489
     * <p>//LC:23490
     * Matchers can be used to perform advanced behaviour.//LC:23491
     * For example you could write a matcher to delete all occurrences//LC:23492
     * where the character 'a' is followed by a number.//LC:23493
     *//LC:23494
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23495
     * @param replaceStr  the string to replace the match with, null is a delete//LC:23496
     * @param startIndex  the start index, inclusive, must be valid//LC:23497
     * @param endIndex  the end index, exclusive, must be valid except//LC:23498
     *  that if too large it is treated as end of string//LC:23499
     * @param replaceCount  the number of times to replace, -1 for replace all//LC:23500
     * @return this, to enable chaining//LC:23501
     * @throws IndexOutOfBoundsException if start index is invalid//LC:23502
     *///LC:23503
    public StrBuilder replace(//LC:23504
            final StrMatcher matcher, final String replaceStr,//LC:23505
            final int startIndex, int endIndex, final int replaceCount) {//LC:23506
        endIndex = validateRange(startIndex, endIndex);//LC:23507
        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);//LC:23508
    }//LC:23509
//LC:23510
    /**//LC:23511
     * Replaces within the builder using a matcher.//LC:23512
     * <p>//LC:23513
     * Matchers can be used to perform advanced behaviour.//LC:23514
     * For example you could write a matcher to delete all occurrences//LC:23515
     * where the character 'a' is followed by a number.//LC:23516
     *//LC:23517
     * @param matcher  the matcher to use to find the deletion, null causes no action//LC:23518
     * @param replaceStr  the string to replace the match with, null is a delete//LC:23519
     * @param from  the start index, must be valid//LC:23520
     * @param to  the end index (exclusive), must be valid//LC:23521
     * @param replaceCount  the number of times to replace, -1 for replace all//LC:23522
     * @return this, to enable chaining//LC:23523
     * @throws IndexOutOfBoundsException if any index is invalid//LC:23524
     *///LC:23525
    private StrBuilder replaceImpl(//LC:23526
            final StrMatcher matcher, final String replaceStr,//LC:23527
            final int from, int to, int replaceCount) {//LC:23528
        if (matcher == null || size == 0) {//LC:23529
            return this;//LC:23530
        }//LC:23531
        final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());//LC:23532
        final char[] buf = buffer;//LC:23533
        for (int i = from; i < to && replaceCount != 0; i++) {//LC:23534
            final int removeLen = matcher.isMatch(buf, i, from, to);//LC:23535
            if (removeLen > 0) {//LC:23536
                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);//LC:23537
                to = to - removeLen + replaceLen;//LC:23538
                i = i + replaceLen - 1;//LC:23539
                if (replaceCount > 0) {//LC:23540
                    replaceCount--;//LC:23541
                }//LC:23542
            }//LC:23543
        }//LC:23544
        return this;//LC:23545
    }//LC:23546
//LC:23547
    //-----------------------------------------------------------------------//LC:23548
    /**//LC:23549
     * Reverses the string builder placing each character in the opposite index.//LC:23550
     *//LC:23551
     * @return this, to enable chaining//LC:23552
     *///LC:23553
    public StrBuilder reverse() {//LC:23554
        if (size == 0) {//LC:23555
            return this;//LC:23556
        }//LC:23557
//LC:23558
        final int half = size / 2;//LC:23559
        final char[] buf = buffer;//LC:23560
        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {//LC:23561
            final char swap = buf[leftIdx];//LC:23562
            buf[leftIdx] = buf[rightIdx];//LC:23563
            buf[rightIdx] = swap;//LC:23564
        }//LC:23565
        return this;//LC:23566
    }//LC:23567
//LC:23568
    //-----------------------------------------------------------------------//LC:23569
    /**//LC:23570
     * Trims the builder by removing characters less than or equal to a space//LC:23571
     * from the beginning and end.//LC:23572
     *//LC:23573
     * @return this, to enable chaining//LC:23574
     *///LC:23575
    public StrBuilder trim() {//LC:23576
        if (size == 0) {//LC:23577
            return this;//LC:23578
        }//LC:23579
        int len = size;//LC:23580
        final char[] buf = buffer;//LC:23581
        int pos = 0;//LC:23582
        while (pos < len && buf[pos] <= ' ') {//LC:23583
            pos++;//LC:23584
        }//LC:23585
        while (pos < len && buf[len - 1] <= ' ') {//LC:23586
            len--;//LC:23587
        }//LC:23588
        if (len < size) {//LC:23589
            delete(len, size);//LC:23590
        }//LC:23591
        if (pos > 0) {//LC:23592
            delete(0, pos);//LC:23593
        }//LC:23594
        return this;//LC:23595
    }//LC:23596
//LC:23597
    //-----------------------------------------------------------------------//LC:23598
    /**//LC:23599
     * Checks whether this builder starts with the specified string.//LC:23600
     * <p>//LC:23601
     * Note that this method handles null input quietly, unlike String.//LC:23602
     *//LC:23603
     * @param str  the string to search for, null returns false//LC:23604
     * @return true if the builder starts with the string//LC:23605
     *///LC:23606
    public boolean startsWith(final String str) {//LC:23607
        if (str == null) {//LC:23608
            return false;//LC:23609
        }//LC:23610
        final int len = str.length();//LC:23611
        if (len == 0) {//LC:23612
            return true;//LC:23613
        }//LC:23614
        if (len > size) {//LC:23615
            return false;//LC:23616
        }//LC:23617
        for (int i = 0; i < len; i++) {//LC:23618
            if (buffer[i] != str.charAt(i)) {//LC:23619
                return false;//LC:23620
            }//LC:23621
        }//LC:23622
        return true;//LC:23623
    }//LC:23624
//LC:23625
    /**//LC:23626
     * Checks whether this builder ends with the specified string.//LC:23627
     * <p>//LC:23628
     * Note that this method handles null input quietly, unlike String.//LC:23629
     *//LC:23630
     * @param str  the string to search for, null returns false//LC:23631
     * @return true if the builder ends with the string//LC:23632
     *///LC:23633
    public boolean endsWith(final String str) {//LC:23634
        if (str == null) {//LC:23635
            return false;//LC:23636
        }//LC:23637
        final int len = str.length();//LC:23638
        if (len == 0) {//LC:23639
            return true;//LC:23640
        }//LC:23641
        if (len > size) {//LC:23642
            return false;//LC:23643
        }//LC:23644
        int pos = size - len;//LC:23645
        for (int i = 0; i < len; i++,pos++) {//LC:23646
            if (buffer[pos] != str.charAt(i)) {//LC:23647
                return false;//LC:23648
            }//LC:23649
        }//LC:23650
        return true;//LC:23651
    }//LC:23652
//LC:23653
    //-----------------------------------------------------------------------//LC:23654
    /**//LC:23655
     * {@inheritDoc}//LC:23656
     * @since 3.0//LC:23657
     *///LC:23658
    @Override//LC:23659
    public CharSequence subSequence(final int startIndex, final int endIndex) {//LC:23660
        if (startIndex < 0) {//LC:23661
            throw new StringIndexOutOfBoundsException(startIndex);//LC:23662
        }//LC:23663
        if (endIndex > size) {//LC:23664
            throw new StringIndexOutOfBoundsException(endIndex);//LC:23665
        }//LC:23666
        if (startIndex > endIndex) {//LC:23667
            throw new StringIndexOutOfBoundsException(endIndex - startIndex);//LC:23668
        }//LC:23669
        return substring(startIndex, endIndex);//LC:23670
    }//LC:23671
//LC:23672
    /**//LC:23673
     * Extracts a portion of this string builder as a string.//LC:23674
     *//LC:23675
     * @param start  the start index, inclusive, must be valid//LC:23676
     * @return the new string//LC:23677
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23678
     *///LC:23679
    public String substring(final int start) {//LC:23680
        return substring(start, size);//LC:23681
    }//LC:23682
//LC:23683
    /**//LC:23684
     * Extracts a portion of this string builder as a string.//LC:23685
     * <p>//LC:23686
     * Note: This method treats an endIndex greater than the length of the//LC:23687
     * builder as equal to the length of the builder, and continues//LC:23688
     * without error, unlike StringBuffer or String.//LC:23689
     *//LC:23690
     * @param startIndex  the start index, inclusive, must be valid//LC:23691
     * @param endIndex  the end index, exclusive, must be valid except//LC:23692
     *  that if too large it is treated as end of string//LC:23693
     * @return the new string//LC:23694
     * @throws IndexOutOfBoundsException if the index is invalid//LC:23695
     *///LC:23696
    public String substring(final int startIndex, int endIndex) {//LC:23697
        endIndex = validateRange(startIndex, endIndex);//LC:23698
        return new String(buffer, startIndex, endIndex - startIndex);//LC:23699
    }//LC:23700
//LC:23701
    /**//LC:23702
     * Extracts the leftmost characters from the string builder without//LC:23703
     * throwing an exception.//LC:23704
     * <p>//LC:23705
     * This method extracts the left <code>length</code> characters from//LC:23706
     * the builder. If this many characters are not available, the whole//LC:23707
     * builder is returned. Thus the returned string may be shorter than the//LC:23708
     * length requested.//LC:23709
     *//LC:23710
     * @param length  the number of characters to extract, negative returns empty string//LC:23711
     * @return the new string//LC:23712
     *///LC:23713
    public String leftString(final int length) {//LC:23714
        if (length <= 0) {//LC:23715
            return "";//LC:23716
        } else if (length >= size) {//LC:23717
            return new String(buffer, 0, size);//LC:23718
        } else {//LC:23719
            return new String(buffer, 0, length);//LC:23720
        }//LC:23721
    }//LC:23722
//LC:23723
    /**//LC:23724
     * Extracts the rightmost characters from the string builder without//LC:23725
     * throwing an exception.//LC:23726
     * <p>//LC:23727
     * This method extracts the right <code>length</code> characters from//LC:23728
     * the builder. If this many characters are not available, the whole//LC:23729
     * builder is returned. Thus the returned string may be shorter than the//LC:23730
     * length requested.//LC:23731
     *//LC:23732
     * @param length  the number of characters to extract, negative returns empty string//LC:23733
     * @return the new string//LC:23734
     *///LC:23735
    public String rightString(final int length) {//LC:23736
        if (length <= 0) {//LC:23737
            return "";//LC:23738
        } else if (length >= size) {//LC:23739
            return new String(buffer, 0, size);//LC:23740
        } else {//LC:23741
            return new String(buffer, size - length, length);//LC:23742
        }//LC:23743
    }//LC:23744
//LC:23745
    /**//LC:23746
     * Extracts some characters from the middle of the string builder without//LC:23747
     * throwing an exception.//LC:23748
     * <p>//LC:23749
     * This method extracts <code>length</code> characters from the builder//LC:23750
     * at the specified index.//LC:23751
     * If the index is negative it is treated as zero.//LC:23752
     * If the index is greater than the builder size, it is treated as the builder size.//LC:23753
     * If the length is negative, the empty string is returned.//LC:23754
     * If insufficient characters are available in the builder, as much as possible is returned.//LC:23755
     * Thus the returned string may be shorter than the length requested.//LC:23756
     *//LC:23757
     * @param index  the index to start at, negative means zero//LC:23758
     * @param length  the number of characters to extract, negative returns empty string//LC:23759
     * @return the new string//LC:23760
     *///LC:23761
    public String midString(int index, final int length) {//LC:23762
        if (index < 0) {//LC:23763
            index = 0;//LC:23764
        }//LC:23765
        if (length <= 0 || index >= size) {//LC:23766
            return "";//LC:23767
        }//LC:23768
        if (size <= index + length) {//LC:23769
            return new String(buffer, index, size - index);//LC:23770
        }//LC:23771
        return new String(buffer, index, length);//LC:23772
    }//LC:23773
//LC:23774
    //-----------------------------------------------------------------------//LC:23775
    /**//LC:23776
     * Checks if the string builder contains the specified char.//LC:23777
     *//LC:23778
     * @param ch  the character to find//LC:23779
     * @return true if the builder contains the character//LC:23780
     *///LC:23781
    public boolean contains(final char ch) {//LC:23782
        final char[] thisBuf = buffer;//LC:23783
        for (int i = 0; i < this.size; i++) {//LC:23784
            if (thisBuf[i] == ch) {//LC:23785
                return true;//LC:23786
            }//LC:23787
        }//LC:23788
        return false;//LC:23789
    }//LC:23790
//LC:23791
    /**//LC:23792
     * Checks if the string builder contains the specified string.//LC:23793
     *//LC:23794
     * @param str  the string to find//LC:23795
     * @return true if the builder contains the string//LC:23796
     *///LC:23797
    public boolean contains(final String str) {//LC:23798
        return indexOf(str, 0) >= 0;//LC:23799
    }//LC:23800
//LC:23801
    /**//LC:23802
     * Checks if the string builder contains a string matched using the//LC:23803
     * specified matcher.//LC:23804
     * <p>//LC:23805
     * Matchers can be used to perform advanced searching behaviour.//LC:23806
     * For example you could write a matcher to search for the character//LC:23807
     * 'a' followed by a number.//LC:23808
     *//LC:23809
     * @param matcher  the matcher to use, null returns -1//LC:23810
     * @return true if the matcher finds a match in the builder//LC:23811
     *///LC:23812
    public boolean contains(final StrMatcher matcher) {//LC:23813
        return indexOf(matcher, 0) >= 0;//LC:23814
    }//LC:23815
//LC:23816
    //-----------------------------------------------------------------------//LC:23817
    /**//LC:23818
     * Searches the string builder to find the first reference to the specified char.//LC:23819
     *//LC:23820
     * @param ch  the character to find//LC:23821
     * @return the first index of the character, or -1 if not found//LC:23822
     *///LC:23823
    public int indexOf(final char ch) {//LC:23824
        return indexOf(ch, 0);//LC:23825
    }//LC:23826
//LC:23827
    /**//LC:23828
     * Searches the string builder to find the first reference to the specified char.//LC:23829
     *//LC:23830
     * @param ch  the character to find//LC:23831
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:23832
     * @return the first index of the character, or -1 if not found//LC:23833
     *///LC:23834
    public int indexOf(final char ch, int startIndex) {//LC:23835
        startIndex = (startIndex < 0 ? 0 : startIndex);//LC:23836
        if (startIndex >= size) {//LC:23837
            return -1;//LC:23838
        }//LC:23839
        final char[] thisBuf = buffer;//LC:23840
        for (int i = startIndex; i < size; i++) {//LC:23841
            if (thisBuf[i] == ch) {//LC:23842
                return i;//LC:23843
            }//LC:23844
        }//LC:23845
        return -1;//LC:23846
    }//LC:23847
//LC:23848
    /**//LC:23849
     * Searches the string builder to find the first reference to the specified string.//LC:23850
     * <p>//LC:23851
     * Note that a null input string will return -1, whereas the JDK throws an exception.//LC:23852
     *//LC:23853
     * @param str  the string to find, null returns -1//LC:23854
     * @return the first index of the string, or -1 if not found//LC:23855
     *///LC:23856
    public int indexOf(final String str) {//LC:23857
        return indexOf(str, 0);//LC:23858
    }//LC:23859
//LC:23860
    /**//LC:23861
     * Searches the string builder to find the first reference to the specified//LC:23862
     * string starting searching from the given index.//LC:23863
     * <p>//LC:23864
     * Note that a null input string will return -1, whereas the JDK throws an exception.//LC:23865
     *//LC:23866
     * @param str  the string to find, null returns -1//LC:23867
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:23868
     * @return the first index of the string, or -1 if not found//LC:23869
     *///LC:23870
    public int indexOf(final String str, int startIndex) {//LC:23871
        startIndex = (startIndex < 0 ? 0 : startIndex);//LC:23872
        if (str == null || startIndex >= size) {//LC:23873
            return -1;//LC:23874
        }//LC:23875
        final int strLen = str.length();//LC:23876
        if (strLen == 1) {//LC:23877
            return indexOf(str.charAt(0), startIndex);//LC:23878
        }//LC:23879
        if (strLen == 0) {//LC:23880
            return startIndex;//LC:23881
        }//LC:23882
        if (strLen > size) {//LC:23883
            return -1;//LC:23884
        }//LC:23885
        final char[] thisBuf = buffer;//LC:23886
        final int len = size - strLen + 1;//LC:23887
        outer://LC:23888
        for (int i = startIndex; i < len; i++) {//LC:23889
            for (int j = 0; j < strLen; j++) {//LC:23890
                if (str.charAt(j) != thisBuf[i + j]) {//LC:23891
                    continue outer;//LC:23892
                }//LC:23893
            }//LC:23894
            return i;//LC:23895
        }//LC:23896
        return -1;//LC:23897
    }//LC:23898
//LC:23899
    /**//LC:23900
     * Searches the string builder using the matcher to find the first match.//LC:23901
     * <p>//LC:23902
     * Matchers can be used to perform advanced searching behaviour.//LC:23903
     * For example you could write a matcher to find the character 'a'//LC:23904
     * followed by a number.//LC:23905
     *//LC:23906
     * @param matcher  the matcher to use, null returns -1//LC:23907
     * @return the first index matched, or -1 if not found//LC:23908
     *///LC:23909
    public int indexOf(final StrMatcher matcher) {//LC:23910
        return indexOf(matcher, 0);//LC:23911
    }//LC:23912
//LC:23913
    /**//LC:23914
     * Searches the string builder using the matcher to find the first//LC:23915
     * match searching from the given index.//LC:23916
     * <p>//LC:23917
     * Matchers can be used to perform advanced searching behaviour.//LC:23918
     * For example you could write a matcher to find the character 'a'//LC:23919
     * followed by a number.//LC:23920
     *//LC:23921
     * @param matcher  the matcher to use, null returns -1//LC:23922
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:23923
     * @return the first index matched, or -1 if not found//LC:23924
     *///LC:23925
    public int indexOf(final StrMatcher matcher, int startIndex) {//LC:23926
        startIndex = (startIndex < 0 ? 0 : startIndex);//LC:23927
        if (matcher == null || startIndex >= size) {//LC:23928
            return -1;//LC:23929
        }//LC:23930
        final int len = size;//LC:23931
        final char[] buf = buffer;//LC:23932
        for (int i = startIndex; i < len; i++) {//LC:23933
            if (matcher.isMatch(buf, i, startIndex, len) > 0) {//LC:23934
                return i;//LC:23935
            }//LC:23936
        }//LC:23937
        return -1;//LC:23938
    }//LC:23939
//LC:23940
    //-----------------------------------------------------------------------//LC:23941
    /**//LC:23942
     * Searches the string builder to find the last reference to the specified char.//LC:23943
     *//LC:23944
     * @param ch  the character to find//LC:23945
     * @return the last index of the character, or -1 if not found//LC:23946
     *///LC:23947
    public int lastIndexOf(final char ch) {//LC:23948
        return lastIndexOf(ch, size - 1);//LC:23949
    }//LC:23950
//LC:23951
    /**//LC:23952
     * Searches the string builder to find the last reference to the specified char.//LC:23953
     *//LC:23954
     * @param ch  the character to find//LC:23955
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:23956
     * @return the last index of the character, or -1 if not found//LC:23957
     *///LC:23958
    public int lastIndexOf(final char ch, int startIndex) {//LC:23959
        startIndex = (startIndex >= size ? size - 1 : startIndex);//LC:23960
        if (startIndex < 0) {//LC:23961
            return -1;//LC:23962
        }//LC:23963
        for (int i = startIndex; i >= 0; i--) {//LC:23964
            if (buffer[i] == ch) {//LC:23965
                return i;//LC:23966
            }//LC:23967
        }//LC:23968
        return -1;//LC:23969
    }//LC:23970
//LC:23971
    /**//LC:23972
     * Searches the string builder to find the last reference to the specified string.//LC:23973
     * <p>//LC:23974
     * Note that a null input string will return -1, whereas the JDK throws an exception.//LC:23975
     *//LC:23976
     * @param str  the string to find, null returns -1//LC:23977
     * @return the last index of the string, or -1 if not found//LC:23978
     *///LC:23979
    public int lastIndexOf(final String str) {//LC:23980
        return lastIndexOf(str, size - 1);//LC:23981
    }//LC:23982
//LC:23983
    /**//LC:23984
     * Searches the string builder to find the last reference to the specified//LC:23985
     * string starting searching from the given index.//LC:23986
     * <p>//LC:23987
     * Note that a null input string will return -1, whereas the JDK throws an exception.//LC:23988
     *//LC:23989
     * @param str  the string to find, null returns -1//LC:23990
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:23991
     * @return the last index of the string, or -1 if not found//LC:23992
     *///LC:23993
    public int lastIndexOf(final String str, int startIndex) {//LC:23994
        startIndex = (startIndex >= size ? size - 1 : startIndex);//LC:23995
        if (str == null || startIndex < 0) {//LC:23996
            return -1;//LC:23997
        }//LC:23998
        final int strLen = str.length();//LC:23999
        if (strLen > 0 && strLen <= size) {//LC:24000
            if (strLen == 1) {//LC:24001
                return lastIndexOf(str.charAt(0), startIndex);//LC:24002
            }//LC:24003
//LC:24004
            outer://LC:24005
            for (int i = startIndex - strLen + 1; i >= 0; i--) {//LC:24006
                for (int j = 0; j < strLen; j++) {//LC:24007
                    if (str.charAt(j) != buffer[i + j]) {//LC:24008
                        continue outer;//LC:24009
                    }//LC:24010
                }//LC:24011
                return i;//LC:24012
            }//LC:24013
//LC:24014
        } else if (strLen == 0) {//LC:24015
            return startIndex;//LC:24016
        }//LC:24017
        return -1;//LC:24018
    }//LC:24019
//LC:24020
    /**//LC:24021
     * Searches the string builder using the matcher to find the last match.//LC:24022
     * <p>//LC:24023
     * Matchers can be used to perform advanced searching behaviour.//LC:24024
     * For example you could write a matcher to find the character 'a'//LC:24025
     * followed by a number.//LC:24026
     *//LC:24027
     * @param matcher  the matcher to use, null returns -1//LC:24028
     * @return the last index matched, or -1 if not found//LC:24029
     *///LC:24030
    public int lastIndexOf(final StrMatcher matcher) {//LC:24031
        return lastIndexOf(matcher, size);//LC:24032
    }//LC:24033
//LC:24034
    /**//LC:24035
     * Searches the string builder using the matcher to find the last//LC:24036
     * match searching from the given index.//LC:24037
     * <p>//LC:24038
     * Matchers can be used to perform advanced searching behaviour.//LC:24039
     * For example you could write a matcher to find the character 'a'//LC:24040
     * followed by a number.//LC:24041
     *//LC:24042
     * @param matcher  the matcher to use, null returns -1//LC:24043
     * @param startIndex  the index to start at, invalid index rounded to edge//LC:24044
     * @return the last index matched, or -1 if not found//LC:24045
     *///LC:24046
    public int lastIndexOf(final StrMatcher matcher, int startIndex) {//LC:24047
        startIndex = (startIndex >= size ? size - 1 : startIndex);//LC:24048
        if (matcher == null || startIndex < 0) {//LC:24049
            return -1;//LC:24050
        }//LC:24051
        final char[] buf = buffer;//LC:24052
        final int endIndex = startIndex + 1;//LC:24053
        for (int i = startIndex; i >= 0; i--) {//LC:24054
            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {//LC:24055
                return i;//LC:24056
            }//LC:24057
        }//LC:24058
        return -1;//LC:24059
    }//LC:24060
//LC:24061
    //-----------------------------------------------------------------------//LC:24062
    /**//LC:24063
     * Creates a tokenizer that can tokenize the contents of this builder.//LC:24064
     * <p>//LC:24065
     * This method allows the contents of this builder to be tokenized.//LC:24066
     * The tokenizer will be setup by default to tokenize on space, tab,//LC:24067
     * newline and formfeed (as per StringTokenizer). These values can be//LC:24068
     * changed on the tokenizer class, before retrieving the tokens.//LC:24069
     * <p>//LC:24070
     * The returned tokenizer is linked to this builder. You may intermix//LC:24071
     * calls to the buider and tokenizer within certain limits, however//LC:24072
     * there is no synchronization. Once the tokenizer has been used once,//LC:24073
     * it must be {@link StrTokenizer#reset() reset} to pickup the latest//LC:24074
     * changes in the builder. For example://LC:24075
     * <pre>//LC:24076
     * StrBuilder b = new StrBuilder();//LC:24077
     * b.append("a b ");//LC:24078
     * StrTokenizer t = b.asTokenizer();//LC:24079
     * String[] tokens1 = t.getTokenArray();  // returns a,b//LC:24080
     * b.append("c d ");//LC:24081
     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)//LC:24082
     * t.reset();              // reset causes builder changes to be picked up//LC:24083
     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d//LC:24084
     * </pre>//LC:24085
     * In addition to simply intermixing appends and tokenization, you can also//LC:24086
     * call the set methods on the tokenizer to alter how it tokenizes. Just//LC:24087
     * remember to call reset when you want to pickup builder changes.//LC:24088
     * <p>//LC:24089
     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}//LC:24090
     * with a non-null value will break the link with the builder.//LC:24091
     *//LC:24092
     * @return a tokenizer that is linked to this builder//LC:24093
     *///LC:24094
    public StrTokenizer asTokenizer() {//LC:24095
        return new StrBuilderTokenizer();//LC:24096
    }//LC:24097
//LC:24098
    //-----------------------------------------------------------------------//LC:24099
    /**//LC:24100
     * Gets the contents of this builder as a Reader.//LC:24101
     * <p>//LC:24102
     * This method allows the contents of the builder to be read//LC:24103
     * using any standard method that expects a Reader.//LC:24104
     * <p>//LC:24105
     * To use, simply create a <code>StrBuilder</code>, populate it with//LC:24106
     * data, call <code>asReader</code>, and then read away.//LC:24107
     * <p>//LC:24108
     * The internal character array is shared between the builder and the reader.//LC:24109
     * This allows you to append to the builder after creating the reader,//LC:24110
     * and the changes will be picked up.//LC:24111
     * Note however, that no synchronization occurs, so you must perform//LC:24112
     * all operations with the builder and the reader in one thread.//LC:24113
     * <p>//LC:24114
     * The returned reader supports marking, and ignores the flush method.//LC:24115
     *//LC:24116
     * @return a reader that reads from this builder//LC:24117
     *///LC:24118
    public Reader asReader() {//LC:24119
        return new StrBuilderReader();//LC:24120
    }//LC:24121
//LC:24122
    //-----------------------------------------------------------------------//LC:24123
    /**//LC:24124
     * Gets this builder as a Writer that can be written to.//LC:24125
     * <p>//LC:24126
     * This method allows you to populate the contents of the builder//LC:24127
     * using any standard method that takes a Writer.//LC:24128
     * <p>//LC:24129
     * To use, simply create a <code>StrBuilder</code>,//LC:24130
     * call <code>asWriter</code>, and populate away. The data is available//LC:24131
     * at any time using the methods of the <code>StrBuilder</code>.//LC:24132
     * <p>//LC:24133
     * The internal character array is shared between the builder and the writer.//LC:24134
     * This allows you to intermix calls that append to the builder and//LC:24135
     * write using the writer and the changes will be occur correctly.//LC:24136
     * Note however, that no synchronization occurs, so you must perform//LC:24137
     * all operations with the builder and the writer in one thread.//LC:24138
     * <p>//LC:24139
     * The returned writer ignores the close and flush methods.//LC:24140
     *//LC:24141
     * @return a writer that populates this builder//LC:24142
     *///LC:24143
    public Writer asWriter() {//LC:24144
        return new StrBuilderWriter();//LC:24145
    }//LC:24146
//LC:24147
    //-----------------------------------------------------------------------//LC:24148
//    /**//LC:24149
//     * Gets a String version of the string builder by calling the internal//LC:24150
//     * constructor of String by reflection.//LC:24151
//     * <p>//LC:24152
//     * WARNING: You must not use the StrBuilder after calling this method//LC:24153
//     * as the buffer is now shared with the String object. To ensure this,//LC:24154
//     * the internal character array is set to null, so you will get//LC:24155
//     * NullPointerExceptions on all method calls.//LC:24156
//     *//LC:24157
//     * @return the builder as a String//LC:24158
//     *///LC:24159
//    public String toSharedString() {//LC:24160
//        try {//LC:24161
//            Constructor con = String.class.getDeclaredConstructor(//LC:24162
//                new Class[] {int.class, int.class, char[].class});//LC:24163
//            con.setAccessible(true);//LC:24164
//            char[] buffer = buf;//LC:24165
//            buf = null;//LC:24166
//            size = -1;//LC:24167
//            nullText = null;//LC:24168
//            return (String) con.newInstance(//LC:24169
//                new Object[] {Integer.valueOf(0), Integer.valueOf(size), buffer});//LC:24170
////LC:24171
//        } catch (Exception ex) {//LC:24172
//            ex.printStackTrace();//LC:24173
//            throw new UnsupportedOperationException("StrBuilder.toSharedString is unsupported: " + ex.getMessage());//LC:24174
//        }//LC:24175
//    }//LC:24176
//LC:24177
    //-----------------------------------------------------------------------//LC:24178
    /**//LC:24179
     * Checks the contents of this builder against another to see if they//LC:24180
     * contain the same character content ignoring case.//LC:24181
     *//LC:24182
     * @param other  the object to check, null returns false//LC:24183
     * @return true if the builders contain the same characters in the same order//LC:24184
     *///LC:24185
    public boolean equalsIgnoreCase(final StrBuilder other) {//LC:24186
        if (this == other) {//LC:24187
            return true;//LC:24188
        }//LC:24189
        if (this.size != other.size) {//LC:24190
            return false;//LC:24191
        }//LC:24192
        final char thisBuf[] = this.buffer;//LC:24193
        final char otherBuf[] = other.buffer;//LC:24194
        for (int i = size - 1; i >= 0; i--) {//LC:24195
            final char c1 = thisBuf[i];//LC:24196
            final char c2 = otherBuf[i];//LC:24197
            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {//LC:24198
                return false;//LC:24199
            }//LC:24200
        }//LC:24201
        return true;//LC:24202
    }//LC:24203
//LC:24204
    /**//LC:24205
     * Checks the contents of this builder against another to see if they//LC:24206
     * contain the same character content.//LC:24207
     *//LC:24208
     * @param other  the object to check, null returns false//LC:24209
     * @return true if the builders contain the same characters in the same order//LC:24210
     *///LC:24211
    public boolean equals(final StrBuilder other) {//LC:24212
        if (this == other) {//LC:24213
            return true;//LC:24214
        }//LC:24215
        if (this.size != other.size) {//LC:24216
            return false;//LC:24217
        }//LC:24218
        final char thisBuf[] = this.buffer;//LC:24219
        final char otherBuf[] = other.buffer;//LC:24220
        for (int i = size - 1; i >= 0; i--) {//LC:24221
            if (thisBuf[i] != otherBuf[i]) {//LC:24222
                return false;//LC:24223
            }//LC:24224
        }//LC:24225
        return true;//LC:24226
    }//LC:24227
//LC:24228
    /**//LC:24229
     * Checks the contents of this builder against another to see if they//LC:24230
     * contain the same character content.//LC:24231
     *//LC:24232
     * @param obj  the object to check, null returns false//LC:24233
     * @return true if the builders contain the same characters in the same order//LC:24234
     *///LC:24235
    @Override//LC:24236
    public boolean equals(final Object obj) {//LC:24237
        if (obj instanceof StrBuilder) {//LC:24238
            return equals((StrBuilder) obj);//LC:24239
        }//LC:24240
        return false;//LC:24241
    }//LC:24242
//LC:24243
    /**//LC:24244
     * Gets a suitable hash code for this builder.//LC:24245
     *//LC:24246
     * @return a hash code//LC:24247
     *///LC:24248
    @Override//LC:24249
    public int hashCode() {//LC:24250
        final char buf[] = buffer;//LC:24251
        int hash = 0;//LC:24252
        for (int i = size - 1; i >= 0; i--) {//LC:24253
            hash = 31 * hash + buf[i];//LC:24254
        }//LC:24255
        return hash;//LC:24256
    }//LC:24257
//LC:24258
    //-----------------------------------------------------------------------//LC:24259
    /**//LC:24260
     * Gets a String version of the string builder, creating a new instance//LC:24261
     * each time the method is called.//LC:24262
     * <p>//LC:24263
     * Note that unlike StringBuffer, the string version returned is//LC:24264
     * independent of the string builder.//LC:24265
     *//LC:24266
     * @return the builder as a String//LC:24267
     *///LC:24268
    @Override//LC:24269
    public String toString() {//LC:24270
        return new String(buffer, 0, size);//LC:24271
    }//LC:24272
//LC:24273
    /**//LC:24274
     * Gets a StringBuffer version of the string builder, creating a//LC:24275
     * new instance each time the method is called.//LC:24276
     *//LC:24277
     * @return the builder as a StringBuffer//LC:24278
     *///LC:24279
    public StringBuffer toStringBuffer() {//LC:24280
        return new StringBuffer(size).append(buffer, 0, size);//LC:24281
    }//LC:24282
//LC:24283
    /**//LC:24284
     * Gets a StringBuilder version of the string builder, creating a//LC:24285
     * new instance each time the method is called.//LC:24286
     *//LC:24287
     * @return the builder as a StringBuilder//LC:24288
     * @since Apache Commons Lang 3.2//LC:24289
     *///LC:24290
    public StringBuilder toStringBuilder() {//LC:24291
        return new StringBuilder(size).append(buffer, 0, size);//LC:24292
    }//LC:24293
//LC:24294
    /**//LC:24295
     * Implement the {@link Builder} interface.//LC:24296
     * @return the builder as a String//LC:24297
     * @since Apache Commons Lang 3.2//LC:24298
     * @see #toString()//LC:24299
     *///LC:24300
    @Override//LC:24301
    public String build() {//LC:24302
        return toString();//LC:24303
    }//LC:24304
//LC:24305
    //-----------------------------------------------------------------------//LC:24306
    /**//LC:24307
     * Validates parameters defining a range of the builder.//LC:24308
     *//LC:24309
     * @param startIndex  the start index, inclusive, must be valid//LC:24310
     * @param endIndex  the end index, exclusive, must be valid except//LC:24311
     *  that if too large it is treated as end of string//LC:24312
     * @return the new string//LC:24313
     * @throws IndexOutOfBoundsException if the index is invalid//LC:24314
     *///LC:24315
    protected int validateRange(final int startIndex, int endIndex) {//LC:24316
        if (startIndex < 0) {//LC:24317
            throw new StringIndexOutOfBoundsException(startIndex);//LC:24318
        }//LC:24319
        if (endIndex > size) {//LC:24320
            endIndex = size;//LC:24321
        }//LC:24322
        if (startIndex > endIndex) {//LC:24323
            throw new StringIndexOutOfBoundsException("end < start");//LC:24324
        }//LC:24325
        return endIndex;//LC:24326
    }//LC:24327
//LC:24328
    /**//LC:24329
     * Validates parameters defining a single index in the builder.//LC:24330
     *//LC:24331
     * @param index  the index, must be valid//LC:24332
     * @throws IndexOutOfBoundsException if the index is invalid//LC:24333
     *///LC:24334
    protected void validateIndex(final int index) {//LC:24335
        if (index < 0 || index > size) {//LC:24336
            throw new StringIndexOutOfBoundsException(index);//LC:24337
        }//LC:24338
    }//LC:24339
//LC:24340
    //-----------------------------------------------------------------------//LC:24341
    /**//LC:24342
     * Inner class to allow StrBuilder to operate as a tokenizer.//LC:24343
     *///LC:24344
    class StrBuilderTokenizer extends StrTokenizer {//LC:24345
//LC:24346
        /**//LC:24347
         * Default constructor.//LC:24348
         *///LC:24349
        StrBuilderTokenizer() {//LC:24350
            super();//LC:24351
        }//LC:24352
//LC:24353
        /** {@inheritDoc} *///LC:24354
        @Override//LC:24355
        protected List<String> tokenize(final char[] chars, final int offset, final int count) {//LC:24356
            if (chars == null) {//LC:24357
                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());//LC:24358
            }//LC:24359
            return super.tokenize(chars, offset, count);//LC:24360
        }//LC:24361
//LC:24362
        /** {@inheritDoc} *///LC:24363
        @Override//LC:24364
        public String getContent() {//LC:24365
            final String str = super.getContent();//LC:24366
            if (str == null) {//LC:24367
                return StrBuilder.this.toString();//LC:24368
            }//LC:24369
            return str;//LC:24370
        }//LC:24371
    }//LC:24372
//LC:24373
    //-----------------------------------------------------------------------//LC:24374
    /**//LC:24375
     * Inner class to allow StrBuilder to operate as a writer.//LC:24376
     *///LC:24377
    class StrBuilderReader extends Reader {//LC:24378
        /** The current stream position. *///LC:24379
        private int pos;//LC:24380
        /** The last mark position. *///LC:24381
        private int mark;//LC:24382
//LC:24383
        /**//LC:24384
         * Default constructor.//LC:24385
         *///LC:24386
        StrBuilderReader() {//LC:24387
            super();//LC:24388
        }//LC:24389
//LC:24390
        /** {@inheritDoc} *///LC:24391
        @Override//LC:24392
        public void close() {//LC:24393
            // do nothing//LC:24394
        }//LC:24395
//LC:24396
        /** {@inheritDoc} *///LC:24397
        @Override//LC:24398
        public int read() {//LC:24399
            if (ready() == false) {//LC:24400
                return -1;//LC:24401
            }//LC:24402
            return StrBuilder.this.charAt(pos++);//LC:24403
        }//LC:24404
//LC:24405
        /** {@inheritDoc} *///LC:24406
        @Override//LC:24407
        public int read(final char b[], final int off, int len) {//LC:24408
            if (off < 0 || len < 0 || off > b.length ||//LC:24409
                    (off + len) > b.length || (off + len) < 0) {//LC:24410
                throw new IndexOutOfBoundsException();//LC:24411
            }//LC:24412
            if (len == 0) {//LC:24413
                return 0;//LC:24414
            }//LC:24415
            if (pos >= StrBuilder.this.size()) {//LC:24416
                return -1;//LC:24417
            }//LC:24418
            if (pos + len > size()) {//LC:24419
                len = StrBuilder.this.size() - pos;//LC:24420
            }//LC:24421
            StrBuilder.this.getChars(pos, pos + len, b, off);//LC:24422
            pos += len;//LC:24423
            return len;//LC:24424
        }//LC:24425
//LC:24426
        /** {@inheritDoc} *///LC:24427
        @Override//LC:24428
        public long skip(long n) {//LC:24429
            if (pos + n > StrBuilder.this.size()) {//LC:24430
                n = StrBuilder.this.size() - pos;//LC:24431
            }//LC:24432
            if (n < 0) {//LC:24433
                return 0;//LC:24434
            }//LC:24435
            pos += n;//LC:24436
            return n;//LC:24437
        }//LC:24438
//LC:24439
        /** {@inheritDoc} *///LC:24440
        @Override//LC:24441
        public boolean ready() {//LC:24442
            return pos < StrBuilder.this.size();//LC:24443
        }//LC:24444
//LC:24445
        /** {@inheritDoc} *///LC:24446
        @Override//LC:24447
        public boolean markSupported() {//LC:24448
            return true;//LC:24449
        }//LC:24450
//LC:24451
        /** {@inheritDoc} *///LC:24452
        @Override//LC:24453
        public void mark(final int readAheadLimit) {//LC:24454
            mark = pos;//LC:24455
        }//LC:24456
//LC:24457
        /** {@inheritDoc} *///LC:24458
        @Override//LC:24459
        public void reset() {//LC:24460
            pos = mark;//LC:24461
        }//LC:24462
    }//LC:24463
//LC:24464
    //-----------------------------------------------------------------------//LC:24465
    /**//LC:24466
     * Inner class to allow StrBuilder to operate as a writer.//LC:24467
     *///LC:24468
    class StrBuilderWriter extends Writer {//LC:24469
//LC:24470
        /**//LC:24471
         * Default constructor.//LC:24472
         *///LC:24473
        StrBuilderWriter() {//LC:24474
            super();//LC:24475
        }//LC:24476
//LC:24477
        /** {@inheritDoc} *///LC:24478
        @Override//LC:24479
        public void close() {//LC:24480
            // do nothing//LC:24481
        }//LC:24482
//LC:24483
        /** {@inheritDoc} *///LC:24484
        @Override//LC:24485
        public void flush() {//LC:24486
            // do nothing//LC:24487
        }//LC:24488
//LC:24489
        /** {@inheritDoc} *///LC:24490
        @Override//LC:24491
        public void write(final int c) {//LC:24492
            StrBuilder.this.append((char) c);//LC:24493
        }//LC:24494
//LC:24495
        /** {@inheritDoc} *///LC:24496
        @Override//LC:24497
        public void write(final char[] cbuf) {//LC:24498
            StrBuilder.this.append(cbuf);//LC:24499
        }//LC:24500
//LC:24501
        /** {@inheritDoc} *///LC:24502
        @Override//LC:24503
        public void write(final char[] cbuf, final int off, final int len) {//LC:24504
            StrBuilder.this.append(cbuf, off, len);//LC:24505
        }//LC:24506
//LC:24507
        /** {@inheritDoc} *///LC:24508
        @Override//LC:24509
        public void write(final String str) {//LC:24510
            StrBuilder.this.append(str);//LC:24511
        }//LC:24512
//LC:24513
        /** {@inheritDoc} *///LC:24514
        @Override//LC:24515
        public void write(final String str, final int off, final int len) {//LC:24516
            StrBuilder.this.append(str, off, len);//LC:24517
        }//LC:24518
    }//LC:24519
//LC:24520
}//LC:24521
//LC:24522
//LC:24523
/**//LC:24524
 * <p>This class assists in validating arguments. The validation methods are//LC:24525
 * based along the following principles://LC:24526
 * <ul>//LC:24527
 *   <li>An invalid {@code null} argument causes a {@link NullPointerException}.</li>//LC:24528
 *   <li>A non-{@code null} argument causes an {@link IllegalArgumentException}.</li>//LC:24529
 *   <li>An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.</li>//LC:24530
 * </ul>//LC:24531
 *//LC:24532
 * <p>All exceptions messages are//LC:24533
 * <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html#syntax">format strings</a>//LC:24534
 * as defined by the Java platform. For example:</p>//LC:24535
 *//LC:24536
 * <pre>//LC:24537
 * Validate.isTrue(i > 0, "The value must be greater than zero: %d", i);//LC:24538
 * Validate.notNull(surname, "The surname must not be %s", null);//LC:24539
 * </pre>//LC:24540
 *//LC:24541
 * <p>#ThreadSafe#</p>//LC:24542
 * @version $Id$//LC:24543
 * @see java.lang.String#format(String, Object...)//LC:24544
 * @since 2.0//LC:24545
 *///LC:24546
class Validate {//LC:24547
//LC:24548
    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE =//LC:24549
            "The value %s is not in the specified exclusive range of %s to %s";//LC:24550
    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE =//LC:24551
            "The value %s is not in the specified inclusive range of %s to %s";//LC:24552
    private static final String DEFAULT_MATCHES_PATTERN_EX = "The string %s does not match the pattern %s";//LC:24553
    private static final String DEFAULT_IS_NULL_EX_MESSAGE = "The validated object is null";//LC:24554
    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = "The validated expression is false";//LC:24555
    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE =//LC:24556
            "The validated array contains null element at index: %d";//LC:24557
    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE =//LC:24558
            "The validated collection contains null element at index: %d";//LC:24559
    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = "The validated character sequence is blank";//LC:24560
    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = "The validated array is empty";//LC:24561
    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE =//LC:24562
            "The validated character sequence is empty";//LC:24563
    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = "The validated collection is empty";//LC:24564
    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = "The validated map is empty";//LC:24565
    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = "The validated array index is invalid: %d";//LC:24566
    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE =//LC:24567
            "The validated character sequence index is invalid: %d";//LC:24568
    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE =//LC:24569
            "The validated collection index is invalid: %d";//LC:24570
    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = "The validated state is false";//LC:24571
    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = "Cannot assign a %s to a %s";//LC:24572
    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = "Expected type: %s, actual: %s";//LC:24573
//LC:24574
    /**//LC:24575
     * Constructor. This class should not normally be instantiated.//LC:24576
     *///LC:24577
    public Validate() {//LC:24578
        super();//LC:24579
    }//LC:24580
//LC:24581
    // isTrue//LC:24582
    //---------------------------------------------------------------------------------//LC:24583
//LC:24584
    /**//LC:24585
     * <p>Validate that the argument condition is {@code true}; otherwise//LC:24586
     * throwing an exception with the specified message. This method is useful when//LC:24587
     * validating according to an arbitrary boolean expression, such as validating a//LC:24588
     * primitive number or using your own custom validation expression.</p>//LC:24589
     *//LC:24590
     * <pre>Validate.isTrue(i > 0.0, "The value must be greater than zero: %d", i);</pre>//LC:24591
     *//LC:24592
     * <p>For performance reasons, the long value is passed as a separate parameter and//LC:24593
     * appended to the exception message only in the case of an error.</p>//LC:24594
     *//LC:24595
     * @param expression  the boolean expression to check//LC:24596
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24597
     * @param value  the value to append to the message when invalid//LC:24598
     * @throws IllegalArgumentException if expression is {@code false}//LC:24599
     * @see #isTrue(boolean)//LC:24600
     * @see #isTrue(boolean, String, double)//LC:24601
     * @see #isTrue(boolean, String, Object...)//LC:24602
     *///LC:24603
    public static void isTrue(final boolean expression, final String message, final long value) {//LC:24604
        if (expression == false) {//LC:24605
            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));//LC:24606
        }//LC:24607
    }//LC:24608
//LC:24609
    /**//LC:24610
     * <p>Validate that the argument condition is {@code true}; otherwise//LC:24611
     * throwing an exception with the specified message. This method is useful when//LC:24612
     * validating according to an arbitrary boolean expression, such as validating a//LC:24613
     * primitive number or using your own custom validation expression.</p>//LC:24614
     *//LC:24615
     * <pre>Validate.isTrue(d > 0.0, "The value must be greater than zero: %s", d);</pre>//LC:24616
     *//LC:24617
     * <p>For performance reasons, the double value is passed as a separate parameter and//LC:24618
     * appended to the exception message only in the case of an error.</p>//LC:24619
     *//LC:24620
     * @param expression  the boolean expression to check//LC:24621
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24622
     * @param value  the value to append to the message when invalid//LC:24623
     * @throws IllegalArgumentException if expression is {@code false}//LC:24624
     * @see #isTrue(boolean)//LC:24625
     * @see #isTrue(boolean, String, long)//LC:24626
     * @see #isTrue(boolean, String, Object...)//LC:24627
     *///LC:24628
    public static void isTrue(final boolean expression, final String message, final double value) {//LC:24629
        if (expression == false) {//LC:24630
            throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));//LC:24631
        }//LC:24632
    }//LC:24633
//LC:24634
    /**//LC:24635
     * <p>Validate that the argument condition is {@code true}; otherwise//LC:24636
     * throwing an exception with the specified message. This method is useful when//LC:24637
     * validating according to an arbitrary boolean expression, such as validating a//LC:24638
     * primitive number or using your own custom validation expression.</p>//LC:24639
     *//LC:24640
     * <pre>//LC:24641
     * Validate.isTrue(i >= min && i <= max, "The value must be between %d and %d", min, max);//LC:24642
     * Validate.isTrue(myObject.isOk(), "The object is not okay");</pre>//LC:24643
     *//LC:24644
     * @param expression  the boolean expression to check//LC:24645
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24646
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24647
     * @throws IllegalArgumentException if expression is {@code false}//LC:24648
     * @see #isTrue(boolean)//LC:24649
     * @see #isTrue(boolean, String, long)//LC:24650
     * @see #isTrue(boolean, String, double)//LC:24651
     *///LC:24652
    public static void isTrue(final boolean expression, final String message, final Object... values) {//LC:24653
        if (expression == false) {//LC:24654
            throw new IllegalArgumentException(String.format(message, values));//LC:24655
        }//LC:24656
    }//LC:24657
//LC:24658
    /**//LC:24659
     * <p>Validate that the argument condition is {@code true}; otherwise//LC:24660
     * throwing an exception. This method is useful when validating according//LC:24661
     * to an arbitrary boolean expression, such as validating a//LC:24662
     * primitive number or using your own custom validation expression.</p>//LC:24663
     *//LC:24664
     * <pre>//LC:24665
     * Validate.isTrue(i > 0);//LC:24666
     * Validate.isTrue(myObject.isOk());</pre>//LC:24667
     *//LC:24668
     * <p>The message of the exception is &quot;The validated expression is//LC:24669
     * false&quot;.</p>//LC:24670
     *//LC:24671
     * @param expression  the boolean expression to check//LC:24672
     * @throws IllegalArgumentException if expression is {@code false}//LC:24673
     * @see #isTrue(boolean, String, long)//LC:24674
     * @see #isTrue(boolean, String, double)//LC:24675
     * @see #isTrue(boolean, String, Object...)//LC:24676
     *///LC:24677
    public static void isTrue(final boolean expression) {//LC:24678
        if (expression == false) {//LC:24679
            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);//LC:24680
        }//LC:24681
    }//LC:24682
//LC:24683
    // notNull//LC:24684
    //---------------------------------------------------------------------------------//LC:24685
//LC:24686
    /**//LC:24687
     * <p>Validate that the specified argument is not {@code null};//LC:24688
     * otherwise throwing an exception.//LC:24689
     *//LC:24690
     * <pre>Validate.notNull(myObject, "The object must not be null");</pre>//LC:24691
     *//LC:24692
     * <p>The message of the exception is &quot;The validated object is//LC:24693
     * null&quot;.</p>//LC:24694
     *//LC:24695
     * @param <T> the object type//LC:24696
     * @param object  the object to check//LC:24697
     * @return the validated object (never {@code null} for method chaining)//LC:24698
     * @throws NullPointerException if the object is {@code null}//LC:24699
     * @see #notNull(Object, String, Object...)//LC:24700
     *///LC:24701
    public static <T> T notNull(final T object) {//LC:24702
        return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);//LC:24703
    }//LC:24704
//LC:24705
    /**//LC:24706
     * <p>Validate that the specified argument is not {@code null};//LC:24707
     * otherwise throwing an exception with the specified message.//LC:24708
     *//LC:24709
     * <pre>Validate.notNull(myObject, "The object must not be null");</pre>//LC:24710
     *//LC:24711
     * @param <T> the object type//LC:24712
     * @param object  the object to check//LC:24713
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24714
     * @param values  the optional values for the formatted exception message//LC:24715
     * @return the validated object (never {@code null} for method chaining)//LC:24716
     * @throws NullPointerException if the object is {@code null}//LC:24717
     * @see #notNull(Object)//LC:24718
     *///LC:24719
    public static <T> T notNull(final T object, final String message, final Object... values) {//LC:24720
        if (object == null) {//LC:24721
            throw new NullPointerException(String.format(message, values));//LC:24722
        }//LC:24723
        return object;//LC:24724
    }//LC:24725
//LC:24726
    // notEmpty array//LC:24727
    //---------------------------------------------------------------------------------//LC:24728
//LC:24729
    /**//LC:24730
     * <p>Validate that the specified argument array is neither {@code null}//LC:24731
     * nor a length of zero (no elements); otherwise throwing an exception//LC:24732
     * with the specified message.//LC:24733
     *//LC:24734
     * <pre>Validate.notEmpty(myArray, "The array must not be empty");</pre>//LC:24735
     *//LC:24736
     * @param <T> the array type//LC:24737
     * @param array  the array to check, validated not null by this method//LC:24738
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24739
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24740
     * @return the validated array (never {@code null} method for chaining)//LC:24741
     * @throws NullPointerException if the array is {@code null}//LC:24742
     * @throws IllegalArgumentException if the array is empty//LC:24743
     * @see #notEmpty(Object[])//LC:24744
     *///LC:24745
    public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {//LC:24746
        if (array == null) {//LC:24747
            throw new NullPointerException(String.format(message, values));//LC:24748
        }//LC:24749
        if (array.length == 0) {//LC:24750
            throw new IllegalArgumentException(String.format(message, values));//LC:24751
        }//LC:24752
        return array;//LC:24753
    }//LC:24754
//LC:24755
    /**//LC:24756
     * <p>Validate that the specified argument array is neither {@code null}//LC:24757
     * nor a length of zero (no elements); otherwise throwing an exception.//LC:24758
     *//LC:24759
     * <pre>Validate.notEmpty(myArray);</pre>//LC:24760
     *//LC:24761
     * <p>The message in the exception is &quot;The validated array is//LC:24762
     * empty&quot;.//LC:24763
     *//LC:24764
     * @param <T> the array type//LC:24765
     * @param array  the array to check, validated not null by this method//LC:24766
     * @return the validated array (never {@code null} method for chaining)//LC:24767
     * @throws NullPointerException if the array is {@code null}//LC:24768
     * @throws IllegalArgumentException if the array is empty//LC:24769
     * @see #notEmpty(Object[], String, Object...)//LC:24770
     *///LC:24771
    public static <T> T[] notEmpty(final T[] array) {//LC:24772
        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);//LC:24773
    }//LC:24774
//LC:24775
    // notEmpty collection//LC:24776
    //---------------------------------------------------------------------------------//LC:24777
//LC:24778
    /**//LC:24779
     * <p>Validate that the specified argument collection is neither {@code null}//LC:24780
     * nor a size of zero (no elements); otherwise throwing an exception//LC:24781
     * with the specified message.//LC:24782
     *//LC:24783
     * <pre>Validate.notEmpty(myCollection, "The collection must not be empty");</pre>//LC:24784
     *//LC:24785
     * @param <T> the collection type//LC:24786
     * @param collection  the collection to check, validated not null by this method//LC:24787
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24788
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24789
     * @return the validated collection (never {@code null} method for chaining)//LC:24790
     * @throws NullPointerException if the collection is {@code null}//LC:24791
     * @throws IllegalArgumentException if the collection is empty//LC:24792
     * @see #notEmpty(Object[])//LC:24793
     *///LC:24794
    public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {//LC:24795
        if (collection == null) {//LC:24796
            throw new NullPointerException(String.format(message, values));//LC:24797
        }//LC:24798
        if (collection.isEmpty()) {//LC:24799
            throw new IllegalArgumentException(String.format(message, values));//LC:24800
        }//LC:24801
        return collection;//LC:24802
    }//LC:24803
//LC:24804
    /**//LC:24805
     * <p>Validate that the specified argument collection is neither {@code null}//LC:24806
     * nor a size of zero (no elements); otherwise throwing an exception.//LC:24807
     *//LC:24808
     * <pre>Validate.notEmpty(myCollection);</pre>//LC:24809
     *//LC:24810
     * <p>The message in the exception is &quot;The validated collection is//LC:24811
     * empty&quot;.</p>//LC:24812
     *//LC:24813
     * @param <T> the collection type//LC:24814
     * @param collection  the collection to check, validated not null by this method//LC:24815
     * @return the validated collection (never {@code null} method for chaining)//LC:24816
     * @throws NullPointerException if the collection is {@code null}//LC:24817
     * @throws IllegalArgumentException if the collection is empty//LC:24818
     * @see #notEmpty(Collection, String, Object...)//LC:24819
     *///LC:24820
    public static <T extends Collection<?>> T notEmpty(final T collection) {//LC:24821
        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);//LC:24822
    }//LC:24823
//LC:24824
    // notEmpty map//LC:24825
    //---------------------------------------------------------------------------------//LC:24826
//LC:24827
    /**//LC:24828
     * <p>Validate that the specified argument map is neither {@code null}//LC:24829
     * nor a size of zero (no elements); otherwise throwing an exception//LC:24830
     * with the specified message.//LC:24831
     *//LC:24832
     * <pre>Validate.notEmpty(myMap, "The map must not be empty");</pre>//LC:24833
     *//LC:24834
     * @param <T> the map type//LC:24835
     * @param map  the map to check, validated not null by this method//LC:24836
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24837
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24838
     * @return the validated map (never {@code null} method for chaining)//LC:24839
     * @throws NullPointerException if the map is {@code null}//LC:24840
     * @throws IllegalArgumentException if the map is empty//LC:24841
     * @see #notEmpty(Object[])//LC:24842
     *///LC:24843
    public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) {//LC:24844
        if (map == null) {//LC:24845
            throw new NullPointerException(String.format(message, values));//LC:24846
        }//LC:24847
        if (map.isEmpty()) {//LC:24848
            throw new IllegalArgumentException(String.format(message, values));//LC:24849
        }//LC:24850
        return map;//LC:24851
    }//LC:24852
//LC:24853
    /**//LC:24854
     * <p>Validate that the specified argument map is neither {@code null}//LC:24855
     * nor a size of zero (no elements); otherwise throwing an exception.//LC:24856
     *//LC:24857
     * <pre>Validate.notEmpty(myMap);</pre>//LC:24858
     *//LC:24859
     * <p>The message in the exception is &quot;The validated map is//LC:24860
     * empty&quot;.</p>//LC:24861
     *//LC:24862
     * @param <T> the map type//LC:24863
     * @param map  the map to check, validated not null by this method//LC:24864
     * @return the validated map (never {@code null} method for chaining)//LC:24865
     * @throws NullPointerException if the map is {@code null}//LC:24866
     * @throws IllegalArgumentException if the map is empty//LC:24867
     * @see #notEmpty(Map, String, Object...)//LC:24868
     *///LC:24869
    public static <T extends Map<?, ?>> T notEmpty(final T map) {//LC:24870
        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);//LC:24871
    }//LC:24872
//LC:24873
    // notEmpty string//LC:24874
    //---------------------------------------------------------------------------------//LC:24875
//LC:24876
    /**//LC:24877
     * <p>Validate that the specified argument character sequence is//LC:24878
     * neither {@code null} nor a length of zero (no characters);//LC:24879
     * otherwise throwing an exception with the specified message.//LC:24880
     *//LC:24881
     * <pre>Validate.notEmpty(myString, "The string must not be empty");</pre>//LC:24882
     *//LC:24883
     * @param <T> the character sequence type//LC:24884
     * @param chars  the character sequence to check, validated not null by this method//LC:24885
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24886
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24887
     * @return the validated character sequence (never {@code null} method for chaining)//LC:24888
     * @throws NullPointerException if the character sequence is {@code null}//LC:24889
     * @throws IllegalArgumentException if the character sequence is empty//LC:24890
     * @see #notEmpty(CharSequence)//LC:24891
     *///LC:24892
    public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) {//LC:24893
        if (chars == null) {//LC:24894
            throw new NullPointerException(String.format(message, values));//LC:24895
        }//LC:24896
        if (chars.length() == 0) {//LC:24897
            throw new IllegalArgumentException(String.format(message, values));//LC:24898
        }//LC:24899
        return chars;//LC:24900
    }//LC:24901
//LC:24902
    /**//LC:24903
     * <p>Validate that the specified argument character sequence is//LC:24904
     * neither {@code null} nor a length of zero (no characters);//LC:24905
     * otherwise throwing an exception with the specified message.//LC:24906
     *//LC:24907
     * <pre>Validate.notEmpty(myString);</pre>//LC:24908
     *//LC:24909
     * <p>The message in the exception is &quot;The validated//LC:24910
     * character sequence is empty&quot;.</p>//LC:24911
     *//LC:24912
     * @param <T> the character sequence type//LC:24913
     * @param chars  the character sequence to check, validated not null by this method//LC:24914
     * @return the validated character sequence (never {@code null} method for chaining)//LC:24915
     * @throws NullPointerException if the character sequence is {@code null}//LC:24916
     * @throws IllegalArgumentException if the character sequence is empty//LC:24917
     * @see #notEmpty(CharSequence, String, Object...)//LC:24918
     *///LC:24919
    public static <T extends CharSequence> T notEmpty(final T chars) {//LC:24920
        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);//LC:24921
    }//LC:24922
//LC:24923
    // notBlank string//LC:24924
    //---------------------------------------------------------------------------------//LC:24925
//LC:24926
    /**//LC:24927
     * <p>Validate that the specified argument character sequence is//LC:24928
     * neither {@code null}, a length of zero (no characters), empty//LC:24929
     * nor whitespace; otherwise throwing an exception with the specified//LC:24930
     * message.//LC:24931
     *//LC:24932
     * <pre>Validate.notBlank(myString, "The string must not be blank");</pre>//LC:24933
     *//LC:24934
     * @param <T> the character sequence type//LC:24935
     * @param chars  the character sequence to check, validated not null by this method//LC:24936
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24937
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24938
     * @return the validated character sequence (never {@code null} method for chaining)//LC:24939
     * @throws NullPointerException if the character sequence is {@code null}//LC:24940
     * @throws IllegalArgumentException if the character sequence is blank//LC:24941
     * @see #notBlank(CharSequence)//LC:24942
     *//LC:24943
     * @since 3.0//LC:24944
     *///LC:24945
    public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) {//LC:24946
        if (chars == null) {//LC:24947
            throw new NullPointerException(String.format(message, values));//LC:24948
        }//LC:24949
        if (StringUtils.isBlank(chars)) {//LC:24950
            throw new IllegalArgumentException(String.format(message, values));//LC:24951
        }//LC:24952
        return chars;//LC:24953
    }//LC:24954
//LC:24955
    /**//LC:24956
     * <p>Validate that the specified argument character sequence is//LC:24957
     * neither {@code null}, a length of zero (no characters), empty//LC:24958
     * nor whitespace; otherwise throwing an exception.//LC:24959
     *//LC:24960
     * <pre>Validate.notBlank(myString);</pre>//LC:24961
     *//LC:24962
     * <p>The message in the exception is &quot;The validated character//LC:24963
     * sequence is blank&quot;.</p>//LC:24964
     *//LC:24965
     * @param <T> the character sequence type//LC:24966
     * @param chars  the character sequence to check, validated not null by this method//LC:24967
     * @return the validated character sequence (never {@code null} method for chaining)//LC:24968
     * @throws NullPointerException if the character sequence is {@code null}//LC:24969
     * @throws IllegalArgumentException if the character sequence is blank//LC:24970
     * @see #notBlank(CharSequence, String, Object...)//LC:24971
     *//LC:24972
     * @since 3.0//LC:24973
     *///LC:24974
    public static <T extends CharSequence> T notBlank(final T chars) {//LC:24975
        return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);//LC:24976
    }//LC:24977
//LC:24978
    // noNullElements array//LC:24979
    //---------------------------------------------------------------------------------//LC:24980
//LC:24981
    /**//LC:24982
     * <p>Validate that the specified argument array is neither//LC:24983
     * {@code null} nor contains any elements that are {@code null};//LC:24984
     * otherwise throwing an exception with the specified message.//LC:24985
     *//LC:24986
     * <pre>Validate.noNullElements(myArray, "The array contain null at position %d");</pre>//LC:24987
     *//LC:24988
     * <p>If the array is {@code null}, then the message in the exception//LC:24989
     * is &quot;The validated object is null&quot;.</p>//LC:24990
     *//LC:24991
     * <p>If the array has a {@code null} element, then the iteration//LC:24992
     * index of the invalid element is appended to the {@code values}//LC:24993
     * argument.</p>//LC:24994
     *//LC:24995
     * @param <T> the array type//LC:24996
     * @param array  the array to check, validated not null by this method//LC:24997
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:24998
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:24999
     * @return the validated array (never {@code null} method for chaining)//LC:25000
     * @throws NullPointerException if the array is {@code null}//LC:25001
     * @throws IllegalArgumentException if an element is {@code null}//LC:25002
     * @see #noNullElements(Object[])//LC:25003
     *///LC:25004
    public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) {//LC:25005
        Validate.notNull(array);//LC:25006
        for (int i = 0; i < array.length; i++) {//LC:25007
            if (array[i] == null) {//LC:25008
                final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));//LC:25009
                throw new IllegalArgumentException(String.format(message, values2));//LC:25010
            }//LC:25011
        }//LC:25012
        return array;//LC:25013
    }//LC:25014
//LC:25015
    /**//LC:25016
     * <p>Validate that the specified argument array is neither//LC:25017
     * {@code null} nor contains any elements that are {@code null};//LC:25018
     * otherwise throwing an exception.//LC:25019
     *//LC:25020
     * <pre>Validate.noNullElements(myArray);</pre>//LC:25021
     *//LC:25022
     * <p>If the array is {@code null}, then the message in the exception//LC:25023
     * is &quot;The validated object is null&quot;.</p>//LC:25024
     *//LC:25025
     * <p>If the array has a {@code null} element, then the message in the//LC:25026
     * exception is &quot;The validated array contains null element at index://LC:25027
     * &quot followed by the index.</p>//LC:25028
     *//LC:25029
     * @param <T> the array type//LC:25030
     * @param array  the array to check, validated not null by this method//LC:25031
     * @return the validated array (never {@code null} method for chaining)//LC:25032
     * @throws NullPointerException if the array is {@code null}//LC:25033
     * @throws IllegalArgumentException if an element is {@code null}//LC:25034
     * @see #noNullElements(Object[], String, Object...)//LC:25035
     *///LC:25036
    public static <T> T[] noNullElements(final T[] array) {//LC:25037
        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);//LC:25038
    }//LC:25039
//LC:25040
    // noNullElements iterable//LC:25041
    //---------------------------------------------------------------------------------//LC:25042
//LC:25043
    /**//LC:25044
     * <p>Validate that the specified argument iterable is neither//LC:25045
     * {@code null} nor contains any elements that are {@code null};//LC:25046
     * otherwise throwing an exception with the specified message.//LC:25047
     *//LC:25048
     * <pre>Validate.noNullElements(myCollection, "The collection contains null at position %d");</pre>//LC:25049
     *//LC:25050
     * <p>If the iterable is {@code null}, then the message in the exception//LC:25051
     * is &quot;The validated object is null&quot;.</p>//LC:25052
     *//LC:25053
     * <p>If the iterable has a {@code null} element, then the iteration//LC:25054
     * index of the invalid element is appended to the {@code values}//LC:25055
     * argument.</p>//LC:25056
     *//LC:25057
     * @param <T> the iterable type//LC:25058
     * @param iterable  the iterable to check, validated not null by this method//LC:25059
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25060
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25061
     * @return the validated iterable (never {@code null} method for chaining)//LC:25062
     * @throws NullPointerException if the array is {@code null}//LC:25063
     * @throws IllegalArgumentException if an element is {@code null}//LC:25064
     * @see #noNullElements(Iterable)//LC:25065
     *///LC:25066
    public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {//LC:25067
        Validate.notNull(iterable);//LC:25068
        int i = 0;//LC:25069
        for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {//LC:25070
            if (it.next() == null) {//LC:25071
                final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));//LC:25072
                throw new IllegalArgumentException(String.format(message, values2));//LC:25073
            }//LC:25074
        }//LC:25075
        return iterable;//LC:25076
    }//LC:25077
//LC:25078
    /**//LC:25079
     * <p>Validate that the specified argument iterable is neither//LC:25080
     * {@code null} nor contains any elements that are {@code null};//LC:25081
     * otherwise throwing an exception.//LC:25082
     *//LC:25083
     * <pre>Validate.noNullElements(myCollection);</pre>//LC:25084
     *//LC:25085
     * <p>If the iterable is {@code null}, then the message in the exception//LC:25086
     * is &quot;The validated object is null&quot;.</p>//LC:25087
     *//LC:25088
     * <p>If the array has a {@code null} element, then the message in the//LC:25089
     * exception is &quot;The validated iterable contains null element at index://LC:25090
     * &quot followed by the index.</p>//LC:25091
     *//LC:25092
     * @param <T> the iterable type//LC:25093
     * @param iterable  the iterable to check, validated not null by this method//LC:25094
     * @return the validated iterable (never {@code null} method for chaining)//LC:25095
     * @throws NullPointerException if the array is {@code null}//LC:25096
     * @throws IllegalArgumentException if an element is {@code null}//LC:25097
     * @see #noNullElements(Iterable, String, Object...)//LC:25098
     *///LC:25099
    public static <T extends Iterable<?>> T noNullElements(final T iterable) {//LC:25100
        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);//LC:25101
    }//LC:25102
//LC:25103
    // validIndex array//LC:25104
    //---------------------------------------------------------------------------------//LC:25105
//LC:25106
    /**//LC:25107
     * <p>Validates that the index is within the bounds of the argument//LC:25108
     * array; otherwise throwing an exception with the specified message.</p>//LC:25109
     *//LC:25110
     * <pre>Validate.validIndex(myArray, 2, "The array index is invalid: ");</pre>//LC:25111
     *//LC:25112
     * <p>If the array is {@code null}, then the message of the exception//LC:25113
     * is &quot;The validated object is null&quot;.</p>//LC:25114
     *//LC:25115
     * @param <T> the array type//LC:25116
     * @param array  the array to check, validated not null by this method//LC:25117
     * @param index  the index to check//LC:25118
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25119
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25120
     * @return the validated array (never {@code null} for method chaining)//LC:25121
     * @throws NullPointerException if the array is {@code null}//LC:25122
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25123
     * @see #validIndex(Object[], int)//LC:25124
     *//LC:25125
     * @since 3.0//LC:25126
     *///LC:25127
    public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) {//LC:25128
        Validate.notNull(array);//LC:25129
        if (index < 0 || index >= array.length) {//LC:25130
            throw new IndexOutOfBoundsException(String.format(message, values));//LC:25131
        }//LC:25132
        return array;//LC:25133
    }//LC:25134
//LC:25135
    /**//LC:25136
     * <p>Validates that the index is within the bounds of the argument//LC:25137
     * array; otherwise throwing an exception.</p>//LC:25138
     *//LC:25139
     * <pre>Validate.validIndex(myArray, 2);</pre>//LC:25140
     *//LC:25141
     * <p>If the array is {@code null}, then the message of the exception//LC:25142
     * is &quot;The validated object is null&quot;.</p>//LC:25143
     *//LC:25144
     * <p>If the index is invalid, then the message of the exception is//LC:25145
     * &quot;The validated array index is invalid: &quot; followed by the//LC:25146
     * index.</p>//LC:25147
     *//LC:25148
     * @param <T> the array type//LC:25149
     * @param array  the array to check, validated not null by this method//LC:25150
     * @param index  the index to check//LC:25151
     * @return the validated array (never {@code null} for method chaining)//LC:25152
     * @throws NullPointerException if the array is {@code null}//LC:25153
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25154
     * @see #validIndex(Object[], int, String, Object...)//LC:25155
     *//LC:25156
     * @since 3.0//LC:25157
     *///LC:25158
    public static <T> T[] validIndex(final T[] array, final int index) {//LC:25159
        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));//LC:25160
    }//LC:25161
//LC:25162
    // validIndex collection//LC:25163
    //---------------------------------------------------------------------------------//LC:25164
//LC:25165
    /**//LC:25166
     * <p>Validates that the index is within the bounds of the argument//LC:25167
     * collection; otherwise throwing an exception with the specified message.</p>//LC:25168
     *//LC:25169
     * <pre>Validate.validIndex(myCollection, 2, "The collection index is invalid: ");</pre>//LC:25170
     *//LC:25171
     * <p>If the collection is {@code null}, then the message of the//LC:25172
     * exception is &quot;The validated object is null&quot;.</p>//LC:25173
     *//LC:25174
     * @param <T> the collection type//LC:25175
     * @param collection  the collection to check, validated not null by this method//LC:25176
     * @param index  the index to check//LC:25177
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25178
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25179
     * @return the validated collection (never {@code null} for chaining)//LC:25180
     * @throws NullPointerException if the collection is {@code null}//LC:25181
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25182
     * @see #validIndex(Collection, int)//LC:25183
     *//LC:25184
     * @since 3.0//LC:25185
     *///LC:25186
    public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {//LC:25187
        Validate.notNull(collection);//LC:25188
        if (index < 0 || index >= collection.size()) {//LC:25189
            throw new IndexOutOfBoundsException(String.format(message, values));//LC:25190
        }//LC:25191
        return collection;//LC:25192
    }//LC:25193
//LC:25194
    /**//LC:25195
     * <p>Validates that the index is within the bounds of the argument//LC:25196
     * collection; otherwise throwing an exception.</p>//LC:25197
     *//LC:25198
     * <pre>Validate.validIndex(myCollection, 2);</pre>//LC:25199
     *//LC:25200
     * <p>If the index is invalid, then the message of the exception//LC:25201
     * is &quot;The validated collection index is invalid: &quot;//LC:25202
     * followed by the index.</p>//LC:25203
     *//LC:25204
     * @param <T> the collection type//LC:25205
     * @param collection  the collection to check, validated not null by this method//LC:25206
     * @param index  the index to check//LC:25207
     * @return the validated collection (never {@code null} for method chaining)//LC:25208
     * @throws NullPointerException if the collection is {@code null}//LC:25209
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25210
     * @see #validIndex(Collection, int, String, Object...)//LC:25211
     *//LC:25212
     * @since 3.0//LC:25213
     *///LC:25214
    public static <T extends Collection<?>> T validIndex(final T collection, final int index) {//LC:25215
        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));//LC:25216
    }//LC:25217
//LC:25218
    // validIndex string//LC:25219
    //---------------------------------------------------------------------------------//LC:25220
//LC:25221
    /**//LC:25222
     * <p>Validates that the index is within the bounds of the argument//LC:25223
     * character sequence; otherwise throwing an exception with the//LC:25224
     * specified message.</p>//LC:25225
     *//LC:25226
     * <pre>Validate.validIndex(myStr, 2, "The string index is invalid: ");</pre>//LC:25227
     *//LC:25228
     * <p>If the character sequence is {@code null}, then the message//LC:25229
     * of the exception is &quot;The validated object is null&quot;.</p>//LC:25230
     *//LC:25231
     * @param <T> the character sequence type//LC:25232
     * @param chars  the character sequence to check, validated not null by this method//LC:25233
     * @param index  the index to check//LC:25234
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25235
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25236
     * @return the validated character sequence (never {@code null} for method chaining)//LC:25237
     * @throws NullPointerException if the character sequence is {@code null}//LC:25238
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25239
     * @see #validIndex(CharSequence, int)//LC:25240
     *//LC:25241
     * @since 3.0//LC:25242
     *///LC:25243
    public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) {//LC:25244
        Validate.notNull(chars);//LC:25245
        if (index < 0 || index >= chars.length()) {//LC:25246
            throw new IndexOutOfBoundsException(String.format(message, values));//LC:25247
        }//LC:25248
        return chars;//LC:25249
    }//LC:25250
//LC:25251
    /**//LC:25252
     * <p>Validates that the index is within the bounds of the argument//LC:25253
     * character sequence; otherwise throwing an exception.</p>//LC:25254
     *//LC:25255
     * <pre>Validate.validIndex(myStr, 2);</pre>//LC:25256
     *//LC:25257
     * <p>If the character sequence is {@code null}, then the message//LC:25258
     * of the exception is &quot;The validated object is//LC:25259
     * null&quot;.</p>//LC:25260
     *//LC:25261
     * <p>If the index is invalid, then the message of the exception//LC:25262
     * is &quot;The validated character sequence index is invalid: &quot;//LC:25263
     * followed by the index.</p>//LC:25264
     *//LC:25265
     * @param <T> the character sequence type//LC:25266
     * @param chars  the character sequence to check, validated not null by this method//LC:25267
     * @param index  the index to check//LC:25268
     * @return the validated character sequence (never {@code null} for method chaining)//LC:25269
     * @throws NullPointerException if the character sequence is {@code null}//LC:25270
     * @throws IndexOutOfBoundsException if the index is invalid//LC:25271
     * @see #validIndex(CharSequence, int, String, Object...)//LC:25272
     *//LC:25273
     * @since 3.0//LC:25274
     *///LC:25275
    public static <T extends CharSequence> T validIndex(final T chars, final int index) {//LC:25276
        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));//LC:25277
    }//LC:25278
//LC:25279
    // validState//LC:25280
    //---------------------------------------------------------------------------------//LC:25281
//LC:25282
    /**//LC:25283
     * <p>Validate that the stateful condition is {@code true}; otherwise//LC:25284
     * throwing an exception. This method is useful when validating according//LC:25285
     * to an arbitrary boolean expression, such as validating a//LC:25286
     * primitive number or using your own custom validation expression.</p>//LC:25287
     *//LC:25288
     * <pre>//LC:25289
     * Validate.validState(field > 0);//LC:25290
     * Validate.validState(this.isOk());</pre>//LC:25291
     *//LC:25292
     * <p>The message of the exception is &quot;The validated state is//LC:25293
     * false&quot;.</p>//LC:25294
     *//LC:25295
     * @param expression  the boolean expression to check//LC:25296
     * @throws IllegalStateException if expression is {@code false}//LC:25297
     * @see #validState(boolean, String, Object...)//LC:25298
     *//LC:25299
     * @since 3.0//LC:25300
     *///LC:25301
    public static void validState(final boolean expression) {//LC:25302
        if (expression == false) {//LC:25303
            throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);//LC:25304
        }//LC:25305
    }//LC:25306
//LC:25307
    /**//LC:25308
     * <p>Validate that the stateful condition is {@code true}; otherwise//LC:25309
     * throwing an exception with the specified message. This method is useful when//LC:25310
     * validating according to an arbitrary boolean expression, such as validating a//LC:25311
     * primitive number or using your own custom validation expression.</p>//LC:25312
     *//LC:25313
     * <pre>Validate.validState(this.isOk(), "The state is not OK: %s", myObject);</pre>//LC:25314
     *//LC:25315
     * @param expression  the boolean expression to check//LC:25316
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25317
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25318
     * @throws IllegalStateException if expression is {@code false}//LC:25319
     * @see #validState(boolean)//LC:25320
     *//LC:25321
     * @since 3.0//LC:25322
     *///LC:25323
    public static void validState(final boolean expression, final String message, final Object... values) {//LC:25324
        if (expression == false) {//LC:25325
            throw new IllegalStateException(String.format(message, values));//LC:25326
        }//LC:25327
    }//LC:25328
//LC:25329
    // matchesPattern//LC:25330
    //---------------------------------------------------------------------------------//LC:25331
//LC:25332
    /**//LC:25333
     * <p>Validate that the specified argument character sequence matches the specified regular//LC:25334
     * expression pattern; otherwise throwing an exception.</p>//LC:25335
     *//LC:25336
     * <pre>Validate.matchesPattern("hi", "[a-z]*");</pre>//LC:25337
     *//LC:25338
     * <p>The syntax of the pattern is the one used in the {@link Pattern} class.</p>//LC:25339
     *//LC:25340
     * @param input  the character sequence to validate, not null//LC:25341
     * @param pattern  the regular expression pattern, not null//LC:25342
     * @throws IllegalArgumentException if the character sequence does not match the pattern//LC:25343
     * @see #matchesPattern(CharSequence, String, String, Object...)//LC:25344
     *//LC:25345
     * @since 3.0//LC:25346
     *///LC:25347
    public static void matchesPattern(final CharSequence input, final String pattern) {//LC:25348
        // TODO when breaking BC, consider returning input//LC:25349
        if (Pattern.matches(pattern, input) == false) {//LC:25350
            throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));//LC:25351
        }//LC:25352
    }//LC:25353
//LC:25354
    /**//LC:25355
     * <p>Validate that the specified argument character sequence matches the specified regular//LC:25356
     * expression pattern; otherwise throwing an exception with the specified message.</p>//LC:25357
     *//LC:25358
     * <pre>Validate.matchesPattern("hi", "[a-z]*", "%s does not match %s", "hi" "[a-z]*");</pre>//LC:25359
     *//LC:25360
     * <p>The syntax of the pattern is the one used in the {@link Pattern} class.</p>//LC:25361
     *//LC:25362
     * @param input  the character sequence to validate, not null//LC:25363
     * @param pattern  the regular expression pattern, not null//LC:25364
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25365
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25366
     * @throws IllegalArgumentException if the character sequence does not match the pattern//LC:25367
     * @see #matchesPattern(CharSequence, String)//LC:25368
     *//LC:25369
     * @since 3.0//LC:25370
     *///LC:25371
    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {//LC:25372
        // TODO when breaking BC, consider returning input//LC:25373
        if (Pattern.matches(pattern, input) == false) {//LC:25374
            throw new IllegalArgumentException(String.format(message, values));//LC:25375
        }//LC:25376
    }//LC:25377
//LC:25378
    // inclusiveBetween//LC:25379
    //---------------------------------------------------------------------------------//LC:25380
//LC:25381
    /**//LC:25382
     * <p>Validate that the specified argument object fall between the two//LC:25383
     * inclusive values specified; otherwise, throws an exception.</p>//LC:25384
     *//LC:25385
     * <pre>Validate.inclusiveBetween(0, 2, 1);</pre>//LC:25386
     *//LC:25387
     * @param <T> the type of the argument object//LC:25388
     * @param start  the inclusive start value, not null//LC:25389
     * @param end  the inclusive end value, not null//LC:25390
     * @param value  the object to validate, not null//LC:25391
     * @throws IllegalArgumentException if the value falls outside the boundaries//LC:25392
     * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)//LC:25393
     *//LC:25394
     * @since 3.0//LC:25395
     *///LC:25396
    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) {//LC:25397
        // TODO when breaking BC, consider returning value//LC:25398
        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {//LC:25399
            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));//LC:25400
        }//LC:25401
    }//LC:25402
//LC:25403
    /**//LC:25404
     * <p>Validate that the specified argument object fall between the two//LC:25405
     * inclusive values specified; otherwise, throws an exception with the//LC:25406
     * specified message.</p>//LC:25407
     *//LC:25408
     * <pre>Validate.inclusiveBetween(0, 2, 1, "Not in boundaries");</pre>//LC:25409
     *//LC:25410
     * @param <T> the type of the argument object//LC:25411
     * @param start  the inclusive start value, not null//LC:25412
     * @param end  the inclusive end value, not null//LC:25413
     * @param value  the object to validate, not null//LC:25414
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25415
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25416
     * @throws IllegalArgumentException if the value falls outside the boundaries//LC:25417
     * @see #inclusiveBetween(Object, Object, Comparable)//LC:25418
     *//LC:25419
     * @since 3.0//LC:25420
     *///LC:25421
    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {//LC:25422
        // TODO when breaking BC, consider returning value//LC:25423
        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {//LC:25424
            throw new IllegalArgumentException(String.format(message, values));//LC:25425
        }//LC:25426
    }//LC:25427
//LC:25428
    // exclusiveBetween//LC:25429
    //---------------------------------------------------------------------------------//LC:25430
//LC:25431
    /**//LC:25432
     * <p>Validate that the specified argument object fall between the two//LC:25433
     * exclusive values specified; otherwise, throws an exception.</p>//LC:25434
     *//LC:25435
     * <pre>Validate.exclusiveBetween(0, 2, 1);</pre>//LC:25436
     *//LC:25437
     * @param <T> the type of the argument object//LC:25438
     * @param start  the exclusive start value, not null//LC:25439
     * @param end  the exclusive end value, not null//LC:25440
     * @param value  the object to validate, not null//LC:25441
     * @throws IllegalArgumentException if the value falls outside the boundaries//LC:25442
     * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)//LC:25443
     *//LC:25444
     * @since 3.0//LC:25445
     *///LC:25446
    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) {//LC:25447
        // TODO when breaking BC, consider returning value//LC:25448
        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {//LC:25449
            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));//LC:25450
        }//LC:25451
    }//LC:25452
//LC:25453
    /**//LC:25454
     * <p>Validate that the specified argument object fall between the two//LC:25455
     * exclusive values specified; otherwise, throws an exception with the//LC:25456
     * specified message.</p>//LC:25457
     *//LC:25458
     * <pre>Validate.exclusiveBetween(0, 2, 1, "Not in boundaries");</pre>//LC:25459
     *//LC:25460
     * @param <T> the type of the argument object//LC:25461
     * @param start  the exclusive start value, not null//LC:25462
     * @param end  the exclusive end value, not null//LC:25463
     * @param value  the object to validate, not null//LC:25464
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25465
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25466
     * @throws IllegalArgumentException if the value falls outside the boundaries//LC:25467
     * @see #exclusiveBetween(Object, Object, Comparable)//LC:25468
     *//LC:25469
     * @since 3.0//LC:25470
     *///LC:25471
    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {//LC:25472
        // TODO when breaking BC, consider returning value//LC:25473
        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {//LC:25474
            throw new IllegalArgumentException(String.format(message, values));//LC:25475
        }//LC:25476
    }//LC:25477
//LC:25478
    // isInstanceOf//LC:25479
    //---------------------------------------------------------------------------------//LC:25480
//LC:25481
    /**//LC:25482
     * Validates that the argument is an instance of the specified class, if not throws an exception.//LC:25483
     *//LC:25484
     * <p>This method is useful when validating according to an arbitrary class</p>//LC:25485
     *//LC:25486
     * <pre>Validate.isInstanceOf(OkClass.class, object);</pre>//LC:25487
     *//LC:25488
     * <p>The message of the exception is &quot;Expected type: {type}, actual: {obj_type}&quot;</p>//LC:25489
     *//LC:25490
     * @param type  the class the object must be validated against, not null//LC:25491
     * @param obj  the object to check, null throws an exception//LC:25492
     * @throws IllegalArgumentException if argument is not of specified class//LC:25493
     * @see #isInstanceOf(Class, Object, String, Object...)//LC:25494
     *//LC:25495
     * @since 3.0//LC:25496
     *///LC:25497
    public static void isInstanceOf(final Class<?> type, final Object obj) {//LC:25498
        // TODO when breaking BC, consider returning obj//LC:25499
        if (type.isInstance(obj) == false) {//LC:25500
            throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(),//LC:25501
                    obj == null ? "null" : obj.getClass().getName()));//LC:25502
        }//LC:25503
    }//LC:25504
//LC:25505
    /**//LC:25506
     * <p>Validate that the argument is an instance of the specified class; otherwise//LC:25507
     * throwing an exception with the specified message. This method is useful when//LC:25508
     * validating according to an arbitrary class</p>//LC:25509
     *//LC:25510
     * <pre>Validate.isInstanceOf(OkClass.classs, object, "Wrong class, object is of class %s",//LC:25511
     *   object.getClass().getName());</pre>//LC:25512
     *//LC:25513
     * @param type  the class the object must be validated against, not null//LC:25514
     * @param obj  the object to check, null throws an exception//LC:25515
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25516
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25517
     * @throws IllegalArgumentException if argument is not of specified class//LC:25518
     * @see #isInstanceOf(Class, Object)//LC:25519
     *//LC:25520
     * @since 3.0//LC:25521
     *///LC:25522
    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {//LC:25523
        // TODO when breaking BC, consider returning obj//LC:25524
        if (type.isInstance(obj) == false) {//LC:25525
            throw new IllegalArgumentException(String.format(message, values));//LC:25526
        }//LC:25527
    }//LC:25528
//LC:25529
    // isAssignableFrom//LC:25530
    //---------------------------------------------------------------------------------//LC:25531
//LC:25532
    /**//LC:25533
     * Validates that the argument can be converted to the specified class, if not, throws an exception.//LC:25534
     *//LC:25535
     * <p>This method is useful when validating that there will be no casting errors.</p>//LC:25536
     *//LC:25537
     * <pre>Validate.isAssignableFrom(SuperClass.class, object.getClass());</pre>//LC:25538
     *//LC:25539
     * <p>The message format of the exception is &quot;Cannot assign {type} to {superType}&quot;</p>//LC:25540
     *//LC:25541
     * @param superType  the class the class must be validated against, not null//LC:25542
     * @param type  the class to check, not null//LC:25543
     * @throws IllegalArgumentException if type argument is not assignable to the specified superType//LC:25544
     * @see #isAssignableFrom(Class, Class, String, Object...)//LC:25545
     *//LC:25546
     * @since 3.0//LC:25547
     *///LC:25548
    public static void isAssignableFrom(final Class<?> superType, final Class<?> type) {//LC:25549
        // TODO when breaking BC, consider returning type//LC:25550
        if (superType.isAssignableFrom(type) == false) {//LC:25551
            throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? "null" : type.getName(),//LC:25552
                    superType.getName()));//LC:25553
        }//LC:25554
    }//LC:25555
//LC:25556
    /**//LC:25557
     * Validates that the argument can be converted to the specified class, if not throws an exception.//LC:25558
     *//LC:25559
     * <p>This method is useful when validating if there will be no casting errors.</p>//LC:25560
     *//LC:25561
     * <pre>Validate.isAssignableFrom(SuperClass.class, object.getClass());</pre>//LC:25562
     *//LC:25563
     * <p>The message of the exception is &quot;The validated object can not be converted to the&quot;//LC:25564
     * followed by the name of the class and &quot;class&quot;</p>//LC:25565
     *//LC:25566
     * @param superType  the class the class must be validated against, not null//LC:25567
     * @param type  the class to check, not null//LC:25568
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null//LC:25569
     * @param values  the optional values for the formatted exception message, null array not recommended//LC:25570
     * @throws IllegalArgumentException if argument can not be converted to the specified class//LC:25571
     * @see #isAssignableFrom(Class, Class)//LC:25572
     *///LC:25573
    public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {//LC:25574
        // TODO when breaking BC, consider returning type//LC:25575
        if (superType.isAssignableFrom(type) == false) {//LC:25576
            throw new IllegalArgumentException(String.format(message, values));//LC:25577
        }//LC:25578
    }//LC:25579
}//LC:25580
//LC:25581
//LC:25582
//LC:25583
/**//LC:25584
 * <p>Operates on classes without using reflection.</p>//LC:25585
 *//LC:25586
 * <p>This class handles invalid {@code null} inputs as best it can.//LC:25587
 * Each method documents its behaviour in more detail.</p>//LC:25588
 *//LC:25589
 * <p>The notion of a {@code canonical name} includes the human//LC:25590
 * readable name for the type, for example {@code int[]}. The//LC:25591
 * non-canonical method variants work with the JVM names, such as//LC:25592
 * {@code [I}. </p>//LC:25593
 *//LC:25594
 * @since 2.0//LC:25595
 * @version $Id$//LC:25596
 *///LC:25597
class ClassUtils {//LC:25598
//LC:25599
    /**//LC:25600
     * The package separator character: <code>'&#x2e;' == {@value}</code>.//LC:25601
     *///LC:25602
    public static final char PACKAGE_SEPARATOR_CHAR = '.';//LC:25603
//LC:25604
    /**//LC:25605
     * The package separator String: <code>"&#x2e;"</code>.//LC:25606
     *///LC:25607
    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);//LC:25608
//LC:25609
    /**//LC:25610
     * The inner class separator character: <code>'$' == {@value}</code>.//LC:25611
     *///LC:25612
    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';//LC:25613
//LC:25614
    /**//LC:25615
     * The inner class separator String: {@code "$"}.//LC:25616
     *///LC:25617
    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);//LC:25618
//LC:25619
    /**//LC:25620
     * Maps primitive {@code Class}es to their corresponding wrapper {@code Class}.//LC:25621
     *///LC:25622
    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>();//LC:25623
    static {//LC:25624
        primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);//LC:25625
        primitiveWrapperMap.put(Byte.TYPE, Byte.class);//LC:25626
        primitiveWrapperMap.put(Character.TYPE, Character.class);//LC:25627
        primitiveWrapperMap.put(Short.TYPE, Short.class);//LC:25628
        primitiveWrapperMap.put(Integer.TYPE, Integer.class);//LC:25629
        primitiveWrapperMap.put(Long.TYPE, Long.class);//LC:25630
        primitiveWrapperMap.put(Double.TYPE, Double.class);//LC:25631
        primitiveWrapperMap.put(Float.TYPE, Float.class);//LC:25632
        primitiveWrapperMap.put(Void.TYPE, Void.TYPE);//LC:25633
    }//LC:25634
//LC:25635
    /**//LC:25636
     * Maps wrapper {@code Class}es to their corresponding primitive types.//LC:25637
     *///LC:25638
    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();//LC:25639
    static {//LC:25640
        for (final Class<?> primitiveClass : primitiveWrapperMap.keySet()) {//LC:25641
            final Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);//LC:25642
            if (!primitiveClass.equals(wrapperClass)) {//LC:25643
                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);//LC:25644
            }//LC:25645
        }//LC:25646
    }//LC:25647
//LC:25648
    /**//LC:25649
     * Maps a primitive class name to its corresponding abbreviation used in array class names.//LC:25650
     *///LC:25651
    private static final Map<String, String> abbreviationMap = new HashMap<String, String>();//LC:25652
//LC:25653
    /**//LC:25654
     * Maps an abbreviation used in array class names to corresponding primitive class name.//LC:25655
     *///LC:25656
    private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>();//LC:25657
//LC:25658
    /**//LC:25659
     * Add primitive type abbreviation to maps of abbreviations.//LC:25660
     *//LC:25661
     * @param primitive Canonical name of primitive type//LC:25662
     * @param abbreviation Corresponding abbreviation of primitive type//LC:25663
     *///LC:25664
    private static void addAbbreviation(final String primitive, final String abbreviation) {//LC:25665
        abbreviationMap.put(primitive, abbreviation);//LC:25666
        reverseAbbreviationMap.put(abbreviation, primitive);//LC:25667
    }//LC:25668
//LC:25669
    /**//LC:25670
     * Feed abbreviation maps//LC:25671
     *///LC:25672
    static {//LC:25673
        addAbbreviation("int", "I");//LC:25674
        addAbbreviation("boolean", "Z");//LC:25675
        addAbbreviation("float", "F");//LC:25676
        addAbbreviation("long", "J");//LC:25677
        addAbbreviation("short", "S");//LC:25678
        addAbbreviation("byte", "B");//LC:25679
        addAbbreviation("double", "D");//LC:25680
        addAbbreviation("char", "C");//LC:25681
    }//LC:25682
//LC:25683
    /**//LC:25684
     * <p>ClassUtils instances should NOT be constructed in standard programming.//LC:25685
     * Instead, the class should be used as//LC:25686
     * {@code ClassUtils.getShortClassName(cls)}.</p>//LC:25687
     *//LC:25688
     * <p>This constructor is public to permit tools that require a JavaBean//LC:25689
     * instance to operate.</p>//LC:25690
     *///LC:25691
    public ClassUtils() {//LC:25692
        super();//LC:25693
    }//LC:25694
//LC:25695
    // Short class name//LC:25696
    // ----------------------------------------------------------------------//LC:25697
    /**//LC:25698
     * <p>Gets the class name minus the package name for an {@code Object}.</p>//LC:25699
     *//LC:25700
     * @param object  the class to get the short name for, may be null//LC:25701
     * @param valueIfNull  the value to return if null//LC:25702
     * @return the class name of the object without the package name, or the null value//LC:25703
     *///LC:25704
    public static String getShortClassName(final Object object, final String valueIfNull) {//LC:25705
        if (object == null) {//LC:25706
            return valueIfNull;//LC:25707
        }//LC:25708
        return getShortClassName(object.getClass());//LC:25709
    }//LC:25710
//LC:25711
    /**//LC:25712
     * <p>Gets the class name minus the package name from a {@code Class}.</p>//LC:25713
     *//LC:25714
     * <p>Consider using the Java 5 API {@link Class#getSimpleName()} instead.//LC:25715
     * The one known difference is that this code will return {@code "Map.Entry"} while//LC:25716
     * the {@code java.lang.Class} variant will simply return {@code "Entry"}. </p>//LC:25717
     *//LC:25718
     * @param cls  the class to get the short name for.//LC:25719
     * @return the class name without the package name or an empty string//LC:25720
     *///LC:25721
    public static String getShortClassName(final Class<?> cls) {//LC:25722
        if (cls == null) {//LC:25723
            return StringUtils.EMPTY;//LC:25724
        }//LC:25725
        return getShortClassName(cls.getName());//LC:25726
    }//LC:25727
//LC:25728
    /**//LC:25729
     * <p>Gets the class name minus the package name from a String.</p>//LC:25730
     *//LC:25731
     * <p>The string passed in is assumed to be a class name - it is not checked.</p>//LC:25732
//LC:25733
     * <p>Note that this method differs from Class.getSimpleName() in that this will//LC:25734
     * return {@code "Map.Entry"} whilst the {@code java.lang.Class} variant will simply//LC:25735
     * return {@code "Entry"}. </p>//LC:25736
     *//LC:25737
     * @param className  the className to get the short name for//LC:25738
     * @return the class name of the class without the package name or an empty string//LC:25739
     *///LC:25740
    public static String getShortClassName(String className) {//LC:25741
        if (StringUtils.isEmpty(className)) {//LC:25742
            return StringUtils.EMPTY;//LC:25743
        }//LC:25744
//LC:25745
        final StringBuilder arrayPrefix = new StringBuilder();//LC:25746
//LC:25747
        // Handle array encoding//LC:25748
        if (className.startsWith("[")) {//LC:25749
            while (className.charAt(0) == '[') {//LC:25750
                className = className.substring(1);//LC:25751
                arrayPrefix.append("[]");//LC:25752
            }//LC:25753
            // Strip Object type encoding//LC:25754
            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {//LC:25755
                className = className.substring(1, className.length() - 1);//LC:25756
            }//LC:25757
//LC:25758
            if (reverseAbbreviationMap.containsKey(className)) {//LC:25759
                className = reverseAbbreviationMap.get(className);//LC:25760
            }//LC:25761
        }//LC:25762
//LC:25763
        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);//LC:25764
        final int innerIdx = className.indexOf(//LC:25765
                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);//LC:25766
        String out = className.substring(lastDotIdx + 1);//LC:25767
        if (innerIdx != -1) {//LC:25768
            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);//LC:25769
        }//LC:25770
        return out + arrayPrefix;//LC:25771
    }//LC:25772
//LC:25773
    /**//LC:25774
     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>//LC:25775
     *//LC:25776
     * @param cls the class for which to get the simple name.//LC:25777
     * @return the simple class name.//LC:25778
     * @since 3.0//LC:25779
     * @see Class#getSimpleName()//LC:25780
     *///LC:25781
    public static String getSimpleName(final Class<?> cls) {//LC:25782
        if (cls == null) {//LC:25783
            return StringUtils.EMPTY;//LC:25784
        }//LC:25785
        return cls.getSimpleName();//LC:25786
    }//LC:25787
//LC:25788
    /**//LC:25789
     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>//LC:25790
     *//LC:25791
     * @param object the object for which to get the simple class name.//LC:25792
     * @param valueIfNull the value to return if <code>object</code> is <code>null</code>//LC:25793
     * @return the simple class name.//LC:25794
     * @since 3.0//LC:25795
     * @see Class#getSimpleName()//LC:25796
     *///LC:25797
    public static String getSimpleName(final Object object, final String valueIfNull) {//LC:25798
        if (object == null) {//LC:25799
            return valueIfNull;//LC:25800
        }//LC:25801
        return getSimpleName(object.getClass());//LC:25802
    }//LC:25803
//LC:25804
    // Package name//LC:25805
    // ----------------------------------------------------------------------//LC:25806
    /**//LC:25807
     * <p>Gets the package name of an {@code Object}.</p>//LC:25808
     *//LC:25809
     * @param object  the class to get the package name for, may be null//LC:25810
     * @param valueIfNull  the value to return if null//LC:25811
     * @return the package name of the object, or the null value//LC:25812
     *///LC:25813
    public static String getPackageName(final Object object, final String valueIfNull) {//LC:25814
        if (object == null) {//LC:25815
            return valueIfNull;//LC:25816
        }//LC:25817
        return getPackageName(object.getClass());//LC:25818
    }//LC:25819
//LC:25820
    /**//LC:25821
     * <p>Gets the package name of a {@code Class}.</p>//LC:25822
     *//LC:25823
     * @param cls  the class to get the package name for, may be {@code null}.//LC:25824
     * @return the package name or an empty string//LC:25825
     *///LC:25826
    public static String getPackageName(final Class<?> cls) {//LC:25827
        if (cls == null) {//LC:25828
            return StringUtils.EMPTY;//LC:25829
        }//LC:25830
        return getPackageName(cls.getName());//LC:25831
    }//LC:25832
//LC:25833
    /**//LC:25834
     * <p>Gets the package name from a {@code String}.</p>//LC:25835
     *//LC:25836
     * <p>The string passed in is assumed to be a class name - it is not checked.</p>//LC:25837
     * <p>If the class is unpackaged, return an empty string.</p>//LC:25838
     *//LC:25839
     * @param className  the className to get the package name for, may be {@code null}//LC:25840
     * @return the package name or an empty string//LC:25841
     *///LC:25842
    public static String getPackageName(String className) {//LC:25843
        if (StringUtils.isEmpty(className)) {//LC:25844
            return StringUtils.EMPTY;//LC:25845
        }//LC:25846
//LC:25847
        // Strip array encoding//LC:25848
        while (className.charAt(0) == '[') {//LC:25849
            className = className.substring(1);//LC:25850
        }//LC:25851
        // Strip Object type encoding//LC:25852
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {//LC:25853
            className = className.substring(1);//LC:25854
        }//LC:25855
//LC:25856
        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);//LC:25857
        if (i == -1) {//LC:25858
            return StringUtils.EMPTY;//LC:25859
        }//LC:25860
        return className.substring(0, i);//LC:25861
    }//LC:25862
//LC:25863
    // Superclasses/Superinterfaces//LC:25864
    // ----------------------------------------------------------------------//LC:25865
    /**//LC:25866
     * <p>Gets a {@code List} of superclasses for the given class.</p>//LC:25867
     *//LC:25868
     * @param cls  the class to look up, may be {@code null}//LC:25869
     * @return the {@code List} of superclasses in order going up from this one//LC:25870
     *  {@code null} if null input//LC:25871
     *///LC:25872
    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {//LC:25873
        if (cls == null) {//LC:25874
            return null;//LC:25875
        }//LC:25876
        final List<Class<?>> classes = new ArrayList<Class<?>>();//LC:25877
        Class<?> superclass = cls.getSuperclass();//LC:25878
        while (superclass != null) {//LC:25879
            classes.add(superclass);//LC:25880
            superclass = superclass.getSuperclass();//LC:25881
        }//LC:25882
        return classes;//LC:25883
    }//LC:25884
//LC:25885
    /**//LC:25886
     * <p>Gets a {@code List} of all interfaces implemented by the given//LC:25887
     * class and its superclasses.</p>//LC:25888
     *//LC:25889
     * <p>The order is determined by looking through each interface in turn as//LC:25890
     * declared in the source file and following its hierarchy up. Then each//LC:25891
     * superclass is considered in the same way. Later duplicates are ignored,//LC:25892
     * so the order is maintained.</p>//LC:25893
     *//LC:25894
     * @param cls  the class to look up, may be {@code null}//LC:25895
     * @return the {@code List} of interfaces in order,//LC:25896
     *  {@code null} if null input//LC:25897
     *///LC:25898
    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {//LC:25899
        if (cls == null) {//LC:25900
            return null;//LC:25901
        }//LC:25902
//LC:25903
        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();//LC:25904
        getAllInterfaces(cls, interfacesFound);//LC:25905
//LC:25906
        return new ArrayList<Class<?>>(interfacesFound);//LC:25907
    }//LC:25908
//LC:25909
    /**//LC:25910
     * Get the interfaces for the specified class.//LC:25911
     *//LC:25912
     * @param cls  the class to look up, may be {@code null}//LC:25913
     * @param interfacesFound the {@code Set} of interfaces for the class//LC:25914
     *///LC:25915
    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {//LC:25916
        while (cls != null) {//LC:25917
            final Class<?>[] interfaces = cls.getInterfaces();//LC:25918
//LC:25919
            for (final Class<?> i : interfaces) {//LC:25920
                if (interfacesFound.add(i)) {//LC:25921
                    getAllInterfaces(i, interfacesFound);//LC:25922
                }//LC:25923
            }//LC:25924
//LC:25925
            cls = cls.getSuperclass();//LC:25926
        }//LC:25927
    }//LC:25928
//LC:25929
    // Convert list//LC:25930
    // ----------------------------------------------------------------------//LC:25931
    /**//LC:25932
     * <p>Given a {@code List} of class names, this method converts them into classes.</p>//LC:25933
     *//LC:25934
     * <p>A new {@code List} is returned. If the class name cannot be found, {@code null}//LC:25935
     * is stored in the {@code List}. If the class name in the {@code List} is//LC:25936
     * {@code null}, {@code null} is stored in the output {@code List}.</p>//LC:25937
     *//LC:25938
     * @param classNames  the classNames to change//LC:25939
     * @return a {@code List} of Class objects corresponding to the class names,//LC:25940
     *  {@code null} if null input//LC:25941
     * @throws ClassCastException if classNames contains a non String entry//LC:25942
     *///LC:25943
    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {//LC:25944
        if (classNames == null) {//LC:25945
            return null;//LC:25946
        }//LC:25947
        final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());//LC:25948
        for (final String className : classNames) {//LC:25949
            try {//LC:25950
                classes.add(Class.forName(className));//LC:25951
            } catch (final Exception ex) {//LC:25952
                classes.add(null);//LC:25953
            }//LC:25954
        }//LC:25955
        return classes;//LC:25956
    }//LC:25957
//LC:25958
    /**//LC:25959
     * <p>Given a {@code List} of {@code Class} objects, this method converts//LC:25960
     * them into class names.</p>//LC:25961
     *//LC:25962
     * <p>A new {@code List} is returned. {@code null} objects will be copied into//LC:25963
     * the returned list as {@code null}.</p>//LC:25964
     *//LC:25965
     * @param classes  the classes to change//LC:25966
     * @return a {@code List} of class names corresponding to the Class objects,//LC:25967
     *  {@code null} if null input//LC:25968
     * @throws ClassCastException if {@code classes} contains a non-{@code Class} entry//LC:25969
     *///LC:25970
    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {//LC:25971
        if (classes == null) {//LC:25972
            return null;//LC:25973
        }//LC:25974
        final List<String> classNames = new ArrayList<String>(classes.size());//LC:25975
        for (final Class<?> cls : classes) {//LC:25976
            if (cls == null) {//LC:25977
                classNames.add(null);//LC:25978
            } else {//LC:25979
                classNames.add(cls.getName());//LC:25980
            }//LC:25981
        }//LC:25982
        return classNames;//LC:25983
    }//LC:25984
//LC:25985
    // Is assignable//LC:25986
    // ----------------------------------------------------------------------//LC:25987
    /**//LC:25988
     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>//LC:25989
     *//LC:25990
     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each//LC:25991
     * Class pair in the input arrays. It can be used to check if a set of arguments//LC:25992
     * (the first parameter) are suitably compatible with a set of method parameter types//LC:25993
     * (the second parameter).</p>//LC:25994
     *//LC:25995
     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this//LC:25996
     * method takes into account widenings of primitive classes and//LC:25997
     * {@code null}s.</p>//LC:25998
     *//LC:25999
     * <p>Primitive widenings allow an int to be assigned to a {@code long},//LC:26000
     * {@code float} or {@code double}. This method returns the correct//LC:26001
     * result for these cases.</p>//LC:26002
     *//LC:26003
     * <p>{@code Null} may be assigned to any reference type. This method will//LC:26004
     * return {@code true} if {@code null} is passed in and the toClass is//LC:26005
     * non-primitive.</p>//LC:26006
     *//LC:26007
     * <p>Specifically, this method tests whether the type represented by the//LC:26008
     * specified {@code Class} parameter can be converted to the type//LC:26009
     * represented by this {@code Class} object via an identity conversion//LC:26010
     * widening primitive or widening reference conversion. See//LC:26011
     * <em><a href="http://docs.oracle.com/javase/specs/">The Java Language Specification</a></em>,//LC:26012
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>//LC:26013
     *//LC:26014
     * <p><strong>Since Lang 3.0,</strong> this method will default behavior for//LC:26015
     * calculating assignability between primitive and wrapper types <em>corresponding//LC:26016
     * to the running Java version</em>; i.e. autoboxing will be the default//LC:26017
     * behavior in VMs running Java versions >= 1.5.</p>//LC:26018
     *//LC:26019
     * @param classArray  the array of Classes to check, may be {@code null}//LC:26020
     * @param toClassArray  the array of Classes to try to assign into, may be {@code null}//LC:26021
     * @return {@code true} if assignment possible//LC:26022
     *///LC:26023
    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {//LC:26024
        return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));//LC:26025
    }//LC:26026
//LC:26027
    /**//LC:26028
     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>//LC:26029
     *//LC:26030
     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each//LC:26031
     * Class pair in the input arrays. It can be used to check if a set of arguments//LC:26032
     * (the first parameter) are suitably compatible with a set of method parameter types//LC:26033
     * (the second parameter).</p>//LC:26034
     *//LC:26035
     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this//LC:26036
     * method takes into account widenings of primitive classes and//LC:26037
     * {@code null}s.</p>//LC:26038
     *//LC:26039
     * <p>Primitive widenings allow an int to be assigned to a {@code long},//LC:26040
     * {@code float} or {@code double}. This method returns the correct//LC:26041
     * result for these cases.</p>//LC:26042
     *//LC:26043
     * <p>{@code Null} may be assigned to any reference type. This method will//LC:26044
     * return {@code true} if {@code null} is passed in and the toClass is//LC:26045
     * non-primitive.</p>//LC:26046
     *//LC:26047
     * <p>Specifically, this method tests whether the type represented by the//LC:26048
     * specified {@code Class} parameter can be converted to the type//LC:26049
     * represented by this {@code Class} object via an identity conversion//LC:26050
     * widening primitive or widening reference conversion. See//LC:26051
     * <em><a href="http://docs.oracle.com/javase/specs/">The Java Language Specification</a></em>,//LC:26052
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>//LC:26053
     *//LC:26054
     * @param classArray  the array of Classes to check, may be {@code null}//LC:26055
     * @param toClassArray  the array of Classes to try to assign into, may be {@code null}//LC:26056
     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers//LC:26057
     * @return {@code true} if assignment possible//LC:26058
     *///LC:26059
    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {//LC:26060
        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {//LC:26061
            return false;//LC:26062
        }//LC:26063
        if (classArray == null) {//LC:26064
            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;//LC:26065
        }//LC:26066
        if (toClassArray == null) {//LC:26067
            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;//LC:26068
        }//LC:26069
        for (int i = 0; i < classArray.length; i++) {//LC:26070
            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {//LC:26071
                return false;//LC:26072
            }//LC:26073
        }//LC:26074
        return true;//LC:26075
    }//LC:26076
//LC:26077
    /**//LC:26078
     * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},//LC:26079
     * {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).//LC:26080
     *//LC:26081
     * @param type//LC:26082
     *            The class to query or null.//LC:26083
     * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},//LC:26084
     *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).//LC:26085
     * @since 3.1//LC:26086
     *///LC:26087
    public static boolean isPrimitiveOrWrapper(final Class<?> type) {//LC:26088
        if (type == null) {//LC:26089
            return false;//LC:26090
        }//LC:26091
        return type.isPrimitive() || isPrimitiveWrapper(type);//LC:26092
    }//LC:26093
//LC:26094
    /**//LC:26095
     * Returns whether the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character}, {@link Short},//LC:26096
     * {@link Integer}, {@link Long}, {@link Double}, {@link Float}).//LC:26097
     *//LC:26098
     * @param type//LC:26099
     *            The class to query or null.//LC:26100
     * @return true if the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character}, {@link Short},//LC:26101
     *         {@link Integer}, {@link Long}, {@link Double}, {@link Float}).//LC:26102
     * @since 3.1//LC:26103
     *///LC:26104
    public static boolean isPrimitiveWrapper(final Class<?> type) {//LC:26105
        return wrapperPrimitiveMap.containsKey(type);//LC:26106
    }//LC:26107
//LC:26108
    /**//LC:26109
     * <p>Checks if one {@code Class} can be assigned to a variable of//LC:26110
     * another {@code Class}.</p>//LC:26111
     *//LC:26112
     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,//LC:26113
     * this method takes into account widenings of primitive classes and//LC:26114
     * {@code null}s.</p>//LC:26115
     *//LC:26116
     * <p>Primitive widenings allow an int to be assigned to a long, float or//LC:26117
     * double. This method returns the correct result for these cases.</p>//LC:26118
     *//LC:26119
     * <p>{@code Null} may be assigned to any reference type. This method//LC:26120
     * will return {@code true} if {@code null} is passed in and the//LC:26121
     * toClass is non-primitive.</p>//LC:26122
     *//LC:26123
     * <p>Specifically, this method tests whether the type represented by the//LC:26124
     * specified {@code Class} parameter can be converted to the type//LC:26125
     * represented by this {@code Class} object via an identity conversion//LC:26126
     * widening primitive or widening reference conversion. See//LC:26127
     * <em><a href="http://docs.oracle.com/javase/specs/">The Java Language Specification</a></em>,//LC:26128
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>//LC:26129
     *//LC:26130
     * <p><strong>Since Lang 3.0,</strong> this method will default behavior for//LC:26131
     * calculating assignability between primitive and wrapper types <em>corresponding//LC:26132
     * to the running Java version</em>; i.e. autoboxing will be the default//LC:26133
     * behavior in VMs running Java versions >= 1.5.</p>//LC:26134
     *//LC:26135
     * @param cls  the Class to check, may be null//LC:26136
     * @param toClass  the Class to try to assign into, returns false if null//LC:26137
     * @return {@code true} if assignment possible//LC:26138
     *///LC:26139
    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {//LC:26140
        return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));//LC:26141
    }//LC:26142
//LC:26143
    /**//LC:26144
     * <p>Checks if one {@code Class} can be assigned to a variable of//LC:26145
     * another {@code Class}.</p>//LC:26146
     *//LC:26147
     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,//LC:26148
     * this method takes into account widenings of primitive classes and//LC:26149
     * {@code null}s.</p>//LC:26150
     *//LC:26151
     * <p>Primitive widenings allow an int to be assigned to a long, float or//LC:26152
     * double. This method returns the correct result for these cases.</p>//LC:26153
     *//LC:26154
     * <p>{@code Null} may be assigned to any reference type. This method//LC:26155
     * will return {@code true} if {@code null} is passed in and the//LC:26156
     * toClass is non-primitive.</p>//LC:26157
     *//LC:26158
     * <p>Specifically, this method tests whether the type represented by the//LC:26159
     * specified {@code Class} parameter can be converted to the type//LC:26160
     * represented by this {@code Class} object via an identity conversion//LC:26161
     * widening primitive or widening reference conversion. See//LC:26162
     * <em><a href="http://docs.oracle.com/javase/specs/">The Java Language Specification</a></em>,//LC:26163
     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>//LC:26164
     *//LC:26165
     * @param cls  the Class to check, may be null//LC:26166
     * @param toClass  the Class to try to assign into, returns false if null//LC:26167
     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers//LC:26168
     * @return {@code true} if assignment possible//LC:26169
     *///LC:26170
    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {//LC:26171
        if (toClass == null) {//LC:26172
            return false;//LC:26173
        }//LC:26174
        // have to check for null, as isAssignableFrom doesn't//LC:26175
        if (cls == null) {//LC:26176
            return !toClass.isPrimitive();//LC:26177
        }//LC:26178
        //autoboxing://LC:26179
        if (autoboxing) {//LC:26180
            if (cls.isPrimitive() && !toClass.isPrimitive()) {//LC:26181
                cls = primitiveToWrapper(cls);//LC:26182
                if (cls == null) {//LC:26183
                    return false;//LC:26184
                }//LC:26185
            }//LC:26186
            if (toClass.isPrimitive() && !cls.isPrimitive()) {//LC:26187
                cls = wrapperToPrimitive(cls);//LC:26188
                if (cls == null) {//LC:26189
                    return false;//LC:26190
                }//LC:26191
            }//LC:26192
        }//LC:26193
        if (cls.equals(toClass)) {//LC:26194
            return true;//LC:26195
        }//LC:26196
        if (cls.isPrimitive()) {//LC:26197
            if (toClass.isPrimitive() == false) {//LC:26198
                return false;//LC:26199
            }//LC:26200
            if (Integer.TYPE.equals(cls)) {//LC:26201
                return Long.TYPE.equals(toClass)//LC:26202
                        || Float.TYPE.equals(toClass)//LC:26203
                        || Double.TYPE.equals(toClass);//LC:26204
            }//LC:26205
            if (Long.TYPE.equals(cls)) {//LC:26206
                return Float.TYPE.equals(toClass)//LC:26207
                        || Double.TYPE.equals(toClass);//LC:26208
            }//LC:26209
            if (Boolean.TYPE.equals(cls)) {//LC:26210
                return false;//LC:26211
            }//LC:26212
            if (Double.TYPE.equals(cls)) {//LC:26213
                return false;//LC:26214
            }//LC:26215
            if (Float.TYPE.equals(cls)) {//LC:26216
                return Double.TYPE.equals(toClass);//LC:26217
            }//LC:26218
            if (Character.TYPE.equals(cls)) {//LC:26219
                return Integer.TYPE.equals(toClass)//LC:26220
                        || Long.TYPE.equals(toClass)//LC:26221
                        || Float.TYPE.equals(toClass)//LC:26222
                        || Double.TYPE.equals(toClass);//LC:26223
            }//LC:26224
            if (Short.TYPE.equals(cls)) {//LC:26225
                return Integer.TYPE.equals(toClass)//LC:26226
                        || Long.TYPE.equals(toClass)//LC:26227
                        || Float.TYPE.equals(toClass)//LC:26228
                        || Double.TYPE.equals(toClass);//LC:26229
            }//LC:26230
            if (Byte.TYPE.equals(cls)) {//LC:26231
                return Short.TYPE.equals(toClass)//LC:26232
                        || Integer.TYPE.equals(toClass)//LC:26233
                        || Long.TYPE.equals(toClass)//LC:26234
                        || Float.TYPE.equals(toClass)//LC:26235
                        || Double.TYPE.equals(toClass);//LC:26236
            }//LC:26237
            // should never get here//LC:26238
            return false;//LC:26239
        }//LC:26240
        return toClass.isAssignableFrom(cls);//LC:26241
    }//LC:26242
//LC:26243
    /**//LC:26244
     * <p>Converts the specified primitive Class object to its corresponding//LC:26245
     * wrapper Class object.</p>//LC:26246
     *//LC:26247
     * <p>NOTE: From v2.2, this method handles {@code Void.TYPE},//LC:26248
     * returning {@code Void.TYPE}.</p>//LC:26249
     *//LC:26250
     * @param cls  the class to convert, may be null//LC:26251
     * @return the wrapper class for {@code cls} or {@code cls} if//LC:26252
     * {@code cls} is not a primitive. {@code null} if null input.//LC:26253
     * @since 2.1//LC:26254
     *///LC:26255
    public static Class<?> primitiveToWrapper(final Class<?> cls) {//LC:26256
        Class<?> convertedClass = cls;//LC:26257
        if (cls != null && cls.isPrimitive()) {//LC:26258
            convertedClass = primitiveWrapperMap.get(cls);//LC:26259
        }//LC:26260
        return convertedClass;//LC:26261
    }//LC:26262
//LC:26263
    /**//LC:26264
     * <p>Converts the specified array of primitive Class objects to an array of//LC:26265
     * its corresponding wrapper Class objects.</p>//LC:26266
     *//LC:26267
     * @param classes  the class array to convert, may be null or empty//LC:26268
     * @return an array which contains for each given class, the wrapper class or//LC:26269
     * the original class if class is not a primitive. {@code null} if null input.//LC:26270
     * Empty array if an empty array passed in.//LC:26271
     * @since 2.1//LC:26272
     *///LC:26273
    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {//LC:26274
        if (classes == null) {//LC:26275
            return null;//LC:26276
        }//LC:26277
//LC:26278
        if (classes.length == 0) {//LC:26279
            return classes;//LC:26280
        }//LC:26281
//LC:26282
        final Class<?>[] convertedClasses = new Class[classes.length];//LC:26283
        for (int i = 0; i < classes.length; i++) {//LC:26284
            convertedClasses[i] = primitiveToWrapper(classes[i]);//LC:26285
        }//LC:26286
        return convertedClasses;//LC:26287
    }//LC:26288
//LC:26289
    /**//LC:26290
     * <p>Converts the specified wrapper class to its corresponding primitive//LC:26291
     * class.</p>//LC:26292
     *//LC:26293
     * <p>This method is the counter part of {@code primitiveToWrapper()}.//LC:26294
     * If the passed in class is a wrapper class for a primitive type, this//LC:26295
     * primitive type will be returned (e.g. {@code Integer.TYPE} for//LC:26296
     * {@code Integer.class}). For other classes, or if the parameter is//LC:26297
     * <b>null</b>, the return value is <b>null</b>.</p>//LC:26298
     *//LC:26299
     * @param cls the class to convert, may be <b>null</b>//LC:26300
     * @return the corresponding primitive type if {@code cls} is a//LC:26301
     * wrapper class, <b>null</b> otherwise//LC:26302
     * @see #primitiveToWrapper(Class)//LC:26303
     * @since 2.4//LC:26304
     *///LC:26305
    public static Class<?> wrapperToPrimitive(final Class<?> cls) {//LC:26306
        return wrapperPrimitiveMap.get(cls);//LC:26307
    }//LC:26308
//LC:26309
    /**//LC:26310
     * <p>Converts the specified array of wrapper Class objects to an array of//LC:26311
     * its corresponding primitive Class objects.</p>//LC:26312
     *//LC:26313
     * <p>This method invokes {@code wrapperToPrimitive()} for each element//LC:26314
     * of the passed in array.</p>//LC:26315
     *//LC:26316
     * @param classes  the class array to convert, may be null or empty//LC:26317
     * @return an array which contains for each given class, the primitive class or//LC:26318
     * <b>null</b> if the original class is not a wrapper class. {@code null} if null input.//LC:26319
     * Empty array if an empty array passed in.//LC:26320
     * @see #wrapperToPrimitive(Class)//LC:26321
     * @since 2.4//LC:26322
     *///LC:26323
    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {//LC:26324
        if (classes == null) {//LC:26325
            return null;//LC:26326
        }//LC:26327
//LC:26328
        if (classes.length == 0) {//LC:26329
            return classes;//LC:26330
        }//LC:26331
//LC:26332
        final Class<?>[] convertedClasses = new Class[classes.length];//LC:26333
        for (int i = 0; i < classes.length; i++) {//LC:26334
            convertedClasses[i] = wrapperToPrimitive(classes[i]);//LC:26335
        }//LC:26336
        return convertedClasses;//LC:26337
    }//LC:26338
//LC:26339
    // Inner class//LC:26340
    // ----------------------------------------------------------------------//LC:26341
    /**//LC:26342
     * <p>Is the specified class an inner class or static nested class.</p>//LC:26343
     *//LC:26344
     * @param cls  the class to check, may be null//LC:26345
     * @return {@code true} if the class is an inner or static nested class,//LC:26346
     *  false if not or {@code null}//LC:26347
     *///LC:26348
    public static boolean isInnerClass(final Class<?> cls) {//LC:26349
        return cls != null && cls.getEnclosingClass() != null;//LC:26350
    }//LC:26351
//LC:26352
    // Class loading//LC:26353
    // ----------------------------------------------------------------------//LC:26354
    /**//LC:26355
     * Returns the class represented by {@code className} using the//LC:26356
     * {@code classLoader}.  This implementation supports the syntaxes//LC:26357
     * "{@code java.util.Map.Entry[]}", "{@code java.util.Map$Entry[]}",//LC:26358
     * "{@code [Ljava.util.Map.Entry;}", and "{@code [Ljava.util.Map$Entry;}".//LC:26359
     *//LC:26360
     * @param classLoader  the class loader to use to load the class//LC:26361
     * @param className  the class name//LC:26362
     * @param initialize  whether the class must be initialized//LC:26363
     * @return the class represented by {@code className} using the {@code classLoader}//LC:26364
     * @throws ClassNotFoundException if the class is not found//LC:26365
     *///LC:26366
    public static Class<?> getClass(//LC:26367
            final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {//LC:26368
        try {//LC:26369
            Class<?> clazz;//LC:26370
            if (abbreviationMap.containsKey(className)) {//LC:26371
                final String clsName = "[" + abbreviationMap.get(className);//LC:26372
                clazz = Class.forName(clsName, initialize, classLoader).getComponentType();//LC:26373
            } else {//LC:26374
                clazz = Class.forName(toCanonicalName(className), initialize, classLoader);//LC:26375
            }//LC:26376
            return clazz;//LC:26377
        } catch (final ClassNotFoundException ex) {//LC:26378
            // allow path separators (.) as inner class name separators//LC:26379
            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);//LC:26380
//LC:26381
            if (lastDotIndex != -1) {//LC:26382
                try {//LC:26383
                    return getClass(classLoader, className.substring(0, lastDotIndex) +//LC:26384
                                    INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),//LC:26385
                            initialize);//LC:26386
                } catch (final ClassNotFoundException ex2) { // NOPMD//LC:26387
                    // ignore exception//LC:26388
                }//LC:26389
            }//LC:26390
//LC:26391
            throw ex;//LC:26392
        }//LC:26393
    }//LC:26394
//LC:26395
    /**//LC:26396
     * Returns the (initialized) class represented by {@code className}//LC:26397
     * using the {@code classLoader}.  This implementation supports//LC:26398
     * the syntaxes "{@code java.util.Map.Entry[]}",//LC:26399
     * "{@code java.util.Map$Entry[]}", "{@code [Ljava.util.Map.Entry;}",//LC:26400
     * and "{@code [Ljava.util.Map$Entry;}".//LC:26401
     *//LC:26402
     * @param classLoader  the class loader to use to load the class//LC:26403
     * @param className  the class name//LC:26404
     * @return the class represented by {@code className} using the {@code classLoader}//LC:26405
     * @throws ClassNotFoundException if the class is not found//LC:26406
     *///LC:26407
    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {//LC:26408
        return getClass(classLoader, className, true);//LC:26409
    }//LC:26410
//LC:26411
    /**//LC:26412
     * Returns the (initialized) class represented by {@code className}//LC:26413
     * using the current thread's context class loader. This implementation//LC:26414
     * supports the syntaxes "{@code java.util.Map.Entry[]}",//LC:26415
     * "{@code java.util.Map$Entry[]}", "{@code [Ljava.util.Map.Entry;}",//LC:26416
     * and "{@code [Ljava.util.Map$Entry;}".//LC:26417
     *//LC:26418
     * @param className  the class name//LC:26419
     * @return the class represented by {@code className} using the current thread's context class loader//LC:26420
     * @throws ClassNotFoundException if the class is not found//LC:26421
     *///LC:26422
    public static Class<?> getClass(final String className) throws ClassNotFoundException {//LC:26423
        return getClass(className, true);//LC:26424
    }//LC:26425
//LC:26426
    /**//LC:26427
     * Returns the class represented by {@code className} using the//LC:26428
     * current thread's context class loader. This implementation supports the//LC:26429
     * syntaxes "{@code java.util.Map.Entry[]}", "{@code java.util.Map$Entry[]}",//LC:26430
     * "{@code [Ljava.util.Map.Entry;}", and "{@code [Ljava.util.Map$Entry;}".//LC:26431
     *//LC:26432
     * @param className  the class name//LC:26433
     * @param initialize  whether the class must be initialized//LC:26434
     * @return the class represented by {@code className} using the current thread's context class loader//LC:26435
     * @throws ClassNotFoundException if the class is not found//LC:26436
     *///LC:26437
    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {//LC:26438
        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();//LC:26439
        final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;//LC:26440
        return getClass(loader, className, initialize);//LC:26441
    }//LC:26442
//LC:26443
    // Public method//LC:26444
    // ----------------------------------------------------------------------//LC:26445
    /**//LC:26446
     * <p>Returns the desired Method much like {@code Class.getMethod}, however//LC:26447
     * it ensures that the returned Method is from a public class or interface and not//LC:26448
     * from an anonymous inner class. This means that the Method is invokable and//LC:26449
     * doesn't fall foul of Java bug//LC:26450
     * <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957">4071957</a>).//LC:26451
     *//LC:26452
     *  <code><pre>Set set = Collections.unmodifiableSet(...);//LC:26453
     *  Method method = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]);//LC:26454
     *  Object result = method.invoke(set, new Object[]);</pre></code>//LC:26455
     * </p>//LC:26456
     *//LC:26457
     * @param cls  the class to check, not null//LC:26458
     * @param methodName  the name of the method//LC:26459
     * @param parameterTypes  the list of parameters//LC:26460
     * @return the method//LC:26461
     * @throws NullPointerException if the class is null//LC:26462
     * @throws SecurityException if a security violation occurred//LC:26463
     * @throws NoSuchMethodException if the method is not found in the given class//LC:26464
     *  or if the metothod doen't conform with the requirements//LC:26465
     *///LC:26466
    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes)//LC:26467
            throws SecurityException, NoSuchMethodException {//LC:26468
//LC:26469
        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);//LC:26470
        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {//LC:26471
            return declaredMethod;//LC:26472
        }//LC:26473
//LC:26474
        final List<Class<?>> candidateClasses = new ArrayList<Class<?>>();//LC:26475
        candidateClasses.addAll(getAllInterfaces(cls));//LC:26476
        candidateClasses.addAll(getAllSuperclasses(cls));//LC:26477
//LC:26478
        for (final Class<?> candidateClass : candidateClasses) {//LC:26479
            if (!Modifier.isPublic(candidateClass.getModifiers())) {//LC:26480
                continue;//LC:26481
            }//LC:26482
            Method candidateMethod;//LC:26483
            try {//LC:26484
                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);//LC:26485
            } catch (final NoSuchMethodException ex) {//LC:26486
                continue;//LC:26487
            }//LC:26488
            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {//LC:26489
                return candidateMethod;//LC:26490
            }//LC:26491
        }//LC:26492
//LC:26493
        throw new NoSuchMethodException("Can't find a public method for " +//LC:26494
                methodName + " " + ArrayUtils.toString(parameterTypes));//LC:26495
    }//LC:26496
//LC:26497
    // ----------------------------------------------------------------------//LC:26498
    /**//LC:26499
     * Converts a class name to a JLS style class name.//LC:26500
     *//LC:26501
     * @param className  the class name//LC:26502
     * @return the converted name//LC:26503
     *///LC:26504
    private static String toCanonicalName(String className) {//LC:26505
        className = StringUtils.deleteWhitespace(className);//LC:26506
        if (className == null) {//LC:26507
            throw new NullPointerException("className must not be null.");//LC:26508
        } else if (className.endsWith("[]")) {//LC:26509
            final StringBuilder classNameBuffer = new StringBuilder();//LC:26510
            while (className.endsWith("[]")) {//LC:26511
                className = className.substring(0, className.length() - 2);//LC:26512
                classNameBuffer.append("[");//LC:26513
            }//LC:26514
            final String abbreviation = abbreviationMap.get(className);//LC:26515
            if (abbreviation != null) {//LC:26516
                classNameBuffer.append(abbreviation);//LC:26517
            } else {//LC:26518
                classNameBuffer.append("L").append(className).append(";");//LC:26519
            }//LC:26520
            className = classNameBuffer.toString();//LC:26521
        }//LC:26522
        return className;//LC:26523
    }//LC:26524
//LC:26525
    /**//LC:26526
     * <p>Converts an array of {@code Object} in to an array of {@code Class} objects.//LC:26527
     * If any of these objects is null, a null element will be inserted into the array.</p>//LC:26528
     *//LC:26529
     * <p>This method returns {@code null} for a {@code null} input array.</p>//LC:26530
     *//LC:26531
     * @param array an {@code Object} array//LC:26532
     * @return a {@code Class} array, {@code null} if null array input//LC:26533
     * @since 2.4//LC:26534
     *///LC:26535
    public static Class<?>[] toClass(final Object... array) {//LC:26536
        if (array == null) {//LC:26537
            return null;//LC:26538
        } else if (array.length == 0) {//LC:26539
            return ArrayUtils.EMPTY_CLASS_ARRAY;//LC:26540
        }//LC:26541
        final Class<?>[] classes = new Class[array.length];//LC:26542
        for (int i = 0; i < array.length; i++) {//LC:26543
            classes[i] = array[i] == null ? null : array[i].getClass();//LC:26544
        }//LC:26545
        return classes;//LC:26546
    }//LC:26547
//LC:26548
    // Short canonical name//LC:26549
    // ----------------------------------------------------------------------//LC:26550
    /**//LC:26551
     * <p>Gets the canonical name minus the package name for an {@code Object}.</p>//LC:26552
     *//LC:26553
     * @param object  the class to get the short name for, may be null//LC:26554
     * @param valueIfNull  the value to return if null//LC:26555
     * @return the canonical name of the object without the package name, or the null value//LC:26556
     * @since 2.4//LC:26557
     *///LC:26558
    public static String getShortCanonicalName(final Object object, final String valueIfNull) {//LC:26559
        if (object == null) {//LC:26560
            return valueIfNull;//LC:26561
        }//LC:26562
        return getShortCanonicalName(object.getClass().getName());//LC:26563
    }//LC:26564
//LC:26565
    /**//LC:26566
     * <p>Gets the canonical name minus the package name from a {@code Class}.</p>//LC:26567
     *//LC:26568
     * @param cls  the class to get the short name for.//LC:26569
     * @return the canonical name without the package name or an empty string//LC:26570
     * @since 2.4//LC:26571
     *///LC:26572
    public static String getShortCanonicalName(final Class<?> cls) {//LC:26573
        if (cls == null) {//LC:26574
            return StringUtils.EMPTY;//LC:26575
        }//LC:26576
        return getShortCanonicalName(cls.getName());//LC:26577
    }//LC:26578
//LC:26579
    /**//LC:26580
     * <p>Gets the canonical name minus the package name from a String.</p>//LC:26581
     *//LC:26582
     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>//LC:26583
     *//LC:26584
     * @param canonicalName  the class name to get the short name for//LC:26585
     * @return the canonical name of the class without the package name or an empty string//LC:26586
     * @since 2.4//LC:26587
     *///LC:26588
    public static String getShortCanonicalName(final String canonicalName) {//LC:26589
        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));//LC:26590
    }//LC:26591
//LC:26592
    // Package name//LC:26593
    // ----------------------------------------------------------------------//LC:26594
    /**//LC:26595
     * <p>Gets the package name from the canonical name of an {@code Object}.</p>//LC:26596
     *//LC:26597
     * @param object  the class to get the package name for, may be null//LC:26598
     * @param valueIfNull  the value to return if null//LC:26599
     * @return the package name of the object, or the null value//LC:26600
     * @since 2.4//LC:26601
     *///LC:26602
    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {//LC:26603
        if (object == null) {//LC:26604
            return valueIfNull;//LC:26605
        }//LC:26606
        return getPackageCanonicalName(object.getClass().getName());//LC:26607
    }//LC:26608
//LC:26609
    /**//LC:26610
     * <p>Gets the package name from the canonical name of a {@code Class}.</p>//LC:26611
     *//LC:26612
     * @param cls  the class to get the package name for, may be {@code null}.//LC:26613
     * @return the package name or an empty string//LC:26614
     * @since 2.4//LC:26615
     *///LC:26616
    public static String getPackageCanonicalName(final Class<?> cls) {//LC:26617
        if (cls == null) {//LC:26618
            return StringUtils.EMPTY;//LC:26619
        }//LC:26620
        return getPackageCanonicalName(cls.getName());//LC:26621
    }//LC:26622
//LC:26623
    /**//LC:26624
     * <p>Gets the package name from the canonical name. </p>//LC:26625
     *//LC:26626
     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>//LC:26627
     * <p>If the class is unpackaged, return an empty string.</p>//LC:26628
     *//LC:26629
     * @param canonicalName  the canonical name to get the package name for, may be {@code null}//LC:26630
     * @return the package name or an empty string//LC:26631
     * @since 2.4//LC:26632
     *///LC:26633
    public static String getPackageCanonicalName(final String canonicalName) {//LC:26634
        return ClassUtils.getPackageName(getCanonicalName(canonicalName));//LC:26635
    }//LC:26636
//LC:26637
    /**//LC:26638
     * <p>Converts a given name of class into canonical format.//LC:26639
     * If name of class is not a name of array class it returns//LC:26640
     * unchanged name.</p>//LC:26641
     * <p>Example://LC:26642
     * <ul>//LC:26643
     * <li>{@code getCanonicalName("[I") = "int[]"}</li>//LC:26644
     * <li>{@code getCanonicalName("[Ljava.lang.String;") = "java.lang.String[]"}</li>//LC:26645
     * <li>{@code getCanonicalName("java.lang.String") = "java.lang.String"}</li>//LC:26646
     * </ul>//LC:26647
     * </p>//LC:26648
     *//LC:26649
     * @param className the name of class//LC:26650
     * @return canonical form of class name//LC:26651
     * @since 2.4//LC:26652
     *///LC:26653
    private static String getCanonicalName(String className) {//LC:26654
        className = StringUtils.deleteWhitespace(className);//LC:26655
        if (className == null) {//LC:26656
            return null;//LC:26657
        } else {//LC:26658
            int dim = 0;//LC:26659
            while (className.startsWith("[")) {//LC:26660
                dim++;//LC:26661
                className = className.substring(1);//LC:26662
            }//LC:26663
            if (dim < 1) {//LC:26664
                return className;//LC:26665
            } else {//LC:26666
                if (className.startsWith("L")) {//LC:26667
                    className = className.substring(//LC:26668
                            1,//LC:26669
                            className.endsWith(";")//LC:26670
                                    ? className.length() - 1//LC:26671
                                    : className.length());//LC:26672
                } else {//LC:26673
                    if (className.length() > 0) {//LC:26674
                        className = reverseAbbreviationMap.get(className.substring(0, 1));//LC:26675
                    }//LC:26676
                }//LC:26677
                final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);//LC:26678
                for (int i = 0; i < dim; i++) {//LC:26679
                    canonicalClassNameBuffer.append("[]");//LC:26680
                }//LC:26681
                return canonicalClassNameBuffer.toString();//LC:26682
            }//LC:26683
        }//LC:26684
    }//LC:26685
//LC:26686
}//LC:26687
//LC:26688
//LC:26689
//LC:26690
/**//LC:26691
 * <p>//LC:26692
 * Assists in implementing {@link Object#toString()} methods using reflection.//LC:26693
 * </p>//LC:26694
 * <p>//LC:26695
 * This class uses reflection to determine the fields to append. Because these fields are usually private, the class//LC:26696
 * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to//LC:26697
 * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are//LC:26698
 * set up correctly.//LC:26699
 * </p>//LC:26700
 * <p>//LC:26701
 * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these//LC:26702
 * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use//LC:26703
 * synchronization consistent with the class' lock management around the invocation of the method. Take special care to//LC:26704
 * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if//LC:26705
 * modified while the toString method is executing.//LC:26706
 * </p>//LC:26707
 * <p>//LC:26708
 * A typical invocation for this method would look like://LC:26709
 * </p>//LC:26710
 * <pre>//LC:26711
 * public String toString() {//LC:26712
 *     return ReflectionToStringBuilder.toString(this);//LC:26713
 * }//LC:26714
 * </pre>//LC:26715
 * <p>//LC:26716
 * You can also use the builder to debug 3rd party objects://LC:26717
 * </p>//LC:26718
 * <pre>//LC:26719
 * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));//LC:26720
 * </pre>//LC:26721
 * <p>//LC:26722
 * A subclass can control field output by overriding the methods://LC:26723
 * <ul>//LC:26724
 * <li>{@link #accept(java.lang.reflect.Field)}</li>//LC:26725
 * <li>{@link #getValue(java.lang.reflect.Field)}</li>//LC:26726
 * </ul>//LC:26727
 * </p>//LC:26728
 * <p>//LC:26729
 * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>://LC:26730
 * </p>//LC:26731
 * <pre>//LC:26732
 * public String toString() {//LC:26733
 *     return (new ReflectionToStringBuilder(this) {//LC:26734
 *         protected boolean accept(Field f) {//LC:26735
 *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);//LC:26736
 *         }//LC:26737
 *     }).toString();//LC:26738
 * }//LC:26739
 * </pre>//LC:26740
 * <p>//LC:26741
 * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.//LC:26742
 * </p>//LC:26743
 *//LC:26744
 * @since 2.0//LC:26745
 * @version $Id$//LC:26746
 *///LC:26747
class ReflectionToStringBuilder extends ToStringBuilder {//LC:26748
//LC:26749
    /**//LC:26750
     * <p>//LC:26751
     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.//LC:26752
     * </p>//LC:26753
     *//LC:26754
     * <p>//LC:26755
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:26756
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:26757
     * also not as efficient as testing explicitly.//LC:26758
     * </p>//LC:26759
     *//LC:26760
     * <p>//LC:26761
     * Transient members will be not be included, as they are likely derived. Static fields will not be included.//LC:26762
     * Superclass fields will be appended.//LC:26763
     * </p>//LC:26764
     *//LC:26765
     * @param object//LC:26766
     *            the Object to be output//LC:26767
     * @return the String result//LC:26768
     * @throws IllegalArgumentException//LC:26769
     *             if the Object is <code>null</code>//LC:26770
     *///LC:26771
    public static String toString(final Object object) {//LC:26772
        return toString(object, null, false, false, null);//LC:26773
    }//LC:26774
//LC:26775
    /**//LC:26776
     * <p>//LC:26777
     * Builds a <code>toString</code> value through reflection.//LC:26778
     * </p>//LC:26779
     *//LC:26780
     * <p>//LC:26781
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:26782
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:26783
     * also not as efficient as testing explicitly.//LC:26784
     * </p>//LC:26785
     *//LC:26786
     * <p>//LC:26787
     * Transient members will be not be included, as they are likely derived. Static fields will not be included.//LC:26788
     * Superclass fields will be appended.//LC:26789
     * </p>//LC:26790
     *//LC:26791
     * <p>//LC:26792
     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.//LC:26793
     * </p>//LC:26794
     *//LC:26795
     * @param object//LC:26796
     *            the Object to be output//LC:26797
     * @param style//LC:26798
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:26799
     * @return the String result//LC:26800
     * @throws IllegalArgumentException//LC:26801
     *             if the Object or <code>ToStringStyle</code> is <code>null</code>//LC:26802
     *///LC:26803
    public static String toString(final Object object, final ToStringStyle style) {//LC:26804
        return toString(object, style, false, false, null);//LC:26805
    }//LC:26806
//LC:26807
    /**//LC:26808
     * <p>//LC:26809
     * Builds a <code>toString</code> value through reflection.//LC:26810
     * </p>//LC:26811
     *//LC:26812
     * <p>//LC:26813
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:26814
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:26815
     * also not as efficient as testing explicitly.//LC:26816
     * </p>//LC:26817
     *//LC:26818
     * <p>//LC:26819
     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they//LC:26820
     * are ignored, as they are likely derived fields, and not part of the value of the Object.//LC:26821
     * </p>//LC:26822
     *//LC:26823
     * <p>//LC:26824
     * Static fields will not be included. Superclass fields will be appended.//LC:26825
     * </p>//LC:26826
     *//LC:26827
     * <p>//LC:26828
     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.//LC:26829
     * </p>//LC:26830
     *//LC:26831
     * @param object//LC:26832
     *            the Object to be output//LC:26833
     * @param style//LC:26834
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:26835
     * @param outputTransients//LC:26836
     *            whether to include transient fields//LC:26837
     * @return the String result//LC:26838
     * @throws IllegalArgumentException//LC:26839
     *             if the Object is <code>null</code>//LC:26840
     *///LC:26841
    public static String toString(final Object object, final ToStringStyle style, final boolean outputTransients) {//LC:26842
        return toString(object, style, outputTransients, false, null);//LC:26843
    }//LC:26844
//LC:26845
    /**//LC:26846
     * <p>//LC:26847
     * Builds a <code>toString</code> value through reflection.//LC:26848
     * </p>//LC:26849
     *//LC:26850
     * <p>//LC:26851
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:26852
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:26853
     * also not as efficient as testing explicitly.//LC:26854
     * </p>//LC:26855
     *//LC:26856
     * <p>//LC:26857
     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they//LC:26858
     * are ignored, as they are likely derived fields, and not part of the value of the Object.//LC:26859
     * </p>//LC:26860
     *//LC:26861
     * <p>//LC:26862
     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are//LC:26863
     * ignored.//LC:26864
     * </p>//LC:26865
     *//LC:26866
     * <p>//LC:26867
     * Static fields will not be included. Superclass fields will be appended.//LC:26868
     * </p>//LC:26869
     *//LC:26870
     * <p>//LC:26871
     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.//LC:26872
     * </p>//LC:26873
     *//LC:26874
     * @param object//LC:26875
     *            the Object to be output//LC:26876
     * @param style//LC:26877
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:26878
     * @param outputTransients//LC:26879
     *            whether to include transient fields//LC:26880
     * @param outputStatics//LC:26881
     *            whether to include transient fields//LC:26882
     * @return the String result//LC:26883
     * @throws IllegalArgumentException//LC:26884
     *             if the Object is <code>null</code>//LC:26885
     * @since 2.1//LC:26886
     *///LC:26887
    public static String toString(final Object object, final ToStringStyle style, final boolean outputTransients, final boolean outputStatics) {//LC:26888
        return toString(object, style, outputTransients, outputStatics, null);//LC:26889
    }//LC:26890
//LC:26891
    /**//LC:26892
     * <p>//LC:26893
     * Builds a <code>toString</code> value through reflection.//LC:26894
     * </p>//LC:26895
     *//LC:26896
     * <p>//LC:26897
     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will//LC:26898
     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is//LC:26899
     * also not as efficient as testing explicitly.//LC:26900
     * </p>//LC:26901
     *//LC:26902
     * <p>//LC:26903
     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they//LC:26904
     * are ignored, as they are likely derived fields, and not part of the value of the Object.//LC:26905
     * </p>//LC:26906
     *//LC:26907
     * <p>//LC:26908
     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are//LC:26909
     * ignored.//LC:26910
     * </p>//LC:26911
     *//LC:26912
     * <p>//LC:26913
     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as//LC:26914
     * <code>java.lang.Object</code>.//LC:26915
     * </p>//LC:26916
     *//LC:26917
     * <p>//LC:26918
     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.//LC:26919
     * </p>//LC:26920
     *//LC:26921
     * @param <T>//LC:26922
     *            the type of the object//LC:26923
     * @param object//LC:26924
     *            the Object to be output//LC:26925
     * @param style//LC:26926
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:26927
     * @param outputTransients//LC:26928
     *            whether to include transient fields//LC:26929
     * @param outputStatics//LC:26930
     *            whether to include static fields//LC:26931
     * @param reflectUpToClass//LC:26932
     *            the superclass to reflect up to (inclusive), may be <code>null</code>//LC:26933
     * @return the String result//LC:26934
     * @throws IllegalArgumentException//LC:26935
     *             if the Object is <code>null</code>//LC:26936
     * @since 2.1//LC:26937
     *///LC:26938
    public static <T> String toString(//LC:26939
            final T object, final ToStringStyle style, final boolean outputTransients,//LC:26940
            final boolean outputStatics, final Class<? super T> reflectUpToClass) {//LC:26941
        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)//LC:26942
                .toString();//LC:26943
    }//LC:26944
//LC:26945
    /**//LC:26946
     * Builds a String for a toString method excluding the given field names.//LC:26947
     *//LC:26948
     * @param object//LC:26949
     *            The object to "toString".//LC:26950
     * @param excludeFieldNames//LC:26951
     *            The field names to exclude. Null excludes nothing.//LC:26952
     * @return The toString value.//LC:26953
     *///LC:26954
    public static String toStringExclude(final Object object, final Collection<String> excludeFieldNames) {//LC:26955
        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));//LC:26956
    }//LC:26957
//LC:26958
    /**//LC:26959
     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>//LC:26960
     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element//LC:26961
     * is <code>null</code>.//LC:26962
     *//LC:26963
     * @param collection//LC:26964
     *            The collection to convert//LC:26965
     * @return A new array of Strings.//LC:26966
     *///LC:26967
    static String[] toNoNullStringArray(final Collection<String> collection) {//LC:26968
        if (collection == null) {//LC:26969
            return ArrayUtils.EMPTY_STRING_ARRAY;//LC:26970
        }//LC:26971
        return toNoNullStringArray(collection.toArray());//LC:26972
    }//LC:26973
//LC:26974
    /**//LC:26975
     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists//LC:26976
     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}//LC:26977
     * if an array element is <code>null</code>.//LC:26978
     *//LC:26979
     * @param array//LC:26980
     *            The array to check//LC:26981
     * @return The given array or a new array without null.//LC:26982
     *///LC:26983
    static String[] toNoNullStringArray(final Object[] array) {//LC:26984
        final List<String> list = new ArrayList<String>(array.length);//LC:26985
        for (final Object e : array) {//LC:26986
            if (e != null) {//LC:26987
                list.add(e.toString());//LC:26988
            }//LC:26989
        }//LC:26990
        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);//LC:26991
    }//LC:26992
//LC:26993
//LC:26994
    /**//LC:26995
     * Builds a String for a toString method excluding the given field names.//LC:26996
     *//LC:26997
     * @param object//LC:26998
     *            The object to "toString".//LC:26999
     * @param excludeFieldNames//LC:27000
     *            The field names to exclude//LC:27001
     * @return The toString value.//LC:27002
     *///LC:27003
    public static String toStringExclude(final Object object, final String... excludeFieldNames) {//LC:27004
        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();//LC:27005
    }//LC:27006
//LC:27007
    /**//LC:27008
     * Whether or not to append static fields.//LC:27009
     *///LC:27010
    private boolean appendStatics = false;//LC:27011
//LC:27012
    /**//LC:27013
     * Whether or not to append transient fields.//LC:27014
     *///LC:27015
    private boolean appendTransients = false;//LC:27016
//LC:27017
    /**//LC:27018
     * Which field names to exclude from output. Intended for fields like <code>"password"</code>.//LC:27019
     *//LC:27020
     * @since 3.0 this is protected instead of private//LC:27021
     *///LC:27022
    protected String[] excludeFieldNames;//LC:27023
//LC:27024
    /**//LC:27025
     * The last super class to stop appending fields for.//LC:27026
     *///LC:27027
    private Class<?> upToClass = null;//LC:27028
//LC:27029
    /**//LC:27030
     * <p>//LC:27031
     * Constructor.//LC:27032
     * </p>//LC:27033
     *//LC:27034
     * <p>//LC:27035
     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.//LC:27036
     * </p>//LC:27037
     *//LC:27038
     * @param object//LC:27039
     *            the Object to build a <code>toString</code> for, must not be <code>null</code>//LC:27040
     * @throws IllegalArgumentException//LC:27041
     *             if the Object passed in is <code>null</code>//LC:27042
     *///LC:27043
    public ReflectionToStringBuilder(final Object object) {//LC:27044
        super(object);//LC:27045
    }//LC:27046
//LC:27047
    /**//LC:27048
     * <p>//LC:27049
     * Constructor.//LC:27050
     * </p>//LC:27051
     *//LC:27052
     * <p>//LC:27053
     * If the style is <code>null</code>, the default style is used.//LC:27054
     * </p>//LC:27055
     *//LC:27056
     * @param object//LC:27057
     *            the Object to build a <code>toString</code> for, must not be <code>null</code>//LC:27058
     * @param style//LC:27059
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:27060
     * @throws IllegalArgumentException//LC:27061
     *             if the Object passed in is <code>null</code>//LC:27062
     *///LC:27063
    public ReflectionToStringBuilder(final Object object, final ToStringStyle style) {//LC:27064
        super(object, style);//LC:27065
    }//LC:27066
//LC:27067
    /**//LC:27068
     * <p>//LC:27069
     * Constructor.//LC:27070
     * </p>//LC:27071
     *//LC:27072
     * <p>//LC:27073
     * If the style is <code>null</code>, the default style is used.//LC:27074
     * </p>//LC:27075
     *//LC:27076
     * <p>//LC:27077
     * If the buffer is <code>null</code>, a new one is created.//LC:27078
     * </p>//LC:27079
     *//LC:27080
     * @param object//LC:27081
     *            the Object to build a <code>toString</code> for//LC:27082
     * @param style//LC:27083
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:27084
     * @param buffer//LC:27085
     *            the <code>StringBuffer</code> to populate, may be <code>null</code>//LC:27086
     * @throws IllegalArgumentException//LC:27087
     *             if the Object passed in is <code>null</code>//LC:27088
     *///LC:27089
    public ReflectionToStringBuilder(final Object object, final ToStringStyle style, final StringBuffer buffer) {//LC:27090
        super(object, style, buffer);//LC:27091
    }//LC:27092
//LC:27093
    /**//LC:27094
     * Constructor.//LC:27095
     *//LC:27096
     * @param <T>//LC:27097
     *            the type of the object//LC:27098
     * @param object//LC:27099
     *            the Object to build a <code>toString</code> for//LC:27100
     * @param style//LC:27101
     *            the style of the <code>toString</code> to create, may be <code>null</code>//LC:27102
     * @param buffer//LC:27103
     *            the <code>StringBuffer</code> to populate, may be <code>null</code>//LC:27104
     * @param reflectUpToClass//LC:27105
     *            the superclass to reflect up to (inclusive), may be <code>null</code>//LC:27106
     * @param outputTransients//LC:27107
     *            whether to include transient fields//LC:27108
     * @param outputStatics//LC:27109
     *            whether to include static fields//LC:27110
     * @since 2.1//LC:27111
     *///LC:27112
    public <T> ReflectionToStringBuilder(//LC:27113
            final T object, final ToStringStyle style, final StringBuffer buffer,//LC:27114
            final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) {//LC:27115
        super(object, style, buffer);//LC:27116
        this.setUpToClass(reflectUpToClass);//LC:27117
        this.setAppendTransients(outputTransients);//LC:27118
        this.setAppendStatics(outputStatics);//LC:27119
    }//LC:27120
//LC:27121
    /**//LC:27122
     * Returns whether or not to append the given <code>Field</code>.//LC:27123
     * <ul>//LC:27124
     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.//LC:27125
     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.//LC:27126
     * <li>Inner class fields are not appended.</li>//LC:27127
     * </ul>//LC:27128
     *//LC:27129
     * @param field//LC:27130
     *            The Field to test.//LC:27131
     * @return Whether or not to append the given <code>Field</code>.//LC:27132
     *///LC:27133
    protected boolean accept(final Field field) {//LC:27134
        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {//LC:27135
            // Reject field from inner class.//LC:27136
            return false;//LC:27137
        }//LC:27138
        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {//LC:27139
            // Reject transient fields.//LC:27140
            return false;//LC:27141
        }//LC:27142
        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {//LC:27143
            // Reject static fields.//LC:27144
            return false;//LC:27145
        }//LC:27146
        if (this.excludeFieldNames != null//LC:27147
                && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {//LC:27148
            // Reject fields from the getExcludeFieldNames list.//LC:27149
            return false;//LC:27150
        }//LC:27151
        return true;//LC:27152
    }//LC:27153
//LC:27154
    /**//LC:27155
     * <p>//LC:27156
     * Appends the fields and values defined by the given object of the given Class.//LC:27157
     * </p>//LC:27158
     *//LC:27159
     * <p>//LC:27160
     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if//LC:27161
     * <code>Object.toString()</code> had been called and not implemented by the object.//LC:27162
     * </p>//LC:27163
     *//LC:27164
     * @param clazz//LC:27165
     *            The class of object parameter//LC:27166
     *///LC:27167
    protected void appendFieldsIn(final Class<?> clazz) {//LC:27168
        if (clazz.isArray()) {//LC:27169
            this.reflectionAppendArray(this.getObject());//LC:27170
            return;//LC:27171
        }//LC:27172
        final Field[] fields = clazz.getDeclaredFields();//LC:27173
        AccessibleObject.setAccessible(fields, true);//LC:27174
        for (final Field field : fields) {//LC:27175
            final String fieldName = field.getName();//LC:27176
            if (this.accept(field)) {//LC:27177
                try {//LC:27178
                    // Warning: Field.get(Object) creates wrappers objects//LC:27179
                    // for primitive types.//LC:27180
                    final Object fieldValue = this.getValue(field);//LC:27181
                    this.append(fieldName, fieldValue);//LC:27182
                } catch (final IllegalAccessException ex) {//LC:27183
                    //this can't happen. Would get a Security exception//LC:27184
                    // instead//LC:27185
                    //throw a runtime exception in case the impossible//LC:27186
                    // happens.//LC:27187
                    throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());//LC:27188
                }//LC:27189
            }//LC:27190
        }//LC:27191
    }//LC:27192
//LC:27193
    /**//LC:27194
     * @return Returns the excludeFieldNames.//LC:27195
     *///LC:27196
    public String[] getExcludeFieldNames() {//LC:27197
        return this.excludeFieldNames.clone();//LC:27198
    }//LC:27199
//LC:27200
    /**//LC:27201
     * <p>//LC:27202
     * Gets the last super class to stop appending fields for.//LC:27203
     * </p>//LC:27204
     *//LC:27205
     * @return The last super class to stop appending fields for.//LC:27206
     *///LC:27207
    public Class<?> getUpToClass() {//LC:27208
        return this.upToClass;//LC:27209
    }//LC:27210
//LC:27211
    /**//LC:27212
     * <p>//LC:27213
     * Calls <code>java.lang.reflect.Field.get(Object)</code>.//LC:27214
     * </p>//LC:27215
     *//LC:27216
     * @param field//LC:27217
     *            The Field to query.//LC:27218
     * @return The Object from the given Field.//LC:27219
     *//LC:27220
     * @throws IllegalArgumentException//LC:27221
     *             see {@link java.lang.reflect.Field#get(Object)}//LC:27222
     * @throws IllegalAccessException//LC:27223
     *             see {@link java.lang.reflect.Field#get(Object)}//LC:27224
     *//LC:27225
     * @see java.lang.reflect.Field#get(Object)//LC:27226
     *///LC:27227
    protected Object getValue(final Field field) throws IllegalArgumentException, IllegalAccessException {//LC:27228
        return field.get(this.getObject());//LC:27229
    }//LC:27230
//LC:27231
    /**//LC:27232
     * <p>//LC:27233
     * Gets whether or not to append static fields.//LC:27234
     * </p>//LC:27235
     *//LC:27236
     * @return Whether or not to append static fields.//LC:27237
     * @since 2.1//LC:27238
     *///LC:27239
    public boolean isAppendStatics() {//LC:27240
        return this.appendStatics;//LC:27241
    }//LC:27242
//LC:27243
    /**//LC:27244
     * <p>//LC:27245
     * Gets whether or not to append transient fields.//LC:27246
     * </p>//LC:27247
     *//LC:27248
     * @return Whether or not to append transient fields.//LC:27249
     *///LC:27250
    public boolean isAppendTransients() {//LC:27251
        return this.appendTransients;//LC:27252
    }//LC:27253
//LC:27254
    /**//LC:27255
     * <p>//LC:27256
     * Append to the <code>toString</code> an <code>Object</code> array.//LC:27257
     * </p>//LC:27258
     *//LC:27259
     * @param array//LC:27260
     *            the array to add to the <code>toString</code>//LC:27261
     * @return this//LC:27262
     *///LC:27263
    public ReflectionToStringBuilder reflectionAppendArray(final Object array) {//LC:27264
        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);//LC:27265
        return this;//LC:27266
    }//LC:27267
//LC:27268
    /**//LC:27269
     * <p>//LC:27270
     * Sets whether or not to append static fields.//LC:27271
     * </p>//LC:27272
     *//LC:27273
     * @param appendStatics//LC:27274
     *            Whether or not to append static fields.//LC:27275
     * @since 2.1//LC:27276
     *///LC:27277
    public void setAppendStatics(final boolean appendStatics) {//LC:27278
        this.appendStatics = appendStatics;//LC:27279
    }//LC:27280
//LC:27281
    /**//LC:27282
     * <p>//LC:27283
     * Sets whether or not to append transient fields.//LC:27284
     * </p>//LC:27285
     *//LC:27286
     * @param appendTransients//LC:27287
     *            Whether or not to append transient fields.//LC:27288
     *///LC:27289
    public void setAppendTransients(final boolean appendTransients) {//LC:27290
        this.appendTransients = appendTransients;//LC:27291
    }//LC:27292
//LC:27293
    /**//LC:27294
     * Sets the field names to exclude.//LC:27295
     *//LC:27296
     * @param excludeFieldNamesParam//LC:27297
     *            The excludeFieldNames to excluding from toString or <code>null</code>.//LC:27298
     * @return <code>this</code>//LC:27299
     *///LC:27300
    public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {//LC:27301
        if (excludeFieldNamesParam == null) {//LC:27302
            this.excludeFieldNames = null;//LC:27303
        } else {//LC:27304
            //clone and remove nulls//LC:27305
            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);//LC:27306
            Arrays.sort(this.excludeFieldNames);//LC:27307
        }//LC:27308
        return this;//LC:27309
    }//LC:27310
//LC:27311
    /**//LC:27312
     * <p>//LC:27313
     * Sets the last super class to stop appending fields for.//LC:27314
     * </p>//LC:27315
     *//LC:27316
     * @param clazz//LC:27317
     *            The last super class to stop appending fields for.//LC:27318
     *///LC:27319
    public void setUpToClass(final Class<?> clazz) {//LC:27320
        if (clazz != null) {//LC:27321
            final Object object = getObject();//LC:27322
            if (object != null && clazz.isInstance(object) == false) {//LC:27323
                throw new IllegalArgumentException("Specified class is not a superclass of the object");//LC:27324
            }//LC:27325
        }//LC:27326
        this.upToClass = clazz;//LC:27327
    }//LC:27328
//LC:27329
    /**//LC:27330
     * <p>//LC:27331
     * Gets the String built by this builder.//LC:27332
     * </p>//LC:27333
     *//LC:27334
     * @return the built string//LC:27335
     *///LC:27336
    @Override//LC:27337
    public String toString() {//LC:27338
        if (this.getObject() == null) {//LC:27339
            return this.getStyle().getNullText();//LC:27340
        }//LC:27341
        Class<?> clazz = this.getObject().getClass();//LC:27342
        this.appendFieldsIn(clazz);//LC:27343
        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {//LC:27344
            clazz = clazz.getSuperclass();//LC:27345
            this.appendFieldsIn(clazz);//LC:27346
        }//LC:27347
        return super.toString();//LC:27348
    }//LC:27349
//LC:27350
}//LC:27351
//LC:27352
//LC:27353
/**//LC:27354
 * <p>//LC:27355
 * The Builder interface is designed to designate a class as a <em>builder</em>//LC:27356
 * object in the Builder design pattern. Builders are capable of creating and//LC:27357
 * configuring objects or results that normally take multiple steps to construct//LC:27358
 * or are very complex to derive.//LC:27359
 * </p>//LC:27360
 *//LC:27361
 * <p>//LC:27362
 * The builder interface defines a single method, {@link #build()}, that//LC:27363
 * classes must implement. The result of this method should be the final//LC:27364
 * configured object or result after all building operations are performed.//LC:27365
 * </p>//LC:27366
 *//LC:27367
 * <p>//LC:27368
 * It is a recommended practice that the methods supplied to configure the//LC:27369
 * object or result being built return a reference to {@code this} so that//LC:27370
 * method calls can be chained together.//LC:27371
 * </p>//LC:27372
 *//LC:27373
 * <p>//LC:27374
 * Example Builder://LC:27375
 * <code><pre>//LC:27376
 * class FontBuilder implements Builder&lt;Font&gt; {//LC:27377
 *     private Font font;//LC:27378
 *//LC:27379
 *     public FontBuilder(String fontName) {//LC:27380
 *         this.font = new Font(fontName, Font.PLAIN, 12);//LC:27381
 *     }//LC:27382
 *//LC:27383
 *     public FontBuilder bold() {//LC:27384
 *         this.font = this.font.deriveFont(Font.BOLD);//LC:27385
 *         return this; // Reference returned so calls can be chained//LC:27386
 *     }//LC:27387
 *//LC:27388
 *     public FontBuilder size(float pointSize) {//LC:27389
 *         this.font = this.font.deriveFont(pointSize);//LC:27390
 *         return this; // Reference returned so calls can be chained//LC:27391
 *     }//LC:27392
 *//LC:27393
 *     // Other Font construction methods//LC:27394
 *//LC:27395
 *     public Font build() {//LC:27396
 *         return this.font;//LC:27397
 *     }//LC:27398
 * }//LC:27399
 * </pre></code>//LC:27400
 *//LC:27401
 * Example Builder Usage://LC:27402
 * <code><pre>//LC:27403
 * Font bold14ptSansSerifFont = new FontBuilder(Font.SANS_SERIF).bold()//LC:27404
 *                                                              .size(14.0f)//LC:27405
 *                                                              .build();//LC:27406
 * </pre></code>//LC:27407
 * </p>//LC:27408
 *//LC:27409
 * @param <T> the type of object that the builder will construct or compute.//LC:27410
 *//LC:27411
 * @since 3.0//LC:27412
 * @version $Id$//LC:27413
 *///LC:27414
interface Builder<T> {//LC:27415
//LC:27416
    /**//LC:27417
     * Returns a reference to the object being constructed or result being//LC:27418
     * calculated by the builder.//LC:27419
     *//LC:27420
     * @return the object constructed or result calculated by the builder.//LC:27421
     *///LC:27422
    T build();//LC:27423
}//LC:27424
//LC:27425
//LC:27426
//LC:27427
// adapted from org.apache.axis.utils.IDKey//LC:27428
//LC:27429
/**//LC:27430
 * Wrap an identity key (System.identityHashCode())//LC:27431
 * so that an object can only be equal() to itself.//LC:27432
 *//LC:27433
 * This is necessary to disambiguate the occasional duplicate//LC:27434
 * identityHashCodes that can occur.//LC:27435
 *//LC:27436
 *///LC:27437
final class IDKey {//LC:27438
    private final Object value;//LC:27439
    private final int id;//LC:27440
//LC:27441
    /**//LC:27442
     * Constructor for IDKey//LC:27443
     * @param _value The value//LC:27444
     *///LC:27445
    public IDKey(final Object _value) {//LC:27446
        // This is the Object hashcode//LC:27447
        id = System.identityHashCode(_value);//LC:27448
        // There have been some cases (LANG-459) that return the//LC:27449
        // same identity hash code for different objects.  So//LC:27450
        // the value is also added to disambiguate these cases.//LC:27451
        value = _value;//LC:27452
    }//LC:27453
//LC:27454
    /**//LC:27455
     * returns hashcode - i.e. the system identity hashcode.//LC:27456
     * @return the hashcode//LC:27457
     *///LC:27458
    @Override//LC:27459
    public int hashCode() {//LC:27460
        return id;//LC:27461
    }//LC:27462
//LC:27463
    /**//LC:27464
     * checks if instances are equal//LC:27465
     * @param other The other object to compare to//LC:27466
     * @return if the instances are for the same object//LC:27467
     *///LC:27468
    @Override//LC:27469
    public boolean equals(final Object other) {//LC:27470
        if (!(other instanceof IDKey)) {//LC:27471
            return false;//LC:27472
        }//LC:27473
        final IDKey idKey = (IDKey) other;//LC:27474
        if (id != idKey.id) {//LC:27475
            return false;//LC:27476
        }//LC:27477
        // Note that identity equals is used.//LC:27478
        return value == idKey.value;//LC:27479
    }//LC:27480
}//LC:27481
//LC:27482
//LC:27483
//LC:27484
/**//LC:27485
 * <p>A pair consisting of two elements.</p>//LC:27486
 *//LC:27487
 * <p>This class is an abstract implementation defining the basic API.//LC:27488
 * It refers to the elements as 'left' and 'right'. It also implements the//LC:27489
 * {@code Map.Entry} interface where the key is 'left' and the value is 'right'.</p>//LC:27490
 *//LC:27491
 * <p>Subclass implementations may be mutable or immutable.//LC:27492
 * However, there is no restriction on the type of the stored objects that may be stored.//LC:27493
 * If mutable objects are stored in the pair, then the pair itself effectively becomes mutable.</p>//LC:27494
 *//LC:27495
 * @param <L> the left element type//LC:27496
 * @param <R> the right element type//LC:27497
 *//LC:27498
 * @since Lang 3.0//LC:27499
 * @version $Id$//LC:27500
 *///LC:27501
abstract class Pair<L, R> implements Map.Entry<L, R>, Comparable<Pair<L, R>>, Serializable {//LC:27502
//LC:27503
    /** Serialization version *///LC:27504
    private static final long serialVersionUID = 4954918890077093841L;//LC:27505
//LC:27506
    /**//LC:27507
     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>//LC:27508
     *//LC:27509
     * <p>This factory allows the pair to be created using inference to//LC:27510
     * obtain the generic types.</p>//LC:27511
     *//LC:27512
     * @param <L> the left element type//LC:27513
     * @param <R> the right element type//LC:27514
     * @param left  the left element, may be null//LC:27515
     * @param right  the right element, may be null//LC:27516
     * @return a pair formed from the two parameters, not null//LC:27517
     *///LC:27518
    public static <L, R> Pair<L, R> of(final L left, final R right) {//LC:27519
        return new ImmutablePair<L, R>(left, right);//LC:27520
    }//LC:27521
//LC:27522
    //-----------------------------------------------------------------------//LC:27523
    /**//LC:27524
     * <p>Gets the left element from this pair.</p>//LC:27525
     *//LC:27526
     * <p>When treated as a key-value pair, this is the key.</p>//LC:27527
     *//LC:27528
     * @return the left element, may be null//LC:27529
     *///LC:27530
    public abstract L getLeft();//LC:27531
//LC:27532
    /**//LC:27533
     * <p>Gets the right element from this pair.</p>//LC:27534
     *//LC:27535
     * <p>When treated as a key-value pair, this is the value.</p>//LC:27536
     *//LC:27537
     * @return the right element, may be null//LC:27538
     *///LC:27539
    public abstract R getRight();//LC:27540
//LC:27541
    /**//LC:27542
     * <p>Gets the key from this pair.</p>//LC:27543
     *//LC:27544
     * <p>This method implements the {@code Map.Entry} interface returning the//LC:27545
     * left element as the key.</p>//LC:27546
     *//LC:27547
     * @return the left element as the key, may be null//LC:27548
     *///LC:27549
    @Override//LC:27550
    public final L getKey() {//LC:27551
        return getLeft();//LC:27552
    }//LC:27553
//LC:27554
    /**//LC:27555
     * <p>Gets the value from this pair.</p>//LC:27556
     *//LC:27557
     * <p>This method implements the {@code Map.Entry} interface returning the//LC:27558
     * right element as the value.</p>//LC:27559
     *//LC:27560
     * @return the right element as the value, may be null//LC:27561
     *///LC:27562
    @Override//LC:27563
    public R getValue() {//LC:27564
        return getRight();//LC:27565
    }//LC:27566
//LC:27567
    //-----------------------------------------------------------------------//LC:27568
    /**//LC:27569
     * <p>Compares the pair based on the left element followed by the right element.//LC:27570
     * The types must be {@code Comparable}.</p>//LC:27571
     *//LC:27572
     * @param other  the other pair, not null//LC:27573
     * @return negative if this is less, zero if equal, positive if greater//LC:27574
     *///LC:27575
    @Override//LC:27576
    public int compareTo(final Pair<L, R> other) {//LC:27577
        return new CompareToBuilder().append(getLeft(), other.getLeft())//LC:27578
                .append(getRight(), other.getRight()).toComparison();//LC:27579
    }//LC:27580
//LC:27581
    /**//LC:27582
     * <p>Compares this pair to another based on the two elements.</p>//LC:27583
     *//LC:27584
     * @param obj  the object to compare to, null returns false//LC:27585
     * @return true if the elements of the pair are equal//LC:27586
     *///LC:27587
    @Override//LC:27588
    public boolean equals(final Object obj) {//LC:27589
        if (obj == this) {//LC:27590
            return true;//LC:27591
        }//LC:27592
        if (obj instanceof Map.Entry<?, ?>) {//LC:27593
            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;//LC:27594
            return ObjectUtils.equals(getKey(), other.getKey())//LC:27595
                    && ObjectUtils.equals(getValue(), other.getValue());//LC:27596
        }//LC:27597
        return false;//LC:27598
    }//LC:27599
//LC:27600
    /**//LC:27601
     * <p>Returns a suitable hash code.//LC:27602
     * The hash code follows the definition in {@code Map.Entry}.</p>//LC:27603
     *//LC:27604
     * @return the hash code//LC:27605
     *///LC:27606
    @Override//LC:27607
    public int hashCode() {//LC:27608
        // see Map.Entry API specification//LC:27609
        return (getKey() == null ? 0 : getKey().hashCode()) ^//LC:27610
                (getValue() == null ? 0 : getValue().hashCode());//LC:27611
    }//LC:27612
//LC:27613
    /**//LC:27614
     * <p>Returns a String representation of this pair using the format {@code ($left,$right)}.</p>//LC:27615
     *//LC:27616
     * @return a string describing this object, not null//LC:27617
     *///LC:27618
    @Override//LC:27619
    public String toString() {//LC:27620
        return new StringBuilder().append('(').append(getLeft()).append(',').append(getRight()).append(')').toString();//LC:27621
    }//LC:27622
//LC:27623
    /**//LC:27624
     * <p>Formats the receiver using the given format.</p>//LC:27625
     *//LC:27626
     * <p>This uses {@link java.util.Formattable} to perform the formatting. Two variables may//LC:27627
     * be used to embed the left and right elements. Use {@code %1$s} for the left//LC:27628
     * element (key) and {@code %2$s} for the right element (value).//LC:27629
     * The default format used by {@code toString()} is {@code (%1$s,%2$s)}.</p>//LC:27630
     *//LC:27631
     * @param format  the format string, optionally containing {@code %1$s} and {@code %2$s}, not null//LC:27632
     * @return the formatted string, not null//LC:27633
     *///LC:27634
    public String toString(final String format) {//LC:27635
        return String.format(format, getLeft(), getRight());//LC:27636
    }//LC:27637
//LC:27638
}//LC:27639
//LC:27640
//LC:27641
/**//LC:27642
 * A matcher class that can be queried to determine if a character array//LC:27643
 * portion matches.//LC:27644
 * <p>//LC:27645
 * This class comes complete with various factory methods.//LC:27646
 * If these do not suffice, you can subclass and implement your own matcher.//LC:27647
 *//LC:27648
 * @since 2.2//LC:27649
 * @version $Id$//LC:27650
 *///LC:27651
abstract class StrMatcher {//LC:27652
//LC:27653
    /**//LC:27654
     * Matches the comma character.//LC:27655
     *///LC:27656
    private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');//LC:27657
    /**//LC:27658
     * Matches the tab character.//LC:27659
     *///LC:27660
    private static final StrMatcher TAB_MATCHER = new CharMatcher('\t');//LC:27661
    /**//LC:27662
     * Matches the space character.//LC:27663
     *///LC:27664
    private static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');//LC:27665
    /**//LC:27666
     * Matches the same characters as StringTokenizer,//LC:27667
     * namely space, tab, newline, formfeed.//LC:27668
     *///LC:27669
    private static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(" \t\n\r\f".toCharArray());//LC:27670
    /**//LC:27671
     * Matches the String trim() whitespace characters.//LC:27672
     *///LC:27673
    private static final StrMatcher TRIM_MATCHER = new TrimMatcher();//LC:27674
    /**//LC:27675
     * Matches the double quote character.//LC:27676
     *///LC:27677
    private static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\'');//LC:27678
    /**//LC:27679
     * Matches the double quote character.//LC:27680
     *///LC:27681
    private static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('"');//LC:27682
    /**//LC:27683
     * Matches the single or double quote character.//LC:27684
     *///LC:27685
    private static final StrMatcher QUOTE_MATCHER = new CharSetMatcher("'\"".toCharArray());//LC:27686
    /**//LC:27687
     * Matches no characters.//LC:27688
     *///LC:27689
    private static final StrMatcher NONE_MATCHER = new NoMatcher();//LC:27690
//LC:27691
    // -----------------------------------------------------------------------//LC:27692
//LC:27693
    /**//LC:27694
     * Returns a matcher which matches the comma character.//LC:27695
     *//LC:27696
     * @return a matcher for a comma//LC:27697
     *///LC:27698
    public static StrMatcher commaMatcher() {//LC:27699
        return COMMA_MATCHER;//LC:27700
    }//LC:27701
//LC:27702
    /**//LC:27703
     * Returns a matcher which matches the tab character.//LC:27704
     *//LC:27705
     * @return a matcher for a tab//LC:27706
     *///LC:27707
    public static StrMatcher tabMatcher() {//LC:27708
        return TAB_MATCHER;//LC:27709
    }//LC:27710
//LC:27711
    /**//LC:27712
     * Returns a matcher which matches the space character.//LC:27713
     *//LC:27714
     * @return a matcher for a space//LC:27715
     *///LC:27716
    public static StrMatcher spaceMatcher() {//LC:27717
        return SPACE_MATCHER;//LC:27718
    }//LC:27719
//LC:27720
    /**//LC:27721
     * Matches the same characters as StringTokenizer,//LC:27722
     * namely space, tab, newline and formfeed.//LC:27723
     *//LC:27724
     * @return the split matcher//LC:27725
     *///LC:27726
    public static StrMatcher splitMatcher() {//LC:27727
        return SPLIT_MATCHER;//LC:27728
    }//LC:27729
//LC:27730
    /**//LC:27731
     * Matches the String trim() whitespace characters.//LC:27732
     *//LC:27733
     * @return the trim matcher//LC:27734
     *///LC:27735
    public static StrMatcher trimMatcher() {//LC:27736
        return TRIM_MATCHER;//LC:27737
    }//LC:27738
//LC:27739
    /**//LC:27740
     * Returns a matcher which matches the single quote character.//LC:27741
     *//LC:27742
     * @return a matcher for a single quote//LC:27743
     *///LC:27744
    public static StrMatcher singleQuoteMatcher() {//LC:27745
        return SINGLE_QUOTE_MATCHER;//LC:27746
    }//LC:27747
//LC:27748
    /**//LC:27749
     * Returns a matcher which matches the double quote character.//LC:27750
     *//LC:27751
     * @return a matcher for a double quote//LC:27752
     *///LC:27753
    public static StrMatcher doubleQuoteMatcher() {//LC:27754
        return DOUBLE_QUOTE_MATCHER;//LC:27755
    }//LC:27756
//LC:27757
    /**//LC:27758
     * Returns a matcher which matches the single or double quote character.//LC:27759
     *//LC:27760
     * @return a matcher for a single or double quote//LC:27761
     *///LC:27762
    public static StrMatcher quoteMatcher() {//LC:27763
        return QUOTE_MATCHER;//LC:27764
    }//LC:27765
//LC:27766
    /**//LC:27767
     * Matches no characters.//LC:27768
     *//LC:27769
     * @return a matcher that matches nothing//LC:27770
     *///LC:27771
    public static StrMatcher noneMatcher() {//LC:27772
        return NONE_MATCHER;//LC:27773
    }//LC:27774
//LC:27775
    /**//LC:27776
     * Constructor that creates a matcher from a character.//LC:27777
     *//LC:27778
     * @param ch  the character to match, must not be null//LC:27779
     * @return a new Matcher for the given char//LC:27780
     *///LC:27781
    public static StrMatcher charMatcher(final char ch) {//LC:27782
        return new CharMatcher(ch);//LC:27783
    }//LC:27784
//LC:27785
    /**//LC:27786
     * Constructor that creates a matcher from a set of characters.//LC:27787
     *//LC:27788
     * @param chars  the characters to match, null or empty matches nothing//LC:27789
     * @return a new matcher for the given char[]//LC:27790
     *///LC:27791
    public static StrMatcher charSetMatcher(final char... chars) {//LC:27792
        if (chars == null || chars.length == 0) {//LC:27793
            return NONE_MATCHER;//LC:27794
        }//LC:27795
        if (chars.length == 1) {//LC:27796
            return new CharMatcher(chars[0]);//LC:27797
        }//LC:27798
        return new CharSetMatcher(chars);//LC:27799
    }//LC:27800
//LC:27801
    /**//LC:27802
     * Constructor that creates a matcher from a string representing a set of characters.//LC:27803
     *//LC:27804
     * @param chars  the characters to match, null or empty matches nothing//LC:27805
     * @return a new Matcher for the given characters//LC:27806
     *///LC:27807
    public static StrMatcher charSetMatcher(final String chars) {//LC:27808
        if (StringUtils.isEmpty(chars)) {//LC:27809
            return NONE_MATCHER;//LC:27810
        }//LC:27811
        if (chars.length() == 1) {//LC:27812
            return new CharMatcher(chars.charAt(0));//LC:27813
        }//LC:27814
        return new CharSetMatcher(chars.toCharArray());//LC:27815
    }//LC:27816
//LC:27817
    /**//LC:27818
     * Constructor that creates a matcher from a string.//LC:27819
     *//LC:27820
     * @param str  the string to match, null or empty matches nothing//LC:27821
     * @return a new Matcher for the given String//LC:27822
     *///LC:27823
    public static StrMatcher stringMatcher(final String str) {//LC:27824
        if (StringUtils.isEmpty(str)) {//LC:27825
            return NONE_MATCHER;//LC:27826
        }//LC:27827
        return new StringMatcher(str);//LC:27828
    }//LC:27829
//LC:27830
    //-----------------------------------------------------------------------//LC:27831
    /**//LC:27832
     * Constructor.//LC:27833
     *///LC:27834
    protected StrMatcher() {//LC:27835
        super();//LC:27836
    }//LC:27837
//LC:27838
    /**//LC:27839
     * Returns the number of matching characters, zero for no match.//LC:27840
     * <p>//LC:27841
     * This method is called to check for a match.//LC:27842
     * The parameter <code>pos</code> represents the current position to be//LC:27843
     * checked in the string <code>buffer</code> (a character array which must//LC:27844
     * not be changed).//LC:27845
     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.//LC:27846
     * <p>//LC:27847
     * The character array may be larger than the active area to be matched.//LC:27848
     * Only values in the buffer between the specifed indices may be accessed.//LC:27849
     * <p>//LC:27850
     * The matching code may check one character or many.//LC:27851
     * It may check characters preceding <code>pos</code> as well as those//LC:27852
     * after, so long as no checks exceed the bounds specified.//LC:27853
     * <p>//LC:27854
     * It must return zero for no match, or a positive number if a match was found.//LC:27855
     * The number indicates the number of characters that matched.//LC:27856
     *//LC:27857
     * @param buffer  the text content to match against, do not change//LC:27858
     * @param pos  the starting position for the match, valid for buffer//LC:27859
     * @param bufferStart  the first active index in the buffer, valid for buffer//LC:27860
     * @param bufferEnd  the end index (exclusive) of the active buffer, valid for buffer//LC:27861
     * @return the number of matching characters, zero for no match//LC:27862
     *///LC:27863
    public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);//LC:27864
//LC:27865
    /**//LC:27866
     * Returns the number of matching characters, zero for no match.//LC:27867
     * <p>//LC:27868
     * This method is called to check for a match.//LC:27869
     * The parameter <code>pos</code> represents the current position to be//LC:27870
     * checked in the string <code>buffer</code> (a character array which must//LC:27871
     * not be changed).//LC:27872
     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.//LC:27873
     * <p>//LC:27874
     * The matching code may check one character or many.//LC:27875
     * It may check characters preceding <code>pos</code> as well as those after.//LC:27876
     * <p>//LC:27877
     * It must return zero for no match, or a positive number if a match was found.//LC:27878
     * The number indicates the number of characters that matched.//LC:27879
     *//LC:27880
     * @param buffer  the text content to match against, do not change//LC:27881
     * @param pos  the starting position for the match, valid for buffer//LC:27882
     * @return the number of matching characters, zero for no match//LC:27883
     * @since 2.4//LC:27884
     *///LC:27885
    public int isMatch(final char[] buffer, final int pos) {//LC:27886
        return isMatch(buffer, pos, 0, buffer.length);//LC:27887
    }//LC:27888
//LC:27889
    //-----------------------------------------------------------------------//LC:27890
    /**//LC:27891
     * Class used to define a set of characters for matching purposes.//LC:27892
     *///LC:27893
    static final class CharSetMatcher extends StrMatcher {//LC:27894
        /** The set of characters to match. *///LC:27895
        private final char[] chars;//LC:27896
//LC:27897
        /**//LC:27898
         * Constructor that creates a matcher from a character array.//LC:27899
         *//LC:27900
         * @param chars  the characters to match, must not be null//LC:27901
         *///LC:27902
        CharSetMatcher(final char chars[]) {//LC:27903
            super();//LC:27904
            this.chars = chars.clone();//LC:27905
            Arrays.sort(this.chars);//LC:27906
        }//LC:27907
//LC:27908
        /**//LC:27909
         * Returns whether or not the given character matches.//LC:27910
         *//LC:27911
         * @param buffer  the text content to match against, do not change//LC:27912
         * @param pos  the starting position for the match, valid for buffer//LC:27913
         * @param bufferStart  the first active index in the buffer, valid for buffer//LC:27914
         * @param bufferEnd  the end index of the active buffer, valid for buffer//LC:27915
         * @return the number of matching characters, zero for no match//LC:27916
         *///LC:27917
        @Override//LC:27918
        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {//LC:27919
            return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;//LC:27920
        }//LC:27921
    }//LC:27922
//LC:27923
    //-----------------------------------------------------------------------//LC:27924
    /**//LC:27925
     * Class used to define a character for matching purposes.//LC:27926
     *///LC:27927
    static final class CharMatcher extends StrMatcher {//LC:27928
        /** The character to match. *///LC:27929
        private final char ch;//LC:27930
//LC:27931
        /**//LC:27932
         * Constructor that creates a matcher that matches a single character.//LC:27933
         *//LC:27934
         * @param ch  the character to match//LC:27935
         *///LC:27936
        CharMatcher(final char ch) {//LC:27937
            super();//LC:27938
            this.ch = ch;//LC:27939
        }//LC:27940
//LC:27941
        /**//LC:27942
         * Returns whether or not the given character matches.//LC:27943
         *//LC:27944
         * @param buffer  the text content to match against, do not change//LC:27945
         * @param pos  the starting position for the match, valid for buffer//LC:27946
         * @param bufferStart  the first active index in the buffer, valid for buffer//LC:27947
         * @param bufferEnd  the end index of the active buffer, valid for buffer//LC:27948
         * @return the number of matching characters, zero for no match//LC:27949
         *///LC:27950
        @Override//LC:27951
        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {//LC:27952
            return ch == buffer[pos] ? 1 : 0;//LC:27953
        }//LC:27954
    }//LC:27955
//LC:27956
    //-----------------------------------------------------------------------//LC:27957
    /**//LC:27958
     * Class used to define a set of characters for matching purposes.//LC:27959
     *///LC:27960
    static final class StringMatcher extends StrMatcher {//LC:27961
        /** The string to match, as a character array. *///LC:27962
        private final char[] chars;//LC:27963
//LC:27964
        /**//LC:27965
         * Constructor that creates a matcher from a String.//LC:27966
         *//LC:27967
         * @param str  the string to match, must not be null//LC:27968
         *///LC:27969
        StringMatcher(final String str) {//LC:27970
            super();//LC:27971
            chars = str.toCharArray();//LC:27972
        }//LC:27973
//LC:27974
        /**//LC:27975
         * Returns whether or not the given text matches the stored string.//LC:27976
         *//LC:27977
         * @param buffer  the text content to match against, do not change//LC:27978
         * @param pos  the starting position for the match, valid for buffer//LC:27979
         * @param bufferStart  the first active index in the buffer, valid for buffer//LC:27980
         * @param bufferEnd  the end index of the active buffer, valid for buffer//LC:27981
         * @return the number of matching characters, zero for no match//LC:27982
         *///LC:27983
        @Override//LC:27984
        public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) {//LC:27985
            final int len = chars.length;//LC:27986
            if (pos + len > bufferEnd) {//LC:27987
                return 0;//LC:27988
            }//LC:27989
            for (int i = 0; i < chars.length; i++, pos++) {//LC:27990
                if (chars[i] != buffer[pos]) {//LC:27991
                    return 0;//LC:27992
                }//LC:27993
            }//LC:27994
            return len;//LC:27995
        }//LC:27996
    }//LC:27997
//LC:27998
    //-----------------------------------------------------------------------//LC:27999
    /**//LC:28000
     * Class used to match no characters.//LC:28001
     *///LC:28002
    static final class NoMatcher extends StrMatcher {//LC:28003
//LC:28004
        /**//LC:28005
         * Constructs a new instance of <code>NoMatcher</code>.//LC:28006
         *///LC:28007
        NoMatcher() {//LC:28008
            super();//LC:28009
        }//LC:28010
//LC:28011
        /**//LC:28012
         * Always returns <code>false</code>.//LC:28013
         *//LC:28014
         * @param buffer  the text content to match against, do not change//LC:28015
         * @param pos  the starting position for the match, valid for buffer//LC:28016
         * @param bufferStart  the first active index in the buffer, valid for buffer//LC:28017
         * @param bufferEnd  the end index of the active buffer, valid for buffer//LC:28018
         * @return the number of matching characters, zero for no match//LC:28019
         *///LC:28020
        @Override//LC:28021
        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {//LC:28022
            return 0;//LC:28023
        }//LC:28024
    }//LC:28025
//LC:28026
    //-----------------------------------------------------------------------//LC:28027
    /**//LC:28028
     * Class used to match whitespace as per trim().//LC:28029
     *///LC:28030
    static final class TrimMatcher extends StrMatcher {//LC:28031
//LC:28032
        /**//LC:28033
         * Constructs a new instance of <code>TrimMatcher</code>.//LC:28034
         *///LC:28035
        TrimMatcher() {//LC:28036
            super();//LC:28037
        }//LC:28038
//LC:28039
        /**//LC:28040
         * Returns whether or not the given character matches.//LC:28041
         *//LC:28042
         * @param buffer  the text content to match against, do not change//LC:28043
         * @param pos  the starting position for the match, valid for buffer//LC:28044
         * @param bufferStart  the first active index in the buffer, valid for buffer//LC:28045
         * @param bufferEnd  the end index of the active buffer, valid for buffer//LC:28046
         * @return the number of matching characters, zero for no match//LC:28047
         *///LC:28048
        @Override//LC:28049
        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {//LC:28050
            return buffer[pos] <= 32 ? 1 : 0;//LC:28051
        }//LC:28052
    }//LC:28053
//LC:28054
}//LC:28055
//LC:28056
//LC:28057
//LC:28058
/**//LC:28059
 * <p>//LC:28060
 * Helpers for {@code java.lang.System}.//LC:28061
 * </p>//LC:28062
 * <p>//LC:28063
 * If a system property cannot be read due to security restrictions, the corresponding field in this class will be set//LC:28064
 * to {@code null} and a message will be written to {@code System.err}.//LC:28065
 * </p>//LC:28066
 * <p>//LC:28067
 * #ThreadSafe#//LC:28068
 * </p>//LC:28069
 *//LC:28070
 * @since 1.0//LC:28071
 * @version $Id$//LC:28072
 *///LC:28073
class SystemUtils {//LC:28074
//LC:28075
    /**//LC:28076
     * The prefix String for all Windows OS.//LC:28077
     *///LC:28078
    private static final String OS_NAME_WINDOWS_PREFIX = "Windows";//LC:28079
//LC:28080
    // System property constants//LC:28081
    // -----------------------------------------------------------------------//LC:28082
    // These MUST be declared first. Other constants depend on this.//LC:28083
//LC:28084
    /**//LC:28085
     * The System property key for the user home directory.//LC:28086
     *///LC:28087
    private static final String USER_HOME_KEY = "user.home";//LC:28088
//LC:28089
    /**//LC:28090
     * The System property key for the user directory.//LC:28091
     *///LC:28092
    private static final String USER_DIR_KEY = "user.dir";//LC:28093
//LC:28094
    /**//LC:28095
     * The System property key for the Java IO temporary directory.//LC:28096
     *///LC:28097
    private static final String JAVA_IO_TMPDIR_KEY = "java.io.tmpdir";//LC:28098
//LC:28099
    /**//LC:28100
     * The System property key for the Java home directory.//LC:28101
     *///LC:28102
    private static final String JAVA_HOME_KEY = "java.home";//LC:28103
//LC:28104
    /**//LC:28105
     * <p>//LC:28106
     * The {@code awt.toolkit} System Property.//LC:28107
     * </p>//LC:28108
     * <p>//LC:28109
     * Holds a class name, on Windows XP this is {@code sun.awt.windows.WToolkit}.//LC:28110
     * </p>//LC:28111
     * <p>//LC:28112
     * <b>On platforms without a GUI, this value is {@code null}.</b>//LC:28113
     * </p>//LC:28114
     * <p>//LC:28115
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28116
     * not exist.//LC:28117
     * </p>//LC:28118
     * <p>//LC:28119
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28120
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28121
     * sync with that System property.//LC:28122
     * </p>//LC:28123
     *//LC:28124
     * @since 2.1//LC:28125
     *///LC:28126
    public static final String AWT_TOOLKIT = getSystemProperty("awt.toolkit");//LC:28127
//LC:28128
    /**//LC:28129
     * <p>//LC:28130
     * The {@code file.encoding} System Property.//LC:28131
     * </p>//LC:28132
     * <p>//LC:28133
     * File encoding, such as {@code Cp1252}.//LC:28134
     * </p>//LC:28135
     * <p>//LC:28136
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28137
     * not exist.//LC:28138
     * </p>//LC:28139
     * <p>//LC:28140
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28141
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28142
     * sync with that System property.//LC:28143
     * </p>//LC:28144
     *//LC:28145
     * @since 2.0//LC:28146
     * @since Java 1.2//LC:28147
     *///LC:28148
    public static final String FILE_ENCODING = getSystemProperty("file.encoding");//LC:28149
//LC:28150
    /**//LC:28151
     * <p>//LC:28152
     * The {@code file.separator} System Property.//LC:28153
     * The file separator is://LC:28154
     * <ul>//LC:28155
     * <li>{@code "/"}</code> on UNIX</li>//LC:28156
     * <li>{@code "\"}</code> on Windows.</li>//LC:28157
     * </ul>//LC:28158
     * </p>//LC:28159
     * <p>//LC:28160
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28161
     * not exist.//LC:28162
     * </p>//LC:28163
     * <p>//LC:28164
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28165
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28166
     * sync with that System property.//LC:28167
     * </p>//LC:28168
     *//LC:28169
     * @since Java 1.1//LC:28170
     *///LC:28171
    public static final String FILE_SEPARATOR = getSystemProperty("file.separator");//LC:28172
//LC:28173
    /**//LC:28174
     * <p>//LC:28175
     * The {@code java.awt.fonts} System Property.//LC:28176
     * </p>//LC:28177
     * <p>//LC:28178
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28179
     * not exist.//LC:28180
     * </p>//LC:28181
     * <p>//LC:28182
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28183
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28184
     * sync with that System property.//LC:28185
     * </p>//LC:28186
     *//LC:28187
     * @since 2.1//LC:28188
     *///LC:28189
    public static final String JAVA_AWT_FONTS = getSystemProperty("java.awt.fonts");//LC:28190
//LC:28191
    /**//LC:28192
     * <p>//LC:28193
     * The {@code java.awt.graphicsenv} System Property.//LC:28194
     * </p>//LC:28195
     * <p>//LC:28196
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28197
     * not exist.//LC:28198
     * </p>//LC:28199
     * <p>//LC:28200
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28201
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28202
     * sync with that System property.//LC:28203
     * </p>//LC:28204
     *//LC:28205
     * @since 2.1//LC:28206
     *///LC:28207
    public static final String JAVA_AWT_GRAPHICSENV = getSystemProperty("java.awt.graphicsenv");//LC:28208
//LC:28209
    /**//LC:28210
     * <p>//LC:28211
     * The {@code java.awt.headless} System Property. The value of this property is the String {@code "true"} or//LC:28212
     * {@code "false"}.//LC:28213
     * </p>//LC:28214
     * <p>//LC:28215
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28216
     * not exist.//LC:28217
     * </p>//LC:28218
     * <p>//LC:28219
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28220
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28221
     * sync with that System property.//LC:28222
     * </p>//LC:28223
     *//LC:28224
     * @see #isJavaAwtHeadless()//LC:28225
     * @since 2.1//LC:28226
     * @since Java 1.4//LC:28227
     *///LC:28228
    public static final String JAVA_AWT_HEADLESS = getSystemProperty("java.awt.headless");//LC:28229
//LC:28230
    /**//LC:28231
     * <p>//LC:28232
     * The {@code java.awt.printerjob} System Property.//LC:28233
     * </p>//LC:28234
     * <p>//LC:28235
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28236
     * not exist.//LC:28237
     * </p>//LC:28238
     * <p>//LC:28239
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28240
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28241
     * sync with that System property.//LC:28242
     * </p>//LC:28243
     *//LC:28244
     * @since 2.1//LC:28245
     *///LC:28246
    public static final String JAVA_AWT_PRINTERJOB = getSystemProperty("java.awt.printerjob");//LC:28247
//LC:28248
    /**//LC:28249
     * <p>//LC:28250
     * The {@code java.class.path} System Property. Java class path.//LC:28251
     * </p>//LC:28252
     * <p>//LC:28253
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28254
     * not exist.//LC:28255
     * </p>//LC:28256
     * <p>//LC:28257
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28258
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28259
     * sync with that System property.//LC:28260
     * </p>//LC:28261
     *//LC:28262
     * @since Java 1.1//LC:28263
     *///LC:28264
    public static final String JAVA_CLASS_PATH = getSystemProperty("java.class.path");//LC:28265
//LC:28266
    /**//LC:28267
     * <p>//LC:28268
     * The {@code java.class.version} System Property. Java class format version number.//LC:28269
     * </p>//LC:28270
     * <p>//LC:28271
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28272
     * not exist.//LC:28273
     * </p>//LC:28274
     * <p>//LC:28275
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28276
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28277
     * sync with that System property.//LC:28278
     * </p>//LC:28279
     *//LC:28280
     * @since Java 1.1//LC:28281
     *///LC:28282
    public static final String JAVA_CLASS_VERSION = getSystemProperty("java.class.version");//LC:28283
//LC:28284
    /**//LC:28285
     * <p>//LC:28286
     * The {@code java.compiler} System Property. Name of JIT compiler to use. First in JDK version 1.2. Not used in Sun//LC:28287
     * JDKs after 1.2.//LC:28288
     * </p>//LC:28289
     * <p>//LC:28290
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28291
     * not exist.//LC:28292
     * </p>//LC:28293
     * <p>//LC:28294
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28295
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28296
     * sync with that System property.//LC:28297
     * </p>//LC:28298
     *//LC:28299
     * @since Java 1.2. Not used in Sun versions after 1.2.//LC:28300
     *///LC:28301
    public static final String JAVA_COMPILER = getSystemProperty("java.compiler");//LC:28302
//LC:28303
    /**//LC:28304
     * <p>//LC:28305
     * The {@code java.endorsed.dirs} System Property. Path of endorsed directory or directories.//LC:28306
     * </p>//LC:28307
     * <p>//LC:28308
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28309
     * not exist.//LC:28310
     * </p>//LC:28311
     * <p>//LC:28312
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28313
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28314
     * sync with that System property.//LC:28315
     * </p>//LC:28316
     *//LC:28317
     * @since Java 1.4//LC:28318
     *///LC:28319
    public static final String JAVA_ENDORSED_DIRS = getSystemProperty("java.endorsed.dirs");//LC:28320
//LC:28321
    /**//LC:28322
     * <p>//LC:28323
     * The {@code java.ext.dirs} System Property. Path of extension directory or directories.//LC:28324
     * </p>//LC:28325
     * <p>//LC:28326
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28327
     * not exist.//LC:28328
     * </p>//LC:28329
     * <p>//LC:28330
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28331
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28332
     * sync with that System property.//LC:28333
     * </p>//LC:28334
     *//LC:28335
     * @since Java 1.3//LC:28336
     *///LC:28337
    public static final String JAVA_EXT_DIRS = getSystemProperty("java.ext.dirs");//LC:28338
//LC:28339
    /**//LC:28340
     * <p>//LC:28341
     * The {@code java.home} System Property. Java installation directory.//LC:28342
     * </p>//LC:28343
     * <p>//LC:28344
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28345
     * not exist.//LC:28346
     * </p>//LC:28347
     * <p>//LC:28348
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28349
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28350
     * sync with that System property.//LC:28351
     * </p>//LC:28352
     *//LC:28353
     * @since Java 1.1//LC:28354
     *///LC:28355
    public static final String JAVA_HOME = getSystemProperty(JAVA_HOME_KEY);//LC:28356
//LC:28357
    /**//LC:28358
     * <p>//LC:28359
     * The {@code java.io.tmpdir} System Property. Default temp file path.//LC:28360
     * </p>//LC:28361
     * <p>//LC:28362
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28363
     * not exist.//LC:28364
     * </p>//LC:28365
     * <p>//LC:28366
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28367
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28368
     * sync with that System property.//LC:28369
     * </p>//LC:28370
     *//LC:28371
     * @since Java 1.2//LC:28372
     *///LC:28373
    public static final String JAVA_IO_TMPDIR = getSystemProperty(JAVA_IO_TMPDIR_KEY);//LC:28374
//LC:28375
    /**//LC:28376
     * <p>//LC:28377
     * The {@code java.library.path} System Property. List of paths to search when loading libraries.//LC:28378
     * </p>//LC:28379
     * <p>//LC:28380
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28381
     * not exist.//LC:28382
     * </p>//LC:28383
     * <p>//LC:28384
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28385
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28386
     * sync with that System property.//LC:28387
     * </p>//LC:28388
     *//LC:28389
     * @since Java 1.2//LC:28390
     *///LC:28391
    public static final String JAVA_LIBRARY_PATH = getSystemProperty("java.library.path");//LC:28392
//LC:28393
    /**//LC:28394
     * <p>//LC:28395
     * The {@code java.runtime.name} System Property. Java Runtime Environment name.//LC:28396
     * </p>//LC:28397
     * <p>//LC:28398
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28399
     * not exist.//LC:28400
     * </p>//LC:28401
     * <p>//LC:28402
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28403
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28404
     * sync with that System property.//LC:28405
     * </p>//LC:28406
     *//LC:28407
     * @since 2.0//LC:28408
     * @since Java 1.3//LC:28409
     *///LC:28410
    public static final String JAVA_RUNTIME_NAME = getSystemProperty("java.runtime.name");//LC:28411
//LC:28412
    /**//LC:28413
     * <p>//LC:28414
     * The {@code java.runtime.version} System Property. Java Runtime Environment version.//LC:28415
     * </p>//LC:28416
     * <p>//LC:28417
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28418
     * not exist.//LC:28419
     * </p>//LC:28420
     * <p>//LC:28421
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28422
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28423
     * sync with that System property.//LC:28424
     * </p>//LC:28425
     *//LC:28426
     * @since 2.0//LC:28427
     * @since Java 1.3//LC:28428
     *///LC:28429
    public static final String JAVA_RUNTIME_VERSION = getSystemProperty("java.runtime.version");//LC:28430
//LC:28431
    /**//LC:28432
     * <p>//LC:28433
     * The {@code java.specification.name} System Property. Java Runtime Environment specification name.//LC:28434
     * </p>//LC:28435
     * <p>//LC:28436
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28437
     * not exist.//LC:28438
     * </p>//LC:28439
     * <p>//LC:28440
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28441
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28442
     * sync with that System property.//LC:28443
     * </p>//LC:28444
     *//LC:28445
     * @since Java 1.2//LC:28446
     *///LC:28447
    public static final String JAVA_SPECIFICATION_NAME = getSystemProperty("java.specification.name");//LC:28448
//LC:28449
    /**//LC:28450
     * <p>//LC:28451
     * The {@code java.specification.vendor} System Property. Java Runtime Environment specification vendor.//LC:28452
     * </p>//LC:28453
     * <p>//LC:28454
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28455
     * not exist.//LC:28456
     * </p>//LC:28457
     * <p>//LC:28458
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28459
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28460
     * sync with that System property.//LC:28461
     * </p>//LC:28462
     *//LC:28463
     * @since Java 1.2//LC:28464
     *///LC:28465
    public static final String JAVA_SPECIFICATION_VENDOR = getSystemProperty("java.specification.vendor");//LC:28466
//LC:28467
    /**//LC:28468
     * <p>//LC:28469
     * The {@code java.specification.version} System Property. Java Runtime Environment specification version.//LC:28470
     * </p>//LC:28471
     * <p>//LC:28472
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28473
     * not exist.//LC:28474
     * </p>//LC:28475
     * <p>//LC:28476
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28477
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28478
     * sync with that System property.//LC:28479
     * </p>//LC:28480
     *//LC:28481
     * @since Java 1.3//LC:28482
     *///LC:28483
    public static final String JAVA_SPECIFICATION_VERSION = getSystemProperty("java.specification.version");//LC:28484
    private static final JavaVersion JAVA_SPECIFICATION_VERSION_AS_ENUM = JavaVersion.get(JAVA_SPECIFICATION_VERSION);//LC:28485
//LC:28486
    /**//LC:28487
     * <p>//LC:28488
     * The {@code java.util.prefs.PreferencesFactory} System Property. A class name.//LC:28489
     * </p>//LC:28490
     * <p>//LC:28491
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28492
     * not exist.//LC:28493
     * </p>//LC:28494
     * <p>//LC:28495
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28496
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28497
     * sync with that System property.//LC:28498
     * </p>//LC:28499
     *//LC:28500
     * @since 2.1//LC:28501
     * @since Java 1.4//LC:28502
     *///LC:28503
    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY =//LC:28504
            getSystemProperty("java.util.prefs.PreferencesFactory");//LC:28505
//LC:28506
    /**//LC:28507
     * <p>//LC:28508
     * The {@code java.vendor} System Property. Java vendor-specific string.//LC:28509
     * </p>//LC:28510
     * <p>//LC:28511
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28512
     * not exist.//LC:28513
     * </p>//LC:28514
     * <p>//LC:28515
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28516
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28517
     * sync with that System property.//LC:28518
     * </p>//LC:28519
     *//LC:28520
     * @since Java 1.1//LC:28521
     *///LC:28522
    public static final String JAVA_VENDOR = getSystemProperty("java.vendor");//LC:28523
//LC:28524
    /**//LC:28525
     * <p>//LC:28526
     * The {@code java.vendor.url} System Property. Java vendor URL.//LC:28527
     * </p>//LC:28528
     * <p>//LC:28529
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28530
     * not exist.//LC:28531
     * </p>//LC:28532
     * <p>//LC:28533
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28534
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28535
     * sync with that System property.//LC:28536
     * </p>//LC:28537
     *//LC:28538
     * @since Java 1.1//LC:28539
     *///LC:28540
    public static final String JAVA_VENDOR_URL = getSystemProperty("java.vendor.url");//LC:28541
//LC:28542
    /**//LC:28543
     * <p>//LC:28544
     * The {@code java.version} System Property. Java version number.//LC:28545
     * </p>//LC:28546
     * <p>//LC:28547
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28548
     * not exist.//LC:28549
     * </p>//LC:28550
     * <p>//LC:28551
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28552
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28553
     * sync with that System property.//LC:28554
     * </p>//LC:28555
     *//LC:28556
     * @since Java 1.1//LC:28557
     *///LC:28558
    public static final String JAVA_VERSION = getSystemProperty("java.version");//LC:28559
//LC:28560
    /**//LC:28561
     * <p>//LC:28562
     * The {@code java.vm.info} System Property. Java Virtual Machine implementation info.//LC:28563
     * </p>//LC:28564
     * <p>//LC:28565
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28566
     * not exist.//LC:28567
     * </p>//LC:28568
     * <p>//LC:28569
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28570
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28571
     * sync with that System property.//LC:28572
     * </p>//LC:28573
     *//LC:28574
     * @since 2.0//LC:28575
     * @since Java 1.2//LC:28576
     *///LC:28577
    public static final String JAVA_VM_INFO = getSystemProperty("java.vm.info");//LC:28578
//LC:28579
    /**//LC:28580
     * <p>//LC:28581
     * The {@code java.vm.name} System Property. Java Virtual Machine implementation name.//LC:28582
     * </p>//LC:28583
     * <p>//LC:28584
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28585
     * not exist.//LC:28586
     * </p>//LC:28587
     * <p>//LC:28588
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28589
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28590
     * sync with that System property.//LC:28591
     * </p>//LC:28592
     *//LC:28593
     * @since Java 1.2//LC:28594
     *///LC:28595
    public static final String JAVA_VM_NAME = getSystemProperty("java.vm.name");//LC:28596
//LC:28597
    /**//LC:28598
     * <p>//LC:28599
     * The {@code java.vm.specification.name} System Property. Java Virtual Machine specification name.//LC:28600
     * </p>//LC:28601
     * <p>//LC:28602
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28603
     * not exist.//LC:28604
     * </p>//LC:28605
     * <p>//LC:28606
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28607
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28608
     * sync with that System property.//LC:28609
     * </p>//LC:28610
     *//LC:28611
     * @since Java 1.2//LC:28612
     *///LC:28613
    public static final String JAVA_VM_SPECIFICATION_NAME = getSystemProperty("java.vm.specification.name");//LC:28614
//LC:28615
    /**//LC:28616
     * <p>//LC:28617
     * The {@code java.vm.specification.vendor} System Property. Java Virtual Machine specification vendor.//LC:28618
     * </p>//LC:28619
     * <p>//LC:28620
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28621
     * not exist.//LC:28622
     * </p>//LC:28623
     * <p>//LC:28624
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28625
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28626
     * sync with that System property.//LC:28627
     * </p>//LC:28628
     *//LC:28629
     * @since Java 1.2//LC:28630
     *///LC:28631
    public static final String JAVA_VM_SPECIFICATION_VENDOR = getSystemProperty("java.vm.specification.vendor");//LC:28632
//LC:28633
    /**//LC:28634
     * <p>//LC:28635
     * The {@code java.vm.specification.version} System Property. Java Virtual Machine specification version.//LC:28636
     * </p>//LC:28637
     * <p>//LC:28638
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28639
     * not exist.//LC:28640
     * </p>//LC:28641
     * <p>//LC:28642
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28643
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28644
     * sync with that System property.//LC:28645
     * </p>//LC:28646
     *//LC:28647
     * @since Java 1.2//LC:28648
     *///LC:28649
    public static final String JAVA_VM_SPECIFICATION_VERSION = getSystemProperty("java.vm.specification.version");//LC:28650
//LC:28651
    /**//LC:28652
     * <p>//LC:28653
     * The {@code java.vm.vendor} System Property. Java Virtual Machine implementation vendor.//LC:28654
     * </p>//LC:28655
     * <p>//LC:28656
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28657
     * not exist.//LC:28658
     * </p>//LC:28659
     * <p>//LC:28660
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28661
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28662
     * sync with that System property.//LC:28663
     * </p>//LC:28664
     *//LC:28665
     * @since Java 1.2//LC:28666
     *///LC:28667
    public static final String JAVA_VM_VENDOR = getSystemProperty("java.vm.vendor");//LC:28668
//LC:28669
    /**//LC:28670
     * <p>//LC:28671
     * The {@code java.vm.version} System Property. Java Virtual Machine implementation version.//LC:28672
     * </p>//LC:28673
     * <p>//LC:28674
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28675
     * not exist.//LC:28676
     * </p>//LC:28677
     * <p>//LC:28678
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28679
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28680
     * sync with that System property.//LC:28681
     * </p>//LC:28682
     *//LC:28683
     * @since Java 1.2//LC:28684
     *///LC:28685
    public static final String JAVA_VM_VERSION = getSystemProperty("java.vm.version");//LC:28686
//LC:28687
    /**//LC:28688
     * <p>//LC:28689
     * The {@code line.separator} System Property. Line separator (<code>&quot;\n&quot;</code> on UNIX).//LC:28690
     * </p>//LC:28691
     * <p>//LC:28692
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28693
     * not exist.//LC:28694
     * </p>//LC:28695
     * <p>//LC:28696
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28697
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28698
     * sync with that System property.//LC:28699
     * </p>//LC:28700
     *//LC:28701
     * @since Java 1.1//LC:28702
     *///LC:28703
    public static final String LINE_SEPARATOR = getSystemProperty("line.separator");//LC:28704
//LC:28705
    /**//LC:28706
     * <p>//LC:28707
     * The {@code os.arch} System Property. Operating system architecture.//LC:28708
     * </p>//LC:28709
     * <p>//LC:28710
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28711
     * not exist.//LC:28712
     * </p>//LC:28713
     * <p>//LC:28714
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28715
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28716
     * sync with that System property.//LC:28717
     * </p>//LC:28718
     *//LC:28719
     * @since Java 1.1//LC:28720
     *///LC:28721
    public static final String OS_ARCH = getSystemProperty("os.arch");//LC:28722
//LC:28723
    /**//LC:28724
     * <p>//LC:28725
     * The {@code os.name} System Property. Operating system name.//LC:28726
     * </p>//LC:28727
     * <p>//LC:28728
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28729
     * not exist.//LC:28730
     * </p>//LC:28731
     * <p>//LC:28732
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28733
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28734
     * sync with that System property.//LC:28735
     * </p>//LC:28736
     *//LC:28737
     * @since Java 1.1//LC:28738
     *///LC:28739
    public static final String OS_NAME = getSystemProperty("os.name");//LC:28740
//LC:28741
    /**//LC:28742
     * <p>//LC:28743
     * The {@code os.version} System Property. Operating system version.//LC:28744
     * </p>//LC:28745
     * <p>//LC:28746
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28747
     * not exist.//LC:28748
     * </p>//LC:28749
     * <p>//LC:28750
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28751
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28752
     * sync with that System property.//LC:28753
     * </p>//LC:28754
     *//LC:28755
     * @since Java 1.1//LC:28756
     *///LC:28757
    public static final String OS_VERSION = getSystemProperty("os.version");//LC:28758
//LC:28759
    /**//LC:28760
     * <p>//LC:28761
     * The {@code path.separator} System Property. Path separator (<code>&quot;:&quot;</code> on UNIX).//LC:28762
     * </p>//LC:28763
     * <p>//LC:28764
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28765
     * not exist.//LC:28766
     * </p>//LC:28767
     * <p>//LC:28768
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28769
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28770
     * sync with that System property.//LC:28771
     * </p>//LC:28772
     *//LC:28773
     * @since Java 1.1//LC:28774
     *///LC:28775
    public static final String PATH_SEPARATOR = getSystemProperty("path.separator");//LC:28776
//LC:28777
    /**//LC:28778
     * <p>//LC:28779
     * The {@code user.country} or {@code user.region} System Property. User's country code, such as {@code GB}. First//LC:28780
     * in Java version 1.2 as {@code user.region}. Renamed to {@code user.country} in 1.4//LC:28781
     * </p>//LC:28782
     * <p>//LC:28783
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28784
     * not exist.//LC:28785
     * </p>//LC:28786
     * <p>//LC:28787
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28788
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28789
     * sync with that System property.//LC:28790
     * </p>//LC:28791
     *//LC:28792
     * @since 2.0//LC:28793
     * @since Java 1.2//LC:28794
     *///LC:28795
    public static final String USER_COUNTRY = getSystemProperty("user.country") == null ?//LC:28796
            getSystemProperty("user.region") : getSystemProperty("user.country");//LC:28797
//LC:28798
    /**//LC:28799
     * <p>//LC:28800
     * The {@code user.dir} System Property. User's current working directory.//LC:28801
     * </p>//LC:28802
     * <p>//LC:28803
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28804
     * not exist.//LC:28805
     * </p>//LC:28806
     * <p>//LC:28807
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28808
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28809
     * sync with that System property.//LC:28810
     * </p>//LC:28811
     *//LC:28812
     * @since Java 1.1//LC:28813
     *///LC:28814
    public static final String USER_DIR = getSystemProperty(USER_DIR_KEY);//LC:28815
//LC:28816
    /**//LC:28817
     * <p>//LC:28818
     * The {@code user.home} System Property. User's home directory.//LC:28819
     * </p>//LC:28820
     * <p>//LC:28821
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28822
     * not exist.//LC:28823
     * </p>//LC:28824
     * <p>//LC:28825
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28826
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28827
     * sync with that System property.//LC:28828
     * </p>//LC:28829
     *//LC:28830
     * @since Java 1.1//LC:28831
     *///LC:28832
    public static final String USER_HOME = getSystemProperty(USER_HOME_KEY);//LC:28833
//LC:28834
    /**//LC:28835
     * <p>//LC:28836
     * The {@code user.language} System Property. User's language code, such as {@code "en"}.//LC:28837
     * </p>//LC:28838
     * <p>//LC:28839
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28840
     * not exist.//LC:28841
     * </p>//LC:28842
     * <p>//LC:28843
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28844
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28845
     * sync with that System property.//LC:28846
     * </p>//LC:28847
     *//LC:28848
     * @since 2.0//LC:28849
     * @since Java 1.2//LC:28850
     *///LC:28851
    public static final String USER_LANGUAGE = getSystemProperty("user.language");//LC:28852
//LC:28853
    /**//LC:28854
     * <p>//LC:28855
     * The {@code user.name} System Property. User's account name.//LC:28856
     * </p>//LC:28857
     * <p>//LC:28858
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28859
     * not exist.//LC:28860
     * </p>//LC:28861
     * <p>//LC:28862
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28863
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28864
     * sync with that System property.//LC:28865
     * </p>//LC:28866
     *//LC:28867
     * @since Java 1.1//LC:28868
     *///LC:28869
    public static final String USER_NAME = getSystemProperty("user.name");//LC:28870
//LC:28871
    /**//LC:28872
     * <p>//LC:28873
     * The {@code user.timezone} System Property. For example: {@code "America/Los_Angeles"}.//LC:28874
     * </p>//LC:28875
     * <p>//LC:28876
     * Defaults to {@code null} if the runtime does not have security access to read this property or the property does//LC:28877
     * not exist.//LC:28878
     * </p>//LC:28879
     * <p>//LC:28880
     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or//LC:28881
     * {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value will be out of//LC:28882
     * sync with that System property.//LC:28883
     * </p>//LC:28884
     *//LC:28885
     * @since 2.1//LC:28886
     *///LC:28887
    public static final String USER_TIMEZONE = getSystemProperty("user.timezone");//LC:28888
//LC:28889
    // Java version checks//LC:28890
    // -----------------------------------------------------------------------//LC:28891
    // These MUST be declared after those above as they depend on the//LC:28892
    // values being set up//LC:28893
//LC:28894
    /**//LC:28895
     * <p>//LC:28896
     * Is {@code true} if this is Java version 1.1 (also 1.1.x versions).//LC:28897
     * </p>//LC:28898
     * <p>//LC:28899
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28900
     * </p>//LC:28901
     *///LC:28902
    public static final boolean IS_JAVA_1_1 = getJavaVersionMatches("1.1");//LC:28903
//LC:28904
    /**//LC:28905
     * <p>//LC:28906
     * Is {@code true} if this is Java version 1.2 (also 1.2.x versions).//LC:28907
     * </p>//LC:28908
     * <p>//LC:28909
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28910
     * </p>//LC:28911
     *///LC:28912
    public static final boolean IS_JAVA_1_2 = getJavaVersionMatches("1.2");//LC:28913
//LC:28914
    /**//LC:28915
     * <p>//LC:28916
     * Is {@code true} if this is Java version 1.3 (also 1.3.x versions).//LC:28917
     * </p>//LC:28918
     * <p>//LC:28919
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28920
     * </p>//LC:28921
     *///LC:28922
    public static final boolean IS_JAVA_1_3 = getJavaVersionMatches("1.3");//LC:28923
//LC:28924
    /**//LC:28925
     * <p>//LC:28926
     * Is {@code true} if this is Java version 1.4 (also 1.4.x versions).//LC:28927
     * </p>//LC:28928
     * <p>//LC:28929
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28930
     * </p>//LC:28931
     *///LC:28932
    public static final boolean IS_JAVA_1_4 = getJavaVersionMatches("1.4");//LC:28933
//LC:28934
    /**//LC:28935
     * <p>//LC:28936
     * Is {@code true} if this is Java version 1.5 (also 1.5.x versions).//LC:28937
     * </p>//LC:28938
     * <p>//LC:28939
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28940
     * </p>//LC:28941
     *///LC:28942
    public static final boolean IS_JAVA_1_5 = getJavaVersionMatches("1.5");//LC:28943
//LC:28944
    /**//LC:28945
     * <p>//LC:28946
     * Is {@code true} if this is Java version 1.6 (also 1.6.x versions).//LC:28947
     * </p>//LC:28948
     * <p>//LC:28949
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28950
     * </p>//LC:28951
     *///LC:28952
    public static final boolean IS_JAVA_1_6 = getJavaVersionMatches("1.6");//LC:28953
//LC:28954
    /**//LC:28955
     * <p>//LC:28956
     * Is {@code true} if this is Java version 1.7 (also 1.7.x versions).//LC:28957
     * </p>//LC:28958
     * <p>//LC:28959
     * The field will return {@code false} if {@link #JAVA_VERSION} is {@code null}.//LC:28960
     * </p>//LC:28961
     *//LC:28962
     * @since 3.0//LC:28963
     *///LC:28964
    public static final boolean IS_JAVA_1_7 = getJavaVersionMatches("1.7");//LC:28965
//LC:28966
    // Operating system checks//LC:28967
    // -----------------------------------------------------------------------//LC:28968
    // These MUST be declared after those above as they depend on the//LC:28969
    // values being set up//LC:28970
    // OS names from http://www.vamphq.com/os.html//LC:28971
    // Selected ones included - please advise dev@commons.apache.org//LC:28972
    // if you want another added or a mistake corrected//LC:28973
//LC:28974
    /**//LC:28975
     * <p>//LC:28976
     * Is {@code true} if this is AIX.//LC:28977
     * </p>//LC:28978
     * <p>//LC:28979
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:28980
     * </p>//LC:28981
     *//LC:28982
     * @since 2.0//LC:28983
     *///LC:28984
    public static final boolean IS_OS_AIX = getOSMatchesName("AIX");//LC:28985
//LC:28986
    /**//LC:28987
     * <p>//LC:28988
     * Is {@code true} if this is HP-UX.//LC:28989
     * </p>//LC:28990
     * <p>//LC:28991
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:28992
     * </p>//LC:28993
     *//LC:28994
     * @since 2.0//LC:28995
     *///LC:28996
    public static final boolean IS_OS_HP_UX = getOSMatchesName("HP-UX");//LC:28997
//LC:28998
    /**//LC:28999
     * <p>//LC:29000
     * Is {@code true} if this is Irix.//LC:29001
     * </p>//LC:29002
     * <p>//LC:29003
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29004
     * </p>//LC:29005
     *//LC:29006
     * @since 2.0//LC:29007
     *///LC:29008
    public static final boolean IS_OS_IRIX = getOSMatchesName("Irix");//LC:29009
//LC:29010
    /**//LC:29011
     * <p>//LC:29012
     * Is {@code true} if this is Linux.//LC:29013
     * </p>//LC:29014
     * <p>//LC:29015
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29016
     * </p>//LC:29017
     *//LC:29018
     * @since 2.0//LC:29019
     *///LC:29020
    public static final boolean IS_OS_LINUX = getOSMatchesName("Linux") || getOSMatchesName("LINUX");//LC:29021
//LC:29022
    /**//LC:29023
     * <p>//LC:29024
     * Is {@code true} if this is Mac.//LC:29025
     * </p>//LC:29026
     * <p>//LC:29027
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29028
     * </p>//LC:29029
     *//LC:29030
     * @since 2.0//LC:29031
     *///LC:29032
    public static final boolean IS_OS_MAC = getOSMatchesName("Mac");//LC:29033
//LC:29034
    /**//LC:29035
     * <p>//LC:29036
     * Is {@code true} if this is Mac.//LC:29037
     * </p>//LC:29038
     * <p>//LC:29039
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29040
     * </p>//LC:29041
     *//LC:29042
     * @since 2.0//LC:29043
     *///LC:29044
    public static final boolean IS_OS_MAC_OSX = getOSMatchesName("Mac OS X");//LC:29045
//LC:29046
    /**//LC:29047
     * <p>//LC:29048
     * Is {@code true} if this is FreeBSD.//LC:29049
     * </p>//LC:29050
     * <p>//LC:29051
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29052
     * </p>//LC:29053
     *//LC:29054
     * @since 3.1//LC:29055
     *///LC:29056
    public static final boolean IS_OS_FREE_BSD = getOSMatchesName("FreeBSD");//LC:29057
//LC:29058
    /**//LC:29059
     * <p>//LC:29060
     * Is {@code true} if this is OpenBSD.//LC:29061
     * </p>//LC:29062
     * <p>//LC:29063
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29064
     * </p>//LC:29065
     *//LC:29066
     * @since 3.1//LC:29067
     *///LC:29068
    public static final boolean IS_OS_OPEN_BSD = getOSMatchesName("OpenBSD");//LC:29069
//LC:29070
    /**//LC:29071
     * <p>//LC:29072
     * Is {@code true} if this is NetBSD.//LC:29073
     * </p>//LC:29074
     * <p>//LC:29075
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29076
     * </p>//LC:29077
     *//LC:29078
     * @since 3.1//LC:29079
     *///LC:29080
    public static final boolean IS_OS_NET_BSD = getOSMatchesName("NetBSD");//LC:29081
//LC:29082
    /**//LC:29083
     * <p>//LC:29084
     * Is {@code true} if this is OS/2.//LC:29085
     * </p>//LC:29086
     * <p>//LC:29087
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29088
     * </p>//LC:29089
     *//LC:29090
     * @since 2.0//LC:29091
     *///LC:29092
    public static final boolean IS_OS_OS2 = getOSMatchesName("OS/2");//LC:29093
//LC:29094
    /**//LC:29095
     * <p>//LC:29096
     * Is {@code true} if this is Solaris.//LC:29097
     * </p>//LC:29098
     * <p>//LC:29099
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29100
     * </p>//LC:29101
     *//LC:29102
     * @since 2.0//LC:29103
     *///LC:29104
    public static final boolean IS_OS_SOLARIS = getOSMatchesName("Solaris");//LC:29105
//LC:29106
    /**//LC:29107
     * <p>//LC:29108
     * Is {@code true} if this is SunOS.//LC:29109
     * </p>//LC:29110
     * <p>//LC:29111
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29112
     * </p>//LC:29113
     *//LC:29114
     * @since 2.0//LC:29115
     *///LC:29116
    public static final boolean IS_OS_SUN_OS = getOSMatchesName("SunOS");//LC:29117
//LC:29118
    /**//LC:29119
     * <p>//LC:29120
     * Is {@code true} if this is a UNIX like system, as in any of AIX, HP-UX, Irix, Linux, MacOSX, Solaris or SUN OS.//LC:29121
     * </p>//LC:29122
     * <p>//LC:29123
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29124
     * </p>//LC:29125
     *//LC:29126
     * @since 2.1//LC:29127
     *///LC:29128
    public static final boolean IS_OS_UNIX = IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX || IS_OS_MAC_OSX//LC:29129
            || IS_OS_SOLARIS || IS_OS_SUN_OS || IS_OS_FREE_BSD || IS_OS_OPEN_BSD || IS_OS_NET_BSD;//LC:29130
//LC:29131
    /**//LC:29132
     * <p>//LC:29133
     * Is {@code true} if this is Windows.//LC:29134
     * </p>//LC:29135
     * <p>//LC:29136
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29137
     * </p>//LC:29138
     *//LC:29139
     * @since 2.0//LC:29140
     *///LC:29141
    public static final boolean IS_OS_WINDOWS = getOSMatchesName(OS_NAME_WINDOWS_PREFIX);//LC:29142
//LC:29143
    /**//LC:29144
     * <p>//LC:29145
     * Is {@code true} if this is Windows 2000.//LC:29146
     * </p>//LC:29147
     * <p>//LC:29148
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29149
     * </p>//LC:29150
     *//LC:29151
     * @since 2.0//LC:29152
     *///LC:29153
    public static final boolean IS_OS_WINDOWS_2000 = getOSMatches(OS_NAME_WINDOWS_PREFIX, "5.0");//LC:29154
//LC:29155
    /**//LC:29156
     * <p>//LC:29157
     * Is {@code true} if this is Windows 2003.//LC:29158
     * </p>//LC:29159
     * <p>//LC:29160
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29161
     * </p>//LC:29162
     *//LC:29163
     * @since 3.1//LC:29164
     *///LC:29165
    public static final boolean IS_OS_WINDOWS_2003 = getOSMatches(OS_NAME_WINDOWS_PREFIX, "5.2");//LC:29166
//LC:29167
    /**//LC:29168
     * <p>//LC:29169
     * Is {@code true} if this is Windows 2008.//LC:29170
     * </p>//LC:29171
     * <p>//LC:29172
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29173
     * </p>//LC:29174
     *//LC:29175
     * @since 3.1//LC:29176
     *///LC:29177
    public static final boolean IS_OS_WINDOWS_2008 = getOSMatches(OS_NAME_WINDOWS_PREFIX + " Server 2008", "6.1");//LC:29178
//LC:29179
    /**//LC:29180
     * <p>//LC:29181
     * Is {@code true} if this is Windows 95.//LC:29182
     * </p>//LC:29183
     * <p>//LC:29184
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29185
     * </p>//LC:29186
     *//LC:29187
     * @since 2.0//LC:29188
     *///LC:29189
    public static final boolean IS_OS_WINDOWS_95 = getOSMatches(OS_NAME_WINDOWS_PREFIX + " 9", "4.0");//LC:29190
    // Java 1.2 running on Windows98 returns 'Windows 95', hence the above//LC:29191
//LC:29192
    /**//LC:29193
     * <p>//LC:29194
     * Is {@code true} if this is Windows 98.//LC:29195
     * </p>//LC:29196
     * <p>//LC:29197
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29198
     * </p>//LC:29199
     *//LC:29200
     * @since 2.0//LC:29201
     *///LC:29202
    public static final boolean IS_OS_WINDOWS_98 = getOSMatches(OS_NAME_WINDOWS_PREFIX + " 9", "4.1");//LC:29203
    // Java 1.2 running on Windows98 returns 'Windows 95', hence the above//LC:29204
//LC:29205
    /**//LC:29206
     * <p>//LC:29207
     * Is {@code true} if this is Windows ME.//LC:29208
     * </p>//LC:29209
     * <p>//LC:29210
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29211
     * </p>//LC:29212
     *//LC:29213
     * @since 2.0//LC:29214
     *///LC:29215
    public static final boolean IS_OS_WINDOWS_ME = getOSMatches(OS_NAME_WINDOWS_PREFIX, "4.9");//LC:29216
    // Java 1.2 running on WindowsME may return 'Windows 95', hence the above//LC:29217
//LC:29218
    /**//LC:29219
     * <p>//LC:29220
     * Is {@code true} if this is Windows NT.//LC:29221
     * </p>//LC:29222
     * <p>//LC:29223
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29224
     * </p>//LC:29225
     *//LC:29226
     * @since 2.0//LC:29227
     *///LC:29228
    public static final boolean IS_OS_WINDOWS_NT = getOSMatchesName(OS_NAME_WINDOWS_PREFIX + " NT");//LC:29229
    // Windows 2000 returns 'Windows 2000' but may suffer from same Java1.2 problem//LC:29230
//LC:29231
    /**//LC:29232
     * <p>//LC:29233
     * Is {@code true} if this is Windows XP.//LC:29234
     * </p>//LC:29235
     * <p>//LC:29236
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29237
     * </p>//LC:29238
     *//LC:29239
     * @since 2.0//LC:29240
     *///LC:29241
    public static final boolean IS_OS_WINDOWS_XP = getOSMatches(OS_NAME_WINDOWS_PREFIX, "5.1");//LC:29242
//LC:29243
    // -----------------------------------------------------------------------//LC:29244
    /**//LC:29245
     * <p>//LC:29246
     * Is {@code true} if this is Windows Vista.//LC:29247
     * </p>//LC:29248
     * <p>//LC:29249
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29250
     * </p>//LC:29251
     *//LC:29252
     * @since 2.4//LC:29253
     *///LC:29254
    public static final boolean IS_OS_WINDOWS_VISTA = getOSMatches(OS_NAME_WINDOWS_PREFIX, "6.0");//LC:29255
//LC:29256
    /**//LC:29257
     * <p>//LC:29258
     * Is {@code true} if this is Windows 7.//LC:29259
     * </p>//LC:29260
     * <p>//LC:29261
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29262
     * </p>//LC:29263
     *//LC:29264
     * @since 3.0//LC:29265
     *///LC:29266
    public static final boolean IS_OS_WINDOWS_7 = getOSMatches(OS_NAME_WINDOWS_PREFIX, "6.1");//LC:29267
//LC:29268
    /**//LC:29269
     * <p>//LC:29270
     * Is {@code true} if this is Windows 8.//LC:29271
     * </p>//LC:29272
     * <p>//LC:29273
     * The field will return {@code false} if {@code OS_NAME} is {@code null}.//LC:29274
     * </p>//LC:29275
     *//LC:29276
     * @since 3.2//LC:29277
     *///LC:29278
    public static final boolean IS_OS_WINDOWS_8 = getOSMatches(OS_NAME_WINDOWS_PREFIX, "6.2");//LC:29279
//LC:29280
    /**//LC:29281
     * <p>//LC:29282
     * Gets the Java home directory as a {@code File}.//LC:29283
     * </p>//LC:29284
     *//LC:29285
     * @return a directory//LC:29286
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow//LC:29287
     * access to the specified system property.//LC:29288
     * @see System#getProperty(String)//LC:29289
     * @since 2.1//LC:29290
     *///LC:29291
    public static File getJavaHome() {//LC:29292
        return new File(System.getProperty(JAVA_HOME_KEY));//LC:29293
    }//LC:29294
//LC:29295
    /**//LC:29296
     * <p>//LC:29297
     * Gets the Java IO temporary directory as a {@code File}.//LC:29298
     * </p>//LC:29299
     *//LC:29300
     * @return a directory//LC:29301
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow//LC:29302
     * access to the specified system property.//LC:29303
     * @see System#getProperty(String)//LC:29304
     * @since 2.1//LC:29305
     *///LC:29306
    public static File getJavaIoTmpDir() {//LC:29307
        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));//LC:29308
    }//LC:29309
//LC:29310
    /**//LC:29311
     * <p>//LC:29312
     * Decides if the Java version matches.//LC:29313
     * </p>//LC:29314
     *//LC:29315
     * @param versionPrefix the prefix for the java version//LC:29316
     * @return true if matches, or false if not or can't determine//LC:29317
     *///LC:29318
    private static boolean getJavaVersionMatches(final String versionPrefix) {//LC:29319
        return isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);//LC:29320
    }//LC:29321
//LC:29322
    /**//LC:29323
     * Decides if the operating system matches.//LC:29324
     *//LC:29325
     * @param osNamePrefix the prefix for the os name//LC:29326
     * @param osVersionPrefix the prefix for the version//LC:29327
     * @return true if matches, or false if not or can't determine//LC:29328
     *///LC:29329
    private static boolean getOSMatches(final String osNamePrefix, final String osVersionPrefix) {//LC:29330
        return isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);//LC:29331
    }//LC:29332
//LC:29333
    /**//LC:29334
     * Decides if the operating system matches.//LC:29335
     *//LC:29336
     * @param osNamePrefix the prefix for the os name//LC:29337
     * @return true if matches, or false if not or can't determine//LC:29338
     *///LC:29339
    private static boolean getOSMatchesName(final String osNamePrefix) {//LC:29340
        return isOSNameMatch(OS_NAME, osNamePrefix);//LC:29341
    }//LC:29342
//LC:29343
    // -----------------------------------------------------------------------//LC:29344
    /**//LC:29345
     * <p>//LC:29346
     * Gets a System property, defaulting to {@code null} if the property cannot be read.//LC:29347
     * </p>//LC:29348
     * <p>//LC:29349
     * If a {@code SecurityException} is caught, the return value is {@code null} and a message is written to//LC:29350
     * {@code System.err}.//LC:29351
     * </p>//LC:29352
     *//LC:29353
     * @param property the system property name//LC:29354
     * @return the system property value or {@code null} if a security problem occurs//LC:29355
     *///LC:29356
    private static String getSystemProperty(final String property) {//LC:29357
        try {//LC:29358
            return System.getProperty(property);//LC:29359
        } catch (final SecurityException ex) {//LC:29360
            // we are not allowed to look at this property//LC:29361
            System.err.println("Caught a SecurityException reading the system property '" + property//LC:29362
                    + "'; the SystemUtils property value will default to null.");//LC:29363
            return null;//LC:29364
        }//LC:29365
    }//LC:29366
//LC:29367
    /**//LC:29368
     * <p>//LC:29369
     * Gets the user directory as a {@code File}.//LC:29370
     * </p>//LC:29371
     *//LC:29372
     * @return a directory//LC:29373
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow//LC:29374
     * access to the specified system property.//LC:29375
     * @see System#getProperty(String)//LC:29376
     * @since 2.1//LC:29377
     *///LC:29378
    public static File getUserDir() {//LC:29379
        return new File(System.getProperty(USER_DIR_KEY));//LC:29380
    }//LC:29381
//LC:29382
    /**//LC:29383
     * <p>//LC:29384
     * Gets the user home directory as a {@code File}.//LC:29385
     * </p>//LC:29386
     *//LC:29387
     * @return a directory//LC:29388
     * @throws SecurityException if a security manager exists and its {@code checkPropertyAccess} method doesn't allow//LC:29389
     * access to the specified system property.//LC:29390
     * @see System#getProperty(String)//LC:29391
     * @since 2.1//LC:29392
     *///LC:29393
    public static File getUserHome() {//LC:29394
        return new File(System.getProperty(USER_HOME_KEY));//LC:29395
    }//LC:29396
//LC:29397
    /**//LC:29398
     * Returns whether the {@link #JAVA_AWT_HEADLESS} value is {@code true}.//LC:29399
     *//LC:29400
     * @return {@code true} if {@code JAVA_AWT_HEADLESS} is {@code "true"}, {@code false} otherwise.//LC:29401
     * @see #JAVA_AWT_HEADLESS//LC:29402
     * @since 2.1//LC:29403
     * @since Java 1.4//LC:29404
     *///LC:29405
    public static boolean isJavaAwtHeadless() {//LC:29406
        return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;//LC:29407
    }//LC:29408
//LC:29409
    /**//LC:29410
     * <p>//LC:29411
     * Is the Java version at least the requested version.//LC:29412
     * </p>//LC:29413
     * <p>//LC:29414
     * Example input://LC:29415
     * </p>//LC:29416
     * <ul>//LC:29417
     * <li>{@code 1.2f} to test for Java 1.2</li>//LC:29418
     * <li>{@code 1.31f} to test for Java 1.3.1</li>//LC:29419
     * </ul>//LC:29420
     *//LC:29421
     * @param requiredVersion the required version, for example 1.31f//LC:29422
     * @return {@code true} if the actual version is equal or greater than the required version//LC:29423
     *///LC:29424
    public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) {//LC:29425
        return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);//LC:29426
    }//LC:29427
//LC:29428
    /**//LC:29429
     * <p>//LC:29430
     * Decides if the Java version matches.//LC:29431
     * </p>//LC:29432
     * <p>//LC:29433
     * This method is package private instead of private to support unit test invocation.//LC:29434
     * </p>//LC:29435
     *//LC:29436
     * @param version the actual Java version//LC:29437
     * @param versionPrefix the prefix for the expected Java version//LC:29438
     * @return true if matches, or false if not or can't determine//LC:29439
     *///LC:29440
    static boolean isJavaVersionMatch(final String version, final String versionPrefix) {//LC:29441
        if (version == null) {//LC:29442
            return false;//LC:29443
        }//LC:29444
        return version.startsWith(versionPrefix);//LC:29445
    }//LC:29446
//LC:29447
    /**//LC:29448
     * Decides if the operating system matches.//LC:29449
     * <p>//LC:29450
     * This method is package private instead of private to support unit test invocation.//LC:29451
     * </p>//LC:29452
     *//LC:29453
     * @param osName the actual OS name//LC:29454
     * @param osVersion the actual OS version//LC:29455
     * @param osNamePrefix the prefix for the expected OS name//LC:29456
     * @param osVersionPrefix the prefix for the expected OS version//LC:29457
     * @return true if matches, or false if not or can't determine//LC:29458
     *///LC:29459
    static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {//LC:29460
        if (osName == null || osVersion == null) {//LC:29461
            return false;//LC:29462
        }//LC:29463
        return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);//LC:29464
    }//LC:29465
//LC:29466
    /**//LC:29467
     * Decides if the operating system matches.//LC:29468
     * <p>//LC:29469
     * This method is package private instead of private to support unit test invocation.//LC:29470
     * </p>//LC:29471
     *//LC:29472
     * @param osName the actual OS name//LC:29473
     * @param osNamePrefix the prefix for the expected OS name//LC:29474
     * @return true if matches, or false if not or can't determine//LC:29475
     *///LC:29476
    static boolean isOSNameMatch(final String osName, final String osNamePrefix) {//LC:29477
        if (osName == null) {//LC:29478
            return false;//LC:29479
        }//LC:29480
        return osName.startsWith(osNamePrefix);//LC:29481
    }//LC:29482
//LC:29483
    // -----------------------------------------------------------------------//LC:29484
    /**//LC:29485
     * <p>//LC:29486
     * SystemUtils instances should NOT be constructed in standard programming. Instead, the class should be used as//LC:29487
     * {@code SystemUtils.FILE_SEPARATOR}.//LC:29488
     * </p>//LC:29489
     * <p>//LC:29490
     * This constructor is public to permit tools that require a JavaBean instance to operate.//LC:29491
     * </p>//LC:29492
     *///LC:29493
    public SystemUtils() {//LC:29494
        super();//LC:29495
    }//LC:29496
//LC:29497
}//LC:29498
//LC:29499
//LC:29500
//LC:29501
/**//LC:29502
 * Provides mutable access to a value.//LC:29503
 * <p>//LC:29504
 * <code>Mutable</code> is used as a generic interface to the implementations in this package.//LC:29505
 * <p>//LC:29506
 * A typical use case would be to enable a primitive or string to be passed to a method and allow that method to//LC:29507
 * effectively change the value of the primitive/string. Another use case is to store a frequently changing primitive in//LC:29508
 * a collection (for example a total in a map) without needing to create new Integer/Long wrapper objects.//LC:29509
 *//LC:29510
 * @param <T> the type to set and get//LC:29511
 * @since 2.1//LC:29512
 * @version $Id$//LC:29513
 *///LC:29514
interface Mutable<T> {//LC:29515
//LC:29516
    /**//LC:29517
     * Gets the value of this mutable.//LC:29518
     *//LC:29519
     * @return the stored value//LC:29520
     *///LC:29521
    T getValue();//LC:29522
//LC:29523
    /**//LC:29524
     * Sets the value of this mutable.//LC:29525
     *//LC:29526
     * @param value//LC:29527
     *            the value to store//LC:29528
     * @throws NullPointerException//LC:29529
     *             if the object is null and null is invalid//LC:29530
     * @throws ClassCastException//LC:29531
     *             if the type is invalid//LC:29532
     *///LC:29533
    void setValue(T value);//LC:29534
//LC:29535
}//LC:29536
//LC:29537
//LC:29538
/**//LC:29539
 * Tokenizes a string based based on delimiters (separators)//LC:29540
 * and supporting quoting and ignored character concepts.//LC:29541
 * <p>//LC:29542
 * This class can split a String into many smaller strings. It aims//LC:29543
 * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},//LC:29544
 * however it offers much more control and flexibility including implementing//LC:29545
 * the <code>ListIterator</code> interface. By default, it is set up//LC:29546
 * like <code>StringTokenizer</code>.//LC:29547
 * <p>//LC:29548
 * The input String is split into a number of <i>tokens</i>.//LC:29549
 * Each token is separated from the next String by a <i>delimiter</i>.//LC:29550
 * One or more delimiter characters must be specified.//LC:29551
 * <p>//LC:29552
 * Each token may be surrounded by quotes.//LC:29553
 * The <i>quote</i> matcher specifies the quote character(s).//LC:29554
 * A quote may be escaped within a quoted section by duplicating itself.//LC:29555
 * <p>//LC:29556
 * Between each token and the delimiter are potentially characters that need trimming.//LC:29557
 * The <i>trimmer</i> matcher specifies these characters.//LC:29558
 * One usage might be to trim whitespace characters.//LC:29559
 * <p>//LC:29560
 * At any point outside the quotes there might potentially be invalid characters.//LC:29561
 * The <i>ignored</i> matcher specifies these characters to be removed.//LC:29562
 * One usage might be to remove new line characters.//LC:29563
 * <p>//LC:29564
 * Empty tokens may be removed or returned as null.//LC:29565
 * <pre>//LC:29566
 * "a,b,c"         - Three tokens "a","b","c"   (comma delimiter)//LC:29567
 * " a, b , c "    - Three tokens "a","b","c"   (default CSV processing trims whitespace)//LC:29568
 * "a, ", b ,", c" - Three tokens "a, " , " b ", ", c" (quoted text untouched)//LC:29569
 * </pre>//LC:29570
 * <p>//LC:29571
 *//LC:29572
 * This tokenizer has the following properties and options://LC:29573
 *//LC:29574
 * <table>//LC:29575
 *  <tr>//LC:29576
 *   <th>Property</th><th>Type</th><th>Default</th>//LC:29577
 *  </tr>//LC:29578
 *  <tr>//LC:29579
 *   <td>delim</td><td>CharSetMatcher</td><td>{ \t\n\r\f}</td>//LC:29580
 *  </tr>//LC:29581
 *  <tr>//LC:29582
 *   <td>quote</td><td>NoneMatcher</td><td>{}</td>//LC:29583
 *  </tr>//LC:29584
 *  <tr>//LC:29585
 *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>//LC:29586
 *  </tr>//LC:29587
 *  <tr>//LC:29588
 *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>//LC:29589
 *  </tr>//LC:29590
 *  <tr>//LC:29591
 *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>//LC:29592
 *  </tr>//LC:29593
 * </table>//LC:29594
 *//LC:29595
 * @since 2.2//LC:29596
 * @version $Id$//LC:29597
 *///LC:29598
class StrTokenizer implements ListIterator<String>, Cloneable {//LC:29599
//LC:29600
    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;//LC:29601
    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;//LC:29602
    static {//LC:29603
        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();//LC:29604
        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());//LC:29605
        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());//LC:29606
        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());//LC:29607
        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());//LC:29608
        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);//LC:29609
        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);//LC:29610
//LC:29611
        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();//LC:29612
        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());//LC:29613
        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());//LC:29614
        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());//LC:29615
        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());//LC:29616
        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);//LC:29617
        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);//LC:29618
    }//LC:29619
//LC:29620
    /** The text to work on. *///LC:29621
    private char chars[];//LC:29622
    /** The parsed tokens *///LC:29623
    private String tokens[];//LC:29624
    /** The current iteration position *///LC:29625
    private int tokenPos;//LC:29626
//LC:29627
    /** The delimiter matcher *///LC:29628
    private StrMatcher delimMatcher = StrMatcher.splitMatcher();//LC:29629
    /** The quote matcher *///LC:29630
    private StrMatcher quoteMatcher = StrMatcher.noneMatcher();//LC:29631
    /** The ignored matcher *///LC:29632
    private StrMatcher ignoredMatcher = StrMatcher.noneMatcher();//LC:29633
    /** The trimmer matcher *///LC:29634
    private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();//LC:29635
//LC:29636
    /** Whether to return empty tokens as null *///LC:29637
    private boolean emptyAsNull = false;//LC:29638
    /** Whether to ignore empty tokens *///LC:29639
    private boolean ignoreEmptyTokens = true;//LC:29640
//LC:29641
    //-----------------------------------------------------------------------//LC:29642
//LC:29643
    /**//LC:29644
     * Returns a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.//LC:29645
     *//LC:29646
     * @return a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.//LC:29647
     *///LC:29648
    private static StrTokenizer getCSVClone() {//LC:29649
        return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();//LC:29650
    }//LC:29651
//LC:29652
    /**//LC:29653
     * Gets a new tokenizer instance which parses Comma Separated Value strings//LC:29654
     * initializing it with the given input.  The default for CSV processing//LC:29655
     * will be trim whitespace from both ends (which can be overridden with//LC:29656
     * the setTrimmer method).//LC:29657
     * <p>//LC:29658
     * You must call a "reset" method to set the string which you want to parse.//LC:29659
     * @return a new tokenizer instance which parses Comma Separated Value strings//LC:29660
     *///LC:29661
    public static StrTokenizer getCSVInstance() {//LC:29662
        return getCSVClone();//LC:29663
    }//LC:29664
//LC:29665
    /**//LC:29666
     * Gets a new tokenizer instance which parses Comma Separated Value strings//LC:29667
     * initializing it with the given input.  The default for CSV processing//LC:29668
     * will be trim whitespace from both ends (which can be overridden with//LC:29669
     * the setTrimmer method).//LC:29670
     *//LC:29671
     * @param input  the text to parse//LC:29672
     * @return a new tokenizer instance which parses Comma Separated Value strings//LC:29673
     *///LC:29674
    public static StrTokenizer getCSVInstance(final String input) {//LC:29675
        final StrTokenizer tok = getCSVClone();//LC:29676
        tok.reset(input);//LC:29677
        return tok;//LC:29678
    }//LC:29679
//LC:29680
    /**//LC:29681
     * Gets a new tokenizer instance which parses Comma Separated Value strings//LC:29682
     * initializing it with the given input.  The default for CSV processing//LC:29683
     * will be trim whitespace from both ends (which can be overridden with//LC:29684
     * the setTrimmer method).//LC:29685
     *//LC:29686
     * @param input  the text to parse//LC:29687
     * @return a new tokenizer instance which parses Comma Separated Value strings//LC:29688
     *///LC:29689
    public static StrTokenizer getCSVInstance(final char[] input) {//LC:29690
        final StrTokenizer tok = getCSVClone();//LC:29691
        tok.reset(input);//LC:29692
        return tok;//LC:29693
    }//LC:29694
//LC:29695
    /**//LC:29696
     * Returns a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.//LC:29697
     *//LC:29698
     * @return a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.//LC:29699
     *///LC:29700
    private static StrTokenizer getTSVClone() {//LC:29701
        return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();//LC:29702
    }//LC:29703
//LC:29704
//LC:29705
    /**//LC:29706
     * Gets a new tokenizer instance which parses Tab Separated Value strings.//LC:29707
     * The default for CSV processing will be trim whitespace from both ends//LC:29708
     * (which can be overridden with the setTrimmer method).//LC:29709
     * <p>//LC:29710
     * You must call a "reset" method to set the string which you want to parse.//LC:29711
     * @return a new tokenizer instance which parses Tab Separated Value strings.//LC:29712
     *///LC:29713
    public static StrTokenizer getTSVInstance() {//LC:29714
        return getTSVClone();//LC:29715
    }//LC:29716
//LC:29717
    /**//LC:29718
     * Gets a new tokenizer instance which parses Tab Separated Value strings.//LC:29719
     * The default for CSV processing will be trim whitespace from both ends//LC:29720
     * (which can be overridden with the setTrimmer method).//LC:29721
     * @param input  the string to parse//LC:29722
     * @return a new tokenizer instance which parses Tab Separated Value strings.//LC:29723
     *///LC:29724
    public static StrTokenizer getTSVInstance(final String input) {//LC:29725
        final StrTokenizer tok = getTSVClone();//LC:29726
        tok.reset(input);//LC:29727
        return tok;//LC:29728
    }//LC:29729
//LC:29730
    /**//LC:29731
     * Gets a new tokenizer instance which parses Tab Separated Value strings.//LC:29732
     * The default for CSV processing will be trim whitespace from both ends//LC:29733
     * (which can be overridden with the setTrimmer method).//LC:29734
     * @param input  the string to parse//LC:29735
     * @return a new tokenizer instance which parses Tab Separated Value strings.//LC:29736
     *///LC:29737
    public static StrTokenizer getTSVInstance(final char[] input) {//LC:29738
        final StrTokenizer tok = getTSVClone();//LC:29739
        tok.reset(input);//LC:29740
        return tok;//LC:29741
    }//LC:29742
//LC:29743
    //-----------------------------------------------------------------------//LC:29744
    /**//LC:29745
     * Constructs a tokenizer splitting on space, tab, newline and formfeed//LC:29746
     * as per StringTokenizer, but with no text to tokenize.//LC:29747
     * <p>//LC:29748
     * This constructor is normally used with {@link #reset(String)}.//LC:29749
     *///LC:29750
    public StrTokenizer() {//LC:29751
        super();//LC:29752
        this.chars = null;//LC:29753
    }//LC:29754
//LC:29755
    /**//LC:29756
     * Constructs a tokenizer splitting on space, tab, newline and formfeed//LC:29757
     * as per StringTokenizer.//LC:29758
     *//LC:29759
     * @param input  the string which is to be parsed//LC:29760
     *///LC:29761
    public StrTokenizer(final String input) {//LC:29762
        super();//LC:29763
        if (input != null) {//LC:29764
            chars = input.toCharArray();//LC:29765
        } else {//LC:29766
            chars = null;//LC:29767
        }//LC:29768
    }//LC:29769
//LC:29770
    /**//LC:29771
     * Constructs a tokenizer splitting on the specified delimiter character.//LC:29772
     *//LC:29773
     * @param input  the string which is to be parsed//LC:29774
     * @param delim  the field delimiter character//LC:29775
     *///LC:29776
    public StrTokenizer(final String input, final char delim) {//LC:29777
        this(input);//LC:29778
        setDelimiterChar(delim);//LC:29779
    }//LC:29780
//LC:29781
    /**//LC:29782
     * Constructs a tokenizer splitting on the specified delimiter string.//LC:29783
     *//LC:29784
     * @param input  the string which is to be parsed//LC:29785
     * @param delim  the field delimiter string//LC:29786
     *///LC:29787
    public StrTokenizer(final String input, final String delim) {//LC:29788
        this(input);//LC:29789
        setDelimiterString(delim);//LC:29790
    }//LC:29791
//LC:29792
    /**//LC:29793
     * Constructs a tokenizer splitting using the specified delimiter matcher.//LC:29794
     *//LC:29795
     * @param input  the string which is to be parsed//LC:29796
     * @param delim  the field delimiter matcher//LC:29797
     *///LC:29798
    public StrTokenizer(final String input, final StrMatcher delim) {//LC:29799
        this(input);//LC:29800
        setDelimiterMatcher(delim);//LC:29801
    }//LC:29802
//LC:29803
    /**//LC:29804
     * Constructs a tokenizer splitting on the specified delimiter character//LC:29805
     * and handling quotes using the specified quote character.//LC:29806
     *//LC:29807
     * @param input  the string which is to be parsed//LC:29808
     * @param delim  the field delimiter character//LC:29809
     * @param quote  the field quoted string character//LC:29810
     *///LC:29811
    public StrTokenizer(final String input, final char delim, final char quote) {//LC:29812
        this(input, delim);//LC:29813
        setQuoteChar(quote);//LC:29814
    }//LC:29815
//LC:29816
    /**//LC:29817
     * Constructs a tokenizer splitting using the specified delimiter matcher//LC:29818
     * and handling quotes using the specified quote matcher.//LC:29819
     *//LC:29820
     * @param input  the string which is to be parsed//LC:29821
     * @param delim  the field delimiter matcher//LC:29822
     * @param quote  the field quoted string matcher//LC:29823
     *///LC:29824
    public StrTokenizer(final String input, final StrMatcher delim, final StrMatcher quote) {//LC:29825
        this(input, delim);//LC:29826
        setQuoteMatcher(quote);//LC:29827
    }//LC:29828
//LC:29829
    /**//LC:29830
     * Constructs a tokenizer splitting on space, tab, newline and formfeed//LC:29831
     * as per StringTokenizer.//LC:29832
     *//LC:29833
     * @param input  the string which is to be parsed, not cloned//LC:29834
     *///LC:29835
    public StrTokenizer(final char[] input) {//LC:29836
        super();//LC:29837
        this.chars = ArrayUtils.clone(input);//LC:29838
    }//LC:29839
//LC:29840
    /**//LC:29841
     * Constructs a tokenizer splitting on the specified character.//LC:29842
     *//LC:29843
     * @param input  the string which is to be parsed, not cloned//LC:29844
     * @param delim the field delimiter character//LC:29845
     *///LC:29846
    public StrTokenizer(final char[] input, final char delim) {//LC:29847
        this(input);//LC:29848
        setDelimiterChar(delim);//LC:29849
    }//LC:29850
//LC:29851
    /**//LC:29852
     * Constructs a tokenizer splitting on the specified string.//LC:29853
     *//LC:29854
     * @param input  the string which is to be parsed, not cloned//LC:29855
     * @param delim the field delimiter string//LC:29856
     *///LC:29857
    public StrTokenizer(final char[] input, final String delim) {//LC:29858
        this(input);//LC:29859
        setDelimiterString(delim);//LC:29860
    }//LC:29861
//LC:29862
    /**//LC:29863
     * Constructs a tokenizer splitting using the specified delimiter matcher.//LC:29864
     *//LC:29865
     * @param input  the string which is to be parsed, not cloned//LC:29866
     * @param delim  the field delimiter matcher//LC:29867
     *///LC:29868
    public StrTokenizer(final char[] input, final StrMatcher delim) {//LC:29869
        this(input);//LC:29870
        setDelimiterMatcher(delim);//LC:29871
    }//LC:29872
//LC:29873
    /**//LC:29874
     * Constructs a tokenizer splitting on the specified delimiter character//LC:29875
     * and handling quotes using the specified quote character.//LC:29876
     *//LC:29877
     * @param input  the string which is to be parsed, not cloned//LC:29878
     * @param delim  the field delimiter character//LC:29879
     * @param quote  the field quoted string character//LC:29880
     *///LC:29881
    public StrTokenizer(final char[] input, final char delim, final char quote) {//LC:29882
        this(input, delim);//LC:29883
        setQuoteChar(quote);//LC:29884
    }//LC:29885
//LC:29886
    /**//LC:29887
     * Constructs a tokenizer splitting using the specified delimiter matcher//LC:29888
     * and handling quotes using the specified quote matcher.//LC:29889
     *//LC:29890
     * @param input  the string which is to be parsed, not cloned//LC:29891
     * @param delim  the field delimiter character//LC:29892
     * @param quote  the field quoted string character//LC:29893
     *///LC:29894
    public StrTokenizer(final char[] input, final StrMatcher delim, final StrMatcher quote) {//LC:29895
        this(input, delim);//LC:29896
        setQuoteMatcher(quote);//LC:29897
    }//LC:29898
//LC:29899
    // API//LC:29900
    //-----------------------------------------------------------------------//LC:29901
    /**//LC:29902
     * Gets the number of tokens found in the String.//LC:29903
     *//LC:29904
     * @return the number of matched tokens//LC:29905
     *///LC:29906
    public int size() {//LC:29907
        checkTokenized();//LC:29908
        return tokens.length;//LC:29909
    }//LC:29910
//LC:29911
    /**//LC:29912
     * Gets the next token from the String.//LC:29913
     * Equivalent to {@link #next()} except it returns null rather than//LC:29914
     * throwing {@link NoSuchElementException} when no tokens remain.//LC:29915
     *//LC:29916
     * @return the next sequential token, or null when no more tokens are found//LC:29917
     *///LC:29918
    public String nextToken() {//LC:29919
        if (hasNext()) {//LC:29920
            return tokens[tokenPos++];//LC:29921
        }//LC:29922
        return null;//LC:29923
    }//LC:29924
//LC:29925
    /**//LC:29926
     * Gets the previous token from the String.//LC:29927
     *//LC:29928
     * @return the previous sequential token, or null when no more tokens are found//LC:29929
     *///LC:29930
    public String previousToken() {//LC:29931
        if (hasPrevious()) {//LC:29932
            return tokens[--tokenPos];//LC:29933
        }//LC:29934
        return null;//LC:29935
    }//LC:29936
//LC:29937
    /**//LC:29938
     * Gets a copy of the full token list as an independent modifiable array.//LC:29939
     *//LC:29940
     * @return the tokens as a String array//LC:29941
     *///LC:29942
    public String[] getTokenArray() {//LC:29943
        checkTokenized();//LC:29944
        return tokens.clone();//LC:29945
    }//LC:29946
//LC:29947
    /**//LC:29948
     * Gets a copy of the full token list as an independent modifiable list.//LC:29949
     *//LC:29950
     * @return the tokens as a String array//LC:29951
     *///LC:29952
    public List<String> getTokenList() {//LC:29953
        checkTokenized();//LC:29954
        final List<String> list = new ArrayList<String>(tokens.length);//LC:29955
        for (final String element : tokens) {//LC:29956
            list.add(element);//LC:29957
        }//LC:29958
        return list;//LC:29959
    }//LC:29960
//LC:29961
    /**//LC:29962
     * Resets this tokenizer, forgetting all parsing and iteration already completed.//LC:29963
     * <p>//LC:29964
     * This method allows the same tokenizer to be reused for the same String.//LC:29965
     *//LC:29966
     * @return this, to enable chaining//LC:29967
     *///LC:29968
    public StrTokenizer reset() {//LC:29969
        tokenPos = 0;//LC:29970
        tokens = null;//LC:29971
        return this;//LC:29972
    }//LC:29973
//LC:29974
    /**//LC:29975
     * Reset this tokenizer, giving it a new input string to parse.//LC:29976
     * In this manner you can re-use a tokenizer with the same settings//LC:29977
     * on multiple input lines.//LC:29978
     *//LC:29979
     * @param input  the new string to tokenize, null sets no text to parse//LC:29980
     * @return this, to enable chaining//LC:29981
     *///LC:29982
    public StrTokenizer reset(final String input) {//LC:29983
        reset();//LC:29984
        if (input != null) {//LC:29985
            this.chars = input.toCharArray();//LC:29986
        } else {//LC:29987
            this.chars = null;//LC:29988
        }//LC:29989
        return this;//LC:29990
    }//LC:29991
//LC:29992
    /**//LC:29993
     * Reset this tokenizer, giving it a new input string to parse.//LC:29994
     * In this manner you can re-use a tokenizer with the same settings//LC:29995
     * on multiple input lines.//LC:29996
     *//LC:29997
     * @param input  the new character array to tokenize, not cloned, null sets no text to parse//LC:29998
     * @return this, to enable chaining//LC:29999
     *///LC:30000
    public StrTokenizer reset(final char[] input) {//LC:30001
        reset();//LC:30002
        this.chars = ArrayUtils.clone(input);//LC:30003
        return this;//LC:30004
    }//LC:30005
//LC:30006
    // ListIterator//LC:30007
    //-----------------------------------------------------------------------//LC:30008
    /**//LC:30009
     * Checks whether there are any more tokens.//LC:30010
     *//LC:30011
     * @return true if there are more tokens//LC:30012
     *///LC:30013
    @Override//LC:30014
    public boolean hasNext() {//LC:30015
        checkTokenized();//LC:30016
        return tokenPos < tokens.length;//LC:30017
    }//LC:30018
//LC:30019
    /**//LC:30020
     * Gets the next token.//LC:30021
     *//LC:30022
     * @return the next String token//LC:30023
     * @throws NoSuchElementException if there are no more elements//LC:30024
     *///LC:30025
    @Override//LC:30026
    public String next() {//LC:30027
        if (hasNext()) {//LC:30028
            return tokens[tokenPos++];//LC:30029
        }//LC:30030
        throw new NoSuchElementException();//LC:30031
    }//LC:30032
//LC:30033
    /**//LC:30034
     * Gets the index of the next token to return.//LC:30035
     *//LC:30036
     * @return the next token index//LC:30037
     *///LC:30038
    @Override//LC:30039
    public int nextIndex() {//LC:30040
        return tokenPos;//LC:30041
    }//LC:30042
//LC:30043
    /**//LC:30044
     * Checks whether there are any previous tokens that can be iterated to.//LC:30045
     *//LC:30046
     * @return true if there are previous tokens//LC:30047
     *///LC:30048
    @Override//LC:30049
    public boolean hasPrevious() {//LC:30050
        checkTokenized();//LC:30051
        return tokenPos > 0;//LC:30052
    }//LC:30053
//LC:30054
    /**//LC:30055
     * Gets the token previous to the last returned token.//LC:30056
     *//LC:30057
     * @return the previous token//LC:30058
     *///LC:30059
    @Override//LC:30060
    public String previous() {//LC:30061
        if (hasPrevious()) {//LC:30062
            return tokens[--tokenPos];//LC:30063
        }//LC:30064
        throw new NoSuchElementException();//LC:30065
    }//LC:30066
//LC:30067
    /**//LC:30068
     * Gets the index of the previous token.//LC:30069
     *//LC:30070
     * @return the previous token index//LC:30071
     *///LC:30072
    @Override//LC:30073
    public int previousIndex() {//LC:30074
        return tokenPos - 1;//LC:30075
    }//LC:30076
//LC:30077
    /**//LC:30078
     * Unsupported ListIterator operation.//LC:30079
     *//LC:30080
     * @throws UnsupportedOperationException always//LC:30081
     *///LC:30082
    @Override//LC:30083
    public void remove() {//LC:30084
        throw new UnsupportedOperationException("remove() is unsupported");//LC:30085
    }//LC:30086
//LC:30087
    /**//LC:30088
     * Unsupported ListIterator operation.//LC:30089
     * @param obj this parameter ignored.//LC:30090
     * @throws UnsupportedOperationException always//LC:30091
     *///LC:30092
    @Override//LC:30093
    public void set(final String obj) {//LC:30094
        throw new UnsupportedOperationException("set() is unsupported");//LC:30095
    }//LC:30096
//LC:30097
    /**//LC:30098
     * Unsupported ListIterator operation.//LC:30099
     * @param obj this parameter ignored.//LC:30100
     * @throws UnsupportedOperationException always//LC:30101
     *///LC:30102
    @Override//LC:30103
    public void add(final String obj) {//LC:30104
        throw new UnsupportedOperationException("add() is unsupported");//LC:30105
    }//LC:30106
//LC:30107
    // Implementation//LC:30108
    //-----------------------------------------------------------------------//LC:30109
    /**//LC:30110
     * Checks if tokenization has been done, and if not then do it.//LC:30111
     *///LC:30112
    private void checkTokenized() {//LC:30113
        if (tokens == null) {//LC:30114
            if (chars == null) {//LC:30115
                // still call tokenize as subclass may do some work//LC:30116
                final List<String> split = tokenize(null, 0, 0);//LC:30117
                tokens = split.toArray(new String[split.size()]);//LC:30118
            } else {//LC:30119
                final List<String> split = tokenize(chars, 0, chars.length);//LC:30120
                tokens = split.toArray(new String[split.size()]);//LC:30121
            }//LC:30122
        }//LC:30123
    }//LC:30124
//LC:30125
    /**//LC:30126
     * Internal method to performs the tokenization.//LC:30127
     * <p>//LC:30128
     * Most users of this class do not need to call this method. This method//LC:30129
     * will be called automatically by other (public) methods when required.//LC:30130
     * <p>//LC:30131
     * This method exists to allow subclasses to add code before or after the//LC:30132
     * tokenization. For example, a subclass could alter the character array,//LC:30133
     * offset or count to be parsed, or call the tokenizer multiple times on//LC:30134
     * multiple strings. It is also be possible to filter the results.//LC:30135
     * <p>//LC:30136
     * <code>StrTokenizer</code> will always pass a zero offset and a count//LC:30137
     * equal to the length of the array to this method, however a subclass//LC:30138
     * may pass other values, or even an entirely different array.//LC:30139
     *//LC:30140
     * @param chars  the character array being tokenized, may be null//LC:30141
     * @param offset  the start position within the character array, must be valid//LC:30142
     * @param count  the number of characters to tokenize, must be valid//LC:30143
     * @return the modifiable list of String tokens, unmodifiable if null array or zero count//LC:30144
     *///LC:30145
    protected List<String> tokenize(final char[] chars, final int offset, final int count) {//LC:30146
        if (chars == null || count == 0) {//LC:30147
            return Collections.emptyList();//LC:30148
        }//LC:30149
        final StrBuilder buf = new StrBuilder();//LC:30150
        final List<String> tokens = new ArrayList<String>();//LC:30151
        int pos = offset;//LC:30152
//LC:30153
        // loop around the entire buffer//LC:30154
        while (pos >= 0 && pos < count) {//LC:30155
            // find next token//LC:30156
            pos = readNextToken(chars, pos, count, buf, tokens);//LC:30157
//LC:30158
            // handle case where end of string is a delimiter//LC:30159
            if (pos >= count) {//LC:30160
                addToken(tokens, "");//LC:30161
            }//LC:30162
        }//LC:30163
        return tokens;//LC:30164
    }//LC:30165
//LC:30166
    /**//LC:30167
     * Adds a token to a list, paying attention to the parameters we've set.//LC:30168
     *//LC:30169
     * @param list  the list to add to//LC:30170
     * @param tok  the token to add//LC:30171
     *///LC:30172
    private void addToken(final List<String> list, String tok) {//LC:30173
        if (StringUtils.isEmpty(tok)) {//LC:30174
            if (isIgnoreEmptyTokens()) {//LC:30175
                return;//LC:30176
            }//LC:30177
            if (isEmptyTokenAsNull()) {//LC:30178
                tok = null;//LC:30179
            }//LC:30180
        }//LC:30181
        list.add(tok);//LC:30182
    }//LC:30183
//LC:30184
    /**//LC:30185
     * Reads character by character through the String to get the next token.//LC:30186
     *//LC:30187
     * @param chars  the character array being tokenized//LC:30188
     * @param start  the first character of field//LC:30189
     * @param len  the length of the character array being tokenized//LC:30190
     * @param workArea  a temporary work area//LC:30191
     * @param tokens  the list of parsed tokens//LC:30192
     * @return the starting position of the next field (the character//LC:30193
     *  immediately after the delimiter), or -1 if end of string found//LC:30194
     *///LC:30195
    private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) {//LC:30196
        // skip all leading whitespace, unless it is the//LC:30197
        // field delimiter or the quote character//LC:30198
        while (start < len) {//LC:30199
            final int removeLen = Math.max(//LC:30200
                    getIgnoredMatcher().isMatch(chars, start, start, len),//LC:30201
                    getTrimmerMatcher().isMatch(chars, start, start, len));//LC:30202
            if (removeLen == 0 ||//LC:30203
                    getDelimiterMatcher().isMatch(chars, start, start, len) > 0 ||//LC:30204
                    getQuoteMatcher().isMatch(chars, start, start, len) > 0) {//LC:30205
                break;//LC:30206
            }//LC:30207
            start += removeLen;//LC:30208
        }//LC:30209
//LC:30210
        // handle reaching end//LC:30211
        if (start >= len) {//LC:30212
            addToken(tokens, "");//LC:30213
            return -1;//LC:30214
        }//LC:30215
//LC:30216
        // handle empty token//LC:30217
        final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);//LC:30218
        if (delimLen > 0) {//LC:30219
            addToken(tokens, "");//LC:30220
            return start + delimLen;//LC:30221
        }//LC:30222
//LC:30223
        // handle found token//LC:30224
        final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);//LC:30225
        if (quoteLen > 0) {//LC:30226
            return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);//LC:30227
        }//LC:30228
        return readWithQuotes(chars, start, len, workArea, tokens, 0, 0);//LC:30229
    }//LC:30230
//LC:30231
    /**//LC:30232
     * Reads a possibly quoted string token.//LC:30233
     *//LC:30234
     * @param chars  the character array being tokenized//LC:30235
     * @param start  the first character of field//LC:30236
     * @param len  the length of the character array being tokenized//LC:30237
     * @param workArea  a temporary work area//LC:30238
     * @param tokens  the list of parsed tokens//LC:30239
     * @param quoteStart  the start position of the matched quote, 0 if no quoting//LC:30240
     * @param quoteLen  the length of the matched quote, 0 if no quoting//LC:30241
     * @return the starting position of the next field (the character//LC:30242
     *  immediately after the delimiter, or if end of string found,//LC:30243
     *  then the length of string//LC:30244
     *///LC:30245
    private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea,//LC:30246
                               final List<String> tokens, final int quoteStart, final int quoteLen) {//LC:30247
        // Loop until we've found the end of the quoted//LC:30248
        // string or the end of the input//LC:30249
        workArea.clear();//LC:30250
        int pos = start;//LC:30251
        boolean quoting = quoteLen > 0;//LC:30252
        int trimStart = 0;//LC:30253
//LC:30254
        while (pos < len) {//LC:30255
            // quoting mode can occur several times throughout a string//LC:30256
            // we must switch between quoting and non-quoting until we//LC:30257
            // encounter a non-quoted delimiter, or end of string//LC:30258
            if (quoting) {//LC:30259
                // In quoting mode//LC:30260
//LC:30261
                // If we've found a quote character, see if it's//LC:30262
                // followed by a second quote.  If so, then we need//LC:30263
                // to actually put the quote character into the token//LC:30264
                // rather than end the token.//LC:30265
                if (isQuote(chars, pos, len, quoteStart, quoteLen)) {//LC:30266
                    if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {//LC:30267
                        // matched pair of quotes, thus an escaped quote//LC:30268
                        workArea.append(chars, pos, quoteLen);//LC:30269
                        pos += quoteLen * 2;//LC:30270
                        trimStart = workArea.size();//LC:30271
                        continue;//LC:30272
                    }//LC:30273
//LC:30274
                    // end of quoting//LC:30275
                    quoting = false;//LC:30276
                    pos += quoteLen;//LC:30277
                    continue;//LC:30278
                }//LC:30279
//LC:30280
                // copy regular character from inside quotes//LC:30281
                workArea.append(chars[pos++]);//LC:30282
                trimStart = workArea.size();//LC:30283
//LC:30284
            } else {//LC:30285
                // Not in quoting mode//LC:30286
//LC:30287
                // check for delimiter, and thus end of token//LC:30288
                final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);//LC:30289
                if (delimLen > 0) {//LC:30290
                    // return condition when end of token found//LC:30291
                    addToken(tokens, workArea.substring(0, trimStart));//LC:30292
                    return pos + delimLen;//LC:30293
                }//LC:30294
//LC:30295
                // check for quote, and thus back into quoting mode//LC:30296
                if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) {//LC:30297
                    quoting = true;//LC:30298
                    pos += quoteLen;//LC:30299
                    continue;//LC:30300
                }//LC:30301
//LC:30302
                // check for ignored (outside quotes), and ignore//LC:30303
                final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);//LC:30304
                if (ignoredLen > 0) {//LC:30305
                    pos += ignoredLen;//LC:30306
                    continue;//LC:30307
                }//LC:30308
//LC:30309
                // check for trimmed character//LC:30310
                // don't yet know if its at the end, so copy to workArea//LC:30311
                // use trimStart to keep track of trim at the end//LC:30312
                final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);//LC:30313
                if (trimmedLen > 0) {//LC:30314
                    workArea.append(chars, pos, trimmedLen);//LC:30315
                    pos += trimmedLen;//LC:30316
                    continue;//LC:30317
                }//LC:30318
//LC:30319
                // copy regular character from outside quotes//LC:30320
                workArea.append(chars[pos++]);//LC:30321
                trimStart = workArea.size();//LC:30322
            }//LC:30323
        }//LC:30324
//LC:30325
        // return condition when end of string found//LC:30326
        addToken(tokens, workArea.substring(0, trimStart));//LC:30327
        return -1;//LC:30328
    }//LC:30329
//LC:30330
    /**//LC:30331
     * Checks if the characters at the index specified match the quote//LC:30332
     * already matched in readNextToken().//LC:30333
     *//LC:30334
     * @param chars  the character array being tokenized//LC:30335
     * @param pos  the position to check for a quote//LC:30336
     * @param len  the length of the character array being tokenized//LC:30337
     * @param quoteStart  the start position of the matched quote, 0 if no quoting//LC:30338
     * @param quoteLen  the length of the matched quote, 0 if no quoting//LC:30339
     * @return true if a quote is matched//LC:30340
     *///LC:30341
    private boolean isQuote(final char[] chars, final int pos, final int len, final int quoteStart, final int quoteLen) {//LC:30342
        for (int i = 0; i < quoteLen; i++) {//LC:30343
            if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) {//LC:30344
                return false;//LC:30345
            }//LC:30346
        }//LC:30347
        return true;//LC:30348
    }//LC:30349
//LC:30350
    // Delimiter//LC:30351
    //-----------------------------------------------------------------------//LC:30352
    /**//LC:30353
     * Gets the field delimiter matcher.//LC:30354
     *//LC:30355
     * @return the delimiter matcher in use//LC:30356
     *///LC:30357
    public StrMatcher getDelimiterMatcher() {//LC:30358
        return this.delimMatcher;//LC:30359
    }//LC:30360
//LC:30361
    /**//LC:30362
     * Sets the field delimiter matcher.//LC:30363
     * <p>//LC:30364
     * The delimitier is used to separate one token from another.//LC:30365
     *//LC:30366
     * @param delim  the delimiter matcher to use//LC:30367
     * @return this, to enable chaining//LC:30368
     *///LC:30369
    public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {//LC:30370
        if (delim == null) {//LC:30371
            this.delimMatcher = StrMatcher.noneMatcher();//LC:30372
        } else {//LC:30373
            this.delimMatcher = delim;//LC:30374
        }//LC:30375
        return this;//LC:30376
    }//LC:30377
//LC:30378
    /**//LC:30379
     * Sets the field delimiter character.//LC:30380
     *//LC:30381
     * @param delim  the delimiter character to use//LC:30382
     * @return this, to enable chaining//LC:30383
     *///LC:30384
    public StrTokenizer setDelimiterChar(final char delim) {//LC:30385
        return setDelimiterMatcher(StrMatcher.charMatcher(delim));//LC:30386
    }//LC:30387
//LC:30388
    /**//LC:30389
     * Sets the field delimiter string.//LC:30390
     *//LC:30391
     * @param delim  the delimiter string to use//LC:30392
     * @return this, to enable chaining//LC:30393
     *///LC:30394
    public StrTokenizer setDelimiterString(final String delim) {//LC:30395
        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));//LC:30396
    }//LC:30397
//LC:30398
    // Quote//LC:30399
    //-----------------------------------------------------------------------//LC:30400
    /**//LC:30401
     * Gets the quote matcher currently in use.//LC:30402
     * <p>//LC:30403
     * The quote character is used to wrap data between the tokens.//LC:30404
     * This enables delimiters to be entered as data.//LC:30405
     * The default value is '"' (double quote).//LC:30406
     *//LC:30407
     * @return the quote matcher in use//LC:30408
     *///LC:30409
    public StrMatcher getQuoteMatcher() {//LC:30410
        return quoteMatcher;//LC:30411
    }//LC:30412
//LC:30413
    /**//LC:30414
     * Set the quote matcher to use.//LC:30415
     * <p>//LC:30416
     * The quote character is used to wrap data between the tokens.//LC:30417
     * This enables delimiters to be entered as data.//LC:30418
     *//LC:30419
     * @param quote  the quote matcher to use, null ignored//LC:30420
     * @return this, to enable chaining//LC:30421
     *///LC:30422
    public StrTokenizer setQuoteMatcher(final StrMatcher quote) {//LC:30423
        if (quote != null) {//LC:30424
            this.quoteMatcher = quote;//LC:30425
        }//LC:30426
        return this;//LC:30427
    }//LC:30428
//LC:30429
    /**//LC:30430
     * Sets the quote character to use.//LC:30431
     * <p>//LC:30432
     * The quote character is used to wrap data between the tokens.//LC:30433
     * This enables delimiters to be entered as data.//LC:30434
     *//LC:30435
     * @param quote  the quote character to use//LC:30436
     * @return this, to enable chaining//LC:30437
     *///LC:30438
    public StrTokenizer setQuoteChar(final char quote) {//LC:30439
        return setQuoteMatcher(StrMatcher.charMatcher(quote));//LC:30440
    }//LC:30441
//LC:30442
    // Ignored//LC:30443
    //-----------------------------------------------------------------------//LC:30444
    /**//LC:30445
     * Gets the ignored character matcher.//LC:30446
     * <p>//LC:30447
     * These characters are ignored when parsing the String, unless they are//LC:30448
     * within a quoted region.//LC:30449
     * The default value is not to ignore anything.//LC:30450
     *//LC:30451
     * @return the ignored matcher in use//LC:30452
     *///LC:30453
    public StrMatcher getIgnoredMatcher() {//LC:30454
        return ignoredMatcher;//LC:30455
    }//LC:30456
//LC:30457
    /**//LC:30458
     * Set the matcher for characters to ignore.//LC:30459
     * <p>//LC:30460
     * These characters are ignored when parsing the String, unless they are//LC:30461
     * within a quoted region.//LC:30462
     *//LC:30463
     * @param ignored  the ignored matcher to use, null ignored//LC:30464
     * @return this, to enable chaining//LC:30465
     *///LC:30466
    public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {//LC:30467
        if (ignored != null) {//LC:30468
            this.ignoredMatcher = ignored;//LC:30469
        }//LC:30470
        return this;//LC:30471
    }//LC:30472
//LC:30473
    /**//LC:30474
     * Set the character to ignore.//LC:30475
     * <p>//LC:30476
     * This character is ignored when parsing the String, unless it is//LC:30477
     * within a quoted region.//LC:30478
     *//LC:30479
     * @param ignored  the ignored character to use//LC:30480
     * @return this, to enable chaining//LC:30481
     *///LC:30482
    public StrTokenizer setIgnoredChar(final char ignored) {//LC:30483
        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));//LC:30484
    }//LC:30485
//LC:30486
    // Trimmer//LC:30487
    //-----------------------------------------------------------------------//LC:30488
    /**//LC:30489
     * Gets the trimmer character matcher.//LC:30490
     * <p>//LC:30491
     * These characters are trimmed off on each side of the delimiter//LC:30492
     * until the token or quote is found.//LC:30493
     * The default value is not to trim anything.//LC:30494
     *//LC:30495
     * @return the trimmer matcher in use//LC:30496
     *///LC:30497
    public StrMatcher getTrimmerMatcher() {//LC:30498
        return trimmerMatcher;//LC:30499
    }//LC:30500
//LC:30501
    /**//LC:30502
     * Sets the matcher for characters to trim.//LC:30503
     * <p>//LC:30504
     * These characters are trimmed off on each side of the delimiter//LC:30505
     * until the token or quote is found.//LC:30506
     *//LC:30507
     * @param trimmer  the trimmer matcher to use, null ignored//LC:30508
     * @return this, to enable chaining//LC:30509
     *///LC:30510
    public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {//LC:30511
        if (trimmer != null) {//LC:30512
            this.trimmerMatcher = trimmer;//LC:30513
        }//LC:30514
        return this;//LC:30515
    }//LC:30516
//LC:30517
    //-----------------------------------------------------------------------//LC:30518
    /**//LC:30519
     * Gets whether the tokenizer currently returns empty tokens as null.//LC:30520
     * The default for this property is false.//LC:30521
     *//LC:30522
     * @return true if empty tokens are returned as null//LC:30523
     *///LC:30524
    public boolean isEmptyTokenAsNull() {//LC:30525
        return this.emptyAsNull;//LC:30526
    }//LC:30527
//LC:30528
    /**//LC:30529
     * Sets whether the tokenizer should return empty tokens as null.//LC:30530
     * The default for this property is false.//LC:30531
     *//LC:30532
     * @param emptyAsNull  whether empty tokens are returned as null//LC:30533
     * @return this, to enable chaining//LC:30534
     *///LC:30535
    public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {//LC:30536
        this.emptyAsNull = emptyAsNull;//LC:30537
        return this;//LC:30538
    }//LC:30539
//LC:30540
    //-----------------------------------------------------------------------//LC:30541
    /**//LC:30542
     * Gets whether the tokenizer currently ignores empty tokens.//LC:30543
     * The default for this property is true.//LC:30544
     *//LC:30545
     * @return true if empty tokens are not returned//LC:30546
     *///LC:30547
    public boolean isIgnoreEmptyTokens() {//LC:30548
        return ignoreEmptyTokens;//LC:30549
    }//LC:30550
//LC:30551
    /**//LC:30552
     * Sets whether the tokenizer should ignore and not return empty tokens.//LC:30553
     * The default for this property is true.//LC:30554
     *//LC:30555
     * @param ignoreEmptyTokens  whether empty tokens are not returned//LC:30556
     * @return this, to enable chaining//LC:30557
     *///LC:30558
    public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {//LC:30559
        this.ignoreEmptyTokens = ignoreEmptyTokens;//LC:30560
        return this;//LC:30561
    }//LC:30562
//LC:30563
    //-----------------------------------------------------------------------//LC:30564
    /**//LC:30565
     * Gets the String content that the tokenizer is parsing.//LC:30566
     *//LC:30567
     * @return the string content being parsed//LC:30568
     *///LC:30569
    public String getContent() {//LC:30570
        if (chars == null) {//LC:30571
            return null;//LC:30572
        }//LC:30573
        return new String(chars);//LC:30574
    }//LC:30575
//LC:30576
    //-----------------------------------------------------------------------//LC:30577
    /**//LC:30578
     * Creates a new instance of this Tokenizer. The new instance is reset so//LC:30579
     * that it will be at the start of the token list.//LC:30580
     * If a {@link CloneNotSupportedException} is caught, return <code>null</code>.//LC:30581
     *//LC:30582
     * @return a new instance of this Tokenizer which has been reset.//LC:30583
     *///LC:30584
    @Override//LC:30585
    public Object clone() {//LC:30586
        try {//LC:30587
            return cloneReset();//LC:30588
        } catch (final CloneNotSupportedException ex) {//LC:30589
            return null;//LC:30590
        }//LC:30591
    }//LC:30592
//LC:30593
    /**//LC:30594
     * Creates a new instance of this Tokenizer. The new instance is reset so that//LC:30595
     * it will be at the start of the token list.//LC:30596
     *//LC:30597
     * @return a new instance of this Tokenizer which has been reset.//LC:30598
     * @throws CloneNotSupportedException if there is a problem cloning//LC:30599
     *///LC:30600
    Object cloneReset() throws CloneNotSupportedException {//LC:30601
        // this method exists to enable 100% test coverage//LC:30602
        final StrTokenizer cloned = (StrTokenizer) super.clone();//LC:30603
        if (cloned.chars != null) {//LC:30604
            cloned.chars = cloned.chars.clone();//LC:30605
        }//LC:30606
        cloned.reset();//LC:30607
        return cloned;//LC:30608
    }//LC:30609
//LC:30610
    //-----------------------------------------------------------------------//LC:30611
    /**//LC:30612
     * Gets the String content that the tokenizer is parsing.//LC:30613
     *//LC:30614
     * @return the string content being parsed//LC:30615
     *///LC:30616
    @Override//LC:30617
    public String toString() {//LC:30618
        if (tokens == null) {//LC:30619
            return "StrTokenizer[not tokenized yet]";//LC:30620
        }//LC:30621
        return "StrTokenizer" + getTokenList();//LC:30622
    }//LC:30623
//LC:30624
}//LC:30625
//LC:30626
//LC:30627
/**//LC:30628
 * <p>An enum representing all the versions of the Java specification.//LC:30629
 * This is intended to mirror available values from the//LC:30630
 * <em>java.specification.version</em> System property. </p>//LC:30631
 *//LC:30632
 * @since 3.0//LC:30633
 * @version $Id: $//LC:30634
 *///LC:30635
enum JavaVersion {//LC:30636
//LC:30637
    /**//LC:30638
     * The Java version reported by Android. This is not an official Java version number.//LC:30639
     *///LC:30640
    JAVA_0_9(1.5f, "0.9"),//LC:30641
//LC:30642
    /**//LC:30643
     * Java 1.1.//LC:30644
     *///LC:30645
    JAVA_1_1(1.1f, "1.1"),//LC:30646
//LC:30647
    /**//LC:30648
     * Java 1.2.//LC:30649
     *///LC:30650
    JAVA_1_2(1.2f, "1.2"),//LC:30651
//LC:30652
    /**//LC:30653
     * Java 1.3.//LC:30654
     *///LC:30655
    JAVA_1_3(1.3f, "1.3"),//LC:30656
//LC:30657
    /**//LC:30658
     * Java 1.4.//LC:30659
     *///LC:30660
    JAVA_1_4(1.4f, "1.4"),//LC:30661
//LC:30662
    /**//LC:30663
     * Java 1.5.//LC:30664
     *///LC:30665
    JAVA_1_5(1.5f, "1.5"),//LC:30666
//LC:30667
    /**//LC:30668
     * Java 1.6.//LC:30669
     *///LC:30670
    JAVA_1_6(1.6f, "1.6"),//LC:30671
//LC:30672
    /**//LC:30673
     * Java 1.7.//LC:30674
     *///LC:30675
    JAVA_1_7(1.7f, "1.7"),//LC:30676
//LC:30677
    /**//LC:30678
     * Java 1.8.//LC:30679
     *///LC:30680
    JAVA_1_8(1.8f, "1.8");//LC:30681
//LC:30682
    /**//LC:30683
     * The float value.//LC:30684
     *///LC:30685
    private float value;//LC:30686
    /**//LC:30687
     * The standard name.//LC:30688
     *///LC:30689
    private String name;//LC:30690
//LC:30691
    /**//LC:30692
     * Constructor.//LC:30693
     *//LC:30694
     * @param value  the float value//LC:30695
     * @param name  the standard name, not null//LC:30696
     *///LC:30697
    JavaVersion(final float value, final String name) {//LC:30698
        this.value = value;//LC:30699
        this.name = name;//LC:30700
    }//LC:30701
//LC:30702
    //-----------------------------------------------------------------------//LC:30703
    /**//LC:30704
     * <p>Whether this version of Java is at least the version of Java passed in.</p>//LC:30705
     *//LC:30706
     * <p>For example:<br />//LC:30707
     *  {@code myVersion.atLeast(JavaVersion.JAVA_1_4)}<p>//LC:30708
     *//LC:30709
     * @param requiredVersion  the version to check against, not null//LC:30710
     * @return true if this version is equal to or greater than the specified version//LC:30711
     *///LC:30712
    public boolean atLeast(final JavaVersion requiredVersion) {//LC:30713
        return this.value >= requiredVersion.value;//LC:30714
    }//LC:30715
//LC:30716
    /**//LC:30717
     * Transforms the given string with a Java version number to the//LC:30718
     * corresponding constant of this enumeration class. This method is used//LC:30719
     * internally.//LC:30720
     *//LC:30721
     * @param nom the Java version as string//LC:30722
     * @return the corresponding enumeration constant or <b>null</b> if the//LC:30723
     * version is unknown//LC:30724
     *///LC:30725
    // helper for static importing//LC:30726
    static JavaVersion getJavaVersion(final String nom) {//LC:30727
        return get(nom);//LC:30728
    }//LC:30729
//LC:30730
    /**//LC:30731
     * Transforms the given string with a Java version number to the//LC:30732
     * corresponding constant of this enumeration class. This method is used//LC:30733
     * internally.//LC:30734
     *//LC:30735
     * @param nom the Java version as string//LC:30736
     * @return the corresponding enumeration constant or <b>null</b> if the//LC:30737
     * version is unknown//LC:30738
     *///LC:30739
    static JavaVersion get(final String nom) {//LC:30740
        if ("0.9".equals(nom)) {//LC:30741
            return JAVA_0_9;//LC:30742
        } else if ("1.1".equals(nom)) {//LC:30743
            return JAVA_1_1;//LC:30744
        } else if ("1.2".equals(nom)) {//LC:30745
            return JAVA_1_2;//LC:30746
        } else if ("1.3".equals(nom)) {//LC:30747
            return JAVA_1_3;//LC:30748
        } else if ("1.4".equals(nom)) {//LC:30749
            return JAVA_1_4;//LC:30750
        } else if ("1.5".equals(nom)) {//LC:30751
            return JAVA_1_5;//LC:30752
        } else if ("1.6".equals(nom)) {//LC:30753
            return JAVA_1_6;//LC:30754
        } else if ("1.7".equals(nom)) {//LC:30755
            return JAVA_1_7;//LC:30756
        } else if ("1.8".equals(nom)) {//LC:30757
            return JAVA_1_8;//LC:30758
        } else {//LC:30759
            return null;//LC:30760
        }//LC:30761
    }//LC:30762
//LC:30763
    //-----------------------------------------------------------------------//LC:30764
    /**//LC:30765
     * <p>The string value is overridden to return the standard name.</p>//LC:30766
     *//LC:30767
     * <p>For example, <code>"1.5"</code>.</p>//LC:30768
     *//LC:30769
     * @return the name, not null//LC:30770
     *///LC:30771
    @Override//LC:30772
    public String toString() {//LC:30773
        return name;//LC:30774
    }//LC:30775
//LC:30776
}//LC:30777
//LC:30778
//LC:30779
/**//LC:30780
 * <p>An immutable pair consisting of two {@code Object} elements.</p>//LC:30781
 *//LC:30782
 * <p>Although the implementation is immutable, there is no restriction on the objects//LC:30783
 * that may be stored. If mutable objects are stored in the pair, then the pair//LC:30784
 * itself effectively becomes mutable. The class is also not {@code final}, so a subclass//LC:30785
 * could add undesirable behaviour.</p>//LC:30786
 *//LC:30787
 * <p>#ThreadSafe# if both paired objects are thread-safe</p>//LC:30788
 *//LC:30789
 * @param <L> the left element type//LC:30790
 * @param <R> the right element type//LC:30791
 *//LC:30792
 * @since Lang 3.0//LC:30793
 * @version $Id$//LC:30794
 *///LC:30795
final class ImmutablePair<L, R> extends Pair<L, R> {//LC:30796
//LC:30797
    /** Serialization version *///LC:30798
    private static final long serialVersionUID = 4954918890077093841L;//LC:30799
//LC:30800
    /** Left object *///LC:30801
    public final L left;//LC:30802
    /** Right object *///LC:30803
    public final R right;//LC:30804
//LC:30805
    /**//LC:30806
     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>//LC:30807
     *//LC:30808
     * <p>This factory allows the pair to be created using inference to//LC:30809
     * obtain the generic types.</p>//LC:30810
     *//LC:30811
     * @param <L> the left element type//LC:30812
     * @param <R> the right element type//LC:30813
     * @param left  the left element, may be null//LC:30814
     * @param right  the right element, may be null//LC:30815
     * @return a pair formed from the two parameters, not null//LC:30816
     *///LC:30817
    public static <L, R> ImmutablePair<L, R> of(final L left, final R right) {//LC:30818
        return new ImmutablePair<L, R>(left, right);//LC:30819
    }//LC:30820
//LC:30821
    /**//LC:30822
     * Create a new pair instance.//LC:30823
     *//LC:30824
     * @param left  the left value, may be null//LC:30825
     * @param right  the right value, may be null//LC:30826
     *///LC:30827
    public ImmutablePair(final L left, final R right) {//LC:30828
        super();//LC:30829
        this.left = left;//LC:30830
        this.right = right;//LC:30831
    }//LC:30832
//LC:30833
    //-----------------------------------------------------------------------//LC:30834
    /**//LC:30835
     * {@inheritDoc}//LC:30836
     *///LC:30837
    @Override//LC:30838
    public L getLeft() {//LC:30839
        return left;//LC:30840
    }//LC:30841
//LC:30842
    /**//LC:30843
     * {@inheritDoc}//LC:30844
     *///LC:30845
    @Override//LC:30846
    public R getRight() {//LC:30847
        return right;//LC:30848
    }//LC:30849
//LC:30850
    /**//LC:30851
     * <p>Throws {@code UnsupportedOperationException}.</p>//LC:30852
     *//LC:30853
     * <p>This pair is immutable, so this operation is not supported.</p>//LC:30854
     *//LC:30855
     * @param value  the value to set//LC:30856
     * @return never//LC:30857
     * @throws UnsupportedOperationException as this operation is not supported//LC:30858
     *///LC:30859
    @Override//LC:30860
    public R setValue(final R value) {//LC:30861
        throw new UnsupportedOperationException();//LC:30862
    }//LC:30863
//LC:30864
}//LC:30865
//LC:30866
//LC:30867
//LC:30868
/**//LC:30869
 * Assists in implementing {@link java.lang.Comparable#compareTo(Object)} methods.//LC:30870
 *//LC:30871
 * It is consistent with <code>equals(Object)</code> and//LC:30872
 * <code>hashcode()</code> built with {@link EqualsBuilder} and//LC:30873
 * {@link HashCodeBuilder}.</p>//LC:30874
 *//LC:30875
 * <p>Two Objects that compare equal using <code>equals(Object)</code> should normally//LC:30876
 * also compare equal using <code>compareTo(Object)</code>.</p>//LC:30877
 *//LC:30878
 * <p>All relevant fields should be included in the calculation of the//LC:30879
 * comparison. Derived fields may be ignored. The same fields, in the same//LC:30880
 * order, should be used in both <code>compareTo(Object)</code> and//LC:30881
 * <code>equals(Object)</code>.</p>//LC:30882
 *//LC:30883
 * <p>To use this class write code as follows:</p>//LC:30884
 *//LC:30885
 * <pre>//LC:30886
 * public class MyClass {//LC:30887
 *   String field1;//LC:30888
 *   int field2;//LC:30889
 *   boolean field3;//LC:30890
 *//LC:30891
 *   ...//LC:30892
 *//LC:30893
 *   public int compareTo(Object o) {//LC:30894
 *     MyClass myClass = (MyClass) o;//LC:30895
 *     return new CompareToBuilder()//LC:30896
 *       .appendSuper(super.compareTo(o)//LC:30897
 *       .append(this.field1, myClass.field1)//LC:30898
 *       .append(this.field2, myClass.field2)//LC:30899
 *       .append(this.field3, myClass.field3)//LC:30900
 *       .toComparison();//LC:30901
 *   }//LC:30902
 * }//LC:30903
 * </pre>//LC:30904
 *//LC:30905
 * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use//LC:30906
 * reflection to determine the fields to append. Because fields can be private,//LC:30907
 * <code>reflectionCompare</code> uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to//LC:30908
 * bypass normal access control checks. This will fail under a security manager,//LC:30909
 * unless the appropriate permissions are set up correctly. It is also//LC:30910
 * slower than appending explicitly.</p>//LC:30911
 *//LC:30912
 * <p>A typical implementation of <code>compareTo(Object)</code> using//LC:30913
 * <code>reflectionCompare</code> looks like:</p>//LC:30914
//LC:30915
 * <pre>//LC:30916
 * public int compareTo(Object o) {//LC:30917
 *   return CompareToBuilder.reflectionCompare(this, o);//LC:30918
 * }//LC:30919
 * </pre>//LC:30920
 *//LC:30921
 * @see java.lang.Comparable//LC:30922
 * @see java.lang.Object#equals(Object)//LC:30923
 * @see java.lang.Object#hashCode()//LC:30924
 * @see EqualsBuilder//LC:30925
 * @see HashCodeBuilder//LC:30926
 * @since 1.0//LC:30927
 * @version $Id$//LC:30928
 *///LC:30929
class CompareToBuilder implements Builder<Integer> {//LC:30930
//LC:30931
    /**//LC:30932
     * Current state of the comparison as appended fields are checked.//LC:30933
     *///LC:30934
    private int comparison;//LC:30935
//LC:30936
    /**//LC:30937
     * <p>Constructor for CompareToBuilder.</p>//LC:30938
     *//LC:30939
     * <p>Starts off assuming that the objects are equal. Multiple calls are//LC:30940
     * then made to the various append methods, followed by a call to//LC:30941
     * {@link #toComparison} to get the result.</p>//LC:30942
     *///LC:30943
    public CompareToBuilder() {//LC:30944
        super();//LC:30945
        comparison = 0;//LC:30946
    }//LC:30947
//LC:30948
    //-----------------------------------------------------------------------//LC:30949
    /**//LC:30950
     * <p>Compares two <code>Object</code>s via reflection.</p>//LC:30951
     *//LC:30952
     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>//LC:30953
     * is used to bypass normal access control checks. This will fail under a//LC:30954
     * security manager unless the appropriate permissions are set.</p>//LC:30955
     *//LC:30956
     * <ul>//LC:30957
     * <li>Static fields will not be compared</li>//LC:30958
     * <li>Transient members will be not be compared, as they are likely derived//LC:30959
     *     fields</li>//LC:30960
     * <li>Superclass fields will be compared</li>//LC:30961
     * </ul>//LC:30962
     *//LC:30963
     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,//LC:30964
     * they are considered equal.</p>//LC:30965
     *//LC:30966
     * @param lhs  left-hand object//LC:30967
     * @param rhs  right-hand object//LC:30968
     * @return a negative integer, zero, or a positive integer as <code>lhs</code>//LC:30969
     *  is less than, equal to, or greater than <code>rhs</code>//LC:30970
     * @throws NullPointerException  if either (but not both) parameters are//LC:30971
     *  <code>null</code>//LC:30972
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:30973
     *  with <code>lhs</code>//LC:30974
     *///LC:30975
    public static int reflectionCompare(final Object lhs, final Object rhs) {//LC:30976
        return reflectionCompare(lhs, rhs, false, null);//LC:30977
    }//LC:30978
//LC:30979
    /**//LC:30980
     * <p>Compares two <code>Object</code>s via reflection.</p>//LC:30981
     *//LC:30982
     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>//LC:30983
     * is used to bypass normal access control checks. This will fail under a//LC:30984
     * security manager unless the appropriate permissions are set.</p>//LC:30985
     *//LC:30986
     * <ul>//LC:30987
     * <li>Static fields will not be compared</li>//LC:30988
     * <li>If <code>compareTransients</code> is <code>true</code>,//LC:30989
     *     compares transient members.  Otherwise ignores them, as they//LC:30990
     *     are likely derived fields.</li>//LC:30991
     * <li>Superclass fields will be compared</li>//LC:30992
     * </ul>//LC:30993
     *//LC:30994
     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,//LC:30995
     * they are considered equal.</p>//LC:30996
     *//LC:30997
     * @param lhs  left-hand object//LC:30998
     * @param rhs  right-hand object//LC:30999
     * @param compareTransients  whether to compare transient fields//LC:31000
     * @return a negative integer, zero, or a positive integer as <code>lhs</code>//LC:31001
     *  is less than, equal to, or greater than <code>rhs</code>//LC:31002
     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>//LC:31003
     *  (but not both) is <code>null</code>//LC:31004
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31005
     *  with <code>lhs</code>//LC:31006
     *///LC:31007
    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {//LC:31008
        return reflectionCompare(lhs, rhs, compareTransients, null);//LC:31009
    }//LC:31010
//LC:31011
    /**//LC:31012
     * <p>Compares two <code>Object</code>s via reflection.</p>//LC:31013
     *//LC:31014
     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>//LC:31015
     * is used to bypass normal access control checks. This will fail under a//LC:31016
     * security manager unless the appropriate permissions are set.</p>//LC:31017
     *//LC:31018
     * <ul>//LC:31019
     * <li>Static fields will not be compared</li>//LC:31020
     * <li>If <code>compareTransients</code> is <code>true</code>,//LC:31021
     *     compares transient members.  Otherwise ignores them, as they//LC:31022
     *     are likely derived fields.</li>//LC:31023
     * <li>Superclass fields will be compared</li>//LC:31024
     * </ul>//LC:31025
     *//LC:31026
     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,//LC:31027
     * they are considered equal.</p>//LC:31028
     *//LC:31029
     * @param lhs  left-hand object//LC:31030
     * @param rhs  right-hand object//LC:31031
     * @param excludeFields  Collection of String fields to exclude//LC:31032
     * @return a negative integer, zero, or a positive integer as <code>lhs</code>//LC:31033
     *  is less than, equal to, or greater than <code>rhs</code>//LC:31034
     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>//LC:31035
     *  (but not both) is <code>null</code>//LC:31036
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31037
     *  with <code>lhs</code>//LC:31038
     * @since 2.2//LC:31039
     *///LC:31040
    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {//LC:31041
        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));//LC:31042
    }//LC:31043
//LC:31044
    /**//LC:31045
     * <p>Compares two <code>Object</code>s via reflection.</p>//LC:31046
     *//LC:31047
     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>//LC:31048
     * is used to bypass normal access control checks. This will fail under a//LC:31049
     * security manager unless the appropriate permissions are set.</p>//LC:31050
     *//LC:31051
     * <ul>//LC:31052
     * <li>Static fields will not be compared</li>//LC:31053
     * <li>If <code>compareTransients</code> is <code>true</code>,//LC:31054
     *     compares transient members.  Otherwise ignores them, as they//LC:31055
     *     are likely derived fields.</li>//LC:31056
     * <li>Superclass fields will be compared</li>//LC:31057
     * </ul>//LC:31058
     *//LC:31059
     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,//LC:31060
     * they are considered equal.</p>//LC:31061
     *//LC:31062
     * @param lhs  left-hand object//LC:31063
     * @param rhs  right-hand object//LC:31064
     * @param excludeFields  array of fields to exclude//LC:31065
     * @return a negative integer, zero, or a positive integer as <code>lhs</code>//LC:31066
     *  is less than, equal to, or greater than <code>rhs</code>//LC:31067
     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>//LC:31068
     *  (but not both) is <code>null</code>//LC:31069
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31070
     *  with <code>lhs</code>//LC:31071
     * @since 2.2//LC:31072
     *///LC:31073
    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {//LC:31074
        return reflectionCompare(lhs, rhs, false, null, excludeFields);//LC:31075
    }//LC:31076
//LC:31077
    /**//LC:31078
     * <p>Compares two <code>Object</code>s via reflection.</p>//LC:31079
     *//LC:31080
     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>//LC:31081
     * is used to bypass normal access control checks. This will fail under a//LC:31082
     * security manager unless the appropriate permissions are set.</p>//LC:31083
     *//LC:31084
     * <ul>//LC:31085
     * <li>Static fields will not be compared</li>//LC:31086
     * <li>If the <code>compareTransients</code> is <code>true</code>,//LC:31087
     *     compares transient members.  Otherwise ignores them, as they//LC:31088
     *     are likely derived fields.</li>//LC:31089
     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.//LC:31090
     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>//LC:31091
     * </ul>//LC:31092
     *//LC:31093
     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,//LC:31094
     * they are considered equal.</p>//LC:31095
     *//LC:31096
     * @param lhs  left-hand object//LC:31097
     * @param rhs  right-hand object//LC:31098
     * @param compareTransients  whether to compare transient fields//LC:31099
     * @param reflectUpToClass  last superclass for which fields are compared//LC:31100
     * @param excludeFields  fields to exclude//LC:31101
     * @return a negative integer, zero, or a positive integer as <code>lhs</code>//LC:31102
     *  is less than, equal to, or greater than <code>rhs</code>//LC:31103
     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>//LC:31104
     *  (but not both) is <code>null</code>//LC:31105
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31106
     *  with <code>lhs</code>//LC:31107
     * @since 2.2 (2.0 as <code>reflectionCompare(Object, Object, boolean, Class)</code>)//LC:31108
     *///LC:31109
    public static int reflectionCompare(//LC:31110
            final Object lhs,//LC:31111
            final Object rhs,//LC:31112
            final boolean compareTransients,//LC:31113
            final Class<?> reflectUpToClass,//LC:31114
            final String... excludeFields) {//LC:31115
//LC:31116
        if (lhs == rhs) {//LC:31117
            return 0;//LC:31118
        }//LC:31119
        if (lhs == null || rhs == null) {//LC:31120
            throw new NullPointerException();//LC:31121
        }//LC:31122
        Class<?> lhsClazz = lhs.getClass();//LC:31123
        if (!lhsClazz.isInstance(rhs)) {//LC:31124
            throw new ClassCastException();//LC:31125
        }//LC:31126
        final CompareToBuilder compareToBuilder = new CompareToBuilder();//LC:31127
        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);//LC:31128
        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {//LC:31129
            lhsClazz = lhsClazz.getSuperclass();//LC:31130
            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);//LC:31131
        }//LC:31132
        return compareToBuilder.toComparison();//LC:31133
    }//LC:31134
//LC:31135
    /**//LC:31136
     * <p>Appends to <code>builder</code> the comparison of <code>lhs</code>//LC:31137
     * to <code>rhs</code> using the fields defined in <code>clazz</code>.</p>//LC:31138
     *//LC:31139
     * @param lhs  left-hand object//LC:31140
     * @param rhs  right-hand object//LC:31141
     * @param clazz  <code>Class</code> that defines fields to be compared//LC:31142
     * @param builder  <code>CompareToBuilder</code> to append to//LC:31143
     * @param useTransients  whether to compare transient fields//LC:31144
     * @param excludeFields  fields to exclude//LC:31145
     *///LC:31146
    private static void reflectionAppend(//LC:31147
            final Object lhs,//LC:31148
            final Object rhs,//LC:31149
            final Class<?> clazz,//LC:31150
            final CompareToBuilder builder,//LC:31151
            final boolean useTransients,//LC:31152
            final String[] excludeFields) {//LC:31153
//LC:31154
        final Field[] fields = clazz.getDeclaredFields();//LC:31155
        AccessibleObject.setAccessible(fields, true);//LC:31156
        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {//LC:31157
            final Field f = fields[i];//LC:31158
            if (!ArrayUtils.contains(excludeFields, f.getName())//LC:31159
                    && (f.getName().indexOf('$') == -1)//LC:31160
                    && (useTransients || !Modifier.isTransient(f.getModifiers()))//LC:31161
                    && (!Modifier.isStatic(f.getModifiers()))) {//LC:31162
                try {//LC:31163
                    builder.append(f.get(lhs), f.get(rhs));//LC:31164
                } catch (final IllegalAccessException e) {//LC:31165
                    // This can't happen. Would get a Security exception instead.//LC:31166
                    // Throw a runtime exception in case the impossible happens.//LC:31167
                    throw new InternalError("Unexpected IllegalAccessException");//LC:31168
                }//LC:31169
            }//LC:31170
        }//LC:31171
    }//LC:31172
//LC:31173
    //-----------------------------------------------------------------------//LC:31174
    /**//LC:31175
     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>//LC:31176
     * result of the superclass.</p>//LC:31177
     *//LC:31178
     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>//LC:31179
     * @return this - used to chain append calls//LC:31180
     * @since 2.0//LC:31181
     *///LC:31182
    public CompareToBuilder appendSuper(final int superCompareTo) {//LC:31183
        if (comparison != 0) {//LC:31184
            return this;//LC:31185
        }//LC:31186
        comparison = superCompareTo;//LC:31187
        return this;//LC:31188
    }//LC:31189
//LC:31190
    //-----------------------------------------------------------------------//LC:31191
    /**//LC:31192
     * <p>Appends to the <code>builder</code> the comparison of//LC:31193
     * two <code>Object</code>s.</p>//LC:31194
     *//LC:31195
     * <ol>//LC:31196
     * <li>Check if <code>lhs == rhs</code></li>//LC:31197
     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,//LC:31198
     *     a <code>null</code> object is less than a non-<code>null</code> object</li>//LC:31199
     * <li>Check the object contents</li>//LC:31200
     * </ol>//LC:31201
     *//LC:31202
     * <p><code>lhs</code> must either be an array or implement {@link Comparable}.</p>//LC:31203
     *//LC:31204
     * @param lhs  left-hand object//LC:31205
     * @param rhs  right-hand object//LC:31206
     * @return this - used to chain append calls//LC:31207
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31208
     *  with <code>lhs</code>//LC:31209
     *///LC:31210
    public CompareToBuilder append(final Object lhs, final Object rhs) {//LC:31211
        return append(lhs, rhs, null);//LC:31212
    }//LC:31213
//LC:31214
    /**//LC:31215
     * <p>Appends to the <code>builder</code> the comparison of//LC:31216
     * two <code>Object</code>s.</p>//LC:31217
     *//LC:31218
     * <ol>//LC:31219
     * <li>Check if <code>lhs == rhs</code></li>//LC:31220
     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,//LC:31221
     *     a <code>null</code> object is less than a non-<code>null</code> object</li>//LC:31222
     * <li>Check the object contents</li>//LC:31223
     * </ol>//LC:31224
     *//LC:31225
     * <p>If <code>lhs</code> is an array, array comparison methods will be used.//LC:31226
     * Otherwise <code>comparator</code> will be used to compare the objects.//LC:31227
     * If <code>comparator</code> is <code>null</code>, <code>lhs</code> must//LC:31228
     * implement {@link Comparable} instead.</p>//LC:31229
     *//LC:31230
     * @param lhs  left-hand object//LC:31231
     * @param rhs  right-hand object//LC:31232
     * @param comparator  <code>Comparator</code> used to compare the objects,//LC:31233
     *  <code>null</code> means treat lhs as <code>Comparable</code>//LC:31234
     * @return this - used to chain append calls//LC:31235
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31236
     *  with <code>lhs</code>//LC:31237
     * @since 2.0//LC:31238
     *///LC:31239
    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {//LC:31240
        if (comparison != 0) {//LC:31241
            return this;//LC:31242
        }//LC:31243
        if (lhs == rhs) {//LC:31244
            return this;//LC:31245
        }//LC:31246
        if (lhs == null) {//LC:31247
            comparison = -1;//LC:31248
            return this;//LC:31249
        }//LC:31250
        if (rhs == null) {//LC:31251
            comparison = +1;//LC:31252
            return this;//LC:31253
        }//LC:31254
        if (lhs.getClass().isArray()) {//LC:31255
            // switch on type of array, to dispatch to the correct handler//LC:31256
            // handles multi dimensional arrays//LC:31257
            // throws a ClassCastException if rhs is not the correct array type//LC:31258
            if (lhs instanceof long[]) {//LC:31259
                append((long[]) lhs, (long[]) rhs);//LC:31260
            } else if (lhs instanceof int[]) {//LC:31261
                append((int[]) lhs, (int[]) rhs);//LC:31262
            } else if (lhs instanceof short[]) {//LC:31263
                append((short[]) lhs, (short[]) rhs);//LC:31264
            } else if (lhs instanceof char[]) {//LC:31265
                append((char[]) lhs, (char[]) rhs);//LC:31266
            } else if (lhs instanceof byte[]) {//LC:31267
                append((byte[]) lhs, (byte[]) rhs);//LC:31268
            } else if (lhs instanceof double[]) {//LC:31269
                append((double[]) lhs, (double[]) rhs);//LC:31270
            } else if (lhs instanceof float[]) {//LC:31271
                append((float[]) lhs, (float[]) rhs);//LC:31272
            } else if (lhs instanceof boolean[]) {//LC:31273
                append((boolean[]) lhs, (boolean[]) rhs);//LC:31274
            } else {//LC:31275
                // not an array of primitives//LC:31276
                // throws a ClassCastException if rhs is not an array//LC:31277
                append((Object[]) lhs, (Object[]) rhs, comparator);//LC:31278
            }//LC:31279
        } else {//LC:31280
            // the simple case, not an array, just test the element//LC:31281
            if (comparator == null) {//LC:31282
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc//LC:31283
                final Comparable<Object> comparable = (Comparable<Object>) lhs;//LC:31284
                comparison = comparable.compareTo(rhs);//LC:31285
            } else {//LC:31286
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc//LC:31287
                final Comparator<Object> comparator2 = (Comparator<Object>) comparator;//LC:31288
                comparison = comparator2.compare(lhs, rhs);//LC:31289
            }//LC:31290
        }//LC:31291
        return this;//LC:31292
    }//LC:31293
//LC:31294
    //-------------------------------------------------------------------------//LC:31295
    /**//LC:31296
     * Appends to the <code>builder</code> the comparison of//LC:31297
     * two <code>long</code>s.//LC:31298
     *//LC:31299
     * @param lhs  left-hand value//LC:31300
     * @param rhs  right-hand value//LC:31301
     * @return this - used to chain append calls//LC:31302
     *///LC:31303
    public CompareToBuilder append(final long lhs, final long rhs) {//LC:31304
        if (comparison != 0) {//LC:31305
            return this;//LC:31306
        }//LC:31307
        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));//LC:31308
        return this;//LC:31309
    }//LC:31310
//LC:31311
    /**//LC:31312
     * Appends to the <code>builder</code> the comparison of//LC:31313
     * two <code>int</code>s.//LC:31314
     *//LC:31315
     * @param lhs  left-hand value//LC:31316
     * @param rhs  right-hand value//LC:31317
     * @return this - used to chain append calls//LC:31318
     *///LC:31319
    public CompareToBuilder append(final int lhs, final int rhs) {//LC:31320
        if (comparison != 0) {//LC:31321
            return this;//LC:31322
        }//LC:31323
        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));//LC:31324
        return this;//LC:31325
    }//LC:31326
//LC:31327
    /**//LC:31328
     * Appends to the <code>builder</code> the comparison of//LC:31329
     * two <code>short</code>s.//LC:31330
     *//LC:31331
     * @param lhs  left-hand value//LC:31332
     * @param rhs  right-hand value//LC:31333
     * @return this - used to chain append calls//LC:31334
     *///LC:31335
    public CompareToBuilder append(final short lhs, final short rhs) {//LC:31336
        if (comparison != 0) {//LC:31337
            return this;//LC:31338
        }//LC:31339
        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));//LC:31340
        return this;//LC:31341
    }//LC:31342
//LC:31343
    /**//LC:31344
     * Appends to the <code>builder</code> the comparison of//LC:31345
     * two <code>char</code>s.//LC:31346
     *//LC:31347
     * @param lhs  left-hand value//LC:31348
     * @param rhs  right-hand value//LC:31349
     * @return this - used to chain append calls//LC:31350
     *///LC:31351
    public CompareToBuilder append(final char lhs, final char rhs) {//LC:31352
        if (comparison != 0) {//LC:31353
            return this;//LC:31354
        }//LC:31355
        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));//LC:31356
        return this;//LC:31357
    }//LC:31358
//LC:31359
    /**//LC:31360
     * Appends to the <code>builder</code> the comparison of//LC:31361
     * two <code>byte</code>s.//LC:31362
     *//LC:31363
     * @param lhs  left-hand value//LC:31364
     * @param rhs  right-hand value//LC:31365
     * @return this - used to chain append calls//LC:31366
     *///LC:31367
    public CompareToBuilder append(final byte lhs, final byte rhs) {//LC:31368
        if (comparison != 0) {//LC:31369
            return this;//LC:31370
        }//LC:31371
        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));//LC:31372
        return this;//LC:31373
    }//LC:31374
//LC:31375
    /**//LC:31376
     * <p>Appends to the <code>builder</code> the comparison of//LC:31377
     * two <code>double</code>s.</p>//LC:31378
     *//LC:31379
     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>//LC:31380
     *//LC:31381
     * <p>It is compatible with the hash code generated by//LC:31382
     * <code>HashCodeBuilder</code>.</p>//LC:31383
     *//LC:31384
     * @param lhs  left-hand value//LC:31385
     * @param rhs  right-hand value//LC:31386
     * @return this - used to chain append calls//LC:31387
     *///LC:31388
    public CompareToBuilder append(final double lhs, final double rhs) {//LC:31389
        if (comparison != 0) {//LC:31390
            return this;//LC:31391
        }//LC:31392
        comparison = Double.compare(lhs, rhs);//LC:31393
        return this;//LC:31394
    }//LC:31395
//LC:31396
    /**//LC:31397
     * <p>Appends to the <code>builder</code> the comparison of//LC:31398
     * two <code>float</code>s.</p>//LC:31399
     *//LC:31400
     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>//LC:31401
     *//LC:31402
     * <p>It is compatible with the hash code generated by//LC:31403
     * <code>HashCodeBuilder</code>.</p>//LC:31404
     *//LC:31405
     * @param lhs  left-hand value//LC:31406
     * @param rhs  right-hand value//LC:31407
     * @return this - used to chain append calls//LC:31408
     *///LC:31409
    public CompareToBuilder append(final float lhs, final float rhs) {//LC:31410
        if (comparison != 0) {//LC:31411
            return this;//LC:31412
        }//LC:31413
        comparison = Float.compare(lhs, rhs);//LC:31414
        return this;//LC:31415
    }//LC:31416
//LC:31417
    /**//LC:31418
     * Appends to the <code>builder</code> the comparison of//LC:31419
     * two <code>booleans</code>s.//LC:31420
     *//LC:31421
     * @param lhs  left-hand value//LC:31422
     * @param rhs  right-hand value//LC:31423
     * @return this - used to chain append calls//LC:31424
     *///LC:31425
    public CompareToBuilder append(final boolean lhs, final boolean rhs) {//LC:31426
        if (comparison != 0) {//LC:31427
            return this;//LC:31428
        }//LC:31429
        if (lhs == rhs) {//LC:31430
            return this;//LC:31431
        }//LC:31432
        if (lhs == false) {//LC:31433
            comparison = -1;//LC:31434
        } else {//LC:31435
            comparison = +1;//LC:31436
        }//LC:31437
        return this;//LC:31438
    }//LC:31439
//LC:31440
    //-----------------------------------------------------------------------//LC:31441
    /**//LC:31442
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31443
     * two <code>Object</code> arrays.</p>//LC:31444
     *//LC:31445
     * <ol>//LC:31446
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31447
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31448
     *  <li>Check array length, a short length array is less than a long length array</li>//LC:31449
     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>//LC:31450
     * </ol>//LC:31451
     *//LC:31452
     * <p>This method will also will be called for the top level of multi-dimensional,//LC:31453
     * ragged, and multi-typed arrays.</p>//LC:31454
     *//LC:31455
     * @param lhs  left-hand array//LC:31456
     * @param rhs  right-hand array//LC:31457
     * @return this - used to chain append calls//LC:31458
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31459
     *  with <code>lhs</code>//LC:31460
     *///LC:31461
    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {//LC:31462
        return append(lhs, rhs, null);//LC:31463
    }//LC:31464
//LC:31465
    /**//LC:31466
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31467
     * two <code>Object</code> arrays.</p>//LC:31468
     *//LC:31469
     * <ol>//LC:31470
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31471
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31472
     *  <li>Check array length, a short length array is less than a long length array</li>//LC:31473
     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>//LC:31474
     * </ol>//LC:31475
     *//LC:31476
     * <p>This method will also will be called for the top level of multi-dimensional,//LC:31477
     * ragged, and multi-typed arrays.</p>//LC:31478
     *//LC:31479
     * @param lhs  left-hand array//LC:31480
     * @param rhs  right-hand array//LC:31481
     * @param comparator  <code>Comparator</code> to use to compare the array elements,//LC:31482
     *  <code>null</code> means to treat <code>lhs</code> elements as <code>Comparable</code>.//LC:31483
     * @return this - used to chain append calls//LC:31484
     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible//LC:31485
     *  with <code>lhs</code>//LC:31486
     * @since 2.0//LC:31487
     *///LC:31488
    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {//LC:31489
        if (comparison != 0) {//LC:31490
            return this;//LC:31491
        }//LC:31492
        if (lhs == rhs) {//LC:31493
            return this;//LC:31494
        }//LC:31495
        if (lhs == null) {//LC:31496
            comparison = -1;//LC:31497
            return this;//LC:31498
        }//LC:31499
        if (rhs == null) {//LC:31500
            comparison = +1;//LC:31501
            return this;//LC:31502
        }//LC:31503
        if (lhs.length != rhs.length) {//LC:31504
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31505
            return this;//LC:31506
        }//LC:31507
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31508
            append(lhs[i], rhs[i], comparator);//LC:31509
        }//LC:31510
        return this;//LC:31511
    }//LC:31512
//LC:31513
    /**//LC:31514
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31515
     * two <code>long</code> arrays.</p>//LC:31516
     *//LC:31517
     * <ol>//LC:31518
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31519
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31520
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31521
     *  <li>Check array contents element by element using {@link #append(long, long)}</li>//LC:31522
     * </ol>//LC:31523
     *//LC:31524
     * @param lhs  left-hand array//LC:31525
     * @param rhs  right-hand array//LC:31526
     * @return this - used to chain append calls//LC:31527
     *///LC:31528
    public CompareToBuilder append(final long[] lhs, final long[] rhs) {//LC:31529
        if (comparison != 0) {//LC:31530
            return this;//LC:31531
        }//LC:31532
        if (lhs == rhs) {//LC:31533
            return this;//LC:31534
        }//LC:31535
        if (lhs == null) {//LC:31536
            comparison = -1;//LC:31537
            return this;//LC:31538
        }//LC:31539
        if (rhs == null) {//LC:31540
            comparison = +1;//LC:31541
            return this;//LC:31542
        }//LC:31543
        if (lhs.length != rhs.length) {//LC:31544
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31545
            return this;//LC:31546
        }//LC:31547
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31548
            append(lhs[i], rhs[i]);//LC:31549
        }//LC:31550
        return this;//LC:31551
    }//LC:31552
//LC:31553
    /**//LC:31554
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31555
     * two <code>int</code> arrays.</p>//LC:31556
     *//LC:31557
     * <ol>//LC:31558
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31559
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31560
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31561
     *  <li>Check array contents element by element using {@link #append(int, int)}</li>//LC:31562
     * </ol>//LC:31563
     *//LC:31564
     * @param lhs  left-hand array//LC:31565
     * @param rhs  right-hand array//LC:31566
     * @return this - used to chain append calls//LC:31567
     *///LC:31568
    public CompareToBuilder append(final int[] lhs, final int[] rhs) {//LC:31569
        if (comparison != 0) {//LC:31570
            return this;//LC:31571
        }//LC:31572
        if (lhs == rhs) {//LC:31573
            return this;//LC:31574
        }//LC:31575
        if (lhs == null) {//LC:31576
            comparison = -1;//LC:31577
            return this;//LC:31578
        }//LC:31579
        if (rhs == null) {//LC:31580
            comparison = +1;//LC:31581
            return this;//LC:31582
        }//LC:31583
        if (lhs.length != rhs.length) {//LC:31584
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31585
            return this;//LC:31586
        }//LC:31587
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31588
            append(lhs[i], rhs[i]);//LC:31589
        }//LC:31590
        return this;//LC:31591
    }//LC:31592
//LC:31593
    /**//LC:31594
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31595
     * two <code>short</code> arrays.</p>//LC:31596
     *//LC:31597
     * <ol>//LC:31598
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31599
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31600
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31601
     *  <li>Check array contents element by element using {@link #append(short, short)}</li>//LC:31602
     * </ol>//LC:31603
     *//LC:31604
     * @param lhs  left-hand array//LC:31605
     * @param rhs  right-hand array//LC:31606
     * @return this - used to chain append calls//LC:31607
     *///LC:31608
    public CompareToBuilder append(final short[] lhs, final short[] rhs) {//LC:31609
        if (comparison != 0) {//LC:31610
            return this;//LC:31611
        }//LC:31612
        if (lhs == rhs) {//LC:31613
            return this;//LC:31614
        }//LC:31615
        if (lhs == null) {//LC:31616
            comparison = -1;//LC:31617
            return this;//LC:31618
        }//LC:31619
        if (rhs == null) {//LC:31620
            comparison = +1;//LC:31621
            return this;//LC:31622
        }//LC:31623
        if (lhs.length != rhs.length) {//LC:31624
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31625
            return this;//LC:31626
        }//LC:31627
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31628
            append(lhs[i], rhs[i]);//LC:31629
        }//LC:31630
        return this;//LC:31631
    }//LC:31632
//LC:31633
    /**//LC:31634
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31635
     * two <code>char</code> arrays.</p>//LC:31636
     *//LC:31637
     * <ol>//LC:31638
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31639
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31640
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31641
     *  <li>Check array contents element by element using {@link #append(char, char)}</li>//LC:31642
     * </ol>//LC:31643
     *//LC:31644
     * @param lhs  left-hand array//LC:31645
     * @param rhs  right-hand array//LC:31646
     * @return this - used to chain append calls//LC:31647
     *///LC:31648
    public CompareToBuilder append(final char[] lhs, final char[] rhs) {//LC:31649
        if (comparison != 0) {//LC:31650
            return this;//LC:31651
        }//LC:31652
        if (lhs == rhs) {//LC:31653
            return this;//LC:31654
        }//LC:31655
        if (lhs == null) {//LC:31656
            comparison = -1;//LC:31657
            return this;//LC:31658
        }//LC:31659
        if (rhs == null) {//LC:31660
            comparison = +1;//LC:31661
            return this;//LC:31662
        }//LC:31663
        if (lhs.length != rhs.length) {//LC:31664
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31665
            return this;//LC:31666
        }//LC:31667
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31668
            append(lhs[i], rhs[i]);//LC:31669
        }//LC:31670
        return this;//LC:31671
    }//LC:31672
//LC:31673
    /**//LC:31674
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31675
     * two <code>byte</code> arrays.</p>//LC:31676
     *//LC:31677
     * <ol>//LC:31678
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31679
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31680
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31681
     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>//LC:31682
     * </ol>//LC:31683
     *//LC:31684
     * @param lhs  left-hand array//LC:31685
     * @param rhs  right-hand array//LC:31686
     * @return this - used to chain append calls//LC:31687
     *///LC:31688
    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {//LC:31689
        if (comparison != 0) {//LC:31690
            return this;//LC:31691
        }//LC:31692
        if (lhs == rhs) {//LC:31693
            return this;//LC:31694
        }//LC:31695
        if (lhs == null) {//LC:31696
            comparison = -1;//LC:31697
            return this;//LC:31698
        }//LC:31699
        if (rhs == null) {//LC:31700
            comparison = +1;//LC:31701
            return this;//LC:31702
        }//LC:31703
        if (lhs.length != rhs.length) {//LC:31704
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31705
            return this;//LC:31706
        }//LC:31707
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31708
            append(lhs[i], rhs[i]);//LC:31709
        }//LC:31710
        return this;//LC:31711
    }//LC:31712
//LC:31713
    /**//LC:31714
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31715
     * two <code>double</code> arrays.</p>//LC:31716
     *//LC:31717
     * <ol>//LC:31718
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31719
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31720
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31721
     *  <li>Check array contents element by element using {@link #append(double, double)}</li>//LC:31722
     * </ol>//LC:31723
     *//LC:31724
     * @param lhs  left-hand array//LC:31725
     * @param rhs  right-hand array//LC:31726
     * @return this - used to chain append calls//LC:31727
     *///LC:31728
    public CompareToBuilder append(final double[] lhs, final double[] rhs) {//LC:31729
        if (comparison != 0) {//LC:31730
            return this;//LC:31731
        }//LC:31732
        if (lhs == rhs) {//LC:31733
            return this;//LC:31734
        }//LC:31735
        if (lhs == null) {//LC:31736
            comparison = -1;//LC:31737
            return this;//LC:31738
        }//LC:31739
        if (rhs == null) {//LC:31740
            comparison = +1;//LC:31741
            return this;//LC:31742
        }//LC:31743
        if (lhs.length != rhs.length) {//LC:31744
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31745
            return this;//LC:31746
        }//LC:31747
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31748
            append(lhs[i], rhs[i]);//LC:31749
        }//LC:31750
        return this;//LC:31751
    }//LC:31752
//LC:31753
    /**//LC:31754
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31755
     * two <code>float</code> arrays.</p>//LC:31756
     *//LC:31757
     * <ol>//LC:31758
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31759
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31760
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31761
     *  <li>Check array contents element by element using {@link #append(float, float)}</li>//LC:31762
     * </ol>//LC:31763
     *//LC:31764
     * @param lhs  left-hand array//LC:31765
     * @param rhs  right-hand array//LC:31766
     * @return this - used to chain append calls//LC:31767
     *///LC:31768
    public CompareToBuilder append(final float[] lhs, final float[] rhs) {//LC:31769
        if (comparison != 0) {//LC:31770
            return this;//LC:31771
        }//LC:31772
        if (lhs == rhs) {//LC:31773
            return this;//LC:31774
        }//LC:31775
        if (lhs == null) {//LC:31776
            comparison = -1;//LC:31777
            return this;//LC:31778
        }//LC:31779
        if (rhs == null) {//LC:31780
            comparison = +1;//LC:31781
            return this;//LC:31782
        }//LC:31783
        if (lhs.length != rhs.length) {//LC:31784
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31785
            return this;//LC:31786
        }//LC:31787
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31788
            append(lhs[i], rhs[i]);//LC:31789
        }//LC:31790
        return this;//LC:31791
    }//LC:31792
//LC:31793
    /**//LC:31794
     * <p>Appends to the <code>builder</code> the deep comparison of//LC:31795
     * two <code>boolean</code> arrays.</p>//LC:31796
     *//LC:31797
     * <ol>//LC:31798
     *  <li>Check if arrays are the same using <code>==</code></li>//LC:31799
     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>//LC:31800
     *  <li>Check array length, a shorter length array is less than a longer length array</li>//LC:31801
     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>//LC:31802
     * </ol>//LC:31803
     *//LC:31804
     * @param lhs  left-hand array//LC:31805
     * @param rhs  right-hand array//LC:31806
     * @return this - used to chain append calls//LC:31807
     *///LC:31808
    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {//LC:31809
        if (comparison != 0) {//LC:31810
            return this;//LC:31811
        }//LC:31812
        if (lhs == rhs) {//LC:31813
            return this;//LC:31814
        }//LC:31815
        if (lhs == null) {//LC:31816
            comparison = -1;//LC:31817
            return this;//LC:31818
        }//LC:31819
        if (rhs == null) {//LC:31820
            comparison = +1;//LC:31821
            return this;//LC:31822
        }//LC:31823
        if (lhs.length != rhs.length) {//LC:31824
            comparison = (lhs.length < rhs.length) ? -1 : +1;//LC:31825
            return this;//LC:31826
        }//LC:31827
        for (int i = 0; i < lhs.length && comparison == 0; i++) {//LC:31828
            append(lhs[i], rhs[i]);//LC:31829
        }//LC:31830
        return this;//LC:31831
    }//LC:31832
//LC:31833
    //-----------------------------------------------------------------------//LC:31834
    /**//LC:31835
     * Returns a negative integer, a positive integer, or zero as//LC:31836
     * the <code>builder</code> has judged the "left-hand" side//LC:31837
     * as less than, greater than, or equal to the "right-hand"//LC:31838
     * side.//LC:31839
     *//LC:31840
     * @return final comparison result//LC:31841
     * @see #build()//LC:31842
     *///LC:31843
    public int toComparison() {//LC:31844
        return comparison;//LC:31845
    }//LC:31846
//LC:31847
    /**//LC:31848
     * Returns a negative Integer, a positive Integer, or zero as//LC:31849
     * the <code>builder</code> has judged the "left-hand" side//LC:31850
     * as less than, greater than, or equal to the "right-hand"//LC:31851
     * side.//LC:31852
     *//LC:31853
     * @return final comparison result as an Integer//LC:31854
     * @see #toComparison()//LC:31855
     * @since 3.0//LC:31856
     *///LC:31857
    @Override//LC:31858
    public Integer build() {//LC:31859
        return Integer.valueOf(toComparison());//LC:31860
    }//LC:31861
}//LC:31862
//LC:31863
